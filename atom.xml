<?xml version="1.0" encoding="UTF-8"?><feed xmlns="http://www.w3.org/2005/Atom">
  <title>我有分寸</title>
  <id>http://wangxu.me/</id>
  <updated>2016-06-19T02:59:41-07:00</updated>
  <subtitle>某创业公司的看门大爷</subtitle>
  <link href="http://wangxu.me/"></link>
  <author>
    <name>我有分寸</name>
  </author>
  <entry>
    <title>RunV: 让 Docker 支持虚拟化容器</title>
    <updated>2016-06-17T15:06:08+08:00</updated>
    <id>tag:wangxu.me,2016-06-17:/hyper/2016/06/17/runv-docker-integration/index.html</id>
    <content type="html">&lt;p&gt;在此，我们很高兴地告知各位，我们已经初步完成了 runV (OCI 的基于虚拟化技术的容器运行时引擎) 与 Docker 的集成。这里，我们感谢 runV 团队的优秀工作，而且这次更新的一个特别之处在于，这些更新是由 Hyper 的开发团队和来自社区的参与者共同完成的，他们也是 runV 社区的重要部分，并在此接受致谢。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从去年夏末 OCI （开放容器促进组织）在 Linux 基金会下成立的时候起，Hyper 的 runV 就成为了 &lt;a href=&#34;https://github.com/opencontainers/runtime-spec/blob/master/implementations.md&#34;&gt;OCI 官方的基于虚拟化技术的容器运行时引擎实现[1]&lt;/a&gt;，而另一个基于容器的实现就是 Docker 的 runC。很久以来，大家都期盼着能用 Docker 命令行同时启动 runC 和 runV 容器，不过，由于 Docker 的执行引擎在按照他们的节奏向前推进，这个愿望一直未能实现。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;今年四月，&lt;a href=&#34;[https://blog.docker.com/2016/04/docker-engine-1-11-runc/&#34;&gt;docker 发布了 1.11，集成了 containerd，连接了 runC [2]&lt;/a&gt;，这为支持更多的 runtime 铺就了道路，于是，runV 与 Docker/Containerd 的集成就再次提上了台面。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;作为基于 hypervisor 的 OCI runtime，Hyper 的 runV 与 Docker 1.11+/Containerd 的集成工作是比较容易的，&lt;a href=&#34;https://github.com/hyperhq/runv#run-it-with-docker&#34;&gt;经过简单的调试，就可以让 Docker 和 containerd 直接对接到 runv 上[3]&lt;/a&gt;。但由于 containerd 是为 runC 量身定制的， runC本身也是一个不断改进中的实现，命令行会不断变化，并且包含一些专有的特性，这个集成有不少局限，对于 tty, exec, 网络等方面的支持仍有不足。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过，得益于 docker/containerd 提供的良好接口，我们给出了一个对 tty, exec, 网络等方面兼容性更好的过渡方案 —— 我们在 runv 中附带了 &lt;a href=&#34;[https://github.com/hyperhq/runv/blob/master/containerd/README.md&#34;&gt;runv-containerd 程序 [4]&lt;/a&gt;，基于 containerd并针对 hypervisor 进行了一些调整， 利用 runV ，现在 docker 可以直接创建功能齐备的虚拟化容器了。&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&lt;code&gt;# in terminal #1&#xA;runv-containerd --debug --driver libvirt --kernel /opt/hyperstart/build/kernel --initrd /opt/hyperstart/build/hyper-initrd.img&#xA;# in terminal #2&#xA;docker daemon -D -l debug --containerd=/run/runv-containerd/containerd.sock&#xA;# in terminal #3 for trying it&#xA;docker run -ti busybox&#xA;# ls   # (already in the terminal of the busybox container)&#xA;# exit # (quit the container)&#xA;&lt;/code&gt;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;未来随着 OCI/containerd/runV 的进一步发展，相信我们还可以做到更好更完美的集成。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[1] &lt;a href=&#34;https://github.com/opencontainers/runtime-spec/blob/master/implementations.md&#34;&gt;https://github.com/opencontainers/runtime-spec/blob/master/implementations.md&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[2] &lt;a href=&#34;https://blog.docker.com/2016/04/docker-engine-1-11-runc/&#34;&gt;https://blog.docker.com/2016/04/docker-engine-1-11-runc/&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[3] &lt;a href=&#34;https://github.com/hyperhq/runv#run-it-with-docker&#34;&gt;https://github.com/hyperhq/runv#run-it-with-docker&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;[4] &lt;a href=&#34;https://github.com/hyperhq/runv/blob/master/containerd/README.md&#34;&gt;https://github.com/hyperhq/runv/blob/master/containerd/README.md&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt; &lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/hyper/2016/06/17/runv-docker-integration/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>浮在天空里，有些话给你</title>
    <updated>2016-06-08T05:12:08+08:00</updated>
    <id>tag:wangxu.me,2016-06-08:/family/2016/06/08/for-dad/index.html</id>
    <content type="html">&lt;p&gt;爸爸：&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2月9日，大年初二，你停下了脚步，而我们却渐行渐远。你是那个最疼我的人，我是你最后托付的人，我手上，你最后的温度不曾散释，我心里，你最后的话语萦绕未消。平日里，你好象仍然未曾远去，总觉的哪天我迈进家门，还能尝到你做的饭菜，我还会劝劝你少喝酒、少放油；而在飞机上的时候，我总觉的自己距离你更近了，几次在航班上泪流满面地回想和你在一起的点滴往事，从幼年的兔子和鹅，一直到高考时晚饭，再到五年前我从移动离职时你的话……这些，你也都不曾忘记，对么？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你离去已过百天，你最疼的屹长大了，学了新知识，学得更有自我意识了，偶尔骗骗我，把我气得半死，和我小时候一样；你那时候对我很宽容的，我们也会好好地爱他、引导他的。他偶尔也会不经意间提到你，但不会多说，他对你可能也无法释怀，你走了，这个小家伙一定很不开心。可爱的小诺诺也从刚两岁长到快两岁半了，不知道是不是感应，你发病前一天坚持想去接我和诺诺，那次没让你去，没想到就阴阳两隔了，而你离开的那天，小诺诺也高烧不退，痛苦之极；如今，她越来越懂事了，她出乎预料地不肯忘记你，你刚走那几天，她会指着很多东西说“是爷爷的”，而到最近，她还会提起“爷爷怎么不来啊，让爷爷也一起来吧”，“爷爷做菜好吃，让爷爷回来给我做菜吧”，每每引得妈妈潸然泪下。我曾经感伤“爱也会被遗忘”，有的时候却也想，遗忘可能也是对生者的保护，如果诺诺真能快点遗忘，妈妈可能也没这么伤心吧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;说到妈妈，她还没有适应没有你的生活，没有你来给她拿主意，她似乎越来越不知道该走向哪里，我告诉她，她还可以有大约25年有质量的晚年生活，25年可以让一个婴儿成长到研究生毕业，可以和以往完全不同，可以活出更多精彩。我不知道她能听进去多少，她原来太依赖你来思考了，她不愿意接受别人的思想注入，不过我会尽力的，愿天空里的你也能帮助她度过难关。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;你走了，我也一夜长大，从前我在你的家庭里，营造我的小家庭，如今我也在家族里，试着和其他长辈们沟通，你离去的痛，和追加上的更多责任，让我更明白人生。我知道要关爱我的家庭，要关照妈妈，也要爱护自己。我会更加自律地生活，因为失去你的痛苦，让我知道，不要让爱我的人再那么早承受这份痛，相信我，我会尽力爱护你爱的人的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;飞机已经飞过中欧，快要到达此行的目的地了，快要和你告别了，我想和你分享一段最近注意到的《爱丽丝梦游仙境2》的台词：&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;曾经以为时间是个小偷，将我们拥有的一切都偷走，从不曾给我们机会。但我们错了，她总是先给予再拿走，每一天，每一分，每一秒，都是馈赠；时间教你接受一切，爱的人就在身边，请珍惜。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;你曾经和我一起相处过三十五年，为我付出过三十五年，一起快乐地度过了三十五年，我们一起走过乡间小道也一起飞在过蓝天之中，你自己在一直打拼，也鼓励我勇敢闯荡，如今你离开我了，我在你的注视下渐行渐远，我会把你一直放在心底，永远珍藏着那充满父爱的一分一秒。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;再见，爱你，虽然这句话你没有亲耳听到让我觉得有点遗憾。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;儿 旭&lt;/p&gt;&#xA;&#xA;&lt;p&gt;2016年6月7日于英航BA38航班上&lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/family/2016/06/08/for-dad/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>Hyper 一岁了</title>
    <updated>2016-05-25T20:06:08+08:00</updated>
    <id>tag:wangxu.me,2016-05-25:/hyper/2016/05/25/hyper-birthday/index.html</id>
    <content type="html">&lt;p&gt;今天一早，朋飞就告诉我们，我们和 Google 合作，发在 &lt;a href=&#34;http://blog.kubernetes.io/2016/05/hypernetes-security-and-multi-tenancy-in-kubernetes.html&#34;&gt;Kubernetes 官方博客上的文章&lt;/a&gt;终于上线了，张磊和朋飞，还有 Google Kubernetes 团队的 Dawn 等朋友忙活了这么久的一件事终于在今天有了结果。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一篇文章用了这么久，有点超出我们的预期。不过，看看本文标题，今天刚好是我们向全世界宣布开始 &lt;a href=&#34;https://github.com/hyperhq/hyperd&#34;&gt;HyperContainer&lt;/a&gt; 这个开源项目一周年，这真是个让人惊喜的生日礼物呢！&lt;/p&gt;&#xA;&#xA;&lt;p&gt;一年前，我们忐忑地宣布了这个项目，那篇 blog 在 HackerNews 首页上停了几乎一整天，有人说，如果不算中国股市的话，这是中国人头一次在 HackerNews 首页上停这么久。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在过去的一年里，我们在 HyperContainer 之外，还发布了 RunV, Hypernetes 两个开源项目，并在上个月推出了我们的公有云服务 &lt;a href=&#34;https://www.hyper.sh&#34;&gt;Hyper_&lt;/a&gt;。这几个开源项目我都在之前的 Blog 里有过介绍，毋须多言，有兴趣的同学直接来&lt;a href=&#34;http://github.com/hyperhq/&#34;&gt;我们的 GitHub&lt;/a&gt; 看吧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;就在刚刚，我 Tag 了 HyperContainer 项目的 0.6.0 版本，作为生日祝福送给我们项目自己，感谢开发团队的努力工作，不过我们没时间停下来，在接下来的两个月里，我们还有很多事情要做&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;我们的公有云项目将会有几个比较大的功能升级，就在未来的几个星期里逐步上线，GA 就在眼前，还请各位关注。&lt;/li&gt;&#xA;&lt;li&gt;我们的 HyperContainers 项目会在未来两个月里进一步完善 API、并稳定功能，大约在8月份达到 1.0 。&lt;/li&gt;&#xA;&lt;li&gt;我们的 Hypernetes 会和 Kubernetes 继续合作，大约在秋季的时候，Kubernetes 上游会有 HyperContainer Runtime 的集成。&lt;/li&gt;&#xA;&lt;li&gt;还有更多的进展会在未来几个月里逐步推进……&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;从发布到一岁，是漫长、艰辛而又兴奋的一个过程，未来更多挑战等着我们，让我们一起加油吧！&lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/hyper/2016/05/25/hyper-birthday/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>Hyper 0.5 Released</title>
    <updated>2016-02-06T08:08:08+08:00</updated>
    <id>tag:wangxu.me,2016-02-06:/container/2016/02/06/hyper-0-5/index.html</id>
    <content type="html">&lt;p&gt;今天上午，我 Tag 了 Hyper, runV, Hyperstart 三个项目的 v0.5.0 标签，发布了 0.5 版本，Release Note 是英文的，想着也该有个中文的发布声明，就动笔写了这篇 Blog，送给从此刻开始的春节假期，祝各位开发者们节日休息的好、运维们节日别接告警。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从 0.4 到 0.5，经历了接近五个月，与之前的发布周期相比是长了些，但这五个月中，我们并没有闲着，作为一个开源项目，大家从 GitHub 项目的变更记录可以看到，我们一直在改进自己。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;同时，在这期间，我们还在去年10月末和11月初接连参加了 OpenStack Summit Tokyo 和 DockerCon EU。在会上，我们向世界宣告了我们的新项目——Hypernetes （曾用名 HyperStack）。这个项目以 Hyper 作为强隔离性的运行时；使用 Kubernetes 作为 Pod 调度引擎；利用 OpenStack 组件，以 Neutron 作为 SDN 解决方案，以 Cinder/Ceph 作为持久存储方案，也用 Keystone 作为认证授权中心。这些特性使 Hypernetes 成为一个多租户的 Kubernetes 发布版，吸引了诸多关注目光。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里简单介绍一下 0.4 到 0.5 的变化，最明显的可能就是，对于 CentOS 和 Fedora 的用户，你们现在可以直接安装 RPM 包了（&lt;strike&gt;包好，包好……&lt;/strike&gt;），呃……为啥没有 deb？作为13年的 Debianer，我也很抱歉啊，其实，事实是，CentOS 7.x 的依赖需求情况比较特殊，所以我们专门 Build 了 RPM，当然，稍后我们也会提供 Deb 的，放心吧。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;从软件本身来说，最主要的是我们对 Hyper 的行为做了很多修复和改进，比如对&lt;code&gt;run&lt;/code&gt; 和 &lt;code&gt;exec&lt;/code&gt; 命令的返回值、运行时 tty 的行为、文件映射的行为、文件插入行为的完善和修复、以及很多稳定性的改进，测试方面也做了加强。在功能方面，主要的改进在于和 Neutron 的集成、和 Cinder 的 ceph volume 的集成等，细节方面，&lt;code&gt;run&lt;/code&gt; 命令增加了 &lt;code&gt;-t&lt;/code&gt; 参数标记是否有 tty 设备的区别，增加了 &lt;code&gt;logs&lt;/code&gt; 命令，再就是增加了 &lt;code&gt;libvirt&lt;/code&gt; driver，用户可以在 libvirt 中监控到 hyper 创建的虚拟机。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;最近也有一些译文把 Hypernetes 介绍给国内的朋友，感谢诸位的关注，是的，我们是一个由国内发起、开发团队主要在国内的开源项目。在此版本发布，也是春节来临之际，感谢开发团队们的努力工作，虽然大部分开发团队都是远程工作的，但这就是开源社区的一贯工作方式，我们的团队完全胜任这个工作方式，生产效率与集中工作相比好不示弱。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;0.5 版本的发布让 Hyper 更加接近了产品化，在接下来的时间里 Hyper 和 Hypernetes 都不会停下来，请大家期待我们不久后的下一次产品发布。谢谢大家！再祝各位春节快乐、少收报警！&lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/container/2016/02/06/hyper-0-5/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>关于 Unikernel，你注意到或没注意到的一些东西</title>
    <updated>2016-01-23T08:08:08+08:00</updated>
    <id>tag:wangxu.me,2016-01-23:/container/2016/01/23/unikernel-critics/index.html</id>
    <content type="html">&lt;blockquote&gt;&#xA;&lt;p&gt;&lt;strong&gt;利益相关&lt;/strong&gt;（强行植入广告）：我们（Hyper）创业团队（也是开源项目）同样做了一种基于 Hypervisor 技术的容器解决方案，然而与 unikernel 不同的是，我们是面向通用的容器镜像的，可以直接运行已有镜像。在我看来，大部分人在热捧 unikernel 的时候，实际上他需要的是 Hyper 这样的技术。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;strong&gt;免责声明&lt;/strong&gt;：我所做的预测只对我自己负责，我们在用创造未来的方式来预测未来，并且有其他人与我们在一同来创造未来，我们坚信我们的预测是正确的。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;&lt;img data-src=&#34;/assets/unikernel-in-article.png&#34; alt=&#34;作为一个概念的 unikernel&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;新闻背景&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;前两天，&lt;a href=&#34;https://blog.docker.com/2016/01/unikernel/&#34;&gt;Docker 宣布收购了 Unikernel Systems&lt;/a&gt;，引起了朋友圈刷屏（比如&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==&amp;amp;mid=401469511&amp;amp;idx=1&amp;amp;sn=d4628798a25b2c28d6d0acc2edf85068&#34;&gt;这个&lt;/a&gt;和&lt;a href=&#34;https://mp.weixin.qq.com/s?__biz=MjM5MDE2MTczMQ==&amp;amp;mid=401874323&amp;amp;idx=1&amp;amp;sn=9e78416191cb7b4b2cf04684b97d4750&#34;&gt;这个&lt;/a&gt;）。不过 Twitter 上还是有一些批评声音的，而且 Joyent 的 Bryan Cantrill 大神亲自向信众解释了&lt;a href=&#34;https://www.joyent.com/blog/unikernels-are-unfit-for-production&#34;&gt;为啥 unikernel 不适合于生产系统&lt;/a&gt;，当然，在存在利益相关这方面，他和我是一样的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在和一些技术圈的朋友讨论后，我发现有的朋友并不是很了解 unikernel 技术，只是听起来觉得很好。于是，昨天我在朋友圈里写了这么一段话&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;事实上，unikernel 和 docker image 都是对应用的一个静态封装，从很多种意义上说，unikernel 都是一个更精巧的封装，而 docker image 则是一种更简单、松散、或者说更通用的封装。对于每个人是不是有意义，这因人而异，历史上精巧专用的方案被简单而更具兼容性的方案打败的例子比比皆是。这里，很多人都忽视的一点就是，从 unikernel 的定义出发，就不存在一个 unikernel 可以适应多样的已有二进制程序。需要好好审视自己的应用场景，才知道这张旧船票能否登上你的客船&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;现在我在 Blog 里继续解释一下。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;插一句题外话， unikernel 是一类技术，并不只有 Unikernel Systems 一家拥有，有兴趣的同学可以看看 OSV，这个团队来自 Red Hat，头领是 KVM 的作者 Avi，是一个非常优秀而有执行力的团队。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;什么是 unikernel&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;根据 &lt;a href=&#34;https://en.wikipedia.org/wiki/Unikernel&#34;&gt;Wiki 定义&lt;/a&gt;，unikernel 是专用的、单一地址空间，将操作系统功能作为库调用的程序镜像。也就是说，做一个 unikernel 应用，可以不需要复杂、完整的操作系统，可以只包含需要的功能。想想这简直是小而美的微服务架构的终极追求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;Docker 镜像之所以为人们所称道的原因就在于它完整封装了应用环境，使得应用可以在不同的环境里无需修改直接运行，不用考虑 distro、依赖库之类的问题，而这里，unikernel 连 kernel 都一并打包了，只要放在 hypervisor 上即可运行，这种 portability 似乎是无与伦比的，另一方面，hypervisor 带来的隔离效果要比 linux container 更好，而且，去掉不必要功能后，unikernel 包含的可能含有漏洞的代码也会少，从安全的角度讲，你做得越少，你做错的也就越少，人们不禁赞叹，这真是终极的解决之道啊。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;不过，等等，这里似乎有点问题啊。单一地址空间、操作系统作为库，这样的话和传统的程序有点不一样啊，程序不是跑在 Linux kernel 上了，那么多进程调度谁来做？已有的程序和库怎么用呢？是的，这就是我所说的不存在可以直接适配多样的已有二进制程序的 unikernel，你需要为每个程序一切从头做起，做自己的 unikernel app。换一个角度说，实际上 unikernel 不是让你把你的已有程序和它依赖的 kernel 功能打包，相反，是提供一套工具，帮你把你的程序嵌入到内核里去，得到一个你自己的专有的内核，这要从源码出发，甚至进行一定的移植工作。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;所以，当我在看到这个新闻的时候，甚至在想，docker 这是要回到 PaaS 上去，放弃统一镜像，转而做源码级的服务么？&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;通用的 unikernel？&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;看到我前面的论述，有人会立刻说，把 init 程序，比如 systemd 甚至 Hyper 的 hyperstart 和 unikernel 打包，然后不就可以直接接入已有二进制程序直接，做成通用的 unikernel 了么？&lt;/p&gt;&#xA;&#xA;&lt;p&gt;可是，仔细看看啊各位，首先，从 API/ABI 的角度看，通用的 Unix 或者 Linux kernel 是建立在完整的系统调用集的基础上的，unikernel 通过将内核代码与 App 代码的耦合，放弃了对系统调用的提供。而一旦转而提供完整的 ABI 给应用，那么，和 Linux kernel 也就没有区别了。所以说，unikernel 在提供通用性和进行应用边界划分的时候，选择的不是一个更加普适的接口。或者说，当它转而通用地支持已有的二进制程序的时候，那么它重新变成 hyper 的解决方案，而不是 unikernel 了。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Unikernel 化一个应用，你面对的问题&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;除了丧失二进制级的应用通用性之外，Unikernel 其实还面临着很多其他的问题：&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;首先，你需要移植程序，相当于支持一个新的平台。各种 unikernel 技术多少都提供了和 libc 或 java 平台或其他语言环境一致性非常高的开发环境，方便用户的移植，然而，移植工作多少还是需要的。&lt;/li&gt;&#xA;&lt;li&gt;其次，如果你的应用本身是多线程或多进程的，需要考虑单一地址空间的限制，这不仅是程序语言方面的限制，有的时候也是架构或语义层面的影响。&lt;/li&gt;&#xA;&lt;li&gt;最后，如 Bryan Cantrill 所说，unikernel 程序实际是完全内核态程序，而且只有单一地址空间，这根本没法 debug 嘛，传统或现代的通用程序调试设施基本上都无法使用，连进程的概念都没有，这对开发和调试带来了极大的难度，显然并不是所有的应用开发者都能驾驭这样的应用的。&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;Unikernel 适用的场景有哪些&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;那么，什么应用需要这个场景呢？我个人认为，只有极端追求性能和小体积的场所，可以不惜代价地去做这种 unikernel，就此，很多人都觉得 IoT （物联网）似乎是最佳应用场景之一。我只想问，我们早年间在 4KB ROM，128B RAM 的限制下写的 51 单片机程序在算不算 unikernel 程序？&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;你真的想要的是什么？&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;感谢各位看到这里，作为一篇到处植入广告的文章，能看到最后的都是真爱，所以，我就再插入一段广告吧。如果你的容器服务跑在可信任的环境里，性能是首要要求，那么基于 Linux Container 的 Docker 是你的首选；而如果要提供多租户的容器服务，或者容器里的应用不被完全信任（比如用于测试等用途），那么，基于 Hypervisor 的 Hyper 完全胜任这个环境。并且，两者使用完全相同的镜像，对大部分镜像来说（除了那些刻意放弃主机和容器之间隔离性的应用），Container 能跑的，Hypervisor 也同样能跑。&lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/container/2016/01/23/unikernel-critics/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>DIY PM 2.5 监测仪 (1): 采集和显示</title>
    <updated>2015-12-27T08:08:08+08:00</updated>
    <id>tag:wangxu.me,2015-12-27:/life/2015/12/27/diy-pm25-monitor/index.html</id>
    <content type="html">&lt;blockquote&gt;&#xA;&lt;p&gt;如今北京的空气，嗯，关注点空气质量自我保护吧，废话不多说了，开工吧。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;h2&gt;基本原理&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;有一定精确性但成本比较低的颗粒物检测方法差不多都用的是同一个原理——由于细颗粒物的直径（微米级）和光的波长（可见光的波长是 0.39-0.7 微米）比较接近，所以细颗粒物会对光产生比较强烈的散射，这也就是 PM 2.5 高的时候，空气的能见度一定不好的原因。当然，PM 2.5 高对能见度不好是充分非必要条件，其他因素也可能导致空气能见度不佳。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;基于这个原理，发射一束激光，在一定角度上观测散射光的强度，就可以判断出颗粒物的浓度，当然，这个方法要求对空气中颗粒物直径分布模型、产生散射的物质的成分等有一个假设，同时还受限于光强度测量的精确性，因此，这个测量的精确度是受限的，对于科研可能不太够，但对日常生活的空气检测来说，应该是比较有效和准确的。这次我们的监测仪使用的就是采用这个原理制成的一个模块。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;准备材料&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;raspberry pi 或 arduino，目前测试用的是 rpi 2 和 arduino uno，订的 arduino nano 正在路上，nano 就又小又便宜了。&lt;/li&gt;&#xA;&lt;li&gt;传感器，我用的是淘宝上买的 PMS1003，大家自行搜索 PM2.5 传感器吧，关键字是“激光”或 laser。不同的传感器接口啥的可能不太一样，我这个传感器自带 UART 输出，所以可以从串口直接读取数据。&lt;/li&gt;&#xA;&lt;li&gt;LCD1602 液晶显示，我用了一块 8574 转换电路，转成了 I2C 接口，这样比较省接口。可以直接买一个带 I2C 的 LCD，也可以分别买了自己连，嗯，我是分两次买自己连的，因为我最早（去年？）不知道有 I2C 的……&lt;/li&gt;&#xA;&lt;li&gt;连接线&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;硬件链接&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;因为插接件不太兼容，我把传感器的连接线一端截开焊在了一块板子上，连上插针，方便连接，如果手头有合适插接件的话，可能不用动烙铁了。具体连接很简单：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;传感器连接&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;5V 供电&lt;/li&gt;&#xA;&lt;li&gt;地&lt;/li&gt;&#xA;&lt;li&gt;Setting 管脚，这个接在 Pi 的一个 GPIO 接口上（比如 GPIO 17）或 Arduino 的一个接口上，比如这次用的是 IO 2。这个管脚拉高，模块处于工作状态&lt;/li&gt;&#xA;&lt;li&gt;TXD 连接到 Pi 的 RXD 或 Arduino 的 RXD 上，做采集&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h3&gt;LCD&lt;/h3&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;SDA/SCL I2C 的数据和时钟，接在 Pi 或者 Arduino 的 数据和时钟上&lt;/li&gt;&#xA;&lt;li&gt;Vcc/GND 接 5V 电源和地，实测接 3.3V 会供电不足&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;h2&gt;软件环境&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Pi 的话需要准备下，要把缺省关闭的 I2C 打开，并且把 console 连接的串口去掉，空出串口来给我们采集数据用。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其他的就是要查一下 LCD 的 I2C 地址。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;主体流程&lt;/h2&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;初始化&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;液晶初始化：设置合适的格式和背光&lt;/li&gt;&#xA;&lt;li&gt;模块初始化：初始化串口，找到 &lt;code&gt;0x42&lt;/code&gt;, &lt;code&gt;0x4d&lt;/code&gt; 作为帧的开始，一帧 32 个字节（不同模块参考相应的手册）&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;li&gt;采集&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;采集对应字节的数据，从大结尾转为短整型，然后显示在液晶屏上&lt;/li&gt;&#xA;&lt;/ul&gt;&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;如此而已，非常简单，以后我们再考虑用蓝牙讲数据发送出来。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;源码清单&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;Pi 和 Arduino 的源码如下：&lt;/p&gt;&#xA;&#xA;&lt;h3&gt;Pi 源码&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;主程序：&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;#!/usr/bin/env python&#xA;&#xA;import RPi.GPIO as GPIO&#xA;import serial&#xA;import pylcdlib&#xA;# pylcdlib from https://gist.github.com/gnawux/4f68b8e301b203489336&#xA;&#xA;def readbe16(s, pos):&#xA;    return ( ord(s[pos])&lt;&lt;8) + ord(s[pos+1])&#xA;&#xA;GPIO.setwarnings(False)&#xA;GPIO.setmode(GPIO.BCM)&#xA;GPIO.setup(17, GPIO.OUT)&#xA;GPIO.output(17, True)&#xA;&#xA;# define bus address, port, and pins&#xA;display = pylcdlib.lcd(0x27,1, Rs=0, Rw=1, En=2, Backlight=3, D4=4, D5=5, D6=6, D7=7)&#xA;display.lcd_clear()&#xA;&#xA;ser = serial.Serial(&#34;/dev/ttyAMA0&#34;)&#xA;ser.baudrate=9600&#xA;data = ser.read(32)&#xA;pos  = 0&#xA;while True:&#xA;    pos = data[pos:].index(chr(0x42))&#xA;    if ord(data[(pos+1)&amp;31]) == 0x4d:&#xA;        print(&#39;found BM at %d&#39; % (pos))&#xA;        ser.read(pos)&#xA;    break&#xA;    pos = pos + 1&#xA;    if pos &gt; 31:&#xA;        print(&#39;frame format error&#39;)&#xA;        exit(1)&#xA;&#xA;l1d=-1&#xA;l2d=-1&#xA;&#xA;while True:&#xA;    data = ser.read(32)&#xA;    if data[0] != &#39;B&#39; or data[1] != &#39;M&#39;:&#xA;        print(&#39;frame format error while reading data: %s, %s&#39; % (data[:2], data))&#xA;        exit(1)&#xA;    length = readbe16(data, 2)&#xA;    if length != 28:&#xA;        print(&#39;length error : %d&#39; % (length))&#xA;        exit(1)&#xA;&#xA;    pm25std = readbe16(data, 6)&#xA;    pm25atm = readbe16(data, 12)&#xA;&#xA;    if l1d != pm25std:&#xA;        l1d = pm25std&#xA;        display.lcd_puts(&#39;std: %d ug/m3&#39; % l1d,1)&#xA;    if l2d != pm25atm:&#xA;        l2d = pm25atm&#xA;        display.lcd_puts(&#39;atm: %d ug/m3&#39;% l2d,2)&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;LCD显示库&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;#!/usr/bin/env python&#xA;&#34;&#34;&#34;&#xA;original from http://www.rpiblog.com/2012/07/interfacing-16x2-lcd-with-raspberry-pi.html&#xA;I modified it, thus you can set customized pin defines, such as&#xA;   lcd(0x27,1, Rs=0, Rw=1, En=2, Backlight=3, D4=4, D5=5, D6=6, D7=7)&#xA;&#xA;   address 0x27&#xA;   port    1&#xA;&#xA;   P0 - Rs&#xA;   P1 - RW&#xA;   P2 - En&#xA;   P3 - Backlight&#xA;   P4-P7 - D4-D7&#xA;&#34;&#34;&#34;&#xA;import smbus&#xA;from time import  *&#xA;&#xA;#  General  i2c  device  class  so  that  other  devices  can  be  added  easily&#xA;class i2c_device:&#xA;  def __init__(self, addr, port):&#xA;    self.addr = addr&#xA;    self.bus = smbus.SMBus(port)&#xA;&#xA;  def write(self, byte):&#xA;    self.bus.write_byte(self.addr, byte)&#xA;&#xA;  def read(self):&#xA;    return self.bus.read_byte(self.addr)&#xA;&#xA;  def read_nbytes_data(self, data, n):  #  For  sequential  reads  &gt;  1  byte&#xA;    return self.bus.read_i2c_block_data(self.addr,  data,  n)&#xA;&#xA;&#xA;class  lcd:&#xA;  #initializes  objects  and  lcd&#xA;  def  __init__(self, addr, port, **kwarg):&#xA;    self.pin = {}&#xA;    self.lcd_device = i2c_device(addr, port)&#xA;    self.config(**kwarg)&#xA;    self.Backlight = True&#xA;    self.low_level_write(En=False, Rs=False, Rw=False, data=3)&#xA;    self.lcd_strobe()&#xA;    sleep(0.0005)&#xA;    self.lcd_strobe()&#xA;    sleep(0.0005)&#xA;    self.lcd_strobe()&#xA;    sleep(0.0005)&#xA;    self.low_level_write(En=False, Rs=False, Rw=False, data=2)&#xA;    self.lcd_strobe()&#xA;    sleep(0.0005)&#xA;&#xA;    self.lcd_write(0x28)&#xA;    self.lcd_write(0x08)&#xA;    self.lcd_write(0x01)&#xA;    self.lcd_write(0x06)&#xA;    self.lcd_write(0x0C)&#xA;    self.lcd_write(0x0F)&#xA;&#xA;  def config(self, **kwarg):&#xA;    self.pin[&#39;Rs&#39;] = kwarg.get(&#39;Rs&#39;, 4)&#xA;    self.pin[&#39;Rw&#39;] = kwarg.get(&#39;Rw&#39;, 5)&#xA;    self.pin[&#39;En&#39;] = kwarg.get(&#39;En&#39;, 6)&#xA;    self.pin[&#39;Backlight&#39;] = kwarg.get(&#39;Backlight&#39;, 7)&#xA;    self.pin[&#39;D4&#39;] = kwarg.get(&#39;D4&#39;, 0)&#xA;    self.pin[&#39;D5&#39;] = kwarg.get(&#39;D5&#39;, 1)&#xA;    self.pin[&#39;D6&#39;] = kwarg.get(&#39;D6&#39;, 2)&#xA;    self.pin[&#39;D7&#39;] = kwarg.get(&#39;D7&#39;, 3)&#xA;&#xA;  def backlight(self, on=True):&#xA;    self.backlight = on&#xA;&#xA;  def low_level_write(self, En, Rs, Rw, data):&#xA;    byte = 0&#xA;    if En:&#xA;      byte = byte | 1 &lt;&lt; self.pin[&#39;En&#39;]&#xA;    if Rs:&#xA;      byte = byte | 1 &lt;&lt; self.pin[&#39;Rs&#39;]&#xA;    if Rw:&#xA;      byte = byte | 1 &lt;&lt; self.pin[&#39;Rw&#39;]&#xA;    if self.backlight:&#xA;      byte = byte | 1 &lt;&lt; self.pin[&#39;Backlight&#39;]&#xA;    if data &amp; 0x01 :&#xA;      byte = byte | 1 &lt;&lt; self.pin[&#39;D4&#39;]&#xA;    if data &amp; 0x02 :&#xA;      byte = byte | 1 &lt;&lt; self.pin[&#39;D5&#39;]&#xA;    if data &amp; 0x04 :&#xA;      byte = byte | 1 &lt;&lt; self.pin[&#39;D6&#39;]&#xA;    if data &amp; 0x08 :&#xA;      byte = byte | 1 &lt;&lt; self.pin[&#39;D7&#39;]&#xA;    self.lcd_device.write(byte)&#xA;&#xA;  #  clocks  EN  to  latch  command&#xA;  def  lcd_strobe(self):&#xA;    self.lcd_device.write(self.lcd_device.read()  |  1 &lt;&lt; self.pin[&#39;En&#39;] )&#xA;    self.lcd_device.write(self.lcd_device.read()  &amp;  (0xFF - (1&lt;&lt; self.pin[&#39;En&#39;])) )&#xA;&#xA;  #  write  a  command  to  lcd&#xA;  def  lcd_write(self,  cmd):&#xA;    self.low_level_write(En=False, Rs=False, Rw=False, data=(cmd&gt;&gt;4))&#xA;    self.lcd_strobe()&#xA;    self.low_level_write(En=False, Rs=False, Rw=False, data=(cmd&amp;0x0F))&#xA;    self.lcd_strobe()&#xA;    self.low_level_write(En=False, Rs=False, Rw=False, data=0)&#xA;&#xA;  #  write  a  character  to  lcd  (or  character  rom)&#xA;  def  lcd_write_char(self,  charvalue):&#xA;    self.low_level_write(En=False, Rs=True, Rw=False, data=(charvalue&gt;&gt;4))&#xA;    self.lcd_strobe()&#xA;    self.low_level_write(En=False, Rs=True, Rw=False, data=(charvalue&amp;0x0F))&#xA;    self.lcd_strobe()&#xA;    self.low_level_write(En=False, Rs=False, Rw=False, data=0)&#xA;&#xA;  #  put  char  function&#xA;  def  lcd_putc(self,  char):&#xA;    self.lcd_write_char(ord(char))&#xA;&#xA;  #  put  string  function&#xA;  def  lcd_puts(self,  string,  line):&#xA;    if  line  ==  1:&#xA;      self.lcd_write(0x80)&#xA;    if  line  ==  2:&#xA;      self.lcd_write(0xC0)&#xA;    if  line  ==  3:&#xA;      self.lcd_write(0x94)&#xA;    if  line  ==  4:&#xA;      self.lcd_write(0xD4)&#xA;&#xA;    for  char  in  string:&#xA;      self.lcd_putc(char)&#xA;&#xA;  #  clear  lcd  and  set  to  home&#xA;  def  lcd_clear(self):&#xA;    self.lcd_write(0x1)&#xA;    self.lcd_write(0x2)&#xA;&#xA;  #  add  custom  characters  (0  -  7)&#xA;  def  lcd_load_custon_chars(self,  fontdata):&#xA;    self.lcd_device.bus.write(0x40);&#xA;    for  char  in  fontdata:&#xA;      for  line  in  char:&#xA;        self.lcd_write_char(line)&#xA;&#xA;if __name__ == &#39;__main__&#39;:&#xA;  # define bus address, port, and pins&#xA;  display = lcd(0x27,1, Rs=0, Rw=1, En=2, Backlight=3, D4=4, D5=5, D6=6, D7=7)&#xA;  display.lcd_clear()&#xA;  # line 1 and line 2&#xA;  display.lcd_puts(&#34;I2C LCD on R-Pi&#34;,1)&#xA;  display.lcd_puts(&#34;       by gnawux&#34;,2)&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;h3&gt;Arduino 源码&lt;/h3&gt;&#xA;&#xA;&lt;p&gt;主程序:&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;#include &lt;Wire.h&gt;&#xA;#include &lt;LCD.h&gt;&#xA;#include &lt;LiquidCrystal_I2C.h&gt;  // F Malpartida&#39;s NewLiquidCrystal library&#xA;&#xA;#define I2C_ADDR    0x27  // Define I2C Address for controller&#xA;#define BACKLIGHT_PIN  3&#xA;#define En_pin  2&#xA;#define Rw_pin  1&#xA;#define Rs_pin  0&#xA;#define D4_pin  4&#xA;#define D5_pin  5&#xA;#define D6_pin  6&#xA;#define D7_pin  7&#xA;&#xA;#define  LED_OFF  0&#xA;#define  LED_ON  1&#xA;&#xA;const int SetPin = 2;&#xA;char frame[32];&#xA;&#xA;LiquidCrystal_I2C  lcd(I2C_ADDR,En_pin,Rw_pin,Rs_pin,D4_pin,D5_pin,D6_pin,D7_pin,BACKLIGHT_PIN,POSITIVE);&#xA;&#xA;char banner1[17];&#xA;char banner2[17];&#xA;&#xA;void banner_init() {&#xA;  for(int i = 0; i&lt;16;i++) {&#xA;    banner1[i] = &#39; &#39;;&#xA;    banner2[i] = &#39; &#39;;&#xA;  }&#xA;  banner1[16] = &#39;\0&#39;;&#xA;  banner2[16] = &#39;\0&#39;;&#xA;}&#xA;&#xA;void banner_display() {&#xA;  lcd.setCursor(0,0);&#xA;  lcd.print(banner1);&#xA;  lcd.setCursor(0,1);&#xA;  lcd.print(banner2);&#xA;}&#xA;&#xA;void debug(const char* str) {&#xA;  lcd.setCursor(0,0);&#xA;  lcd.print(str);&#xA;}&#xA;&#xA;void initPanTower() {&#xA;  debug(&#34;begin&#34;);&#xA;  while (1) {&#xA;    if (!Serial.available()) {&#xA;      delay(100);&#xA;      debug(&#34;wating serial&#34;);&#xA;      continue;&#xA;    }&#xA;    debug(&#34;got serial&#34;);&#xA;    int len = 0;&#xA;    int nr = Serial.readBytes(frame, 32);&#xA;    while (len + nr &lt; 32) {&#xA;      len = len + nr;&#xA;      nr = Serial.readBytes(frame + len, 32 - len);&#xA;    }&#xA;    debug(&#34;got frame&#34;);&#xA;    for (int diff = 0; diff &lt; 32 ; diff++ ) {&#xA;      if (frame[diff] == &#39;B&#39; &amp;&amp; frame[(diff+1)%32] == &#39;M&#39;) {&#xA;        nr = len = 0;&#xA;        while (len + nr &lt; diff) {&#xA;          len = len +nr;&#xA;          nr = Serial.readBytes(frame + len, diff - len);&#xA;        }&#xA;        digitalWrite(LED_BUILTIN, HIGH);&#xA;        return;&#xA;      }&#xA;    }&#xA;  }  &#xA;}&#xA;&#xA;void setup()&#xA;{&#xA;  //Initialize LCD&#xA;  lcd.begin (16,2);  // initialize the lcd&#xA;  lcd.backlight();&#xA;  banner_init();&#xA;&#xA;  //Enable Monitor Module&#xA;  pinMode(SetPin, OUTPUT);&#xA;  digitalWrite(SetPin, HIGH);&#xA;&#xA;  //shut the led&#xA;  pinMode(LED_BUILTIN, OUTPUT);&#xA;  digitalWrite(LED_BUILTIN, LOW);&#xA;&#xA;  //Start Serial Port&#xA;  Serial.begin(9600);&#xA;  initPanTower();&#xA;}&#xA;&#xA;void loop()  &#xA;{&#xA;  if (Serial.available()) {&#xA;    int len = 0;&#xA;    int nr = Serial.readBytes(frame, 32);&#xA;    while (len + nr &lt; 32) {&#xA;      len = len + nr;&#xA;      nr = Serial.readBytes(frame + len, 32 - len);&#xA;    }&#xA;&#xA;    int d1 = ((int)frame[6] &lt;&lt; 8) + frame[7];&#xA;    int d2 = ((int)frame[12] &lt;&lt; 8) + frame[13];&#xA;&#xA;    snprintf(banner1, 16, &#34;std: %d ug/m3    &#34;, d1);&#xA;    snprintf(banner2, 16, &#34;atm: %d ug/m3    &#34;, d2);&#xA;    banner_display();&#xA;  }&#xA;}&#xA;&lt;/pre&gt;&#xA;</content>
    <link href="http://wangxu.me/life/2015/12/27/diy-pm25-monitor/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>Kubernetes 中的 Service Account</title>
    <updated>2015-11-03T08:08:08+08:00</updated>
    <id>tag:wangxu.me,2015-11-03:/cloud/2015/11/03/kubernetes-service-account/index.html</id>
    <content type="html">&lt;blockquote&gt;&#xA;&lt;p&gt;照例广告放最前：Hyper 作为一家新的、小的、有梦想的、不做“Copy-to-China”的创业公司，我们欢迎想创新的、有想法的、有技术的小伙伴加盟，并且我们允许远程办公。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;Kubernetes 中的 &lt;em&gt;Service Account&lt;/em&gt; 是个比较难以理解的概念，什么是 Service Account，到底是做什么的？&lt;a href=&#34;http://kubernetes.io/v1.0/docs/user-guide/service-accounts.html&#34;&gt;文档&lt;/a&gt;中如是说——&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;A service account provides an identity for processes that run in a Pod. （服务帐号为 Pod 中的进程提供了一个 id）&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;不过，这个 Pod 中的进程的 id 是做什么用的，在用不到的时候还真让人费脑筋。&lt;a href=&#34;http://kubernetes.io/v1.0/docs/admin/service-accounts-admin.html&#34;&gt;管理文档&lt;/a&gt;里说得更详细一点，但是仍然没有提到是做什么用的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;在这种时候，一个好的例子往往胜过文档的解释。实际上，kubernetes 的官方示例里就有 Service Account 的应用。仔细看这个例子——&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.0/examples/cassandra/README.md&#34;&gt;在 Kubernetes 中运行 Cassandra&lt;/a&gt;。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;大家知道，在 Cassandra 这种全对称结构的集群里，最先启动的种子节点是最重要的，其他节点都要加入到种子节点的集群中才能保证启动的是一个集群而不会分裂成多个集群，Cassandra、Akka 集群都有这个要求。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;然而，在这个例子中，是先启动一个节点，然后直接提高 Replica 数量，来做到多节点的，后面的节点是怎么找到种子节点的呢？仔细看例子的文档——&lt;/p&gt;&#xA;&#xA;&lt;blockquote&gt;&#xA;&lt;p&gt;However it also adds a custom SeedProvider to Cassandra. In Cassandra, a &lt;code&gt;SeedProvider&lt;/code&gt; bootstraps the gossip protocol that Cassandra uses to find other nodes. The &lt;code&gt;KubernetesSeedProvider&lt;/code&gt; discovers the Kubernetes API Server using the built in Kubernetes discovery service, and then uses the Kubernetes API to find new nodes&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;这里提到了，image 中的 Cassandra 有一个特殊的 &lt;code&gt;KubernetesSeedProvider&lt;/code&gt; ，由它调用 Kubernetes 的 API 来获得集群中已经存在的节点的。注意，这里就是在 Pod 中运行的进程调用 Kubernetes API 的地方，也就是 Service Account 工作的地方。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;代码之前，了无秘密，看&lt;a href=&#34;https://github.com/kubernetes/kubernetes/blob/release-1.0/examples/cassandra/java/src/io/k8s/cassandra/KubernetesSeedProvider.java#L101&#34;&gt;这段代码&lt;/a&gt;&lt;/p&gt;&#xA;&#xA;&lt;pre&gt;&#xA;    public List&lt;InetAddress&gt; getSeeds() {&#xA;        List&lt;InetAddress&gt; list = new ArrayList&lt;InetAddress&gt;();&#xA;        String host = &#34;https://kubernetes.default.cluster.local&#34;;&#xA;        String serviceName = getEnvOrDefault(&#34;CASSANDRA_SERVICE&#34;, &#34;cassandra&#34;);&#xA;        String podNamespace = getEnvOrDefault(&#34;POD_NAMESPACE&#34;, &#34;default&#34;);&#xA;        String path = String.format(&#34;/api/v1/namespaces/%s/endpoints/&#34;, podNamespace);&#xA;        try {&#xA;            String token = getServiceAccountToken();&#xA;&lt;/pre&gt;&#xA;&#xA;&lt;p&gt;这里，给出了访问的 endpoints API，并且要从本地取出 Service Account 的 Token，来获得服务发现的信息。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;综上，Service Account 是 Kubernetes 用于集群内运行的程序，进行服务发现时调用 API 的帐号，帐号的 token 会直接挂载到 Pod 中，可以供程序直接使用。&lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/cloud/2015/11/03/kubernetes-service-account/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>Hypernetes与OpenStack东京峰会见闻</title>
    <updated>2015-11-02T08:08:08+08:00</updated>
    <id>tag:wangxu.me,2015-11-02:/cloud/2015/11/02/summit/index.html</id>
    <content type="html">&lt;blockquote&gt;&#xA;&lt;p&gt;广告放最前：作为一家新的、小的、有梦想的、不做“Copy-to-China”的创业公司，我们欢迎想创新的、有想法的、有技术的小伙伴加盟，并且我们允许远程办公。&lt;/p&gt;&#xA;&lt;/blockquote&gt;&#xA;&#xA;&lt;p&gt;10月最后一周，一年两度的 OpenStack Summit 移师东京，转瞬间朋友圈里开始有各种各样的文章出现，有些相当干的干货，比如&lt;a href=&#34;http://www.wzxue.com/openstack-tokyo-summit/&#34;&gt;王豪迈关于存储方面的这篇&lt;/a&gt;，这可是核心开发人员深入参与Design Summit，回来写的文章；当然也有一些水水的公关稿，甚至……（此处省略若干字）&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里，我也忍不住想要聊两句我们 Hyper 和 Hypernetes。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;Hypernetes&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;我们 Hyper 这次参会，带去的新产品就是 &lt;a href=&#34;http://hypernetes.com&#34;&gt;Hypernetes&lt;/a&gt;，一个真正多租户的 &lt;a href=&#34;http://kubernetes.io&#34;&gt;Kubernetes&lt;/a&gt; Distro。Hypernetes&lt;/p&gt;&#xA;&#xA;&lt;ul&gt;&#xA;&lt;li&gt;使用我们的 &lt;a href=&#34;https://hyper.sh&#34;&gt;Hyper&lt;/a&gt; 做计算隔离，轻量级虚机可以提供良好的隔离&lt;/li&gt;&#xA;&lt;li&gt;使用 OpenStack Neutron 进行网络隔离，为每个 k8s namespace 提供独立的二层网络&lt;/li&gt;&#xA;&lt;li&gt;使用 OpenStack Cinder 提供持久化的数据卷&lt;/li&gt;&#xA;&lt;/ul&gt;&#xA;&#xA;&lt;p&gt;我们在 Demo Theater 进行了演示，在我们的展台进行展示，和一些公司进行了交流，同时也在 Hacker News 上进行了发布，总的说，社区对我们的努力还是肯定的，比如，Kubernetes 项目的发起人之一、头号贡献者 Brendan Burns 就在 Twitter 远程表达了他的兴趣&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/brendan.jpg&#34; alt=&#34;quote pic&#34; style=&#34;width: 300px;&#34;/&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;技术媒体们对此也有报道，比如 &lt;a href=&#34;http://www.infoworld.com/article/2997770/application-virtualization/hypernetes-unites-kubernetes-openstack-for-multitenant-container-management.html&#34;&gt;InfoWorld&lt;/a&gt; 这篇，不是公关稿，纯粹是社区对我们工作的反馈。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;加上现场到访展台、会议上交流的公司，整个社区对我们的兴趣有点超出我的预期，感谢全体 Hyper 团队在过去两个月中的非凡努力。对我们来说，接下来就是继续努力工作，在接下来的时间里，尽快从 Demo 到可用产品。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;对 OpenStack 社区与容器的看法&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;这次峰会上，OpenStack 社区的领头羊 Rackspace 发布了他们家的容器服务 &lt;a href=&#34;https://getcarina.com&#34;&gt;Carina&lt;/a&gt;，Magnum 项目的领头人 Adrian Otto 甚至为此在 Keynote 上秀了一段娃，不过，对这个产品，大家的反馈似乎都是很奇怪、为啥还是这样…… 链接已给出，有兴趣的同学可以看看。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;至于 Magnum 项目，仍然处在一种很迷茫的状态，Design Summit 上，项目陈述自己的观点是——不改变用户使用习惯、暴露原生接口给用户；不增加 OpenStack 特定的工具和新元素。同时，会上，当我问及 Adrain ，是否考虑引入通用的容器模型时，Adrain 直接表示，Magnum 将会是 k8s, swarm, marathon 的超集，你可以使用 pod，当然只能落在 k8s 上，也能使用 compose，当然这是 swarm-only 的。在这样的形势下，感觉 Magnum 似乎在沦为一个 Heat Template，不要忘了，对很多人来说，Heat 也是不成熟的。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;相比之下，我倒是觉得 Kuryr 项目把 Neutron 作为 Docker 的 Network Provider，这个项目还是更有意义一些。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;对 OpenStack 其他项目的一些零星感受&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;第一天会上，某巨头的同学透露他们在网络方面的工作更主要集中在 Open Daylight (ODL)项目上，而将 Neutron 作为一个 API 代理，这让我们看到 OpenStack 社区的参与者们开始筹划新的框架了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;而后，豪迈同学透露 Cinder 社区有独立的念头，希望摆脱对 OpenStack 的其他项目的依赖（参见开头处的链接），这真是让我们一众唯恐天下不乱的 startup 喜闻乐见啊。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;其后，前面说的那位同学也提到，其实 neutron 也有摆脱对其他项目依赖的想法。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里，如果用知乎体问我“对于网络和存储社区想要和OpenStack划清界限一事有什么看法？”，我想说&lt;/p&gt;&#xA;&#xA;&lt;p&gt;首先，这是 OpenStack 社区中，Nova 项目过于核心的结果，Nova 是一切的核心，于是网络和存储项目都和 Nova 紧密耦合，这本身就是软件工程的灾难。如今，斗转星移，容器开始唱主角的时候，当 “新星（nova）”已经不太创新的时候，是时候引入第二个计算框架了，k8s 可能无法取代 nova，或者说容器无法取代传统虚机，但容器化的架构，或者说 Immutable 的基础设施，必将占有一个相当大的份额，在此情形之下，Cinder 如此做是顺应潮流的举动，反过来看，neutron 在有了 ODL 这样的项目之后再想划清界限就有点晚了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;但是，不论 OpenStack 开源项目的演进如何，都不能阻挡基金会仍然是成功的，作为大厂商媾和的标准化组织，即使是 Nova 被劈腿了，或者 Cinder 去除唯一依赖了，基金会仍然会通过改变自己，增加新的项目，让基金会向前演进，一个项目不是 OpenStack 的全部，OpenStack 的意义在于厂商们将 IT 基础设施互操作接口标准化的决心。&lt;/p&gt;&#xA;&#xA;&lt;h2&gt;最后&lt;/h2&gt;&#xA;&#xA;&lt;p&gt;最后，广告再来一遍——作为一家新的、小的、有梦想的、不做“Copy-to-China”的创业公司，我们欢迎想创新的、有想法的、有技术的小伙伴加盟，并且我们允许远程办公。&lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/cloud/2015/11/02/summit/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>Blog 系统更新完毕</title>
    <updated>2015-02-24T08:08:08+08:00</updated>
    <id>tag:wangxu.me,2015-02-24:/meta/2015/02/24/blog-update/index.html</id>
    <content type="html">&lt;p&gt;这个 Blog 在主机到期，迁出 wordpress 引擎之后，就放到了 github，不过，因为迁移程序的问题，文章的 url 一直是不 work 的，好几个月之后（可能有），终于修复了这些 URL。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;虽然发布频率已经低到不能再低，但这个 blog 仍然活着。&lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/meta/2015/02/24/blog-update/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
  <entry>
    <title>第一次对汽车进行DIY</title>
    <updated>2014-10-18T08:08:08+08:00</updated>
    <id>tag:wangxu.me,2014-10-18:/life/2014/10/18/car-recorder/index.html</id>
    <content type="html">&lt;p&gt;多年以来，看了这么多有意思的行车记录仪拍的视频，以及这么多的碰磁事件，一直对记录仪很心痒，琢磨着买一个，这次调研之后，郑重动手了。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;促使我动手的一个重要因素是，我发现了一件好玩事情——从保险盒取电，而不是用点烟器供电，走暗线到记录仪。这样的好处在于——点烟器还是很常用的，空出来可以给导航和其他东西用，而且暗线也避免了视觉上的干扰。&lt;/p&gt;&#xA;&#xA;&lt;p&gt;取电的要点是用一个专用的取电器，相当于从一个保险的正极取出12V直流电，过一个新加的保险丝，过调压器调到5V的USB供电，输出到记录仪，回来的负极接到靠近保险盒位置的一个金属点上，嗯，学电子一般都知道，直流设备里，接地和接机壳一般是同一件事情，所以这个没什么问题，这里是不能并回到取电的保险丝负极的，否则那个保险丝的意义就没有了。取电部分的效果如图&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/2014-10-13_15.54.44.jpg&#34; width=&#34;80%&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;这里的主要技术难度是中间的接头部分上烙铁了，用焊锡接了一段线。之后就是打开A柱的护板，把线从里面走上去，沿玻璃顶部走线，线要塞进内饰里，不过因为有降压电路的小盒，没有完全塞进去，不过也没什么妨碍，连接行车记录仪部分的效果如下图。这里还多留了一个USB母口，觉得万一可能有什么用，其实实际上没什么用……&lt;/p&gt;&#xA;&#xA;&lt;p&gt;&lt;img src=&#34;/assets/2014-10-13_15.58.23.jpg&#34; width=&#34;80%&#34; /&gt;&lt;/p&gt;&#xA;&#xA;&lt;p&gt;就这样，还是很简单的。取电器、保险丝和降压线都可以在万能的淘宝买到，这里就不做广告了。&lt;/p&gt;&#xA;</content>
    <link href="http://wangxu.me/life/2014/10/18/car-recorder/index.html"></link>
    <author>
      <name>gnawux</name>
    </author>
  </entry>
</feed>