[{"content":"\n\n\u003e 这不是新闻，更不是通稿，这是一篇记录，一篇情绪的发泄，默默地看完，通稿发出前请不要祝贺，也不要提问，谢谢\n\n终于，感受了希望、失望与绝望，经历了质疑、帮助与抛弃，从去年夏末到今年初夏，我们的这一轮融资终于在这周完成，今天我并不想宣告其中的细节，只想说，两家国内顶级VC担纲的本轮投资，对我们来说已经是非常幸运了。论及过程，可以引用一句名言——“鬼知道这一年我（我们）都经历了些什么”，不过这会儿，我只想感谢一些人，记录一些自己的成长。\n\n### 感谢团队\n\n首先要感谢的必须是我们的团队，这轮融资的过程超乎寻常的坎坷，为了保障公司运作，我们甚至在几个月中对团队成员进行了降薪。在这期间，团队仍然照常进行开发工作，我甚至可以经常看到半夜一两点，有同事在 commit 代码或提 PR，每个人都没有放松对自己的要求。在其中，我看到了他们的职业精神，也看到了他们对项目发起人的信任。这样的折磨经历，面对团队，我只想说，有你们一起是我的幸运，你们不抛弃我，我也不会放弃努力。\n\n### 感谢老领导、老朋友\n\n在最艰苦的一段时间，原本负责技术的我，也积极地参与到见各种潜在的投资人当中来，而在后面这轮融资完成的过程中，我的老领导、老朋友们起到了决定性的作用。其中两位老领导，移动研究院的前院长、达闼的创始人 **Bill Huang** 和盛大云计算的前联席 CEO，UCloud 的 CEO 季总**季昕华**，是我必须感谢的。\n\n本轮的领投方由季总为我们引入，甚至差一点我们 UCloud 也成为了我们的投资人，最终错过也并非 Ucloud 方面提出，这一过程我一直感觉很愧对季总。毫不夸张地说，没有季总，就不会有我们这轮融资，也祝季总的火箭能早日上天。不仅是季总，拜访 UCloud 的时候，莫总和我聊了很久，给我讲了他们创立 UCloud 初期的艰辛，给了我们很多肯定和鼓励，还邀请我去 TIC 大会上讲我们的技术，即使抛开这轮投资不谈，UCloud 的季总和莫总给我们的坚持的动力也是让我收益终生的。\n\n还有其他很多朋友、老同事都给了我很多帮助，对此我诚惶诚恐，希望有朝一日在各位用到我的时候，我能尽力回报。\n\n### 感谢各位投资人\n\n不止是感谢我们的天使投资人真格和云天使的帮助，也不仅是感谢我们的新投资人们，每个接触过的投资人，不管最后投或没投，都给了我们很多帮助，也让我学到了很多。这并不是一句套话，从各位投资人那里，他们会讲他们对于不同技术领域的看法，对于 startup 成长阶段的理解，对于开源生态的认知，这些对于我们今后的发展方向都会产生影响。之前我们知道投资人在努力做伯乐，发现千里马来换取百倍回报，随后我们也知道投资人会用自己管理的资金去左右产业的演进来改变世界。而在这个融资的过程中，我还能感受到投资人对于有理想的创业者的真诚地鼓励，有些投资人虽然本人不做早期投资，也会经常地来回问我进展如何，表态很支持我们的方向，鼓励我看准方向要坚持下去。\n\n### 感谢我的联合创始人\n\n我们之间的事情，只有我们之间懂，不言自明。我们在一起，我们有默契，也彼此了解对方的不足，我们互相认可对方的执着，也互相支持，不论如何困难，我们始终站在一起。我们的决策，是我们共同的决策，对与错，我们共同承担，不分彼此。这一刻我们互相感谢对方的付出，也誓言会继续互相扶助。\n\n### 感谢我的爱人\n\n聚光灯下的荣光只是一刻，而爱人却会和我共同走过一生。在过去半年，我和我的 cofounder 都没有拿过一分工资，还会贴一些日常运营的费用。这期间，家庭的收入来源只有爱人一个人，而她同时还付出大量时间来照看一双儿女，这其中的付出不是谢字可以表达出来的。未来的日子仍然悠长，我们会继续为这个家、为彼此努力付出，也用我们的全情努力来为孩子们树立榜样。\n\n\n----\n\n2017年5月\n","cover":"","link":"life/2017/05/28/oh-it-closed/index.html","preview":"\u003cp\u003e这不是新闻，更不是通稿，这是一篇个人记录，一篇情绪的发泄，默默地看完，通稿发出前请不要祝贺，也不要提问，谢谢\u003c/p\u003e\n","title":"随笔"},{"content":"\n\n\u003e 周五见到一个投资人，见面就说我明显瘦了，我赶快表示，这是我锻炼的结果，为了投资人，健康工作\n\n![4km](/assets/keep1.jpg)\n\n## 其实少吃才是最重要的\n\n根据 keep 记录，过去2个半月，进行了71天，122次锻炼；根据体重计，我的体重大概减了 7-8kg。当然，我总是强调这是锻炼的结果，不过实际上，可能控制饮食才是更重要的，包括但不限于\n\n- 晚饭尽量避免吃肉（饭局除外）；\n- 尽量降低食物的脂肪含量，比如少吃猪肉，在赛百味吃牛肉、辣椒酱、不要芝士……\n- 少喝饮料，两个月没动谈算饮料；\n- 不把自己吃太满足；\n- ……\n\n我感觉，少吃可能是最关键的，睡一宿觉都会轻一点，只要摄入足够少，降低体重大概就不是问题。这么简单的方法，为啥当了快30年胖子的我，一直没试过呢…… 唉，胖子同学们都懂的，少吃可能比锻炼更考验人啊。\n\n## 当然锻炼的效果也不差\n\n当然，我锻炼的目的并不单纯就是轻一点体重，锻炼的对身体机能的效果实际还是不错的，一张图就可以对比出来——\n\n![feb vs apr](/assets/keep-compare.png)\n\n左边是二月一次锻炼，右边是四月的，可以看到，四月锻炼的时候全程都比较稳定，虽然速度和朋友圈的健身达人们没法比，但是状态明显好于二月。而且，还在这个星期，提前8个月，达到了某运营商领导提出的跑10圈的年度目标，我自己当然是满意的。\n\n## 坚持锻炼的心得\n\n这不是我第一次锻炼了，不过，能坚持两个多月，对我来说也算是不俗的成绩了，目前 BMI 指数已经接近肥胖和超重的界限了，希望年底能变成超重。我得留下点坚持心得给我的子孙后代：\n\n- 首先，把要锻炼了这件事情说给别人听，只有公开的目标才是目标，即使实际没人关注这个目标，但自己总会感受到更多的压力，这样会给自己动力；\n- 其次，降低对自己的要求和期望，避免挫败，过高的期望很容易会伴随失望，健身减脂是生活的一个细节，而不是生活的意义，没必要为此伤害自己的感情，如果今天错过了锻炼，没必要自暴自弃，如果今天成绩不好，也没必要放弃自己，如果今天有兄弟远渡重洋来相会，烤鸭和火锅也可以一起吃，但是吃完了并不是健身的目标落空了，而是这只是一个健身过程中的小插曲，明天继续锻炼，并没有挫折；同样，对于目标，我尽量不给自己订有困难的目标，就好象4公里的目标定在年底，这样，我可以根据自己的状态，循序渐进，每多跑一圈都是成功；\n- 再次，经常获得正反馈，这方面不得不说有个 keep 这种健身应用还是挺有帮助的，经常在上面看到自己的努力成果，还是蛮有成就感的，只要注意，不要选择比自己强又比自己努力的人当好友就好了，那样的人就直接屏蔽掉好了；\n- 当然，在锻炼到辛苦的地方的时候，偶尔努力多坚持一下，会有更多回报，当发现自己可以平稳胜任当前训练强度的时候，给自己增加一点强度，不要让自己太享受舒适区，舒适区让自己获得安逸，但会让自己也失去成就感的回报；\n- 最后，要注意保护自己的身体，拉伸运动、合理的装备和场地都是必须的，如果身体不允许，就不要勉强，一辈子的事不能急于一时，这对于我们胖子，特别是我们年事已高的胖老头尤其关键。\n\n好了，作为一个胖子看门大爷就这么多心得，真没没想到胖子也能总结出这么多锻炼心得。当然，心得只是战术，要达到的真正的目的才是战略。\n\n## 更深层的目的，为了爱的人，为了自己\n\n实际上，开始锻炼这件事情想了很久了，[去年我在日志里](/family/2016/06/08/for-dad/)就写过\n\n\u003e 我知道要关爱我的家庭，要关照妈妈，也要爱护自己。我会更加自律地生活，因为失去你的痛苦，让我知道，不要让爱我的人再那么早承受这份痛，相信我，我会尽力爱护你爱的人的。\n\n开头的调侃不是虚的，健康出问题，受影响最大的就是关心你的人，父亲在去年的离去让我陷入深深的痛苦，也让我知道，自己的健康对于爱我的人多模重要，为了他们，我也要更爱自己，就为了这个，我挑战了“吃”——这一胖子最难面对的问题，也在快到37岁的时候，这辈子第一次跑步4km……所有这些，因为我爱你们这些关心我的人，所以我会爱自己，不让你们为我难过。\n\n我会继续坚持努力的，运气好的话，没准能坚持到下半年呢。\n\n## 以及一点黑暗的发现\n\n\u003e 我也不知道为啥我一定想把实话写在日志里啊，请读者兄弟们不要对号入座。\n\n经历了真真实实的锻炼感受以后，我忽然有点发现——我有点理解为什么有人沉迷健身了——这是一种难得的只要持续付出就有收获的活动。相比之下，努力读书、工作啥的都不是这样，努力工作，不一定能升职加薪、成为CEO，赢取白富美；努力读书也可能最终只是发现自己智商不如旁边某个轻轻松松比你高50分的妹子；而健身这种付出与收获成比例的事情，可以让很多逆境中的人获得在生活中无法得到的成就感，所以有人用这个逃避生活。\n\n当然，我不是说朋友圈里你们这些跑步 10km 起的达人们是逃避生活啊，就好象王思聪也喜欢网游，但我们从来不说他是沉迷，只是，你们身边一定有这样的例子吧。倒是对我们创业的人来说，总会遇到一些压抑的地方，健身绝对是一种给你的生活增加阳光的地方，阳光健康的创业者能走得更远，是吧？\n","cover":"","link":"life/2017/04/23/lose-weight/index.html","preview":"\u003cp\u003e这是一篇不太鸡汤的锻炼记录，有些回忆，有些心得，有些欣喜，有些（负能量）感想\u003c/p\u003e\n","title":"锻炼两月记"},{"content":"\n\n..\n\n这一刻，我想了很多，但我不想写在这里，让它埋在心里，让它随风远去\n","cover":"","link":"family/2017/02/09/nothing/index.html","preview":"\u003cp\u003e这一刻，我想了很多，但我不想写在这里，让它埋在心里，让它随风远去\u003c/p\u003e\n","title":"..."},{"content":"\n\n2016 年过去了，2017年到了，农历年到了，然后，爸爸的周年祭日到了... 天知道我这一年到底经历了些什么\n\n\u003e 这一年，有不少快乐的瞬间，可是，毫无疑问，这是痛苦的一年；抬着头，我从未对自己失去过信心，可是，这绝对是失望的一年。\n\n去年的大年夜，我晃在长安街边，却找不到开着的药房；去年的正月初一，我徘徊在病房外，却没能和父亲再面对面聊一两句；去年的大年初二，我偷偷在电梯里泪流满面；大年初六，我送父亲最后一程，只记得大家都叫我照顾好我妈。那之后的大概一个月，我总是不能忘记，他留给在我手上的最后的温度，他最后和我的通话，以及，他送医院的前一天……\n\n当时，我努力了一个多月，我尽力尝试了我能用上的一切手段，我的朋友们也都尽力帮了我，现代医学那么发达的介入手段在帮他支撑，可是，他最终还是无可挽回地离开了我。他那么喜欢孩子，他还要看孙子孙女长大成人呢啊，他那么看重孝心，他的老母亲还在，他还要尽孝床前啊，如此种种，即使有这么多的未尽指出，截止时间还是来了，根本不给宽限，不容商榷。那种经历，可谓是一夜长大。\n\n我依然记得，我从移动离职加入盛大云的时候，爸爸在饭桌上对我说，“男孩就应该出去闯闯，我支持你”，我只是去上海三个月而已，感觉像是要离家不回的样子，而这次，他用自己的生命，再一次教我勇敢地面对生活，之前不敢想象的事情真的发生了，我才知道，并没有真的无法面对的事情，因为，我不得不面对。\n\n一年了，千思万绪，我都无法写出一篇像样的文章来纪念爸爸。但我知道，勇敢地走好是他对我的期待，我要努力面对挑战，战胜困难，也要努力自律，做更好的自己。美好的事情，终会发生。爸爸，一直在我心里。\n","cover":"","link":"family/2017/02/09/a-year-without-you/index.html","preview":"\u003cp\u003e这一年，有不少快乐的瞬间，可是，这是痛苦的一年；抬着头，我从未对自己失去过信心，可是，这是失望的一年\u003c/p\u003e\n","title":"A Year without You"},{"content":"\n\n\u003e 本文来自 hyper.sh 上线四个月以来对用户的一些观察与访谈，作为一种新的服务，用户的创造力可能会超出设计者最初的构想，这里只是部分的归纳，希望能对读者有一定的启发。\n\n## 背景： Hyper.sh 与容器云\n\n今年8月，我们上线了 [HYPER.sh](https://www.hyper.sh) 服务，我们打出的口号之一是——“用 Container 重新发明 IaaS (Re-Invent IaaS with Container)”，不同于之前各大小云服务商提供的容器服务，Hyper.sh 没有运行在一个 IaaS 系统上，容器就是云的一等公民。当然，Hyper.sh 使用了我们自己的开源项目 [HyperContainer](https://github.com/hyperhq/hyperd) 替换掉了 Docker Runtime，所以可以无需底层 IaaS 就可以做到多租户的隔离。\n\n在 Hyper.sh 上，用户无需拥有一个集群/资源池就可以直接创建容器，容器启动时间一般为 3-5 秒（加挂数据卷可能会让这一时间变长一些），在此基础上，计费也按照秒级进行。Hyper.sh 提供了 API 和客户端访问，除了公网 IP、安全组等 IaaS 传统项目之外，Hyper.sh 的客户端和 API 的体验和本地使用 Docker Daemon 别无二致，用户不需要察觉到支持这个 “云中的 Docker Daemon” 的是一个集群，他也看不到节点的概念，只需要 `hyper pull` 和 `hyper run` 就可以了。\n\n所以，TNS 发表了一篇 Top Story --- [Hyper is Docker Done the Right Way](http://thenewstack.io/hyper-docker-done-right-way/) 。这种超出以往的弹性与容器的轻量级属性一起，让一些以往没人做的事情变成了可能。\n\n## 应用案例\n\n### 持续集成 CD/CI\n\n有 BuildBot 和 Jenkins 两大应用， Hyper.sh 没准是最被看好的 CD/CI 基础设施之一了吧。 [《Buildbot集成Hyper_容器云，新型Serverless CI的诞生？》](http://geek.csdn.net/news/detail/96120) 里说了很多细节，在此感谢 CSDN 这篇极客头条的免费推广。简单地说，容器云因为资源粒度更细，避免了时间和资源的浪费，更提高了工作效率，节约了开支。\n\n### 周期性批量处理\n\n我们另外的一位用户会进行一些周期性的 ETL 工作，他会一次启动上百个 container，从 AWS S3 拉下原始数据，进行若干秒钟的处理后，把数据结果推送到他在自己数据中心中的服务器中。在之前使用 EC2 的时候，单台虚机的计费是小时起的，所以，算得快也不能省钱，而放在容器云上之后，直接可以用并发来交换时间，提高效率，却并不会显著增加成本。\n\n在这个用户的启发下，我们还推出了新的 `hyper cron` 服务，如 `cron` 一般，为用户定时启动容器执行任务。\n\n### 按需处理\n\n我们还有一些用户，会进行一些高并发的按需处理，比如一个用户用容器云来承载一个视频处理应用，每当用户上传时，就运行新的容器进行处理，完成后就销毁容器；另外一位加州名校的老师，用 Hyper.sh 容器云来处理学生提交的作业，每个提交的作业会启动一个 container 进行结果验证，完成后销毁容器。这两个应用都和 CD/CI 非常类似，无需预先准备资源，随时按需扩展承载业务。\n\n### 容器容灾\n\n国外有很多用户已经开始使用容器提供服务了，这样的用户会发现，使用容器云同样是容灾的一个方便的手段，因为在 Hyper.sh 上启动容器的时间只有 3-5 秒，他们不需要在平时就有服务器跑着进行热备，只要在需要切换服务的时候，在 Hyper.sh 上启动容器就可以了。对大部分互联网服务来说，三到四个9的可用性就足够了，有了可以秒级启动的容器云，就完全没有必要维持热备的服务器了。\n\n### 轻量网站\n\n有很多低流量的网站，比如我的个人博客或一些稍大的个人项目，甚至完全没必要占据 512MB 内存，如果不启动一些不太重要的服务的话，甚至 64MB 内存都足够，在 Hyper.sh 上也有不少这样的用户，他们之前把网站放在VPS上或者根本没有自己的主机，现在放在 Hyper.sh 上的容器里，可以有自己的独立 IP，利用 letsencrypt 之类的服务提供 Https 服务更容易，成本也不高。\n\n### 业务交付\n\n我们的早期用户里，还有一些咨询公司或自由职业者，他们使用 docker 完成客户的外包任务，之前测试之后，还要帮助用户把产品跑到用户的平台上，或者帮用户搭建环境。现在他们可以直接把成品跑在 Hyper.sh 容器云上，测试完成之后，可以把整个容器直接交付给客户，不需要和他们的其他客户共享容器，所以测试、交付也更容易。\n\n## 模式分析\n\n以上只是一些比较常见的容器应用分析，有些比较微服务，而其他的却并不一定。但它们的共同特点是利用了 Hyper 这类容器云的高弹性和细粒度的资源调配，做到了之前依托 IaaS 无法达到的效率，节约了资源成本或时间成本，总的说有一下几点：\n\n1. **不再需要资源池**，或者说整个云就是资源池——不需要使用虚机池子进行任务调度了，每个任务跑一个容器，跑完销毁；\n2. **并发换时间**——秒级启动、秒级计费，没有很长启动和准备时间的开销，也没有1小时起价的约束，并行化提高效率也就没有了后顾之忧；\n3. **按需启动，无需待机**——只要在需要的时候启动容器就可以，不论是来任务启动、定时启动还是遇到事故紧急启动，都不需要预先预热系统；\n4. **每个应用一个容器**——容器间有良好隔离，不同应用按照各自生命周期管理，无需迁就。\n\n这些容器云的简单模式，让应用变得比以往更加简单，也鼓励着各位用户，包括我们这些狗粮用户，在不断尝试新玩法。后面随着新业务的上线和更多用户的新玩法贡献，我也还会继续更新这个系列。\n","cover":"","link":"hyper/2016/12/19/container-cloud-pattern/index.html","preview":"\u003cp\u003e本文来自 hyper.sh 上线四个月以来对用户的一些观察与访谈，作为一种新的服务，用户的创造力可能会超出设计者最初的构想，这里只是部分的归纳，希望能对读者有一定的启发\u003c/p\u003e\n","title":"容器云中的应用模式（1）"},{"content":"\n\n这本来是一个内部文档，不过似乎发布出来也不错，HyperContainer 支持原生的 Docker Logger，所以这篇日志讲得既是 Docker 的 Logger，也是 Hyper 的 Logger。\n\n\u003e 按，本文的参考代码主要位于 `\"github.com/docker/docker/daemon/logger\"` ，用于参考的 json-file logger 的代码位于 `\"github.com/docker/docker/daemon/logger/jsonfilelog\"` 。\n\n## 关于 Docker Logger\n\nDocker 的日志设计实际很简单，container 进程的标准输出和标准错误输出，就直接作为 container 的正常日志和错误日志。日志系统实际相当于两条管道（对于使用 tty 的 container，是一条），一端作为 `stdout` 和 `stderr` ， attach 到 container 上，接收 container 输出的信息，另一端写入日志系统。\n\n这个日志系统本身是一个具有可扩展性的框架，不仅内建支持了一些日志输出方式，比如 `json-file`, `syslog`，也很容易扩展自己的日志系统，只需要实现几个接口即可。\n\n## 日志消息\n\n日志消息是日志中信息的基本单位，不论是记日志，还是读日志，基本单位都是 `Message` ，形状是这样的\n\n```\n// Message is datastructure that represents record from some container.\ntype Message struct {\n\tContainerID string\n\tLine        []byte\n\tSource      string\n\tTimestamp   time.Time\n}\n```\n\n字段的名字都很有描述性，基本不需要介绍， `Source` 字段是指 `stdout` 或 `stderr`，而消息的内容 (`Line`) 是不包含结尾换行的日志记录，如果写文件的话，需要日志驱动加上换行。\n\n## 日志的记录\n\n记录日志的东西就是 `Logger` ，它只需要实现这个接口：\n\n```\ntype Logger interface {\n\tLog(*Message) error\n\tName() string\n\tClose() error\n}\n```\n\n从简单的说起， `Name()` 就是返回日志驱动的名字，比如 `json-file` 日志驱动就会返回 `\"json-file\"` ，除此之外毫无信息量。而 `Close()` 用来停止记录日志，在 Container 结束的时候调用来结束写入。\n\n记录日志的主要函数是 `Log(*Message) error`, 当然这里也没有什么特别的，还是非常直观易懂，唯一需要注意的是，如果写入有并发的话，需要使用 `chan` 或加锁同步一下，避免写出奇怪的东西来。\n\n## 日志的读取\n\n对于 Docker Logger 来说，同一个 Logger 不紧要支持日志的写入，还要支持日志的读取，读取者要实现 `LogReader` 接口\n\n```\ntype LogReader interface {\n\t// Read logs from underlying logging backend\n\tReadLogs(ReadConfig) *LogWatcher\n}\n```\n\n这个接口只有一个方法，但实际上要比写入复杂，`ReadLogs()` 函数是有一个 `ReadConfig` 类型的参数的：\n\n```\ntype ReadConfig struct {\n\tSince  time.Time\n\tTail   int\n\tFollow bool\n}\n```\n\n这些是用户在读日志的时候可以指定的参数：日志开始时间 (`Since`)，读取日志的最后几行的行数 (`Tail`，为 0 则是输出所有日志)，以及是否 `Follow`，和 `tail` 命令一样，如果 `Follow` 为 `true`，那么，就需要一直等着程序的进一步输出，而不是显示完所有日志就完了。\n\n`ReadLogs()` 并不直接返回日志内容，而是立刻返回一个 `LogWatcher`\n\n```\ntype LogWatcher struct {\n\t// For sending log messages to a reader.\n\tMsg chan *Message\n\t// For sending error messages that occur while while reading logs.\n\tErr           chan error\n\tcloseNotifier chan struct{}\n}\n```\n\n通过这几个 `chan` 来给读者（一般是 logs API 的后端）异步返回日志信息、错误消息以及关闭提醒。这个 `LogWatcher` 有两个方法：\n\n- `Close()` 关闭这个 `LogWatcher`\n- `WatchClose()` ，返回一个 `\u003c-chan`，用于监听 `LogWatcher` 事件，用法大致如下\n\n  ```\nselect {\ncase \u003c-watcher.WatchClose():\n    //closed...\n}\n```\n\n日志是允许多个 reader 同时读的，并且，当有 `Follow` 标记的时候，\n\n## 日志工厂 (Creator)\n\nDocker (或者说 `hyperd`) 会为每个 container 创建一个 `Logger`, 所以，日志驱动实际是通过一个 `Creator` 来创建日志的，每个日志驱动都要提供一个 `Creator` 函数\n\n```\n// Creator builds a logging driver instance with given context.\ntype Creator func(Context) (Logger, error)\n```\n\n这其中的 `Context` 是关于 Container 和 logger 配置的详细信息：\n\n```\ntype Context struct {\n\tConfig              map[string]string\n\tContainerID         string\n\tContainerName       string\n\tContainerEntrypoint string\n\tContainerArgs       []string\n\tContainerImageID    string\n\tContainerImageName  string\n\tContainerCreated    time.Time\n\tContainerEnv        []string\n\tContainerLabels     map[string]string\n\tLogPath             string\n}\n```\n\n由日志用户在创建 Logger 的时候填入，其中 `Config` 字段是日志专用的日志配置信息，`LogPath` 是日志存储路径，但并非所有的日志系统都需要一个路径，其他字段都是 Container 的信息，以备日志驱动可能会用到。\n\n实现日志驱动的时候需要注意的一点是，日志 `Creator` 的返回类型是 `Logger` 接口，而实际上，返回的这个 `Logger` 也要实现 `LogReader`，在使用中，会把 Logger cast 成 *logger.LogReader。\n\n此外，日志驱动还可以提供一个方法来验证配置参数\n\n```\ntype LogOptValidator func(cfg map[string]string) error\n```\n\n日志驱动可以用这个方法来检验用户给的日志配置的合法性，如果有错误，返回一个 `error` 就使得 Container 无法使用这个日志驱动。\n\n## 注册日志驱动\n\n日志驱动实现了上述的类型和工厂方法后，要注册自己来成为系统中可用的日志驱动\n\n```\nfunc RegisterLogDriver(name string, c Creator) error\n\nfunc RegisterLogOptValidator(name string, l LogOptValidator) error\n```\n\n比如，`json-file` 就在自己的 `init()` 里注册了自己的 Creator 和 Validator:\n\n```\nfunc init() {\n\tif err := logger.RegisterLogDriver(Name, New); err != nil {\n\t\tlogrus.Fatal(err)\n\t}\n\tif err := logger.RegisterLogOptValidator(Name, ValidateLogOpt); err != nil {\n\t\tlogrus.Fatal(err)\n\t}\n}\n```\n\n## 小结\n\n没啥可小结的了，就这些。\n","cover":"","link":"docker/2016/11/04/docker-logger/index.html","preview":"\u003cp\u003e这本来是一个内部文档，不过似乎发布出来也不错，HyperContainer 支持原生的 Docker Logger，所以这篇日志讲得既是 Docker 的 Logger，也是 Hyper 的 Logger\u003c/p\u003e\n","title":"实现一个自己的 Docker 日志驱动"},{"content":"\n\n这两天我好像对新闻特别有意见，今天早上看到的新闻是 InfoQ 的这篇 [从RethinkDB的倒闭反思开源项目可持续的盈利模式](http://www.infoq.com/cn/news/2016/10/Reflection-sustainable-profit-co) ，还请来国内开源圈的韩卿和刘奇评论，当然，他们没问我如何看待，如果问了我就没这么多吐槽了，哈哈。\n\n朋友圈里，我可能是最早关注 RethinkDB 倒掉这个新闻的，只是有用户在抱怨 RethinkDB 好像停止开发了的时候我就关注了，不过这是因为我们（[Hyper.sh](https://hyper.sh)）有商业用户用 RethinkDB，所以我跟着关注这个项目的。但是我觉得 RethinkDB 倒掉就上升高度来热烈讨论开源商业模式的问题，实在是让我忽然从隔岸观火一下变成了殃及池鱼，忍不住要说两句了。\n\n开源是一个怎样的生态系统、是不是一个好的商业模式，这个问题从二十年前就开始讨论了，从 Linux 的繁荣到 MySQL 的发展到 Sun 的倒掉，而 **这恍然二十个春秋中， RethinkDB 不过是沧海一粟** ，被拎出来管窥实在是有点片面了，可能媒体也不容易吧，感觉刘奇韩卿他们被找上门评论好累，呵呵，网红不易啊。\n\n我要说，首先，从全球望去做比较通用的基础软件你不开源是没啥出路的，或者说 **没得选，你必须开源**，RethinkDB 如果不开源，广大用户根本不会知道有这么个产品，那么现在你有理想做基础设施方面的创新，而不是集成商，那么好吧，你得开源；\n\n然后，相比于开源学术项目，做 **开源产品和做闭源产品很相似** 的，都面临着吸引用户、留住用户、请用户买账这些问题，所不同的只是吸引用户的渠道不同，换句话说，你做的产品不够好，不论是 feature 不够好、品质不够好、还是节奏不够好，都会面临困境；\n\n还有，我要说的是 **时间问题** ，对于 NoSQL 来说，HBase/MongoDB/Riak/Cassandra 这些明星产品交相辉映的时候已经过去了，你错过了那个时间，没有在那个时间把公司壮大起来，现如今已经是网红刘奇他们这样的 NewSQL 的时代了，那么，即使是扎实的产品，再想抓住眼球的难度就已经高出6个dB了。\n\n**最后，我想说的是， [Hyper](https://github.com/hyperhq/hyperd) 这样的容器领域的开源项目正是时候，加入要抓紧啊** 。\n","cover":"","link":"opensource/2016/10/27/rethinkdb/index.html","preview":"\u003cp\u003e这恍然二十个春秋中， RethinkDB 不过是沧海一粟，被拎出来管窥实在是有点片面了，可能媒体也不容易吧\u003c/p\u003e\n","title":"新闻评论: 也谈 RethinDB 的倒掉"},{"content":"\n\n今天的朋友圈里，充斥着几家云（自）媒体的一条新闻——《XX之家因为无法忍受阿里云而迁移至XX云》，我不赞同其标题，所以也就不转链接了，同样，我不喜欢这种广告形式，也隐去了相关的名字。\n\n作为曾经的竞争对手，本来我以为我会是阿里一生黑的，阿里也有很多做得让我不那么赞同的东西，我今天就算是为他们说句话，也不代表我完全支持阿里云了，其实今天这种通过公关炒作吸引用户从竞争对手上迁移出来的手段，阿里就算不是始作俑者，也是上一辈的集大成者了。但我今天要说的是——\n\n\u003e 国内云服务，什么时候出故障了能根据SLA索赔/赔付，而不是发公关稿、圈大V，才算是环境成熟了。——我 (王旭 @ Hyper.sh)\n\n认识阿里云的几位大牛，有的是一两句话的交情，比如褚霸，还有些深一些，总得有一二十句话吧。上星期 CLSF 上，我和涛哥说你们阿里云作为中国云计算的旗舰，不能光盯着低端市场了，你们要撑起中国云计算的生态系统就不能一直跟着 VPS 拼，要向 AWS 看齐，并在业务上超越。说这话，多少有点自己没能力和 AWS 拼，想看着同胞们上去的咸咸的感觉吧。涛哥嘿嘿一笑，我也理解，毕竟涛哥虽然姓马，却不是马主席啊……\n\n阿里云的盘古与飞天，这么诗意的名字，实际和用户并不直接对接，我有点酸葡萄地吐槽——现在阿里云正事没啥突出的，live migration 和 live patching 已经独步行业了。为啥？AWS 只要给用户送个通知就可以重启机器，而阿里战战兢兢升级的时候稍有不测就会有人开始炒作，结果直接干活的工程师被处罚，这种模式会影响国内云服务的进步，最后，整个国内的云产业和你们在座这些用户也是受害者。\n\n所以啊，我希望的是，国内的用户们和服务商们，你们都行动起来，停止这种互撕吧，用户的架构上面向 cloud native 演进，服务商努力保障 QoS 的同时通过 SLA 界定和解决用户纠纷，通过定价和更有价值的业务，筛选并留住适合的用户，比如 aws redshift 这些（此处应有 Hyper.sh 的广告，因为懒，略过了）。当然这些 **不光是服务商的事，也是用户、监管，和行业标准制定者的工作，良好的国内云生态，需要各位的共同努力**。\n","cover":"","link":"cloud/2016/10/26/alicloud/index.html","preview":"\u003cp\u003e作为曾经的竞争对手，本来我以为我会是阿里一生黑的，不过，今天看这新闻标题，我想为阿里说句话\u003c/p\u003e\n","title":"新闻评论: 你真的无法忍受阿里云么"},{"content":"\n\n\u003e ARM64 (ARMv8) 架构的支持，不仅是对一个新架构的支持，一类新服务器的支持，也把 Hyper 带入到了终端，乃至是物联网（IoT）技术的大门前，等待我们的将是更广阔更精彩的未来。\n\n随着我在过去的几天中先后 merge 了高峰提出的 [hyperhq/hyperstart#207](https://github.com/hyperhq/hyperstart/pull/207), [hyperhq/runv#360](https://github.com/hyperhq/runv/pull/360), 和 [hyperhq/hyperd#437](https://github.com/hyperhq/hyperd/pull/437), 三个 PR，HyperContainer 正式支持了 ARM64 (ARMv8, aarch64) 架构。\n\n![ARM64 support](/assets/arm64.jpg)\n\n```\nroot@pine64:/home/debian# time hyperctl run -t aarch64/busybox sh -c \"echo hello, arm64\"\nhello, arm64\n\nreal    0m4.381s\nuser    0m0.130s\nsys 0m0.080s\n```\n\n在 KVM for ARM 的工作基础上，也借助了之前 IBM 的 runV 多架构支持工作，ARM64支持并没有消耗太多的时间，在这过程中尤其感谢泽帆代表华为提供的 ARM 服务器板作为测试平台，同时我也在 pine64 上对这一工作进行了验证，一切进行得比较顺利。\n\n除了 ARM 64 服务器外， 常见的 ARM64 系统还包括各位的使用高通 Snapdragon 810/820 系列 CPU 的手机，各种 ARM Cortex A53/A57 CPU （华为、三星、MTK芯片）的手机，Raspberry Pi 3、 Pine 64 等常见的嵌入式开发版，价格从一两百块人民币起，有些是随身携带的移动终端，也有些被看作是 IoT 设备，这也标志着未来 HyperContainer 技术还有更多的可能场景。\n\n![pine64](/assets/pine64.jpg)\n\n![华为 ARM64 服务器板](/assets/huwwei-arm64.jpg)\n\n谢谢大家。\n","cover":"/assets/hello-arm64.jpg","link":"hyper/2016/10/17/hyper-arm64/index.html","preview":"\u003cp\u003eARM64 (ARMv8) 架构的支持，不仅是对一个新架构的支持，一类新服务器的支持，也把 Hyper 带入到了终端，乃至是物联网（IoT）技术的大门前，等待我们的将是更广阔更精彩的未来\u003c/p\u003e\n","title":"Hello, ARM64 -- Hyper ARM64 架构支持"},{"content":"\n\n\u003e 更新: 为了支持一跑起来就要有公网的场景，我们改进了 Floating IP 的流程，允许刚刚创建，还没有启动过的 container 加 fip 了，另外，修订了 Dockerfile 减小了一点体积。\n\n[前一偏贴出来](/meta/2016/09/24/blog-to-hyper/)有人评论\n\n\u003e 启动一个ubuntu的image, 然后exec进去安装软件。。。这不符合imutable server哲学\n\n本来因为太简单，已经懒得再做 image 了，不过，既然有同学指出了，好吧，你们说得对，吃自己的狗粮要吃得正宗才对，于是，做个 image 吧。\n\n## 制作 Image\n\n`Dockerfile` 这么写\n\n```\nFROM ubuntu:xenial\nMAINTAINER gnawux@gmail.com\nRUN apt-get update \u0026\u0026 \\\n        apt-get -y install git \u0026\u0026 \\\n        apt-get clean \u0026\u0026 \\\n        rm -fr /var/lib/apt/lists/* /tmp/* /var/tmp/*\nCOPY caddy /srv/\nCOPY entrypoint.sh /\nENTRYPOINT [ \"/entrypoint.sh\" ]\n```\n\n其中的 `entrypoint.sh` 这么写，这样就不用把密码放到 image 里了，嘻嘻\n\n```\n#!/bin/bash\nPASSWORD=password\nif [ $# -ge 1 ] ; then\n\tif [ \"x$1\" != \"x${1#/}\"  ] ; then\n\t\texec \"$@\"\n\tfi\n\tPASSWORD=$1\nfi\n\ncat \u003e srv/Caddyfile \u003c\u003c-ENDFILE\nwangsiyi.net {\n        gzip\n        root wangsiyi.net\n        git {\n                repo https://github.com/gnawux/wangsiyi.net\n                branch gh-pages\n                hook /update ${PASSWORD}\n                hook_type github\n                interval -1\n        }\n}\nwangxu.me {\n        gzip\n        root wangxu.me\n        git {\n                repo https://github.com/gnawux/gnawux.github.io\n                hook /update ${PASSWORD}\n                hook_type github\n                interval -1\n        }\n}\nENDFILE\n\ncd srv\n./caddy -agree -email gnawux@gmail.com -host wangxu.me \u003e /dev/stdout 2\u003e/dev/stderr\n```\n\n上面注意， `entrypoint.sh` 脚本一定要 block 住，不要退出，刚才我一不小心…… 发现怎么都秒退，这个错误太初级了啊，留在 commit log 里实在是比较丢人。\n\n然后，整个制作 image 也可以放在一个脚本里面，比如这样\n\n```\n#!/bin/bash\n\nif [ ! -f caddy ] ; then\n\twget -O - \"https://caddyserver.com/download/build?os=linux\u0026arch=amd64\u0026features=git\" | tar -zxvf -\n\trm -rf init *.txt\nfi\n\n[ ! -f caddy ] \u0026\u0026 echo \"caddy download failed\" \u0026\u0026 exit 1\n\nsudo docker build -t \"gnawux/blog:latest\" .\n```\n\n所有这些我放到 repo 里了： https://github.com/gnawux/xu-site ，本来弄个 repo 我想自己写个 server 的，最后就放个 dockerfile，我也是挺失落的啊。\n\n## 运行\n\n镜像制作好之后，推到 hub，就回到 hyper 来 run 吧，因为 caddy 一启动会自动去找 Let's Encrypt 生成证书，这需要 Floating 一启动就生效，所以我们先创建容器，然后添加 FIP，然后启动 ——\n\n### 首先创建 Container\n\n```\n➜ ~ hyper create -p 80:80 -p 443:443 --name blog --hostname blog -it gnawux/blog xxxxxxx\nblog\n```\n\n### 给它分配一个 Floating IP\n\n```\n➜ ~ hyper fip attach 209.177.91.195 blog\n```\n\n### 启动\n\n\u003e 下面启动之后使用 Ctrl-P+Q 退出，如果不是为了看输出，可以不加 -a -i 参数。\n\n```\n➜ ~ hyper start -a -i blog\nActivating privacy features... done.\nCloning into 'wangsiyi.net'...\nremote: Counting objects: 927, done.\nremote: Total 927 (delta 0), reused 0 (delta 0), pack-reused 927\nReceiving objects: 100% (927/927), 14.32 MiB | 4.47 MiB/s, done.\nResolving deltas: 100% (414/414), done.\nChecking connectivity... done.\n2016/09/24 08:35:22 https://github.com/gnawux/wangsiyi.net.git pulled.\nCloning into 'wangxu.me'...\nremote: Counting objects: 17080, done.\nremote: Compressing objects: 100% (103/103), done.\nremote: Total 17080 (delta 78), reused 0 (delta 0), pack-reused 16951\nReceiving objects: 100% (17080/17080), 28.90 MiB | 5.77 MiB/s, done.\nResolving deltas: 100% (7924/7924), done.\nChecking connectivity... done.\n2016/09/24 08:35:28 https://github.com/gnawux/gnawux.github.io.git pulled.\nhttps://wangsiyi.net\nhttps://wangxu.me\nhttp://wangsiyi.net\nhttp://wangxu.me\n```\n\n一切 OK，大家好好玩。回头我给 `run` 加个参数，直接绑 FIP，就不用分三步给大家讲解了 :)\n\n### 致谢\n\n- 感谢老徐指出减少 Image 大小的命令，[commit 在这里](https://github.com/gnawux/xu-site/commit/51b42c86d88d870947fc017889d10b1ef23498de)\n- 感谢 Tim 指出错别字\n\n另外，这篇居然被人抓了当自己 blog 发出来了，这么硬的广告也抓么？\n","cover":"","link":"meta/2016/09/24/blog-to-hyper-2/index.html","preview":"\u003cp\u003e吃自己的狗粮要吃得更正宗\u003c/p\u003e\n","title":"Blog 迁移后记"},{"content":"\n\n\u003e 更新：Blog贴出来之后，因为有人批评我太懒，于是我知错就改，当天下午就把 blog 的 image 也做了，参见[这篇后记](/meta/2016/09/24/blog-to-hyper-2/)。\n\n## 由来已久的念头\n\n自从我把 [Blog 迁移到 Github (迁移声明)](/meta/2015/02/24/blog-update/index.html)，生活重新变得平静了，不用管 Wordpress 的升级了，不用管主机的事情了，什么都不用操心，DNS 指到 Github 就好了……\n\n自从我用上了我司优秀青年严松的 [ink](https://github.com/InkProject/ink) 之后， blog 文章写作和发布也变得更简单通透了——如果有啥不满意就改改 blog 引擎，给作者发 PR，作为 CTO 强迫他[接受 PR](https://github.com/InkProject/ink/pulls?q=is%3Apr+author%3Agnawux)。\n\n然而，还是有一点点不爽——放在 Github 的 blog，是很难搞 SSL 的，即使是如今有 [Let's Encrypt](https://letsencrypt.org/) 这样的免费服务，仍然无法方便利用……\n\n随着，我家自己的 [Hyper_](https://hyper.sh) 上线，容器部署超简单，三秒上线，可以用小尺寸容器、独立 Floating IP，完美配合，于是，一直想着把自己和儿子的 Blog 迁移到 Hyper_ 上来。\n\n## 更多需求\n\n至于一直为啥没迁移，实际上我有点想做的事情——\n\n- Github 自动触发更新：我的 blog 现在都是 github page 了，我想更新 Github 自动生效，无需手动部署\n- 简单的 image，不想弄复杂的程序和脚本\n- 配置 TLS：一直没弄明白 Let's Encrypt\n\n尤其是自动更新，乃至我都想自己写个 server—……\n\n## 终于找到了\n\nHyper_ 正式上线一个月，我发现好多用户都在用一个叫 [Caddy](https://caddyserver.com/) 的东西，于是就问了下同事，说是新一代的支持 HTTP/2 的 Server。想着是不是可能有我的需求，或者，反正是 Go 写的，不行没准能改改呢，于是就去看了一眼。\n\n哈，我找到了什么 —— https://caddyserver.com/docs/git ——我最主要的需求居然已经被满足了，我可以这么配置\n\n```\nwangsiyi.net {\n        gzip\n        root wangsiyi.net\n        git {\n                repo https://github.com/gnawux/wangsiyi.net\n                branch gh-pages\n                hook /somehandle mypassword\n                hook_type github\n                interval -1\n        }\n}\nwangxu.me {\n        gzip\n        root wangxu.me\n        git {\n                repo https://github.com/gnawux/gnawux.github.io\n                hook /somehandle mypassword\n                hook_type github\n                interval -1\n        }\n}\n```\n\n就这么简单，起服务，自动拉 repo；然后，在 Github 配上 webhook，有 push 的时候，自动更新 webroot 的内容……\n\n（此处切换 DNS A 记录，并等待更新完毕——这个传说会很久，不过如今实际上还是挺快的）\n\n于是，在 hyper 上开了一个 server （绑上 fip）来试下\n\n```\nhyper run -d --name blogs -p 80:80 -p 443:443 ubuntu\nhyper fip attach 2xx.xx.xx.xx blogs\n```\n\n用 `hyper exec -it blogs` 登上去，装上 `wget`, `git`，拉个有 `git` 模块的 Caddy\n\n```\nwget -O caddy.tgz \"https://caddyserver.com/download/build?os=linux\u0026arch=amd64\u0026features=git\"\n```\n\n解开之后，放上刚才的 `Caddyfile`，运行 Caddy。 我看到了什么 —— 居然还啥都没做，就自动配好了 Let's Encrypt 的 CA，现在，我的网站已经支持 SSL 了，Github hook 的配置也完全无痛，设个链接和密码就直接工作了，完全不需要调试。\n\n好吧，有点简单得超出我的预期，嗯，过两天再搞自己的 image 吧，本来就想试试的，没想到就 piu 地一下就切好了，真是太出乎预料了，欢迎大家访问：\n\n- 我的 Blog（就是本站）: https://wangxu.me\n- 我家儿子的 Blog（有一段没更新了，很快更新）: https://wangsiyi.net\n\n以及，我闺女的 Blog （ Coming soon...）\n","cover":"","link":"meta/2016/09/24/blog-to-hyper/index.html","preview":"\u003cp\u003e终于让自己的 Blogs 吃上了自己的狗粮\u003c/p\u003e\n","title":"Blog 迁移"},{"content":"\n\n## 新闻一则: Hyper_ General Available\n\n是的，经过大约 4 个月的从 Private Beta 到 Public Beta， Hyper_ ([www.hyper.sh](https://www.hyper.sh)) 终于 GA 了。\n\n相对于之前的 Beta 服务，我们仍然保持了“云端的单机”这一基本设定，以“免编排”、“免运维”为己任；并加入了端口映射、卷数据初始化、最小64M内存的超小型容器等特性。当然，另一个提升就是，我们换用了新的硬件服务集群，不再使用生产于2009年，被我们废物利用的旧服务器了，性能上有了相当的保证。\n\n欢迎试用，目前的用户，注册送 20 刀余额，当然，不可提现。（IP地址 $1/月，最小的容器大约 $1.03/月，能用来做什么你懂的）\n\n## 正文：发布当天的日记\n\n![感觉身体被掏空](/assets/sofar.jpg)\n\n经过了无数天的开发和调试，参加了无数次的争论，GA 的一天终于临近了，对于发布的日子，我上周随口说了下周四——周四其实是个不错的发布日子，前面留足调试时间，后面又和周末保持了合适的距离，有足够的弹性。\n\n然而，就在这天临近的时候，我忽然注意到，周四是我的生日——虽然我是 Hyper_ 的联合创始人中最为年轻的，可是也已经36岁了——在自己生日发布服务，这未免太中二了一点吧。于是，我们决定在周四将系统准备就绪，而等到周五再进行系统服务的切换，这样，我们于北京时间8月12日傍晚，太平洋时间（夏令时）8月12日凌晨上线了 Hyper_ GA 的系统。周末里，随着 DNS 记录的传播等，Hyper_ 正在逐步迎接用户，并将在周一正式发布英文的新闻稿。\n\n周四的晚上，大家紧张地进行了最后的调试，晚上快接近稳定的时候，我在音箱里放出了这首歌——[网易云音乐链接](http://music.163.com/#/song?id=422427950)、[B站链接](http://www.bilibili.com/video/av5512579/)。一时间，大家都感觉自己被掏空了。\n\n\u003ciframe frameborder=\"no\" border=\"0\" marginwidth=\"0\" marginheight=\"0\" width=330 height=86 src=\"http://music.163.com/outchain/player?type=2\u0026id=422427950\u0026auto=1\u0026height=66\"\u003e\u003c/iframe\u003e\n\n### 去年今日\n\n一年前的这会儿，我们刚刚拆分出 runV 并提交到 OCI、参加了 ContainerCon/LinuxCon/Xen Developer Summit，虽然当时尚没有决定要不要做一个 Cloud，但是，至少当时开了一个头——我们开始了 Hypernetes 项目，这个项目成为了今天的 Hyper_ Cloud 的基础。\n\n这个项目最初叫 HyperStack，意欲表达 Hyper 与 OpenStack 的集成，不过后来，因为 kubernetes 在这个系统中的重要地位，我们创造了一个新名词——Hypernetes，这一命名方式相当受欢迎，后面跟了无数的致敬者。\n\n到了今年，我们团队甚至在 Kubernetes 的官方 Blog 上发布了一篇客座 Blog，来介绍 hypernetes。所有这些都源自一年前的决定。\n\n### 新宿之夜\n\n去年10月底，东京品川，开了一年两度的 OpenStack Summit，在会上，我们第一次向人们介绍了 Hypernetes。展会之余的一天晚上，我和 Cofounder 两个人决定去新宿逛街——结果，俩人在新宿的一个咖啡馆吵了一晚上，要不要做自己的云服务，如果做，卖点是什么。\n\n话说做云，我一开始是拒绝的，作为盛大云的旧部，师承 UCloud 的季总、京东云的何总，回归美国的 Kelvin，以及刻通云的姜总，我深知做一个负责任的公有云是多么困难…… 不过，后来我终归还是被说服了——一来是因为，我们发现，在国外做其实比在国内做挑战略小一些，让不可能成为可能；二来，我也同意，如果我们不做，这个 startup 创立的开源项目可能永远只是个看上去很美却没人敢用的项目。于是，我们开始了……\n\n### 本命年（+虎头蛇尾的结语）\n\n2016年是我的本命年，36岁高龄的我继续担当我司的看门大爷兼CTO，传统上认为本命年是人生的一道坎。作为一个并不宿命论的人也不得不承认，今年对我的个人和家庭真的是多事之秋。（update: 发布之后又居然病倒了，连续四天39度+，不过还是幸存了下来）\n\n不过，值此身体被掏空的日子，虽然感到，也许三十六岁的我不能和三十四五时候一样连续不眠不歇，但如今的我更清楚自己的使命和方向，还有一群优秀的同伙，这也让我可以寄望这本命年成为突破之年，愿今年 [Hyper_](https://hyper.sh) Cloud 的发布也能让大家感受到 IaaS \u0026 CaaS 再次被重新定义，也请大家一起期待后面更多的创新和突破。\n","cover":"/assets/sofar.jpg","link":"hyper/2016/08/13/hyper-ga/index.html","preview":"\u003cp\u003e在自己的生日发布服务，是不是太中二了一点，所以，我们第二天正式切换吧\u003c/p\u003e\n","title":"Hyper_ GA \u0026 Happy Birthday to Myself"},{"content":"\n\n感谢组织，大概2009年到2011年期间，我曾经做过一段中国移动云计算开源与标准化方面的协调人，也先后代表中国移动和盛大云计算参与了一些云计算相关的标准化工作，因此小有一些发言权。\n\n遥想当年，和领导兼合作伙伴、标准化所（现在是标准化院）的周主任一起聊标准化的时候，有一个深切的感触——表面上看，标准化工作就是在设置门槛来限制准入者，这些限制似乎就是标准化的商机所在。然而，更加高瞻远瞩的标准化工作者，并不仅仅把眼光停留在评测和准入机制上，他们会把产业的发展趋势、国家和社会的需求体现到标准当中去。这里不仅仅是让参与标准制定的人给后来人设置难度，让后进入行业的人达到门槛的要求；也会通过给出科学的评测体系，让参与者有可以比较和竞争的依据；更有施展的空间，让创新者可以在不设门槛的地方大胆突破，超越前人。也正因为如此，标准化工作对参与人员的大局观和技术的理解力都有非常高的要求，过度标准化和缺乏标准对产业的发展同样是有害的。\n\n简单举一个例子，对于互联网的数据中心（IDC），制冷是一个很重要的能力，因为全速运转的计算机会释放大量的热能，所以高档 IDC 会有很好的制冷能力，让服务器们冷酷到底。然而，当我们制定云计算标准的时候，是不是要对服务商的数据中心制冷能力有要求呢？这就不一定了，看看先进的数据中心设计理念——他们通过良好的 IDC 散热设计、改进的电源系统、更高的耐热能力、以及优良的集群管理调度系统，可以让系统在更高的温度下，甚至是不使用空调的自然风制冷的情况下，都可以工作，从而在节约大量的能源的情况下，达到相同甚至更好的服务质量。如果我们的标准要求了制冷能力，那么，这样的先进设计反而会被拒之门外，就完全违背了产业的发展方向了；相反，如果我们把服务可用性作为一个标杆，把能效指标作为一个评测指标，那么，通过比较，我们就可以看到哪些是真的更有能力的服务商了。两厢比较，高下立现。\n\n这只是一个简单的例子，我参与标准化的工作不算多，最近又接触了一些，有感而发，想把自己的一点心得分享给没怎么做过标准化工作的开源同仁。其实只要大家在做标准化的时候再站高一层，不局限在自己的公司视角，多想一想产业该如何发展，想一想我们对产业的责任，就知道该往什么方向努力、该回避什么东西了。\n\n\u003e 后记：其实标准化的意义在对等交互的场景特别突出——比如各种通信制式，而在计算机/云计算领域，大家更看重事实标准，开源在某种意义上说，是另一种标准化，有开放基金会背景的开源项目更是可以看作是代码/API形式的标准化。开源和标准化都是全社会的精神财富，而不仅仅是一个人、一个公司的，这一点，做开源和做标准化是非常类似的。\n","cover":"","link":"cloud/2016/07/24/standardization/index.html","preview":"\u003cp\u003e更加高瞻远瞩的标准化工作者，并不仅仅把眼光停留在评测和准入机制上，他们会把产业的发展趋势、国家和社会的需求体现到标准当中去\u003c/p\u003e\n","title":"我眼中的（云计算）标准化"},{"content":"\n\n时间的鬼斧神工总是让人惊叹，一直觉得自己意气风发，可是在公司却像个看门大爷；一直觉得还在家庭生活的磨合期，可别人都在称赞我们儿女双全，两个孩子都在修剪玫瑰花束了。唉，我们不得不承认，已经结婚9年了。早上，我搬进卧室一从99朵玫瑰，告诉老婆今天是结婚纪念日，她惊愕地问今天是几号……\n\n![九年纪念](/assets/anniversary-9.jpg)\n\n9年前的今天，我们步入婚姻殿堂，很多亲友莅临；9年后的今天，当时的嘉宾好多还在我的朋友圈里，感谢他们与我们一起相伴走来；\n\n9年前的今天，家族齐聚一堂，一起憧憬未来生活；9年后的今天，竟有亲人已然逝去，带给我们深深的伤感，也感谢他们曾与我们走过；\n\n9年前的今天，每个人都说，“早生贵子啊”；9年后的今天，他们说，“你们好幸福啊，儿女双全”，感谢孩子们来到我们的生活中来，未来你们也要走自己的路；\n\n9年前的今天，你我许下百年誓言；还好，9年后的今天，我们还在一起，继续着新婚的磨合期，我们每天的生活都是新的，唯有你我不变，相伴长长久久。\n","cover":"/assets/anniversary-9.jpg","link":"family/2016/07/08/anniversary-9/index.html","preview":"\u003cp\u003e时间的鬼斧神工总是让人惊叹，一直觉得自己意气风发，可是在公司却像个看门大爷；一直觉得还在家庭生活的磨合期，可别人都在称赞我们儿女双全，两个孩子都在修剪玫瑰花束了。唉，我们不得不承认，已经结婚9年了。早上，我搬进卧室一从99朵玫瑰，告诉老婆今天是结婚纪念日，她惊愕地问今天是几号\u003c/p\u003e\n","title":"往事匆匆，来日茫茫，唯有你我，相伴久久"},{"content":"\n\n十八年前，我十八岁，那年也有洪水，那年也有足球，那年法国队也表现不错，那年，我参加了高考。对称是我的最爱，这种人生的对称时刻，自然该写点东西记一下。\n\n![1998年，对于很多人的回忆都是苦涩的[1]](/assets/france-98-r9.jpg)\n\n现在的年轻人可能不知道，十八年前的高考，是在7月份，而且有三天，那时候的北京，使用全国卷高考，而我，和今年谢工老师的公子一样，也在八一中学考点，而且，有那么点不尽如人意。\n\n十八年前的高考，本来一切波澜不惊，除了化学，都不怎么难，当然化学都是我的物理之外的第二强项，难，不怕。最后一天考物理，我头上方的电风扇不知怎么，呲哑哑响不停，似乎是什么不祥的预兆，不过，物理有什么可担心的么。然而，在最后一小时，一切都改变了。之后的十八年里，每次提到高考，我都会祥林嫂一样地重复这个故事——\n\n\u003e 比如我这个 SB，1998高考全国卷物理倒数第三道大题，洛沦兹力的符号推导题，圆周长公式代了 πr^2 进去，最后一道力学大题，少看了一个“摩擦力忽略不记”的条件，最后和清华线差5分。\n\n其实，每年高考都有一些失意的人，他们和我一样，自信有实力，可是偏偏强项发挥失常，以致前功尽弃，进而无法自拔。然而，时光荏苒而过，在工大和那么多同病相怜的孩子们一起，哭过以后，我们发现，其实，失常的都是强项，弱项哪有什么可以算得上失常的东西呢？\n\n高考之前，我也考砸过，小学考初中、初中考高中，全没考好。但高考是不同的，因为高考之后，我才真的开始思考为什么没做好、怎么能做好，开始不把问题推卸给运气、命之类的玄学上，也不放在心理、状态这些不可控的东西上，于是我才有了一步步的好转，不管是性格还是临场状态都开始变好。我明白，人不怕犯错，怕不思考，怕重复犯错，怕一辈子学不会怎么面对。\n\n举两个例子，第一个例子是关于性格的，我小时候的同学和我大学以后的同学、同事对我的印象是截然不同的。小时候的我是个非常内向、不敢说话的孩子（，其实我现在仍然有与人交往的恐惧症，更喜欢和计算机交流），但我相信，要成功需要更主动、更自信，于是，大学一开始，我就努力塑造自己主动的形象。我找到的一个方法是，把自己不敢做的事情说出来，说自己要做，然后，在大家的目光下逼着自己做，不管是做课程实验、课程设计，还是小组演讲，我都推着自己向前，同学们居然真的相信我擅长这些了（当然，他们这帮老司机可能根本就是自己懒得干），于是我经常地有各种机会，大一暑假就可以进入实验室了。这之后，我一步步地让自己脸皮变厚，甚至工作第一年的年会上反串《色戒》的王家芝这个角色，在移动研究院一炮走红。\n\n第二个例子是，当我准备考研的时候，除了复习功课，我开始全面的思考考试这个过程，而不仅仅是知识本身。我注意到，我过去的考试失常时刻，经常发生在连续几天考试的最后阶段，这个时候，身体疲惫可能是原因之一，所以，我在考研之前三个月开始坚持每天跑步，提高自己的心肺功能，以更好的身体状态面对马拉松式的考试，而且告诉自己，考研的考试每场有三个小时，中间一定要申请出来上一次厕所，活动一下，调整一下状态。这些准备不一定真的对考试有很多影响，但是努力调整至少会让自己相信自己做好了一切准备，会让自己更有信心地发挥出自己的水平。配合一点运气，我考上了北邮张平老师的研究生（，顺便说，张老师旗下的 WTI 是我国最好的无线通信方面的实验室之一，顺便推荐[我的知乎回答系列](http://wangxu.me/tag/zhihu/index.html)，真的是通信为主的），而这些运气，我相信是我通过自己的努力换来的。\n\n现在的我，算不上成功，不过至少没有在高考后沉沦，这是一篇淡淡的鸡汤，送给那些高考不得意的同学——不思考，只想着受完就完了，基本上等着的是下一次失败，只有面对+思考+改进，才能真的避免同样的挫折。你现在需要的不是等着运气的青睐，而是面对自己，审视自己，改变自己，高考就是一个从此改变自己的机会。\n\n[1] 图片来源: http://www.mirror.co.uk/sport/football/world-cup-2014/world-cup-unconscious-minutes-ahead-3667198\n","cover":"/assets/france-98-r9.jpg","link":"life/2016/07/07/exam-98/index.html","preview":"\u003cp\u003e十八年前，我十八岁，那年也有洪水；那年也有足球；那年法国队也表现不错；那年，我参加了高考。现在的我，算不上成功，不过至少没有在高考后沉沦，这是一篇淡淡的鸡汤，送给那些高考不得意的同学\u003c/p\u003e\n","title":"十八年前的那一次考试"},{"content":"\n\n简讯：昨晚，在 kubernetes 组织下，新建了一个 repo，名为 [frakti [1]](https://github.com/kubernetes/frakti)，标志着 hyperContainer 以最 k8s 地方式融入 k8s 的开始。\n\nfrakti 一名是我起的，如各位所知，[kubernetes 一名来自于舵手的希腊文 κυβερνήτης [2]](https://en.wikipedia.org/wiki/Kubernetes#History) ，\n同样 frakti 也来自于[与船相关的希腊文——水密隔仓 Φρακτή [3]](https://el.wikipedia.org/wiki/%CE%A6%CF%81%CE%B1%CE%BA%CF%84%CE%AE_(%CE%BD%CE%B1%CF%85%CF%80%CE%B7%CE%B3%CE%AF%CE%B1))，\n这是一种通过隔离舱室，提高船的抗沉性的结构，据说最早由中国宋朝的朱彧引入（[参见wiki[4]](https://en.wikipedia.org/wiki/Bulkhead_(partition)#History)），\n 这样的名字，对于我们来自中国的 [hyperContainer [5]](https://github.com/hyperhq/hyperd) 团队与 kubernetes\n 的结合可能再合适不过了。\n\n- [1] https://github.com/kubernetes/frakti\n- [2] https://en.wikipedia.org/wiki/Kubernetes#History\n- [3] https://el.wikipedia.org/wiki/%CE%A6%CF%81%CE%B1%CE%BA%CF%84%CE%AE_(%CE%BD%CE%B1%CF%85%CF%80%CE%B7%CE%B3%CE%AF%CE%B1)\n- [4] https://en.wikipedia.org/wiki/Bulkhead_(partition)#History\n- [5] https://github.com/hyperhq/hyperd\n","cover":"","link":"hyper/2016/06/28/frakti/index.html","preview":"\u003cp\u003ekubernetes 组织下，新建了一个 repo，名为 frakti，标志着 hyperContainer 以最 k8s 地方式融入 k8s 的开始\u003c/p\u003e\n","title":"Kubernetes 新项目 Frakti"},{"content":"\n\n在此，我们很高兴地告知各位，我们已经初步完成了 runV (OCI 的基于虚拟化技术的容器运行时引擎) 与 Docker 的集成。这里，我们感谢 runV 团队的优秀工作，而且这次更新的一个特别之处在于，这些更新是由 Hyper 的开发团队和来自社区的参与者共同完成的，他们也是 runV 社区的重要部分，并在此接受致谢。\n\n从去年夏末 OCI （开放容器促进组织）在 Linux 基金会下成立的时候起，Hyper 的 runV 就成为了 [OCI 官方的基于虚拟化技术的容器运行时引擎实现[1]](https://github.com/opencontainers/runtime-spec/blob/master/implementations.md)，而另一个基于容器的实现就是 Docker 的 runC。很久以来，大家都期盼着能用 Docker 命令行同时启动 runC 和 runV 容器，不过，由于 Docker 的执行引擎在按照他们的节奏向前推进，这个愿望一直未能实现。\n\n今年四月，[docker 发布了 1.11，集成了 containerd，连接了 runC [2]]([https://blog.docker.com/2016/04/docker-engine-1-11-runc/)，这为支持更多的 runtime 铺就了道路，于是，runV 与 Docker/Containerd 的集成就再次提上了台面。\n\n作为基于 hypervisor 的 OCI runtime，Hyper 的 runV 与 Docker 1.11+/Containerd 的集成工作是比较容易的，[经过简单的调试，就可以让 Docker 和 containerd 直接对接到 runv 上[3]](https://github.com/hyperhq/runv#run-it-with-docker)。但由于 containerd 是为 runC 量身定制的， runC本身也是一个不断改进中的实现，命令行会不断变化，并且包含一些专有的特性，这个集成有不少局限，对于 tty, exec, 网络等方面的支持仍有不足。\n\n不过，得益于 docker/containerd 提供的良好接口，我们给出了一个对 tty, exec, 网络等方面兼容性更好的过渡方案 —— 我们在 runv 中附带了 [runv-containerd 程序 [4]]([https://github.com/hyperhq/runv/blob/master/containerd/README.md)，基于 containerd并针对 hypervisor 进行了一些调整， 利用 runV ，现在 docker 可以直接创建功能齐备的虚拟化容器了。\n\n````\n# in terminal #1\nrunv-containerd --debug --driver libvirt --kernel /opt/hyperstart/build/kernel --initrd /opt/hyperstart/build/hyper-initrd.img\n# in terminal #2\ndocker daemon -D -l debug --containerd=/run/runv-containerd/containerd.sock\n# in terminal #3 for trying it\ndocker run -ti busybox\n# ls   # (already in the terminal of the busybox container)\n# exit # (quit the container)\n````\n\n未来随着 OCI/containerd/runV 的进一步发展，相信我们还可以做到更好更完美的集成。\n\n[1] https://github.com/opencontainers/runtime-spec/blob/master/implementations.md\n\n[2] https://blog.docker.com/2016/04/docker-engine-1-11-runc/\n\n[3] https://github.com/hyperhq/runv#run-it-with-docker\n\n[4] https://github.com/hyperhq/runv/blob/master/containerd/README.md\n\n\n \n","cover":"","link":"hyper/2016/06/17/runv-docker-integration/index.html","preview":"\u003cp\u003e在此，我们很高兴地告知各位，我们已经初步完成了 runV (OCI 的基于虚拟化技术的容器运行时引擎) 与 Docker 的集成。这里，我们感谢 runV 团队的优秀工作，而且这次更新的一个特别之处在于，这些更新是由 Hyper 的开发团队和来自社区的参与者共同完成的，他们也是 runV 社区的重要部分，并在此接受致谢。\u003c/p\u003e\n","title":"RunV: 让 Docker 支持虚拟化容器"},{"content":"\n\n爸爸：\n\n2月9日，大年初二，你停下了脚步，而我们却渐行渐远。你是那个最疼我的人，我是你最后托付的人，我手上，你最后的温度不曾散释，我心里，你最后的话语萦绕未消。平日里，你好象仍然未曾远去，总觉的哪天我迈进家门，还能尝到你做的饭菜，我还会劝劝你少喝酒、少放油；而在飞机上的时候，我总觉的自己距离你更近了，几次在航班上泪流满面地回想和你在一起的点滴往事，从幼年的兔子和鹅，一直到高考时晚饭，再到五年前我从移动离职时你的话……这些，你也都不曾忘记，对么？\n\n你离去已过百天，你最疼的屹长大了，学了新知识，学得更有自我意识了，偶尔骗骗我，把我气得半死，和我小时候一样；你那时候对我很宽容的，我们也会好好地爱他、引导他的。他偶尔也会不经意间提到你，但不会多说，他对你可能也无法释怀，你走了，这个小家伙一定很不开心。可爱的小诺诺也从刚两岁长到快两岁半了，不知道是不是感应，你发病前一天坚持想去接我和诺诺，那次没让你去，没想到就阴阳两隔了，而你离开的那天，小诺诺也高烧不退，痛苦之极；如今，她越来越懂事了，她出乎预料地不肯忘记你，你刚走那几天，她会指着很多东西说“是爷爷的”，而到最近，她还会提起“爷爷怎么不来啊，让爷爷也一起来吧”，“爷爷做菜好吃，让爷爷回来给我做菜吧”，每每引得妈妈潸然泪下。我曾经感伤“爱也会被遗忘”，有的时候却也想，遗忘可能也是对生者的保护，如果诺诺真能快点遗忘，妈妈可能也没这么伤心吧。\n\n说到妈妈，她还没有适应没有你的生活，没有你来给她拿主意，她似乎越来越不知道该走向哪里，我告诉她，她还可以有大约25年有质量的晚年生活，25年可以让一个婴儿成长到研究生毕业，可以和以往完全不同，可以活出更多精彩。我不知道她能听进去多少，她原来太依赖你来思考了，她不愿意接受别人的思想注入，不过我会尽力的，愿天空里的你也能帮助她度过难关。\n\n你走了，我也一夜长大，从前我在你的家庭里，营造我的小家庭，如今我也在家族里，试着和其他长辈们沟通，你离去的痛，和追加上的更多责任，让我更明白人生。我知道要关爱我的家庭，要关照妈妈，也要爱护自己。我会更加自律地生活，因为失去你的痛苦，让我知道，不要让爱我的人再那么早承受这份痛，相信我，我会尽力爱护你爱的人的。\n\n飞机已经飞过中欧，快要到达此行的目的地了，快要和你告别了，我想和你分享一段最近注意到的《爱丽丝梦游仙境2》的台词：\n\n\u003e 曾经以为时间是个小偷，将我们拥有的一切都偷走，从不曾给我们机会。但我们错了，她总是先给予再拿走，每一天，每一分，每一秒，都是馈赠；时间教你接受一切，爱的人就在身边，请珍惜。\n\n你曾经和我一起相处过三十五年，为我付出过三十五年，一起快乐地度过了三十五年，我们一起走过乡间小道也一起飞在过蓝天之中，你自己在一直打拼，也鼓励我勇敢闯荡，如今你离开我了，我在你的注视下渐行渐远，我会把你一直放在心底，永远珍藏着那充满父爱的一分一秒。\n\n再见，爱你，虽然这句话你没有亲耳听到让我觉得有点遗憾。\n\n儿 旭\n\n2016年6月7日于英航BA38航班上\n\n","cover":"","link":"family/2016/06/08/for-dad/index.html","preview":"\u003cp\u003e2月9日，大年初二，你停下了脚步，而我们却渐行渐远。你是那个最疼我的人，我是你最后托付的人，我手上，你最后的温度不曾散释，我心里，你最后的话语萦绕未消\u003c/p\u003e\n","title":"浮在天空里，有些话给你"},{"content":"\n\n今天一早，朋飞就告诉我们，我们和 Google 合作，发在 [Kubernetes 官方博客上的文章](http://blog.kubernetes.io/2016/05/hypernetes-security-and-multi-tenancy-in-kubernetes.html)终于上线了，张磊和朋飞，还有 Google Kubernetes 团队的 Dawn 等朋友忙活了这么久的一件事终于在今天有了结果。\n\n一篇文章用了这么久，有点超出我们的预期。不过，看看本文标题，今天刚好是我们向全世界宣布开始 [HyperContainer](https://github.com/hyperhq/hyperd) 这个开源项目一周年，这真是个让人惊喜的生日礼物呢！\n\n一年前，我们忐忑地宣布了这个项目，那篇 blog 在 HackerNews 首页上停了几乎一整天，有人说，如果不算中国股市的话，这是中国人头一次在 HackerNews 首页上停这么久。\n\n在过去的一年里，我们在 HyperContainer 之外，还发布了 RunV, Hypernetes 两个开源项目，并在上个月推出了我们的公有云服务 [Hyper_](https://www.hyper.sh)。这几个开源项目我都在之前的 Blog 里有过介绍，毋须多言，有兴趣的同学直接来[我们的 GitHub](http://github.com/hyperhq/) 看吧。\n\n就在刚刚，我 Tag 了 HyperContainer 项目的 0.6.0 版本，作为生日祝福送给我们项目自己，感谢开发团队的努力工作，不过我们没时间停下来，在接下来的两个月里，我们还有很多事情要做\n\n- 我们的公有云项目将会有几个比较大的功能升级，就在未来的几个星期里逐步上线，GA 就在眼前，还请各位关注。\n- 我们的 HyperContainers 项目会在未来两个月里进一步完善 API、并稳定功能，大约在8月份达到 1.0 。\n- 我们的 Hypernetes 会和 Kubernetes 继续合作，大约在秋季的时候，Kubernetes 上游会有 HyperContainer Runtime 的集成。\n- 还有更多的进展会在未来几个月里逐步推进……\n\n从发布到一岁，是漫长、艰辛而又兴奋的一个过程，未来更多挑战等着我们，让我们一起加油吧！\n","cover":"","link":"hyper/2016/05/25/hyper-birthday/index.html","preview":"\u003cp\u003e一年前，我们忐忑地宣布了这个项目，那篇 blog 在 HackerNews 首页上停了几乎一整天，有人说，如果不算中国股市的话，这是中国人头一次在 HackerNews 首页上停这么久\u003c/p\u003e\n","title":"Hyper 一岁了"},{"content":"\n\n答案链接：https://www.zhihu.com/question/35412725/answer/101715150\n\n为啥没人邀请我？虽然我在知乎上一直专注于无线通信相关问题，不过，我确实是 Hyper_ 的联合创始人和主要作者之一。\n\n前两天， Docker 的 @Honglin Feng 在某群里跟我说知乎的广告效果不错，我还说\n“我都是回答的那些神马在学校的时候学的，没来得及忘掉，也不会用到的东西，废物利用”，\n没想到今天就有人给我这个亲手打广告的机会，不由得还真是有点激动呢。而且这个题居然不是我们自己人提的，颇感意外啊。\n\n先从整体上说一下。刚才 @Gnep 提到，可以关注 [HYPER_](https://www.hyper.sh) 这个我们自己做的基于 HyperContainer 的容器云。\n是的，提到我们 Hyper_ ，大致可以提两件事情 ——\n\n- 一是，我们的容器技术 HyperContainer，就是题主写到的“Make VM run like Container”，\n  或者叫“Secure as VM, Fast as Container”，这个我们是开源的，位于 [Hyper_ · GitHub](https://github.com/hyperhq/hyperd/) ，\n  简单地说是结合了 hypervisor 和 Docker Image 的一种更强调隔离的 App Container，和我们很相似的技术是 Intel 的 Clear Container，\n  我们是同一个星期 Release 的（2015年5月），并没有互相参考，思路暗合；\n- 二是基于我们的容器技术做的容器云 Hyper_ ( https://www.hyper.sh )，因为我们的底层隔离了，上层可以做得更简洁，\n  完全去掉了一般公有服务里的基于虚机的资源池这一层，让用户可以像在一台无限大、永远在线的个人电脑上跑 Docker 一样，\n  直接创建并运行 Container。因为没有资源池这一层，需要初始化的东西很少，所以可以在三秒钟左右的时间里（\n  这个和 container 包含不包含额外的卷有关系，有额外的数据卷需要的时间要长一点）跑起一个虚拟机，\n  并且每个用户的网络和容器都是完全隔离、互不干扰的。而且，因为真的很快，所以秒级计费是有实际意义的哦。\n\n```\n----\u003e8------进入细节的分割线----\u003e8------\n```\n\n以上和以下提到的 Docker 均为 Docker Inc 的商标，属于 Docker 公司的知识产权。\n\n首先从开源项目的由来说起，在最近的两三年中，容器成为云计算领域了最热门的话题。回顾历史，从 FreeBSD Jail\n算起容器技术出现在 *nix 领域中已经发展了接近二十年了，致力于在操作系统中进行更强的运行时隔离。\n\n然而，Docker容器与以往不同，不仅在于运行时隔离，更在于对应用及其依赖环境的标准化封装，从而做到跨部署环境的不变性（immutable）\n和一致性（consistency）。可以说，这是一种新型的应用容器。\n这些应用容器对应用运维的方式带来了颠覆性的效果，然而，运行时容器技术并不足以面对多租户的环境。\nLinus 在2015年的 LinuxCon 上也坦陈，安全性问题常常是个Bug的问题，而犯错不可避免，所以，要想达到好的安全性，\n只靠安全加强是不够的，多一层的封装才是解决之道。在这种背景下，自然地期待保持应用容器的用法，引入虚拟化的强隔离。\n\nHyperContainer就是这样一种技术，结合了虚拟化的强隔离和容器的轻量级——Secure as VM, Fast as Container。\nHyperContainer 并非是简单在虚机里放一个 Docker Daemon，而是用 hypervisor 替换掉了基于 namespace 的 runtime，\n在虚机里面并没有 daemon，也没有完整的 guest distro，而是直接将 Docker Image 放在定制的 Guest Kernel\n上执行的，所以可以做到很快。并且如其他的回答提到的，从用法上说，我们和 Docker 等容器技术是一致的。时间线大致如下——\n\n- 我们从2015年初开始做这个项目\n- 2015年5月以开源项目的形式发布\n- 7月，随着 LinuxFoundation 宣布了开放容器促进组织，Hyper_ 将 HyperContainer 的运行时部分分离为 runV 项目，列为 OCI 的参考实现之一（runtime-spec/implementations.md at master · opencontainers/runtime-spec · GitHub）\n- 2015年10月，又发布了Hypernetes项目，结合了 HyperContainer 容器技术，Kubernetes 调度引擎以及OpenStack 的 Neutron 和 Cinder 等，成为一个多租户的 Kubernetes 发布。\n\n就社区而言，Hyper 作为一组中国人发起（但运行得略国际化）的开源项目，目前在国际上的影响还是略有一些的，除了上面提到的 OCI 之外，Hyper团队正在和 Kubernetes 社区积极合作，Kubernetes 已经计划在未来的版本中集成对 HyperContainer runtime 的支持；另一项由兄弟创业公司数人科技的 @肖德时 肖总推进，并有前阿里员工参与的工作（[MESOS-3435] Add containerizer support for hyper）正在将 HyperContainer runtime 集成到 Mesos 项目中去。\n\n```\n----\u003e8------关于 https://www.hyper.sh 云服务的分割线----\u003e8------\n```\n\n目前的容器云服务有很多，大到 Google 的 GKE，新到国内的一系列云，但 Hyper_ 有所不同，大部分 Docker 用户都满意 Docker\n的命令行用户体验，然而，部署成服务的时候，却需要先拥有一个虚机的资源池，并为这个资源池付费，而非实际跑的 Container。\n\n而 Hyper_ 是直接基于 HyperContainer 和 Hypernetes 项目的，Container 的运行时隔离由 HyperContainer\n保障，网络隔离由 SDN 完成，我们还做了一个新的 Image/Container 存储引擎，让集群的分布式对用户完全透明，\n所以，用户用起来和用自己的笔记本没什么不同，包括像 Docker Link 这样的功能我们也是提供了的，而且在命令行和 API\n上都和 Docker 一致。如果说和 本机有什么不同的话，Hyper_ 上，用户可以直接给容器关联公网 IP，这是 Hypernetes\n项目给我们带来的额外好处。\n\n从用户体验的角度看：\n\n- 一是简单快速，没有多余的东西，虚机是什么鬼，cluster 是什么鬼，都不需要关心，更不用管调度器是土鳖还是高大上；\n- 二是随时起停，当起停的时间很短的时候，起停都不是负担，比如你在上面跑 s***socks 的时候，可以需要的时候跑，不需要的时候停，简单绿色、低碳生活；\n- 三是可以按需使用，用更少的资源更少的钱，完成恰如所需的任务，不用跑不需要的服务。\n\n当然，虽然我自己不太年轻了，但我们还是个年轻的开源项目、年轻的创业公司，项目还在快速发展，每天都有新的 PR 被 merge，\n有新的功能改进和 bug fix；云上面，Compose 这些高级功能也很快就会提供。如果有问题，可以随时在 github 上 file issue 或联系我们。\n","cover":"","link":"zhihu/2016/05/20/how-about-hyper/index.html","preview":"\u003cp\u003e原题描述：根据官网所说，hyper_ 貌似是一个基于 VM 的分层系统，比 Docker 共享 Kernel 更加安全，但是比一般的 VM 系统快得多，能做到秒级启动，而且本身非常精简。不知道有没有大牛已经用过了或者感兴趣，对它的评价是怎样的？\u003c/p\u003e\n","title":"[知乎回答] 如何评价 Hyper_"},{"content":"\n\n回答链接：https://www.zhihu.com/question/23421866/answer/90143146\n\n无线通信中的多普勒效应的影响。\n\n我被邀请过几次了，都是一个点上，人类跑得这么慢，高铁也比光慢这么多，这么点频移凭啥会影响通信质量啊。\n\n还是有很多同学表示这个解释太复杂看不明白，那么结论说在前面结论就是——速度越快，因为多普勒效应，同样带宽的信道受到的影响就越强，能达到的极限通信速率就越低，不仅时速300公里的高铁会有明显影响，时速100公里的汽车也会有。当然，影响高速移动通信的因素还不止多普勒，但多普勒的影响是非常显著的。\n\n对无线通信专业的人来说，多径衰落和多普勒效应是物理层需要克服的最主要的两种信号衰落原因，而在 CDMA 中，因为 RAKE 接收机的使用，多径信号甚至可以成为增益，但多普勒频移带来的深衰落，和对信道估计的影响却是难以应付的。\n\n铺垫一下一些时间的概念：3代CDMA类技术的物理层符号速率，又叫码片速率，是Mcps 级的，也就是每个码片的时间是小于 1 微秒的。3G和4G的无线帧的长度，也就是数据组织的单位，是毫秒到10毫秒级别的。码片那个位置不用4G举例子是因为从某种意义上说，4G OFDM 信号不是一个时间序列，而是一个频率序列，所以不太适合拿来举例子。\n\n简单解释下上面说的两种衰落的成因——\n\n多径：\n\n- 信号不仅沿一条直射的线路到达接收机，也会从其他途径反射、绕射过来，\n- 这些不同的路径会有不同的衰减，因为路程不一样长，也会有不同的时延，\n- 这些多径信号的频率（在不考虑多普勒的情况下）都是一样的，它们叠摞在一起，到达接收机，并不会加强信号，而会让信号变乱。\n- 尤其是当没有直射径的时候，比如你抬头看，很可能由于建筑物或啥东西的阻挡，基站天线到你的手机之间是没有直接通路的，这时候不同的径信号都很差，互相干扰就更严重了\n\n多普勒效应：\n\n- 一定速度的移动会造成信号产生频偏，但并不是说只是信号的中频平移以一点\n- 移动信号本身是一个频带，这个频带里，不同的频率会产生不同的频偏，多普勒效应让信号在频域“色散”了\n- 同时，因为有上面说的多径效应，不同的路径射入的方向是不同的，它们会产生不同强度乃至不同方向的频偏\n- 并且，即使发射机和接收机本身都不运动，传输过来的信号也可能被运动物体反射，还是会有多普勒效应\n- 当这些效应叠加在一起的时候，信号就已经衰落得很好看了\n\n我在另一个答案里，引用了来自：[多普勒效应与多径衰落对移动通信的影响](https://link.zhihu.com/?target=http%3A//wenku.baidu.com/view/440d9299650e52ea551898d1.html%3Fre%3Dview) 的几张图\n\n![doppler envelop](/assets/doppler.png)\n\n可以看到，时速100公里的信道条件，就比时速3公里的信号变化强烈多了。\n\n而无线通信，收到信号的时候，需要“猜”出来发送时候的原始信号是什么样子的，这种猜有很多方法，比如，信号发送的慢一点，让接收方收集足够多信息得到高置信度的答案，或者，发送信号的功率高一些，让 1 和 0 的区别更明显一些。当然，由于发射机功率限制，信号功率不能太高，所以，条件越差的信道能传送的速率就越低。\n\n早年间的通信制式的信号传输速率是一定的，于是，只要在一定限制之内，运行速度高低对信号传输的影响似乎不大。但在新的制式里，为了达到更高的传输速率，系统会对信道的好坏程度做估计，当信道情况好的时候，可以尽力更快地传送。\n\n这里提到了“信道估计”的概念，信道估计可以通过误码率来大致的猜，但是，一种更“激进”的方法是使用“训练序列”，大致思路是这样的：假设在很短的时间内信道状态是稳定的，观察训练序列发生了什么样的扭曲，那么，有用的信号应该也是这么扭曲的，那么我再把它变回来好了。我们在一些制式里使用了这个方案，在这种情况下，只要信道确实如假设般，在刚才提到的毫秒级的无线帧长度里，基本稳定，即使信道确实让信号发生了不小的畸变，都可以高置信度地还原用户数据。\n\n这里，就涉及到多普勒效应的影响了，看上面的图，在低速的时候，信道条件变化更为缓慢，信道估计工作良好，速度一提高，信道随时间变化加快，信道估计就可能无法很好工作了，于是，在高铁上，虽然一般并不是完全无法传输无线数据了，但是可以传输的数据降低了。\n\n所有这些知识，对无线通信方面的研究生来说，都是基础课，并不高深，多普勒效应也离大家的生活并不远，你们的手机每时每刻都在和多普勒效应做斗争。要了解更多的知识，可以看任意的无线通信原理类的教材，我当年用的是 Rapport 的 wireless communications: principles and practice，中文名应该是《无线通信：原理与应用》，关于无线通信低两层的知识，从物理层信道、调制解调到蜂窝网络之类的，这本书都介绍得比较详细，有兴趣的同学看看吧。\n\n附另一个回答 [乘高铁无线网速慢是为什么？](https://www.zhihu.com/question/21669345/answer/19106242):\n\n\u003e 至少有两个原因：\n\u003e\n\u003e - 多普勒效应：因为手机上网是走的无线信号，当有运动的时候，电磁波会产生多普勒效应，简单地说就是信号的频率会随着速度而改变，这造成了信道条件变差，误码率提高，从而降低了传输效率。\n\u003e   - 当然，这么说有个前提，3G的通信质量和信道条件关系是很密切的，因为3G、4G这些更新的无线通信制式，之所以能够达到更高的通信容量，靠得就是压榨信道的承载力，在单位频谱上，容纳更多的比特速率，信道好可以HSPA高速传输，信道不好，即使 384kbps 也很难保证。\n\u003e - 频繁的小区切换/重选：\n\u003e   - 背景：移动通信系统又称为蜂窝系统，在地理上将空间划分为一个个蜂窝状区域（这是理想情况，实际不是那么规矩的），因为电磁波本身随着距离而减弱，一个小区的信号不会强烈干扰到很远小区的通信，所以可以重用资源，从而达到有限的频谱空间服务大量的用户这一目的。\n\u003e   - 问题：但是，高速移动的列车会快速地从一个小区穿行到下一个，于是，手机也得跟着不断地进行变换所在的小区，这个对于正在打电话的终端叫切换，其他的叫重选，都会造成很多开销，这样，可以用于通信的资源就少了。\n\u003e   - 你可能会问，把服务铁路的小区做大点不就好了么，事实上服务铁路和高速公路的基站的覆盖区域本身就比较大。但是，发射功率受制于终端，谁都不想被手机烤熟了不是，嗯，手机也没这么多电；而且，一个基站能用的频谱资源有限，能服务的用户有限，覆盖范围大了，每个用户能得到的资源就更少了，速度也因此受限了。\n\u003e\n\u003e 除此之外，即使一车不开着，可能上网也不会太快，毕竟车上人多，共享无线信道，条件再好，那么多人分也好不到哪去了，肯定和人少信号好的地方没法比\n","cover":"","link":"zhihu/2016/05/12/doppler/index.html","preview":"\u003cp\u003e我被邀请过几次了，都是一个点上，人类跑得这么慢，高铁也比光慢这么多，这么点频移凭啥会影响通信质量啊\u003c/p\u003e\n","title":"[知乎回答] 哪些专业问题在本专业是常识，但在日常生活中却不被人所知？"},{"content":"\n\n前两天，用友UDN的白总来找我做了一个关于开源创业的访谈，是啊，做[Hyper_项目](https://github.com/hyperhq/hyperd/)一年出头的时间了，自己想想也很刺激呢，那就动笔写点什么吧。\n\n![enter image description here](http://7xpvay.com1.z0.glb.clouddn.com/e68a6670-06a1-11e6-94da-7347a1de0463)\n\n这里引用上面图片里 Daocloud 联合创始人孙宏亮的一句话吧。\n\n做开源，辛苦有，好玩也有，今天就说点好玩的。\n\n##开源的造神运动\n\n如果你有一点水平，开源对于树立个人威望是非常有好处的。正如西乔的BetaCat漫画道出的一个真谛——复杂 patch 是很少有人 review 的——只要你做了比较多的工作，那你就毫无疑问是个大牛了。\n\n就拿我自己举例子吧，我自认为自己的水平还是有的，在看门大爷里也算是会写程序的了，还有点自己的小看法，但“大牛”还是差得很远的。这方面我觉得我老婆的眼光特别犀利客观，她一直就觉得我不过尔尔，哪天我敢在家得瑟，绝对被她扑灭，所以我仍然能看到自己的SB之处。\n\n我说这些的意思并不是说开源圈很不堪，恰恰相反，我司活跃在开源社区的牛牛们就各个身手不凡，我所认识的那些大牛也真的让人高山仰止。我的意思是，即使一个如我这样的平凡人，参与开源，你也可以和这些真神们称兄道弟乃至于偷学两手，甚至像我这样出来装神弄鬼，这绝对是个捷径吧。\n\n##“敌我不分”的开源圈\n\n开源项目有意思的一面就在于——它不是你一个人的，所以，开源前，它是你的兴趣，开源后就是整个社区的了，有点意思的项目，会有很多人来一起打理。\n\n国内容器圈是个不大不小的圈子，好几家创业公司，多少有点竞争关系，但是各位知道不，有两家容器创业公司的联合创始人都来给我们提过issue/PR，他们说，他们觉得这个项目有意思——难得有个国内创业公司做底层开源，他们也为此兴奋呢。\n\n##痛并快乐着\n\n刚才说，项目开源了就不是自己的了，这也有一些“负面”作用，当你做一些大调整时，会有人站出来质疑你。\n\n比如因为我们上公有云，为避免命名上的混淆，我们调整了项目仓库的名字和文档URL，不仅有国内的林帆等熟人过来核实，更有人直接在GitHub上发issue抗议。\n\n诚然宝宝心里有不得不做的苦，自家孩子还被别人约束的委屈，但另一方面，有人有在关心你的一举一动，对于开源项目来说不正是它的存在感么。\n\n如今的 hyper 的项目开源已经接近一年，有其他创业公司小伙伴的支持和参与，有另一些国外朋友使用和积极跟进，也有一些大公司，在开源界朋友的推动下来发PR贡献，更有日渐强大的团队推进开发，并让自己的产品运行在开源项目之上并回馈开源，作为一个开源项目，越来越成熟了。\n","cover":"","link":"life/2016/04/16/just-for-fun/index.html","preview":"\u003cp\u003e前两天，用友 UDN 的白总来找我做了一个关于开源创业的访谈，是啊，做 Hyper_ 项目一年出头的时间了，自己想想也很刺激呢，那就动笔写点什么吧\u003c/p\u003e\n","title":"Just for Fun"},{"content":"\n\n不愿回忆，害怕忘记，这是一种会呼吸的痛。\n\n三七将至，爸爸离开这么多天了，生活其实没有什么大不同，就好象之前不在他身边的日子一样，好像第二天又会在他身边。只是偶尔神经会被触到，猛然感到一种压在胸口的痛感，久久无法释怀。理智如我，仍然在逃避回忆。\n\n母亲是个特别豁达的人，豁达到不可思议，甚至似乎我感性的妻子都比母亲更伤心。可是，当我看到早晨她哭过的双眼时，我知道她又回到回忆之中了。正如我无法释怀父亲最后的话，无法忘记他最后留给我的温度一样。\n\n虽然我在躲藏，可回忆却像开着的机器，趁我不注意，悄悄地反复播映。不止是我自己，身边的人也常在不经意间回忆起来。两岁的女儿并不知道发生了什么，但她会不时发现和爷爷有关的东西，说出“爷爷的”；二年级的儿子，也会在玩牌时脱口而出“爷爷教的”……\n\n我小心地留着相关的东西，像揭开伤口的痂一样，偷偷地回忆——虽然会痛，却也害怕忘掉，害怕失去他留给我的最后的印记。但时间还是会冲淡一切，看看儿子，已经不为失去爷爷而痛哭了；想想女儿，将来大概会完全不记得她一度最喜欢的爷爷了。爱也会被忘掉，每当想到这个残酷的事实时，都让我感到更加心碎。\n\n在这里悄悄记下这些，也是我害怕忘记这份悲痛，曾经的爱与欢乐，曾经的痛与追思，希望这份情凝固在文字里，永不逝去。\n","cover":"","link":"family/2016/02/29/forget-or-not/index.html","preview":"\u003cp\u003e爸爸离开这么多天了，生活其实没有什么大不同，就好象之前不在他身边的日子一样，好像第二天又会在他身边。只是偶尔神经会被触到，猛然感到一种压在胸口的痛感，久久无法释怀。理智如我，仍然在逃避回忆\u003c/p\u003e\n","title":"不愿回忆，害怕忘记"},{"content":"\n\n父亲已经离开快11个小时了，因为血氧下降嗜睡，他是睡着离开我们的，没有留下最后的一句话，于是，我家再也没人知道祖先是不是留下了什么宝藏了…\n\n处理了一下午，又带着我的留恋，陪母亲绕北京转了一大圈，看了那些和我小时候和他在一起的生活有关的地方，心里真的真的很难离开他…\n\n到家之后，我有点想问我儿子，他爸和我爸哪个好一点，不过实在没问出口，毫无疑问，他会说我爸比较好，因为他爸爸打过他屁股。\n\n父亲其实是一个有太多牵挂的人，他临走前还惦记着他的老母亲，他前几天还要看孙子孙女的照片。他想回家，他说他要死了，他想再回家一次，可是我们知道这已经做不到了。\n\n父亲是一个极其讲义气的人，今天晚上，我通知了好多他的密友，其中有的是他的中学同学，有的是他刚参加工作时的同事。好多人得到消息的时候都失声了，我想他们也回想起了他们一起的岁月吧。\n\n可我一直相信，父亲最爱的人是我，不止是因为他为了我，在家再也不抽烟了，也不止是我进门忘叫他他就会气得牙疼，我仍然记得小时候，有天，爸爸和他的几个同学喝酒聊天，他在说他和D和L两位叔叔的区别——\n\n他说，如果穷得快要饿死了，L叔叔会让他的儿子为了活下去而抢银行，D叔叔会让他的孩子守法地坚持，而他会让他的儿子留在家里，他去抢银行。今天，这个世界正式宣告，他抢银行未遂。\n\n——实际上，对今天，我的心理铺垫太多了，以至于我见到他的时候，都不那么悲痛了，我甚至在怀疑为什么我能这么冷血，可是，忽然有一刹那，我意识到到我是个可怜的没爸的孩子了，一下就无法控制情绪了。原来我只是反射弧比较长。\n\n如果他爱谁会比爱我多一点，那一定只有我傻乎乎的儿子了，父亲入医院抢救前一天晚上，还不顾自己很疲劳，非要和孙子玩一会儿呢，他也是自从有了孙子开始才戒烟的。儿子还不明白这一切是怎么回事，但我也真不知道该怎么告诉他，爷爷再也不会陪他玩了——\n\n今天我第二次情绪崩溃就是替儿子闺女选花篮的时候，在几位姑姑面前都无法控制自己的情绪了。\n\n这篇日志没有鸡汤结尾，没有啥结论和决心，只是记录我今天的心情，我并不是不能自拔，也不是不能理智看待，可是我真的没有爸爸了，我怎么才能平静接受啊…\n","cover":"","link":"family/2016/02/09/bye-to-dad/index.html","preview":"\u003cp\u003e父亲已经离开快11个小时了，因为血氧下降嗜睡，他是睡着离开我们的，没有留下最后的一句话，于是，我家再也没人知道祖先是不是留下了什么宝藏了\u003c/p\u003e\n","title":"送别父亲"},{"content":"\n\n今天上午，我 Tag 了 Hyper, runV, Hyperstart 三个项目的 v0.5.0 标签，发布了 0.5 版本，Release Note 是英文的，想着也该有个中文的发布声明，就动笔写了这篇 Blog，送给从此刻开始的春节假期，祝各位开发者们节日休息的好、运维们节日别接告警。\n\n从 0.4 到 0.5，经历了接近五个月，与之前的发布周期相比是长了些，但这五个月中，我们并没有闲着，作为一个开源项目，大家从 GitHub 项目的变更记录可以看到，我们一直在改进自己。\n\n同时，在这期间，我们还在去年10月末和11月初接连参加了 OpenStack Summit Tokyo 和 DockerCon EU。在会上，我们向世界宣告了我们的新项目——Hypernetes （曾用名 HyperStack）。这个项目以 Hyper 作为强隔离性的运行时；使用 Kubernetes 作为 Pod 调度引擎；利用 OpenStack 组件，以 Neutron 作为 SDN 解决方案，以 Cinder/Ceph 作为持久存储方案，也用 Keystone 作为认证授权中心。这些特性使 Hypernetes 成为一个多租户的 Kubernetes 发布版，吸引了诸多关注目光。\n\n这里简单介绍一下 0.4 到 0.5 的变化，最明显的可能就是，对于 CentOS 和 Fedora 的用户，你们现在可以直接安装 RPM 包了（\u003cstrike\u003e包好，包好……\u003c/strike\u003e），呃……为啥没有 deb？作为13年的 Debianer，我也很抱歉啊，其实，事实是，CentOS 7.x 的依赖需求情况比较特殊，所以我们专门 Build 了 RPM，当然，稍后我们也会提供 Deb 的，放心吧。\n\n从软件本身来说，最主要的是我们对 Hyper 的行为做了很多修复和改进，比如对`run` 和 `exec` 命令的返回值、运行时 tty 的行为、文件映射的行为、文件插入行为的完善和修复、以及很多稳定性的改进，测试方面也做了加强。在功能方面，主要的改进在于和 Neutron 的集成、和 Cinder 的 ceph volume 的集成等，细节方面，`run` 命令增加了 `-t` 参数标记是否有 tty 设备的区别，增加了 `logs` 命令，再就是增加了 `libvirt` driver，用户可以在 libvirt 中监控到 hyper 创建的虚拟机。\n\n最近也有一些译文把 Hypernetes 介绍给国内的朋友，感谢诸位的关注，是的，我们是一个由国内发起、开发团队主要在国内的开源项目。在此版本发布，也是春节来临之际，感谢开发团队们的努力工作，虽然大部分开发团队都是远程工作的，但这就是开源社区的一贯工作方式，我们的团队完全胜任这个工作方式，生产效率与集中工作相比好不示弱。\n\n0.5 版本的发布让 Hyper 更加接近了产品化，在接下来的时间里 Hyper 和 Hypernetes 都不会停下来，请大家期待我们不久后的下一次产品发布。谢谢大家！再祝各位春节快乐、少收报警！\n\n","cover":"","link":"container/2016/02/06/hyper-0-5/index.html","preview":"\u003cp\u003eHyper 0.5，送给春节假期，祝各位开发者们节日休息的好、运维们节日别接告警。在接下来的时间里 Hyper 和 Hypernetes 都不会停下来，请大家期待我们不久后的下一次产品发布。\u003c/p\u003e\n","title":"Hyper 0.5 Released"},{"content":"\n\n下一个五年，还希望有你。﻿\n\n我的第一个五年，差不多是在山西临汾度过的，父母都是山西插队的“知青”，那五年里，我的记忆只是片段而已，只依稀记得邻居家有个和我差不多大的小姐姐，还一起去公园玩、荡秋千。老爸当时从事建筑行业，常年出差在外，他总说我小时候喜欢在外面，下雨天也要出门，他就一手打着伞，一手抱我在外面。如今我有儿有女，发现我也是这样的，好像父亲都会这样吧。可我还是知道，老爸是真疼我的。﻿﻿\n\n我的第二个五年，回到北京上小学了，老爸逐渐离开了建筑行业，和我在一起的时间变多了，我却还没太多印象和他在一起玩过什么，只记得10岁的时候，他出差去齐齐哈尔，带我顺路去哈尔滨兆霖公园看了冰灯，回来的时候还带我坐了人生第一次飞机，印象里是一架麦道客机，发动机挂在机尾吊舱。老爸一心想让我涨涨见识，让我比他强。﻿﻿\n\n我的第三个五年，碌碌无为，这五年，我从10岁前的小瘦猴，一跃成为了小胖墩儿。别的小朋友得到了红白机，玩起了魂斗罗，我却从老爸那得到了一套兼容 Apple 的天坛学习机，学起了LOGO与BASIC，那时候就注定要做码农么… 这五年里，可惜的是我平时学习还不错，孩子也聪明、脑子快，可是小学考初中没考好，中考还没考好… 于是老爸花了三万六让我上了寄宿的高中，希望我能有点出息。﻿﻿\n\n我的第四个五年，从高中到大学，我给了老爸好大希望，离清华只有咫尺之遥，有多近呢，比北大线高3分，比清华线低五分，就这五分里，我最后一道物理题少看了一个“忽略摩擦力”的条件，倒数第三题洛伦兹力，把圆周长公式代成 πr^2了，毫无违和感吧，看我记多久就知道我悔多深了。老爸的心情也从天上掉下来，可他还怕我想不开，特地为我庆祝生日。这五年里还有一件让我记得的事就是，我有一次严重扁桃体发炎，从那之后，只要我在家，他就不会在家抽烟了，对烟民来说，这不容易吧。﻿﻿\n\n接下来的第五个五年，我从大学到研究生，这一次终于没有考折，他也高兴得不行，就差焚香告慰先祖了。这几年里，我经常在图书大厦、海淀图书城和china-pub买书，老爸私下感到买书的开销好大，不过他从来没跟我表示过。后来，我决定读博，他这种连高中都没上过的人高兴得不行，完全没有阻止我这一傻X行为，唉… 这几年里，有次我问他，我找个外地人当女朋友怎么样，他说，外国的都行… 然后，不太久以后，我就带着我现在的老婆去我家去了。﻿﻿\n\n在我第六个五年里，在老爸心中比我重要的人终于出现了，就是我儿子，一个证明就是，我儿子出生以后，他完全戒烟了。这几年里我拿到博士学位，入职中国移动研究院，结了婚，（老婆）生了儿子，老爸老妈也搬到了天通苑的大房子，这里面，儿子一岁开始就跟着老爸老妈，而我们搬回城里，让工作更方便些，只是一周回去两次。那一段老爸带孙子带得很开心，不过也会为我回家没跟他请安生气得半宿睡不着，呵呵，他在我眼里已经不是那个三头六臂的终结者了，现在他是一个有点儿小心眼儿的老头了。﻿﻿\n\n第七个五年里，我开始为自己的职业生涯寻找变数，我离开移动转投盛大云的时候，跟老爸说要去上海几个月，他立刻跟我说，年轻人就该到处闯闯… 呃… 我就去几个月，还回来呢… 这五年里，儿子回到市里来上幼儿园，老妈过来帮忙照顾，老爸并不常来，因为他舍不得天通苑的大房子，就是盼着我们经常带着他孙子过去。老妈说他身体不好，各种毛病，说实话，看起来没那么严重啊。后来一年，儿子上小学，我们再次搬家，老爸老妈也终于一起过来帮我们带儿子和闺女两个孩子了。两个孩子明显都更喜欢爷爷，老爸也喜欢孩子们，尤其喜欢大孙子。纵有很多磕磕碰碰，但团团圆圆的生活谁不喜欢，可是孩子们出生与长大，长辈们就在变老，眼见着第七个五年就过去了…﻿﻿\n\n老爸和我都是八月份生日，狮子座，我出生的时候他30岁，他过了六个没有我的五年，又看着我过了七个五年，如今又一个五年开始了，坚强点老爸，坚持住，我们还要和孩子们一起走下去呢，像奶奶一样，看孙辈结婚生子，看生生不息﻿﻿﻿\n\n下个五年，还要有你\n","cover":"","link":"family/2016/01/29/dont-give-up/index.html","preview":"\u003cp\u003e老爸和我都是八月份生日，狮子座，我出生的时候他30岁，他过了六个没有我的五年，又看着我过了七个五年，如今又一个五年开始了，坚强点老爸，坚持住，我们还要和孩子们一起走下去呢，像奶奶一样，看孙辈结婚生子，看生生不息﻿﻿﻿\u003c/p\u003e\n","title":"下个五年，还要有你"},{"content":"\n\n\u003e **利益相关**（强行植入广告）：我们（Hyper）创业团队（也是开源项目）同样做了一种基于 Hypervisor 技术的容器解决方案，然而与 unikernel 不同的是，我们是面向通用的容器镜像的，可以直接运行已有镜像。在我看来，大部分人在热捧 unikernel 的时候，实际上他需要的是 Hyper 这样的技术。\n\n\u003e **免责声明**：我所做的预测只对我自己负责，我们在用创造未来的方式来预测未来，并且有其他人与我们在一同来创造未来，我们坚信我们的预测是正确的。\n\n![作为一个概念的 unikernel](/assets/unikernel-in-article.png)\n\n## 新闻背景\n\n前两天，[Docker 宣布收购了 Unikernel Systems](https://blog.docker.com/2016/01/unikernel/)，引起了朋友圈刷屏（比如[这个](https://mp.weixin.qq.com/s?__biz=MzA5OTAyNzQ2OA==\u0026mid=401469511\u0026idx=1\u0026sn=d4628798a25b2c28d6d0acc2edf85068)和[这个](https://mp.weixin.qq.com/s?__biz=MjM5MDE2MTczMQ==\u0026mid=401874323\u0026idx=1\u0026sn=9e78416191cb7b4b2cf04684b97d4750)）。不过 Twitter 上还是有一些批评声音的，而且 Joyent 的 Bryan Cantrill 大神亲自向信众解释了[为啥 unikernel 不适合于生产系统](https://www.joyent.com/blog/unikernels-are-unfit-for-production)，当然，在存在利益相关这方面，他和我是一样的。\n\n在和一些技术圈的朋友讨论后，我发现有的朋友并不是很了解 unikernel 技术，只是听起来觉得很好。于是，昨天我在朋友圈里写了这么一段话\n\n\u003e 事实上，unikernel 和 docker image 都是对应用的一个静态封装，从很多种意义上说，unikernel 都是一个更精巧的封装，而 docker image 则是一种更简单、松散、或者说更通用的封装。对于每个人是不是有意义，这因人而异，历史上精巧专用的方案被简单而更具兼容性的方案打败的例子比比皆是。这里，很多人都忽视的一点就是，从 unikernel 的定义出发，就不存在一个 unikernel 可以适应多样的已有二进制程序。需要好好审视自己的应用场景，才知道这张旧船票能否登上你的客船\n\n现在我在 Blog 里继续解释一下。\n\n插一句题外话， unikernel 是一类技术，并不只有 Unikernel Systems 一家拥有，有兴趣的同学可以看看 OSV，这个团队来自 Red Hat，头领是 KVM 的作者 Avi，是一个非常优秀而有执行力的团队。\n\n## 什么是 unikernel\n\n根据 [Wiki 定义](https://en.wikipedia.org/wiki/Unikernel)，unikernel 是专用的、单一地址空间，将操作系统功能作为库调用的程序镜像。也就是说，做一个 unikernel 应用，可以不需要复杂、完整的操作系统，可以只包含需要的功能。想想这简直是小而美的微服务架构的终极追求。\n\nDocker 镜像之所以为人们所称道的原因就在于它完整封装了应用环境，使得应用可以在不同的环境里无需修改直接运行，不用考虑 distro、依赖库之类的问题，而这里，unikernel 连 kernel 都一并打包了，只要放在 hypervisor 上即可运行，这种 portability 似乎是无与伦比的，另一方面，hypervisor 带来的隔离效果要比 linux container 更好，而且，去掉不必要功能后，unikernel 包含的可能含有漏洞的代码也会少，从安全的角度讲，你做得越少，你做错的也就越少，人们不禁赞叹，这真是终极的解决之道啊。\n\n不过，等等，这里似乎有点问题啊。单一地址空间、操作系统作为库，这样的话和传统的程序有点不一样啊，程序不是跑在 Linux kernel 上了，那么多进程调度谁来做？已有的程序和库怎么用呢？是的，这就是我所说的不存在可以直接适配多样的已有二进制程序的 unikernel，你需要为每个程序一切从头做起，做自己的 unikernel app。换一个角度说，实际上 unikernel 不是让你把你的已有程序和它依赖的 kernel 功能打包，相反，是提供一套工具，帮你把你的程序嵌入到内核里去，得到一个你自己的专有的内核，这要从源码出发，甚至进行一定的移植工作。\n\n所以，当我在看到这个新闻的时候，甚至在想，docker 这是要回到 PaaS 上去，放弃统一镜像，转而做源码级的服务么？\n\n## 通用的 unikernel？\n\n看到我前面的论述，有人会立刻说，把 init 程序，比如 systemd 甚至 Hyper 的 hyperstart 和 unikernel 打包，然后不就可以直接接入已有二进制程序直接，做成通用的 unikernel 了么？\n\n可是，仔细看看啊各位，首先，从 API/ABI 的角度看，通用的 Unix 或者 Linux kernel 是建立在完整的系统调用集的基础上的，unikernel 通过将内核代码与 App 代码的耦合，放弃了对系统调用的提供。而一旦转而提供完整的 ABI 给应用，那么，和 Linux kernel 也就没有区别了。所以说，unikernel 在提供通用性和进行应用边界划分的时候，选择的不是一个更加普适的接口。或者说，当它转而通用地支持已有的二进制程序的时候，那么它重新变成 hyper 的解决方案，而不是 unikernel 了。\n\n## Unikernel 化一个应用，你面对的问题\n\n除了丧失二进制级的应用通用性之外，Unikernel 其实还面临着很多其他的问题：\n\n- 首先，你需要移植程序，相当于支持一个新的平台。各种 unikernel 技术多少都提供了和 libc 或 java 平台或其他语言环境一致性非常高的开发环境，方便用户的移植，然而，移植工作多少还是需要的。\n- 其次，如果你的应用本身是多线程或多进程的，需要考虑单一地址空间的限制，这不仅是程序语言方面的限制，有的时候也是架构或语义层面的影响。\n- 最后，如 Bryan Cantrill 所说，unikernel 程序实际是完全内核态程序，而且只有单一地址空间，这根本没法 debug 嘛，传统或现代的通用程序调试设施基本上都无法使用，连进程的概念都没有，这对开发和调试带来了极大的难度，显然并不是所有的应用开发者都能驾驭这样的应用的。\n\n## Unikernel 适用的场景有哪些\n\n那么，什么应用需要这个场景呢？我个人认为，只有极端追求性能和小体积的场所，可以不惜代价地去做这种 unikernel，就此，很多人都觉得 IoT （物联网）似乎是最佳应用场景之一。我只想问，我们早年间在 4KB ROM，128B RAM 的限制下写的 51 单片机程序在算不算 unikernel 程序？\n\n## 你真的想要的是什么？\n\n感谢各位看到这里，作为一篇到处植入广告的文章，能看到最后的都是真爱，所以，我就再插入一段广告吧。如果你的容器服务跑在可信任的环境里，性能是首要要求，那么基于 Linux Container 的 Docker 是你的首选；而如果要提供多租户的容器服务，或者容器里的应用不被完全信任（比如用于测试等用途），那么，基于 Hypervisor 的 Hyper 完全胜任这个环境。并且，两者使用完全相同的镜像，对大部分镜像来说（除了那些刻意放弃主机和容器之间隔离性的应用），Container 能跑的，Hypervisor 也同样能跑。\n","cover":"","link":"container/2016/01/23/unikernel-critics/index.html","preview":"\u003cp\u003eDocker 收购了 Unikernel System，引起讨论纷纷\u003c/p\u003e\n","title":"关于 Unikernel，你注意到或没注意到的一些东西"},{"content":"\n\n\u003e 如今北京的空气，嗯，关注点空气质量自我保护吧，废话不多说了，开工吧。\n\n## 基本原理\n\n\n有一定精确性但成本比较低的颗粒物检测方法差不多都用的是同一个原理——由于细颗粒物的直径（微米级）和光的波长（可见光的波长是 0.39-0.7 微米）比较接近，所以细颗粒物会对光产生比较强烈的散射，这也就是 PM 2.5 高的时候，空气的能见度一定不好的原因。当然，PM 2.5 高对能见度不好是充分非必要条件，其他因素也可能导致空气能见度不佳。\n\n基于这个原理，发射一束激光，在一定角度上观测散射光的强度，就可以判断出颗粒物的浓度，当然，这个方法要求对空气中颗粒物直径分布模型、产生散射的物质的成分等有一个假设，同时还受限于光强度测量的精确性，因此，这个测量的精确度是受限的，对于科研可能不太够，但对日常生活的空气检测来说，应该是比较有效和准确的。这次我们的监测仪使用的就是采用这个原理制成的一个模块。\n\n## 准备材料\n\n- raspberry pi 或 arduino，目前测试用的是 rpi 2 和 arduino uno，订的 arduino nano 正在路上，nano 就又小又便宜了。\n- 传感器，我用的是淘宝上买的 PMS1003，大家自行搜索 PM2.5 传感器吧，关键字是“激光”或 laser。不同的传感器接口啥的可能不太一样，我这个传感器自带 UART 输出，所以可以从串口直接读取数据。\n- LCD1602 液晶显示，我用了一块 8574 转换电路，转成了 I2C 接口，这样比较省接口。可以直接买一个带 I2C 的 LCD，也可以分别买了自己连，嗯，我是分两次买自己连的，因为我最早（去年？）不知道有 I2C 的……\n- 连接线\n\n## 硬件链接\n\n因为插接件不太兼容，我把传感器的连接线一端截开焊在了一块板子上，连上插针，方便连接，如果手头有合适插接件的话，可能不用动烙铁了。具体连接很简单：\n\n### 传感器连接\n\n- 5V 供电\n- 地\n- Setting 管脚，这个接在 Pi 的一个 GPIO 接口上（比如 GPIO 17）或 Arduino 的一个接口上，比如这次用的是 IO 2。这个管脚拉高，模块处于工作状态\n- TXD 连接到 Pi 的 RXD 或 Arduino 的 RXD 上，做采集\n\n### LCD\n\n- SDA/SCL I2C 的数据和时钟，接在 Pi 或者 Arduino 的 数据和时钟上\n- Vcc/GND 接 5V 电源和地，实测接 3.3V 会供电不足\n\n## 软件环境\n\nPi 的话需要准备下，要把缺省关闭的 I2C 打开，并且把 console 连接的串口去掉，空出串口来给我们采集数据用。\n\n其他的就是要查一下 LCD 的 I2C 地址。\n\n## 主体流程\n\n- 初始化\n  - 液晶初始化：设置合适的格式和背光\n  - 模块初始化：初始化串口，找到 `0x42`, `0x4d` 作为帧的开始，一帧 32 个字节（不同模块参考相应的手册）\n- 采集\n  - 采集对应字节的数据，从大结尾转为短整型，然后显示在液晶屏上\n\n如此而已，非常简单，以后我们再考虑用蓝牙讲数据发送出来。\n\n## 源码清单\n\nPi 和 Arduino 的源码如下：\n\n### Pi 源码\n\n主程序：\n\n\u003cpre\u003e\n#!/usr/bin/env python\n\nimport RPi.GPIO as GPIO\nimport serial\nimport pylcdlib\n# pylcdlib from https://gist.github.com/gnawux/4f68b8e301b203489336\n\ndef readbe16(s, pos):\n    return ( ord(s[pos])\u003c\u003c8) + ord(s[pos+1])\n\nGPIO.setwarnings(False)\nGPIO.setmode(GPIO.BCM)\nGPIO.setup(17, GPIO.OUT)\nGPIO.output(17, True)\n\n# define bus address, port, and pins\ndisplay = pylcdlib.lcd(0x27,1, Rs=0, Rw=1, En=2, Backlight=3, D4=4, D5=5, D6=6, D7=7)\ndisplay.lcd_clear()\n\nser = serial.Serial(\"/dev/ttyAMA0\")\nser.baudrate=9600\ndata = ser.read(32)\npos  = 0\nwhile True:\n    pos = data[pos:].index(chr(0x42))\n    if ord(data[(pos+1)\u002631]) == 0x4d:\n        print('found BM at %d' % (pos))\n        ser.read(pos)\n\tbreak\n    pos = pos + 1\n    if pos \u003e 31:\n        print('frame format error')\n        exit(1)\n\nl1d=-1\nl2d=-1\n\nwhile True:\n    data = ser.read(32)\n    if data[0] != 'B' or data[1] != 'M':\n        print('frame format error while reading data: %s, %s' % (data[:2], data))\n        exit(1)\n    length = readbe16(data, 2)\n    if length != 28:\n        print('length error : %d' % (length))\n        exit(1)\n\n    pm25std = readbe16(data, 6)\n    pm25atm = readbe16(data, 12)\n\n    if l1d != pm25std:\n        l1d = pm25std\n        display.lcd_puts('std: %d ug/m3' % l1d,1)\n    if l2d != pm25atm:\n        l2d = pm25atm\n        display.lcd_puts('atm: %d ug/m3'% l2d,2)\n\u003c/pre\u003e\n\nLCD显示库\n\n\u003cpre\u003e\n#!/usr/bin/env python\n\"\"\"\noriginal from http://www.rpiblog.com/2012/07/interfacing-16x2-lcd-with-raspberry-pi.html\nI modified it, thus you can set customized pin defines, such as\n   lcd(0x27,1, Rs=0, Rw=1, En=2, Backlight=3, D4=4, D5=5, D6=6, D7=7)\n\n   address 0x27\n   port    1\n\n   P0 - Rs\n   P1 - RW\n   P2 - En\n   P3 - Backlight\n   P4-P7 - D4-D7\n\"\"\"\nimport smbus\nfrom time import  *\n\n#  General  i2c  device  class  so  that  other  devices  can  be  added  easily\nclass i2c_device:\n  def __init__(self, addr, port):\n    self.addr = addr\n    self.bus = smbus.SMBus(port)\n\n  def write(self, byte):\n    self.bus.write_byte(self.addr, byte)\n\n  def read(self):\n    return self.bus.read_byte(self.addr)\n\n  def read_nbytes_data(self, data, n):  #  For  sequential  reads  \u003e  1  byte\n    return self.bus.read_i2c_block_data(self.addr,  data,  n)\n\n\nclass  lcd:\n  #initializes  objects  and  lcd\n  def  __init__(self, addr, port, **kwarg):\n    self.pin = {}\n    self.lcd_device = i2c_device(addr, port)\n    self.config(**kwarg)\n    self.Backlight = True\n    self.low_level_write(En=False, Rs=False, Rw=False, data=3)\n    self.lcd_strobe()\n    sleep(0.0005)\n    self.lcd_strobe()\n    sleep(0.0005)\n    self.lcd_strobe()\n    sleep(0.0005)\n    self.low_level_write(En=False, Rs=False, Rw=False, data=2)\n    self.lcd_strobe()\n    sleep(0.0005)\n\n    self.lcd_write(0x28)\n    self.lcd_write(0x08)\n    self.lcd_write(0x01)\n    self.lcd_write(0x06)\n    self.lcd_write(0x0C)\n    self.lcd_write(0x0F)\n\n  def config(self, **kwarg):\n    self.pin['Rs'] = kwarg.get('Rs', 4)\n    self.pin['Rw'] = kwarg.get('Rw', 5)\n    self.pin['En'] = kwarg.get('En', 6)\n    self.pin['Backlight'] = kwarg.get('Backlight', 7)\n    self.pin['D4'] = kwarg.get('D4', 0)\n    self.pin['D5'] = kwarg.get('D5', 1)\n    self.pin['D6'] = kwarg.get('D6', 2)\n    self.pin['D7'] = kwarg.get('D7', 3)\n\n  def backlight(self, on=True):\n    self.backlight = on\n\n  def low_level_write(self, En, Rs, Rw, data):\n    byte = 0\n    if En:\n      byte = byte | 1 \u003c\u003c self.pin['En']\n    if Rs:\n      byte = byte | 1 \u003c\u003c self.pin['Rs']\n    if Rw:\n      byte = byte | 1 \u003c\u003c self.pin['Rw']\n    if self.backlight:\n      byte = byte | 1 \u003c\u003c self.pin['Backlight']\n    if data \u0026 0x01 :\n      byte = byte | 1 \u003c\u003c self.pin['D4']\n    if data \u0026 0x02 :\n      byte = byte | 1 \u003c\u003c self.pin['D5']\n    if data \u0026 0x04 :\n      byte = byte | 1 \u003c\u003c self.pin['D6']\n    if data \u0026 0x08 :\n      byte = byte | 1 \u003c\u003c self.pin['D7']\n    self.lcd_device.write(byte)\n\n  #  clocks  EN  to  latch  command\n  def  lcd_strobe(self):\n    self.lcd_device.write(self.lcd_device.read()  |  1 \u003c\u003c self.pin['En'] )\n    self.lcd_device.write(self.lcd_device.read()  \u0026  (0xFF - (1\u003c\u003c self.pin['En'])) )\n\n  #  write  a  command  to  lcd\n  def  lcd_write(self,  cmd):\n    self.low_level_write(En=False, Rs=False, Rw=False, data=(cmd\u003e\u003e4))\n    self.lcd_strobe()\n    self.low_level_write(En=False, Rs=False, Rw=False, data=(cmd\u00260x0F))\n    self.lcd_strobe()\n    self.low_level_write(En=False, Rs=False, Rw=False, data=0)\n\n  #  write  a  character  to  lcd  (or  character  rom)\n  def  lcd_write_char(self,  charvalue):\n    self.low_level_write(En=False, Rs=True, Rw=False, data=(charvalue\u003e\u003e4))\n    self.lcd_strobe()\n    self.low_level_write(En=False, Rs=True, Rw=False, data=(charvalue\u00260x0F))\n    self.lcd_strobe()\n    self.low_level_write(En=False, Rs=False, Rw=False, data=0)\n\n  #  put  char  function\n  def  lcd_putc(self,  char):\n    self.lcd_write_char(ord(char))\n\n  #  put  string  function\n  def  lcd_puts(self,  string,  line):\n    if  line  ==  1:\n      self.lcd_write(0x80)\n    if  line  ==  2:\n      self.lcd_write(0xC0)\n    if  line  ==  3:\n      self.lcd_write(0x94)\n    if  line  ==  4:\n      self.lcd_write(0xD4)\n\n    for  char  in  string:\n      self.lcd_putc(char)\n\n  #  clear  lcd  and  set  to  home\n  def  lcd_clear(self):\n    self.lcd_write(0x1)\n    self.lcd_write(0x2)\n\n  #  add  custom  characters  (0  -  7)\n  def  lcd_load_custon_chars(self,  fontdata):\n    self.lcd_device.bus.write(0x40);\n    for  char  in  fontdata:\n      for  line  in  char:\n        self.lcd_write_char(line)\n\nif __name__ == '__main__':\n  # define bus address, port, and pins\n  display = lcd(0x27,1, Rs=0, Rw=1, En=2, Backlight=3, D4=4, D5=5, D6=6, D7=7)\n  display.lcd_clear()\n  # line 1 and line 2\n  display.lcd_puts(\"I2C LCD on R-Pi\",1)\n  display.lcd_puts(\"       by gnawux\",2)\n\u003c/pre\u003e\n\n### Arduino 源码\n\n主程序:\n\n\u003cpre\u003e\n#include \u003cWire.h\u003e\n#include \u003cLCD.h\u003e\n#include \u003cLiquidCrystal_I2C.h\u003e  // F Malpartida's NewLiquidCrystal library\n\n#define I2C_ADDR    0x27  // Define I2C Address for controller\n#define BACKLIGHT_PIN  3\n#define En_pin  2\n#define Rw_pin  1\n#define Rs_pin  0\n#define D4_pin  4\n#define D5_pin  5\n#define D6_pin  6\n#define D7_pin  7\n\n#define  LED_OFF  0\n#define  LED_ON  1\n\nconst int SetPin = 2;\nchar frame[32];\n\nLiquidCrystal_I2C  lcd(I2C_ADDR,En_pin,Rw_pin,Rs_pin,D4_pin,D5_pin,D6_pin,D7_pin,BACKLIGHT_PIN,POSITIVE);\n\nchar banner1[17];\nchar banner2[17];\n\nvoid banner_init() {\n  for(int i = 0; i\u003c16;i++) {\n    banner1[i] = ' ';\n    banner2[i] = ' ';\n  }\n  banner1[16] = '\\0';\n  banner2[16] = '\\0';\n}\n\nvoid banner_display() {\n  lcd.setCursor(0,0);\n  lcd.print(banner1);\n  lcd.setCursor(0,1);\n  lcd.print(banner2);\n}\n\nvoid debug(const char* str) {\n  lcd.setCursor(0,0);\n  lcd.print(str);\n}\n\nvoid initPanTower() {\n  debug(\"begin\");\n  while (1) {\n    if (!Serial.available()) {\n      delay(100);\n      debug(\"wating serial\");\n      continue;\n    }\n    debug(\"got serial\");\n    int len = 0;\n    int nr = Serial.readBytes(frame, 32);\n    while (len + nr \u003c 32) {\n      len = len + nr;\n      nr = Serial.readBytes(frame + len, 32 - len);\n    }\n    debug(\"got frame\");\n    for (int diff = 0; diff \u003c 32 ; diff++ ) {\n      if (frame[diff] == 'B' \u0026\u0026 frame[(diff+1)%32] == 'M') {\n        nr = len = 0;\n        while (len + nr \u003c diff) {\n          len = len +nr;\n          nr = Serial.readBytes(frame + len, diff - len);\n        }\n        digitalWrite(LED_BUILTIN, HIGH);\n        return;\n      }\n    }\n  }  \n}\n\nvoid setup()\n{\n  //Initialize LCD\n  lcd.begin (16,2);  // initialize the lcd\n  lcd.backlight();\n  banner_init();\n\n  //Enable Monitor Module\n  pinMode(SetPin, OUTPUT);\n  digitalWrite(SetPin, HIGH);\n\n  //shut the led\n  pinMode(LED_BUILTIN, OUTPUT);\n  digitalWrite(LED_BUILTIN, LOW);\n\n  //Start Serial Port\n  Serial.begin(9600);\n  initPanTower();\n}\n\nvoid loop()  \n{\n  if (Serial.available()) {\n    int len = 0;\n    int nr = Serial.readBytes(frame, 32);\n    while (len + nr \u003c 32) {\n      len = len + nr;\n      nr = Serial.readBytes(frame + len, 32 - len);\n    }\n\n    int d1 = ((int)frame[6] \u003c\u003c 8) + frame[7];\n    int d2 = ((int)frame[12] \u003c\u003c 8) + frame[13];\n\n    snprintf(banner1, 16, \"std: %d ug/m3    \", d1);\n    snprintf(banner2, 16, \"atm: %d ug/m3    \", d2);\n    banner_display();\n  }\n}\n\u003c/pre\u003e\n","cover":"","link":"life/2015/12/27/diy-pm25-monitor/index.html","preview":"\u003cp\u003e通过串口从测试模块采集数据，并显示在 LCD 上\u003c/p\u003e\n","title":"DIY PM 2.5 监测仪 (1): 采集和显示"},{"content":"\n\n\u003e 照例广告放最前：Hyper 作为一家新的、小的、有梦想的、不做“Copy-to-China”的创业公司，我们欢迎想创新的、有想法的、有技术的小伙伴加盟，并且我们允许远程办公。\n\nKubernetes 中的 *Service Account* 是个比较难以理解的概念，什么是 Service Account，到底是做什么的？[文档](http://kubernetes.io/v1.0/docs/user-guide/service-accounts.html)中如是说——\n\n\u003e A service account provides an identity for processes that run in a Pod. （服务帐号为 Pod 中的进程提供了一个 id）\n\n不过，这个 Pod 中的进程的 id 是做什么用的，在用不到的时候还真让人费脑筋。[管理文档](http://kubernetes.io/v1.0/docs/admin/service-accounts-admin.html)里说得更详细一点，但是仍然没有提到是做什么用的。\n\n在这种时候，一个好的例子往往胜过文档的解释。实际上，kubernetes 的官方示例里就有 Service Account 的应用。仔细看这个例子——[在 Kubernetes 中运行 Cassandra](https://github.com/kubernetes/kubernetes/blob/release-1.0/examples/cassandra/README.md)。\n\n大家知道，在 Cassandra 这种全对称结构的集群里，最先启动的种子节点是最重要的，其他节点都要加入到种子节点的集群中才能保证启动的是一个集群而不会分裂成多个集群，Cassandra、Akka 集群都有这个要求。\n\n然而，在这个例子中，是先启动一个节点，然后直接提高 Replica 数量，来做到多节点的，后面的节点是怎么找到种子节点的呢？仔细看例子的文档——\n\n\u003eHowever it also adds a custom SeedProvider to Cassandra. In Cassandra, a `SeedProvider` bootstraps the gossip protocol that Cassandra uses to find other nodes. The `KubernetesSeedProvider` discovers the Kubernetes API Server using the built in Kubernetes discovery service, and then uses the Kubernetes API to find new nodes\n\n这里提到了，image 中的 Cassandra 有一个特殊的 `KubernetesSeedProvider` ，由它调用 Kubernetes 的 API 来获得集群中已经存在的节点的。注意，这里就是在 Pod 中运行的进程调用 Kubernetes API 的地方，也就是 Service Account 工作的地方。\n\n代码之前，了无秘密，看[这段代码](https://github.com/kubernetes/kubernetes/blob/release-1.0/examples/cassandra/java/src/io/k8s/cassandra/KubernetesSeedProvider.java#L101)\n\n\u003cpre\u003e\n    public List\u003cInetAddress\u003e getSeeds() {\n        List\u003cInetAddress\u003e list = new ArrayList\u003cInetAddress\u003e();\n        String host = \"https://kubernetes.default.cluster.local\";\n        String serviceName = getEnvOrDefault(\"CASSANDRA_SERVICE\", \"cassandra\");\n        String podNamespace = getEnvOrDefault(\"POD_NAMESPACE\", \"default\");\n        String path = String.format(\"/api/v1/namespaces/%s/endpoints/\", podNamespace);\n        try {\n            String token = getServiceAccountToken();\n\u003c/pre\u003e\n\n这里，给出了访问的 endpoints API，并且要从本地取出 Service Account 的 Token，来获得服务发现的信息。\n\n综上，Service Account 是 Kubernetes 用于集群内运行的程序，进行服务发现时调用 API 的帐号，帐号的 token 会直接挂载到 Pod 中，可以供程序直接使用。\n","cover":"","link":"cloud/2015/11/03/kubernetes-service-account/index.html","preview":"\u003cp\u003eService Account 是 Kubernetes 用于集群内运行的程序，进行服务发现时调用 API 的帐号\u003c/p\u003e\n","title":"Kubernetes 中的 Service Account"},{"content":"\n\n\u003e 广告放最前：作为一家新的、小的、有梦想的、不做“Copy-to-China”的创业公司，我们欢迎想创新的、有想法的、有技术的小伙伴加盟，并且我们允许远程办公。\n\n10月最后一周，一年两度的 OpenStack Summit 移师东京，转瞬间朋友圈里开始有各种各样的文章出现，有些相当干的干货，比如[王豪迈关于存储方面的这篇](http://www.wzxue.com/openstack-tokyo-summit/)，这可是核心开发人员深入参与Design Summit，回来写的文章；当然也有一些水水的公关稿，甚至……（此处省略若干字）\n\n这里，我也忍不住想要聊两句我们 Hyper 和 Hypernetes。\n\n## Hypernetes\n\n我们 Hyper 这次参会，带去的新产品就是 [Hypernetes](http://hypernetes.com)，一个真正多租户的 [Kubernetes](http://kubernetes.io) Distro。Hypernetes \n\n- 使用我们的 [Hyper](https://hyper.sh) 做计算隔离，轻量级虚机可以提供良好的隔离\n- 使用 OpenStack Neutron 进行网络隔离，为每个 k8s namespace 提供独立的二层网络\n- 使用 OpenStack Cinder 提供持久化的数据卷\n\n我们在 Demo Theater 进行了演示，在我们的展台进行展示，和一些公司进行了交流，同时也在 Hacker News 上进行了发布，总的说，社区对我们的努力还是肯定的，比如，Kubernetes 项目的发起人之一、头号贡献者 Brendan Burns 就在 Twitter 远程表达了他的兴趣\n\n\u003cimg src=\"/assets/brendan.jpg\" alt=\"quote pic\" style=\"width: 300px;\"/\u003e\n\n技术媒体们对此也有报道，比如 [InfoWorld](http://www.infoworld.com/article/2997770/application-virtualization/hypernetes-unites-kubernetes-openstack-for-multitenant-container-management.html) 这篇，不是公关稿，纯粹是社区对我们工作的反馈。\n\n加上现场到访展台、会议上交流的公司，整个社区对我们的兴趣有点超出我的预期，感谢全体 Hyper 团队在过去两个月中的非凡努力。对我们来说，接下来就是继续努力工作，在接下来的时间里，尽快从 Demo 到可用产品。\n\n## 对 OpenStack 社区与容器的看法\n\n这次峰会上，OpenStack 社区的领头羊 Rackspace 发布了他们家的容器服务 [Carina](https://getcarina.com)，Magnum 项目的领头人 Adrian Otto 甚至为此在 Keynote 上秀了一段娃，不过，对这个产品，大家的反馈似乎都是很奇怪、为啥还是这样…… 链接已给出，有兴趣的同学可以看看。\n\n至于 Magnum 项目，仍然处在一种很迷茫的状态，Design Summit 上，项目陈述自己的观点是——不改变用户使用习惯、暴露原生接口给用户；不增加 OpenStack 特定的工具和新元素。同时，会上，当我问及 Adrain ，是否考虑引入通用的容器模型时，Adrain 直接表示，Magnum 将会是 k8s, swarm, marathon 的超集，你可以使用 pod，当然只能落在 k8s 上，也能使用 compose，当然这是 swarm-only 的。在这样的形势下，感觉 Magnum 似乎在沦为一个 Heat Template，不要忘了，对很多人来说，Heat 也是不成熟的。\n\n相比之下，我倒是觉得 Kuryr 项目把 Neutron 作为 Docker 的 Network Provider，这个项目还是更有意义一些。\n\n## 对 OpenStack 其他项目的一些零星感受\n\n第一天会上，某巨头的同学透露他们在网络方面的工作更主要集中在 Open Daylight (ODL)项目上，而将 Neutron 作为一个 API 代理，这让我们看到 OpenStack 社区的参与者们开始筹划新的框架了。\n\n而后，豪迈同学透露 Cinder 社区有独立的念头，希望摆脱对 OpenStack 的其他项目的依赖（参见开头处的链接），这真是让我们一众唯恐天下不乱的 startup 喜闻乐见啊。\n\n其后，前面说的那位同学也提到，其实 neutron 也有摆脱对其他项目依赖的想法。\n\n这里，如果用知乎体问我“对于网络和存储社区想要和OpenStack划清界限一事有什么看法？”，我想说\n\n首先，这是 OpenStack 社区中，Nova 项目过于核心的结果，Nova 是一切的核心，于是网络和存储项目都和 Nova 紧密耦合，这本身就是软件工程的灾难。如今，斗转星移，容器开始唱主角的时候，当 “新星（nova）”已经不太创新的时候，是时候引入第二个计算框架了，k8s 可能无法取代 nova，或者说容器无法取代传统虚机，但容器化的架构，或者说 Immutable 的基础设施，必将占有一个相当大的份额，在此情形之下，Cinder 如此做是顺应潮流的举动，反过来看，neutron 在有了 ODL 这样的项目之后再想划清界限就有点晚了。\n\n但是，不论 OpenStack 开源项目的演进如何，都不能阻挡基金会仍然是成功的，作为大厂商媾和的标准化组织，即使是 Nova 被劈腿了，或者 Cinder 去除唯一依赖了，基金会仍然会通过改变自己，增加新的项目，让基金会向前演进，一个项目不是 OpenStack 的全部，OpenStack 的意义在于厂商们将 IT 基础设施互操作接口标准化的决心。\n\n## 最后\n\n最后，广告再来一遍——作为一家新的、小的、有梦想的、不做“Copy-to-China”的创业公司，我们欢迎想创新的、有想法的、有技术的小伙伴加盟，并且我们允许远程办公。\n\n","cover":"","link":"cloud/2015/11/02/summit/index.html","preview":"\u003cp\u003e10月最后一周，一年两度的 OpenStack Summit 移师东京，转瞬间朋友圈里开始有各种各样的文章出现，这里，我也忍不住想要聊两句我们 Hyper 和 Hypernetes。\u003c/p\u003e\n","title":"Hypernetes与OpenStack东京峰会见闻"},{"content":"\n\n答案链接：https://www.zhihu.com/question/25095290/answer/48503447\n\n两个孩子的爹回答一下，写给自己的。\n\n儿子七岁一年级了，他刚刚出生送新生儿病房，亲手签《病危通知书》的情景还历历在目，当然现在他很健康；对他前两天不好好吃饭不认真学习的怒气也还没完全消散；早上一起出门跑步时的熊抱和结束时互相鼓励的击掌仍然让我兴奋着。\n\n女儿快一岁半了，她出生送回病房，我在门口焦急等着爱人送回来的那份心焦还能体会；在家办公时，她调皮地挤到我边上，叫爸爸然后开心地笑脸让人心都软了；晚上我总是拍她入睡，会占用我二十分钟甚至一小时的时间，然后，时间又是我的了。\n\n但是题主我的家庭生活并不像说的这么轻松惬意，其实六点起床带儿子跑步的同时，我很少晚上十二点以前睡觉，昨晚甚至忙到三点。熟悉我的人知道，我几乎白天从不睡觉，不过今天我给自己放假打一会儿盹。\n\n\u003e “真的，如果真心想做open source技术创业，忘了工作家庭平衡吧，肯定要失去一段时间的。”\n\n——朋友这么说。\n\n可是，不是所有人都理解，孩子们长大得如此之快，我们能陪伴的如此之少，你甚至来不及想要珍惜，他最最依赖你的时间就要过去了，哪有时间来想是平衡到中间还是边上呢？\n\n可孩子们也不只是一个撕碎时间的机器的。\n\n我和儿子现在是共同锻炼、互相鼓励的队友，他是矫情的妈宝，我是臃肿的胖子，我们都要改变自己，我们才坚持了五天，我们的第一个阶段目标是七天，我们都在努力发掘自己的潜力，你可以笑话我们，但我觉得自己确实更精力充沛了，花费的时间有时候是值得的。\n\n昨天研究一个问题到凌晨快三点，早上继续，还是办法不多，心情烦躁，但当女儿跑到近前，把笑脸整个贴在阳台门上，透过玻璃撒娇的时候，心一下放开了，当了爸爸的人才会懂，孩子一笑给你带来什么样的力量。\n\n如果你把给孩子的时间当成投资，那以收获回报的等待之久和不确定性，是注定不值的；为人父母的时间开销、付出的爱本身就是值得珍惜和享受的体验。\n\n如果你把时间看成一碗水，放给孩子一些自己就少一些，那么你是永远无法释怀的；可是付出对你潜能的发掘也可能是你难得的收获。\n\n熟人请不要转朋友圈，避免引起一些误会，我其实真是写给自己的。\n","cover":"","link":"zhihu/2015/05/21/children-time/index.html","preview":"\u003cp\u003e孩子们也不只是一个撕碎时间的机器的。如果你把时间看成一碗水，放给孩子一些自己就少一些，那么你是永远无法释怀的；可是这对你潜能的发掘也可能是你难得的收获\u003c/p\u003e\n","title":"[知乎回答] 刚做爸爸，觉得自己的时间都被孩子剥夺，该怎么调整心态？"},{"content":"\n\n这个 Blog 在主机到期，迁出 wordpress 引擎之后，就放到了 github，不过，因为迁移程序的问题，文章的 url 一直是不 work 的，好几个月之后（可能有），终于修复了这些 URL。\n\n虽然发布频率已经低到不能再低，但这个 blog 仍然活着。\n","cover":"","link":"meta/2015/02/24/blog-update/index.html","preview":"","title":"Blog 系统更新完毕"},{"content":"\n\n答案链接：https://www.zhihu.com/question/27680688/answer/37625116\n\n铱星是一个伟大的设想和伟大的创举，\u003cbr\u003e\n铱星是通信业理想主义的巅峰之作，\u003cbr\u003e\n铱星依靠其星间链路技术，成为了一个真正的民用的全球无缝覆盖的无需地面中继的卫星通信系统。\n\n但铱星无法和同时兴起的低成本、高普及率的地面移动通信系统争夺市场占有率，其可征服的市场被挤压得过于狭小；\u003cbr\u003e\n铱星是完全为语音通信设计的，没有预见到互联网的爆炸式发展；\u003cbr\u003e\n铱星完全的星间链路通信，使他无法被大多数政府钳制。\n\n理想主义的铱星陨落了，它不会死，它只是随风而去，它对永远在线的梦想的终极追求，永远活在所有进入通信业的人的心中，一旦时机成熟，就要死灰复燃。\n\n```\n--------\u003e8-----------回到现实的分割线-----------\u003e8--------\n```\n\n说说设计一个新的卫星通信系统，SpaceX的计划如何我不太清楚，但是， 如今的目标，互联网应用已经重于语音通信了，在铱星的路上，继续向前走需要重新考虑一些目标：\n\n1. 互联网的用量高于语音，可能需要更多的卫星提供足够大的容量；\n2. 需要足够的星-地链路，星间点对点的网内通信的需求可能没有星-地链路的需求高，星间多跳的目的是中继到地面；\n3. 终端的成本要做低，所以卫星的轨道要够低；\n4. 卫星系统最好能低成本、快速折旧，因为网络技术发展太快，避免还没开始商用就过时的问题；\n5. 考虑和航空公司、海运、物流公司合作，考虑运输设备联网、航班邮轮服务、乃至物联网等领域，别光盯着几个探险者，我胆小、不是探险爱好者，不知道那些探险家们在南极或者珠峰顶上是不是总拿着收集发朋友圈，反正我们天天在家用WLAN的，恐怕是不会用卫星，除非价格便宜翻墙方便。\n\n嗯，随便想想，肯定还有落下的，这里面有些问题SpaceX擅长，有些看起来没那么容易，希望他们以美国人的探险家的精神，再来一次理想主义的尝试，祝他们成功。\n","cover":"","link":"zhihu/2015/01/20/iridium/index.html","preview":"\u003cp\u003e铱星是一个伟大的设想和伟大的创举，铱星是通信业理想主义的巅峰之作\u003c/p\u003e\n","title":"[知乎回答] 20年前(1996)MOTO的铱星计划（77颗卫星），与现在SpaceX的700颗卫星计划，有什么异同？"},{"content":"\n\n\u003e 按，从回来开始就写这个游记，写了两个月才写出来，对不起观众了……\n\n2014年8月10-15日，我们父子二人进行了一次草原自驾游，行程2100公里，在北京以北画了一个大圈。因为诺基亚的迅猛的裁员行动，导致团组人员和团长发生了变化，致使我们在没有仔细计划的就进行了这次说走就走的旅行。\n\n\u003cimg src=\"https://monosnap.com/image/pJpxKfqH44fkzWMd3LrT7gb8Bp5LDB.png\" /\u003e\n\n虽然计划并不充分，但这次旅行还是很充实圆满的，这里就记录一下，供后来者参考吧。[全程的照片在这里](https://www.flickr.com/photos/gnawux/sets/72157645995802789/)，不喜欢流水帐的同学也可以只看看照片。\n\n##出发\n\n8月10日早上早点之后，我们就出发了，沿京承高速一路向北，根据地图指示，需要6-7个小时的车程，不敢怠慢。\n\n从京承高速转到承赤高速（编号依然是G45），之后又转上了承赤高速的围场支线，一路高速到了围场县，路上还是相当好走的，而且全程有指向“赛罕坝国家森林公园”的路牌，感觉不用导航也不太会走错。我们在出京前最后一个服务区太师屯停车休息加满油，出京后第一个服务区安子岭服务区吃午饭，之后又在茅荆坝服务区休息了一次。路上儿子累了睡着了，因为之前一直有坐安全座椅的习惯，加上这次有个舒服的颈枕，没有任何不适，全程都十分愉快，满分好评。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15307191607/in/photostream/player/\" width=\"281\" height=\"500\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n下了高速之后，跟着导航走向赛罕坝国家森林公园的入口，大概要一个多小时，这一段路不怎么宽，路况也比较一般，不过，一切才刚刚开始。\n\n##赛罕坝：林场、草原与湖泊\n\n赛罕坝国家森林公园是此行第一站，风景很不错，几处有水的景观都很漂亮，虽然游客不少，但拍出漂亮的照片依然不是难事，只是森林公园里的路实在是非常难走，从景区入口不远的塞罕塔开到七星湖的一段尤其让人担心车的悬挂，泰丰湖正在修路，以后可能就会好了。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15565543982/player/\" width=\"500\" height=\"281\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n赛罕坝国家森林公园的主景区是赛罕坝机械林场，当年大规模造出的人工林，如今连绵不绝，非常壮观，这是在景区的高点塞罕塔上照出的林海\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15470709656/in/set-72157648191857408/player/\" width=\"500\" height=\"281\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n因为我们之前没有详细计划，所以当我们到达景区售票处的时候，实际是一个比较茫然的状态，天色已晚不知道是住在景区里还是外面，也不知道住宿要花费多少……\n\n不过这些问题很快解决了，我们花130块钱买了景区（赛罕坝+御道口）的门票，然后跟着一个在门口拉客的农家院的店主，开车进去了，180一晚，就这么定了。\n\n实际上，景区里面的路还是很遥远的，店主在到店之前带我们去了塞罕塔和七星湖景区。刚才提到的塞罕塔是一座仿古建筑，是景区的制高点，可以环顾塞罕坝森林公园，乃至乌兰布统草原的景色，非常壮观。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/14943946923/player/\" width=\"500\" height=\"500\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n从塞罕塔下来，经过一段漫长的搓板路，到达了七星湖，七星湖的全称好像是“七星湖假鼠妇草湿地保护区”，这里生长着大片的假鼠妇草，这种草大片生长在海拔1100米左右的高原上，但赛罕坝这里海拔大约有1500米，能生长出如此大面积的假鼠妇草非常罕见，因此格外值得保护和研究。单说风景，这里也是非常漂亮的，厚实的大片草地中，点缀着点点的湖面，宛如天上七星下凡……（有点小学生作文的感觉了），不多说了，还是上照片\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15564135345/player/\" width=\"500\" height=\"500\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n到景区的第一个傍晚就收获了如此美景，真让人停不下拍照的手机，随后，我们就入住了带我们进来的农家院，住宿条件还算是不错的，不过吃的着实不便宜。\n\n入住之后，我们抓紧时间研究了带来的攻略，幸亏下载了离线版，因为在这里基本上是无法接入网络的……经过一晚上的研究我们确定了第二天的目的地——上午是泰丰湖、滦河源头和塞北石佛等，然后下午进入内蒙古境内的红山军马场（乌兰布统草原）然后视情况决定，在乌兰布统住下还是直接前往克什克腾旗的经棚镇。\n\n按照农家院老板的指点，我们沿着返回七星湖的路走过去，途中看到了泰丰湖的路标，不过一条主要的路正在修路，我们随即尝试了两条土路，前一条是不通的，不过后一条带我们来到了泰丰湖。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15540399426/player/\" width=\"500\" height=\"500\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n泰丰湖是一个小小的月牙形的小湖，可就是这小湖还是很漂亮的，泛舟湖上，蓝天碧水，周围的绿树以及远处的乌兰布统草原，都非常漂亮，这里不仅满足了儿子坐船的愿望，也让他骑了一回高头大马。儿子十分开心，之后，我俩就离开了泰丰湖，路过了赛罕坝林场总部的门口，然后按照店家的指点，在第二个路口左转之后，直奔内蒙古方向而去，这之后的路就变得非常好开了，基本没什么颠簸。\n\n在到达河北和内蒙的边界之前，我们决定拐向岔路，去探访塞北石佛。这条岔路也非常好走，路上偶尔可以把车停在路边，拍拍远方草原的美景，儿子在兴奋之余还踩进了水沟……\n\n探访石佛的计划最终还是放弃了，在开到景区的一个检查点的时候，工作人员告诉我，后面去石佛的路很难走，而且其实也没什么可看的，为了保护我们的车和今后几天的行程，我们掉头向回开。\n\n很快，我们到达了冀-蒙边界，开出赛罕坝景区之后，我们在一个加油站又加满了油，然后开向内蒙古草原。滦河源头就在冀蒙边界上，这里有一个小市场，和一些滑索之类的游戏项目，没什么太多的东西，我们继续向内蒙古进发。\n\n##乌兰布统：初识草原\n\n乌兰布统草原（红山军马场）景区内，只有一小段路不好走，总体路况远强于赛罕坝森林公园，其实整个内蒙的路况都相当不错。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15378112567/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n刚到草原我就开始感慨，自己好像看到了久违的 Windows XP 桌面，儿子也非常兴奋，到处拍照。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15540396196/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n这里就是安北大将军佟国纲的墓，整个木兰围场，包括河北境内的围场和乌兰布统草原，都和康熙平定准噶尔叛乱的历史故事相关，这位大将军也是主角之一，似乎是康熙皇帝的舅舅还是啥。\n\n之后，我们在午饭后还去了将军泡子，感觉草原上到处都是美景，但却有雷同的感觉，拍几十个不同的 XP 桌面也确实没什么稀罕的，但只要是个水洼就立刻让景色变得不同了，将军泡子就是这么一个景点。午饭的时候我们打听将军泡子，店家也打趣说他也不知道为什么大家都去那个小水坑。\n\n不过我们饭后还是出发驶向将军泡子，路上路过了我们此行的第一个敖包——百草敖包，我们短暂停留之后就开到了将军泡子。\n\n将军泡子实际离路有一两公里的距离，我们车停在大停车场上，周围有不少吃饭和卖东西的地方，我们徒步走向了将军泡子，这里实际可以搭乘一段马车的，我们没搭，有点后悔，这段路其实还挺远的。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15564956442/player/\" width=\"500\" height=\"500\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n将军泡子水确实不多，儿子在这里坐了一段羊车，也算是没白来，离开将军泡子之后，我们向回折，快到午饭的地方的时候，拐向另一个岔路，向北，向着克什克腾旗经棚镇方向开去。\n\n在出景区之前，我又向工作人员打听了到经棚的路程，得到肯定答复后上路了。\n\n##经棚-阿斯哈图石林：山地、草原、牛羊、岩石\n\n对于去经棚的路，我在出发前是有疑惑的——高德地图认为这根本就没路，让我绕大圈；谷歌地图认为路是存在的，但要四个小时左右，这些让我基本不太想在第二天就直接开赴经棚。不过，很多人给了不同的答案——\n\n第一天住宿的农家院老板告诉我，如果开到100，需要两个小时，如果开到140，需要一个半小时，嗯，没给我其他选项；不过在红山军马场午饭的时候，店家说，那边有盘山路，不是很好走，具体时间不确定；决定性的答案来自出景区时的工作人员，他们告诉我120公里，需要两小时，而且没有其他路，不会走错，于是，我和儿子一起出发了。\n\n路上确实有一些山路，但路很平，没什么太大难度，而且路上有些地方的风景仍然不错，只是儿子睡着了，就没再停下来看，等儿子再醒过来时，已经很快就要到经棚了。\n\n经棚类似很多小县城，G303国道穿城而过，我们没有预订酒店，根据我的一贯经验，一般情况下，在去哪或携程之类的地方看到酒店的价格，然后直接到前台问，都可以拿到同样甚至更低的价格，这次也同样没有落空。到得很早，我和儿子安顿下来，休息了一下，吃了晚饭，然后休息、准备第三天的旅程。经棚镇的酒店都有WiFi提供，我甚至还在晚上修了两个bug。\n\n第三天我们的目标是阿斯哈图石林——\n\n阿斯哈图石林离经棚镇大约有160公里，其实还是相当远的，路上过了热水之后，看到一大片向日葵，想起了奥林匹克森林公园的百亩葵花，这里虽然种类没那么多，不过也是很大一篇。\n\n之后，在黄岗梁地区，我们爬升到了海拔1800米，在高山上俯瞰山谷，还是很壮观的。过了山之后，就进入草原牧区，之前看到的草原总觉的少点什么，终于在这里看到了大片的牛羊，牛在过马路的时候，还真是急不得的。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15565314612/in/set-72157648827151031/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n阿斯哈图石林本身是克什克腾世界地质公园的一个部分，这里冰川侵蚀的花岗岩组成形状各异的石雕，不过对我其实吸引力不大，原来石林似乎是可以开车穿过的，不过现在不行了，我们要乘坐景区的班车，在大门和三个主要景区之间摆渡，高处风大，还是应该适当多穿一件衣服的。不过倒也不必租棉衣，没那么夸张。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15565328652/in/set-72157648827151031/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n因为现在阿斯哈图石林不能穿过去了，也就没法从这边开向达里诺尔了，于是，我们从阿斯哈图石林出来，原路回到经棚镇，吃饭休息，准备第四天去达里湖，并直接开向锡林浩特，因为不确定到达的时间，提前在去哪订了一间酒店，这也是我们这一行唯一一次提前预订酒店，事实证明并不成功，呵呵。\n\n##达里湖：草原大湖（以及锡林九曲、贝子庙）\n\n第四天一早，我们出发，沿G303国道一路向西，途中新的高速正在边上修，下次再来可能更好走了，不过老国道也很平，只是没有更多车道而已。\n\n我们的第一站是达里湖，这是一个真正的草原大湖，即使是在大比例尺的地图上，也能清晰地看到它，我们首先开到的是一个小博物馆，这里介绍了同样作为克什克腾世界地址公园一部分的达里湖的一些情况，我们在这里没做太多停留，转到了真正的达里湖畔。\n\n我们在达里湖公园门外停下车，乘坐园区的小车，沿着湖边，一直到达里面码头的位置，毫无疑问，我们选择了坐船去湖中央转一圈，湖真很大，烟波浩渺，转了一大圈回来，我们又继续乘坐小车到达观鸟长廊，用这里提供的望远镜看到很多小鸟啥的。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15378993250/player/\" width=\"500\" height=\"333\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n从达里湖出来，时间其实还挺早，我们决定继续驶向锡林郭勒，去找大草原。\n\n按照计划，在到达锡林浩特之前会先到白音锡勒草原，这里是锡林浩特草原的精华部分之一，有跑马场等地方可以一去。实际情况让我们比较失望，跑马场是跑赛马的，不适合儿子这么小的小朋友，我们又试着找了一下这附近的几个景点，都无功而返，于是我们直接开向锡林浩特了。\n\n在锡林浩特，我们找到入住的酒店之后发现时间尚早，于是就出发寻找传说中的锡林九曲去了。这个方向实际也就是G207国道——我们回家的方向，当我们找到锡林九曲的时候略有失望，这里实际上是一个餐饮中心——话说可能锡林浩特所有的景点都是餐饮中心，但是景点之外的草原也随处是风景。\n\n锡林九曲餐饮中心旁边，我们看到了一小片湖水，据说应该是锡林河和水库，不过和我们刚刚路过的达里湖当然完全不能比了，这里有一个敖包，湖对面还有一些牛羊，拍出照片来还是挺好看的，不过和达里湖真的没法比。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15378658058/player/\" width=\"500\" height=\"333\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n从锡林九曲出来，我们一路回到锡林浩特的酒店，这里离贝子庙已很近，不过有点晚，贝子庙已经关门了，我们爬到上面看了一串大敖包，拍了照片，在广场上玩了一会儿，然后回到酒店休息。\n\n##乌珠穆沁、蒙古汗城：深入草原\n\n第五天，我们的目的是——看锡林郭勒大草原，晚上入住蒙古包。我们选择的路线是从锡林浩特出发，沿省道前往西乌珠穆沁旗和蒙古汗城，然后原路回到锡林浩特，并在合适的位置找一个蒙古包入住，完成内蒙古的完整体验。\n\n我们当天出发发现当地人很少买早点啊，在锡林浩特转了一圈才在肯德基吃了本次旅行最舒服的一次早餐，之后就上路大草原了。我们先在锡林浩特附近，按照酒店老板的指引到了毛登的一个有动物啥的的园子，不过我和儿子都对这里面没啥兴趣，感觉还是个卖餐饮娱乐服务为主的比较坑的地方。\n\n我们回到路上继续向蒙古汗城进发，一路上草原很漂亮，天空阴沉沉的，云很低，时不时还下场雨，路上看到有车停下来拍天上，我们也停下一看，还真看到了天空正上方的彩虹！\n\n长途跋涉，绕过西乌珠穆沁旗的县城之后，我们到达了蒙古汗城，至此我们得到了一个惊人的发现——锡林浩特所有的旅游景点其实都是餐饮娱乐中心，蒙古汗城也是。虽然如此，我们还是在这里骑到了骆驼，儿子很开心，只是没有适合我们两个人吃的东西。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15379183690/in/photostream/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n##蒙古包、返程：告别草原\n\n在蒙古汗城转了一圈之后，我们向回回到县城吃了饭——事实证明儿子在这里吃的东西足够让我们后悔……\n\n我们在开到锡林浩特之前加满了油，这些油会在第六天带我们回家。天下起了雨，我们沿着G207国道向南开，虽然不知道哪里有蒙古包，但我们坚信可以找到。\n\n很快我们就找到了方法，当在路边看到牧民的家的牌子的时候，我们就在路边停下车，按上面的电话打过去，问有没有蒙古包住。这个方法很灵验，第二个电话就找到住的地方了。当天不是周末，蒙古包都很少有游客住，第一家牧民都没在蒙古包，第二家也只有我们一家人。因为这些牧民都是随机找的，我对安全性啥的心里也没有谱，在到达之后就把我们的座标发给我老婆了，呵呵。\n\n这家牧民有500头羊，我们看见的都是些小羊以及带小羊的母羊，非常意外的是，羊们很好奇，不仅主动靠近儿子，而且还围住我们的车。\n\n\u003ciframe src=\"https://www.flickr.com/photos/gnawux/15565645612/in/photostream/player/\" width=\"500\" height=\"333\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\n\n当天的晚饭，我点了内蒙特色手把肉，不过，儿子因为疲劳+中午吃的饭消化不是很好+在牧民的草场里闻到不少牛粪味儿，这三者的作用，在手把肉入口之前就吐了出来，手把肉基本上原封不动的带回了北京。\n\n虽然蒙古包很新奇，不过儿子不舒服，还有一点发烧，我给他冷敷了一宿，第二天（第六天）一早就上路开始返程。\n\n返程路程十分顺利，走S27锡张-SXX张石-G7京新-G6京藏，全程高速，其中锡张高速最后一段是8月13日才通车的，我们是10日出发，15日返程，刚好赶上通车，非常幸运。路上还是有很多漂亮的草原和一些景点，不过，我和儿子已经对草原审美疲劳了，都没有心情停车欣赏了。\n\n因为担心儿子不舒服，路上只在刚进入河北的察北服务区上了一趟厕所，连开了七个多小时直接到家，不过儿子好像只是疲劳，在路上睡了两觉之后就全好了，算是万幸。\n\n##后记\n\n流水帐终于完成了，儿子因为查出来对某些杂草有六级的过敏，估计以后都不会去草原玩了，这次草原看到吐也算是值了吧。一点想法是——\n\n还是有点准备更好，但准备也不需要过多，说走就走，随走随玩也挺好；\n\n围场挺好的，除了路不好走，围场比大草原更有味道；\n\n大草原也挺好看的，走到哪觉得好看就下来看看，景点其实无所谓了\n\n路越来越好走，如果走张家口这个方向到锡林浩特，其实已经是全程高速了\n\n就这些，供大家参考，祝大家玩得开心。\n\n\n","cover":"","link":"life/2014/10/18/travel-in-aug/index.html","preview":"\u003cp\u003e木兰围场、克什克腾、锡林郭勒自驾游\u003c/p\u003e\n","title":"一次说走就走的旅行"},{"content":"\n\n多年以来，看了这么多有意思的行车记录仪拍的视频，以及这么多的碰磁事件，一直对记录仪很心痒，琢磨着买一个，这次调研之后，郑重动手了。\n\n促使我动手的一个重要因素是，我发现了一件好玩事情——从保险盒取电，而不是用点烟器供电，走暗线到记录仪。这样的好处在于——点烟器还是很常用的，空出来可以给导航和其他东西用，而且暗线也避免了视觉上的干扰。\n\n取电的要点是用一个专用的取电器，相当于从一个保险的正极取出12V直流电，过一个新加的保险丝，过调压器调到5V的USB供电，输出到记录仪，回来的负极接到靠近保险盒位置的一个金属点上，嗯，学电子一般都知道，直流设备里，接地和接机壳一般是同一件事情，所以这个没什么问题，这里是不能并回到取电的保险丝负极的，否则那个保险丝的意义就没有了。取电部分的效果如图\n\n\u003cimg src=\"/assets/2014-10-13_15.54.44.jpg\" width=\"80%\" /\u003e\n\n这里的主要技术难度是中间的接头部分上烙铁了，用焊锡接了一段线。之后就是打开A柱的护板，把线从里面走上去，沿玻璃顶部走线，线要塞进内饰里，不过因为有降压电路的小盒，没有完全塞进去，不过也没什么妨碍，连接行车记录仪部分的效果如下图。这里还多留了一个USB母口，觉得万一可能有什么用，其实实际上没什么用……\n\n\u003cimg src=\"/assets/2014-10-13_15.58.23.jpg\" width=\"80%\" /\u003e\n\n就这样，还是很简单的。取电器、保险丝和降压线都可以在万能的淘宝买到，这里就不做广告了。\n","cover":"","link":"life/2014/10/18/car-recorder/index.html","preview":"\u003cp\u003e保险盒取电给行车记录仪供电\u003c/p\u003e\n","title":"第一次对汽车进行DIY"},{"content":"\n\u003cblockquote\u003e\n\n\u003cp class=\"p1\"\u003e转自微博：IT土豪刘老师问我，你有没有一种感觉，就是其他人活的比你轻松幸福一些。我说嗯，常有，这一定是错觉对吧。他说，哦，那倒不是，应该都是真的。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp class=\"p3\"\u003e我也时常这么感慨啊，可是感慨归感慨，自己还是要过自己的生活。\u003c/p\u003e\n\n\u003cp class=\"p3\"\u003e这两天在打包，准备搬家，为了陪伴孩子上小学，搬去小学附近租房，这一去不知何时还能搬回到这里、会不会再搬回到这里，但可以确定的一点是，即使能回来，到那一天，这里也必然不似今天这般模样了。\u003c/p\u003e\n\n\u003cp class=\"p3\"\u003e这个家承载着我们不多的6年多的时光，但它又那么难以释怀，它陪伴斯屹从十月怀胎一直到准小学生，又陪着斯诺走过人生最初半年；这个家陪伴我们跨过30岁，从新婚夫妻到为人父母，从初涉职场到为人前辈，人生中，可以堪称黄金年华的6年又能有几个呢。\u003c/p\u003e\n\n\u003cp class=\"p3\"\u003e还记得，刚刚搬到这里的时候，我们给还没出生的斯屹买了一张童床，我拍了给小床组名叫“虚位以待”的照片，向周围的人宣告了斯屹即将到来，小床又重新装饰漂亮，传给了斯诺，伴她度过了最初的几个月。我们不会再带走这张小床了，将来斯诺能否记得这张小床和这个家呢。\u003c/p\u003e\n\n\u003cp class=\"p3\"\u003e还记得，5年前的结婚纪念日，就在这个家里，我悄悄为爱人送上了99朵玫瑰，因为是清早敲开鲜花市场的门买到的新鲜玫瑰，回来像择菜一般，一点点修剪满是刺的99朵玫瑰，之后两个人傻傻地、开心地和一桶红玫瑰合影。玫瑰早已谢了，我们也将要离开这里了，芬芳却不会离我们而去。\u003c/p\u003e\n\n\u003cp class=\"p3\"\u003e还记得，3年多前，斯屹3岁的时候也从奶奶家搬回这里，和我们重新住在一起，开始上幼儿园，为了能和爸爸妈妈在一起，他从一开始就很坚强地忍住不哭，一直成长到后来的飞一样地骑着红色自行车，在楼后运动场上飞驰的少年，这里还有他幼儿园的小伙伴们，斯屹一定不会忘记这里的，这里有他最无忧无虑的童年。\u003c/p\u003e\n\n\u003cp class=\"p3\"\u003e当然也还记得去年圣诞节前，刚刚出生的宝贝诺诺从医院回到家，我和斯屹妆点上最最漂亮的圣诞树，温馨幸福的一家三口变成了温馨幸福的一家四口，诺诺虽然还不会说话，但七个月来，诺诺与这个家不曾分开，诺诺的小车也跑遍了楼前楼后，这次我们当然也会带着诺诺一起走，小诺诺将来一定记不起这个家了，但爸爸妈妈和哥哥的爱，会如这里的温馨一直陪着她长大，或许将来有一天她还会回到这里。\u003c/p\u003e\n\n\u003cp class=\"p3\"\u003e离开真是件让人忧伤的事情，总有点不知前路在何方的感觉，可我们又不能停下，只希望我们一家继续相亲相爱，希望我们的生活也能越来越舒适幸福，希望孩子们健康快乐。\u003c/p\u003e\n\n\u003cp class=\"p3\"\u003e上面提到的几张照片的链接：\u003ca title=\"相册：蓟门桥家\" href=\"https://www.flickr.com/photos/gnawux/sets/72157645584252908/\"\u003ehttps://www.flickr.com/photos/gnawux/sets/72157645584252908/\u003c/a\u003e 相对于他爷爷奶奶的“天通苑家”，儿子总把这里叫“蓟门桥家”，相册就也叫这个名字了。\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp class=\"p2\"\u003e后记，上次丢了自行车，写了篇博客，后来读者纪阳老师居然送了我一辆自行车，自行车如今仍在，昨天我打包的时候竟然还找到了买车的凭证，在此谢谢纪阳老师啊；这次搬家，半夜coding了一阵之后乎有所感，又写了一篇，就不期待有人送房子了，还是自己努力工作吧，哈哈。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n","cover":"","link":"life/2014/07/29/搬家/index.html","preview":"","title":"搬家"},{"content":"\n\u003cp\u003eBetterBatteryStats 和 XPrivacy，一个对电池，一个对隐私，都是瞄着别的应用的应用，总体感觉比较值得买。其实我买过很多移动应用 iOS 和 Android 平台都有，算起来可能有两千块钱了，总的讲，Android 平台真正值得买的好用的应用并不是很多，而且有不少买了之后就不再装了…… 不过这两款我还是要推荐一下。\u003c/p\u003e\n\n\u003ch2\u003eBetterBatteryStats\u003c/h2\u003e\n\n\u003cp\u003ePlay Store 链接：https://play.google.com/store/apps/details?id=com.asksven.betterbatterystats ，这个应用可以统计手机睡眠相关的情况，帮你发现省点的方法。\u003c/p\u003e\n\n\u003cp\u003e首先说我的一个观点——手机是用来拿在手里玩的，不是用来省电的，如果你什么应用都不用，什么功能都不开，屏幕亮度还调到最低，那么，为啥花四五千块钱买个手机呢，去买个我老婆他们公司（最近改叫微软移动的那家）生产的两百块钱的手机好了。不过，手机虽然是用来玩的，可也只是有电的时候才能玩，所以省电也是需要的，BBS这款应用，可以帮你确定什么应用阻碍了手机进入睡眠，确定是ROM的问题还是应用的问题，进一步解决。\u003c/p\u003e\n\n\u003cp\u003e比如说这个——\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/7WoURGDUMlNF5YVMGXLVNRZIn8B7fc.png\" alt=\"\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看到，一半的 PartialWakeLock 都来自淘宝无线，相比之下，微信就很少影响到手机的睡眠了，而且我得说，我在这段时间里，动不动就看看微信，可是从来没打开过淘宝，所以，这个结果就是——我卸掉了淘宝，之前还卸掉了奇艺。\u003c/p\u003e\n\n\u003cp\u003e当然，这些问题只是当时有，不一定现在的版本还有，本着授之以渔的精神，我把应用介绍给大家，大家自己看吧。\u003c/p\u003e\n\n\u003ch2\u003eXPrivacy Pro\u003c/h2\u003e\n\n\u003cp\u003eXPrivacy 是 Xposed 框架下的应用，不在 play store 里买的，网站在这里 http://www.xprivacy.eu/ ，这个程序是开源的，可以在 GitHub 上得到源代码，付费也就是捐款，捐款得到 license 放到主存里就可以了。与之类似，CM 的 PrivacyGuard 也是用来限制应用权限的，不过 XPrivacy Pro 感觉功能更丰富一些，包括可以导出导入、可以看详细的权限使用记录，有模板，支持各个API的管理，非常丰富。\u003c/p\u003e\n\n\u003cp\u003e隐私这东西，看不见摸不着，而且保护隐私和便利性常常是冲突的，比如，有好几个应用可以拦截短信读取验证码，省去了看-背-输 这个过程，这本来是好好的，但我偏偏不喜欢。因为我不想授权给应用来读我的短信（虽然我的短信差不多全是机器自动发来的）。当然，这个见仁见智了，说得通，只是看你信不信、乐意不乐意了，但我们希望把决定权握在自己手里，而不只是装或不装。\u003c/p\u003e\n\n\u003cp\u003eAndroid 相比于 iOS 系统对每个应用的每个权限的授权功能是非常不足的，XPrivacy 就在这方面可以为用户提供更好的保护。我的用法是——对于要用的应用，开放必须开放的和我认为可以开放的权限，对于可用可不用的应用，如果有莫名其妙的权限要求，那就卸掉。这里也有个例子，就是今天在微博上吵的——\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/d3TFwG7qumQ2FpcmAyeQw5WMd2qdf9.png\" alt=\"\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e支付宝（和其他阿里的无线应用，诸如淘宝、虾米）就这样，即使你没打开它，它也在后台读你的剪贴板。其实读设备ID的请求，差不多所有应用都有，这个用于应用统计也不违反政策，如果咱不喜欢，关掉就是了，可是读剪贴板是为什么呢？Pocket 会在打开的时候读，刚好可以帮你收藏拷进来的链接，这个可以理解，但在后台运行的支付宝和虾米服务就比较难理解了，完全不知所云。\u003c/p\u003e\n\n\u003ch2\u003e额外的废话\u003c/h2\u003e\n\n\u003cp\u003e作为混迹技术圈这么多年的人，我和阿里很多人都是关系远近不同的朋友，其中很多都是比我强很多的大牛，我和阿里，特别是淘宝、支付宝没有任何恩怨，我贴他们是因为我用着他们，没装的应用谁会注意到呢。\u003c/p\u003e\n\n\u003cp\u003e有人说他们可能是在做好事，在帮助我或其他小白，嗯，可能是，我没看代码不知道你们在做什么，但一者，建议你们公开解释下这是在干什么，最好在 play store 的应用介绍里直接说出来为什么用这个权限，很多应用都这么做了；二者，希望你们给用户选择的权利，不是所有用户都喜欢你们这样的行为的，毕竟我们知道国内偷取用户隐私的下三滥应用很多，希望你们作为大公司出来的应用，能多点节操。\u003c/p\u003e\n\n\u003cp\u003e有人说爱用不用，XXX还也读剪贴板呢，对，就是这个道理，在便利和其他方面权衡是我自己做的，但我觉得你们这方面做得不好，拿出来吐槽有什么不行呢，反正在我用的应用里，在后台乱读剪贴板的就你阿里一家。\u003c/p\u003e\n\n\u003cp\u003e最后，我想很贱地问一句，你们阿里无线996工作了这么长时间，Android应用就做成这样（包括电池那段和剪贴板这段），你们觉得你们对得起你们加班的时间么？\u003c/p\u003e\n","cover":"","link":"life/2014/06/22/推荐两款值得买的-android-应用/index.html","preview":"","title":"推荐两款值得买的 Android 应用"},{"content":"\n\u003cp\u003e最近在玩 scala，用到了 spray 来处理 Http，看了一下代码觉得很神奇，这里抄一段 spray 1.3 中的协议处理 pipeline 的实现，原始文件在 spray 中的 spray-io/src/main/scala/spray/io/Pipelines.scala\u003c/p\u003e\n\n\u003cp\u003e在 spray-io 中，网络协议可以拆分成多级流水线来处理，从网络到应用逐级升高，在前一级中处理低级事务，屏蔽掉一些底层机制，把高层决断交给后一级处理；而从应用到网络逐级降低，在前一级接受处理高层命令，分解成低级命令，交给后一级执行。spray-io框架规定了每层的接口，并帮助实现了拼接，而不同协议就负责实现自己的每级流水线。\u003c/p\u003e\n\n\u003cp\u003e比如 Spray-can 的 Http 协议栈处理中，就通过很多级的拼接来实现了一个协议栈：\u003c/p\u003e\n\n\u003cpre class=\"brush: scala; gutter: true\"\u003e    ServerFrontend(settings) \u0026gt;\u0026gt;\n      RequestChunkAggregation(requestChunkAggregationLimit) ? (requestChunkAggregationLimit \u0026gt; 0) \u0026gt;\u0026gt;\n      PipeliningLimiter(pipeliningLimit) ? (pipeliningLimit \u0026gt; 0) \u0026gt;\u0026gt;\n      StatsSupport(statsHolder.get) ? statsSupport \u0026gt;\u0026gt;\n      RemoteAddressHeaderSupport ? remoteAddressHeader \u0026gt;\u0026gt;\n      SSLSessionInfoSupport ? parserSettings.sslSessionInfoHeader \u0026gt;\u0026gt;\n      RequestParsing(settings) \u0026gt;\u0026gt;\n      ResponseRendering(settings) \u0026gt;\u0026gt;\n      ConnectionTimeouts(idleTimeout) ? (reapingCycle.isFinite \u0026amp;\u0026amp; idleTimeout.isFinite) \u0026gt;\u0026gt;\n      PreventHalfClosedConnections(sslEncryption) \u0026gt;\u0026gt;\n      SslTlsSupport(maxEncryptionChunkSize, parserSettings.sslSessionInfoHeader) ? sslEncryption \u0026gt;\u0026gt;\n      TickGenerator(reapingCycle) ? (reapingCycle.isFinite \u0026amp;\u0026amp; (idleTimeout.isFinite || requestTimeout.isFinite)) \u0026gt;\u0026gt;\n      BackPressureHandling(backpressureSettings.get.noAckRate, backpressureSettings.get.readingLowWatermark) ? autoBackPressureEnabled\u003c/pre\u003e\n\n\u003cp\u003e这其中每一行都是一级流水线，\u0026gt;\u0026gt; 就是流水线拼接的方法，它们实现了这样一对流水线：\u003c/p\u003e\n\n\u003cpre class=\"brush: scala; gutter: true\"\u003e  /**\n   * The HttpServerConnection pipeline setup:\n   *\n   * |------------------------------------------------------------------------------------------\n   * | ServerFrontend: converts HttpMessagePart, Closed and SendCompleted events to\n   * |                 MessageHandlerDispatch.DispatchCommand,\n   * |                 generates HttpResponsePartRenderingContext\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | HttpMessagePart                     | HttpResponsePartRenderingContext\n   *    | IOServer.Closed                     | IOServer.Tell\n   *    | IOServer.SentOK                     |\n   *    | TickGenerator.Tick                  |\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | RequestChunkAggregation: listens to HttpMessagePart events, generates HttpRequest events\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | HttpMessagePart                     | HttpResponsePartRenderingContext\n   *    | IOServer.Closed                     | IOServer.Tell\n   *    | IOServer.SentOK                     |\n   *    | TickGenerator.Tick                  |\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | PipeliningLimiter: throttles incoming requests according to the PipeliningLimit, listens\n   * |                    to HttpResponsePartRenderingContext commands and HttpRequestPart events,\n   * |                    generates StopReading and ResumeReading commands\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | HttpMessagePart                     | HttpResponsePartRenderingContext\n   *    | IOServer.Closed                     | IOServer.Tell\n   *    | IOServer.SentOK                     | IOServer.StopReading\n   *    | TickGenerator.Tick                  | IOServer.ResumeReading\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | StatsSupport: listens to most commands and events to collect statistics\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | HttpMessagePart                     | HttpResponsePartRenderingContext\n   *    | IOServer.Closed                     | IOServer.Tell\n   *    | IOServer.SentOK                     | IOServer.StopReading\n   *    | TickGenerator.Tick                  | IOServer.ResumeReading\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | RemoteAddressHeaderSupport: add `Remote-Address` headers to incoming requests\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | HttpMessagePart                     | HttpResponsePartRenderingContext\n   *    | IOServer.Closed                     | IOServer.Tell\n   *    | IOServer.SentOK                     | IOServer.StopReading\n   *    | TickGenerator.Tick                  | IOServer.ResumeReading\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | SSLSessionInfoSupport: add `SSL-Session-Info` header to incoming requests\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | HttpMessagePart                     | HttpResponsePartRenderingContext\n   *    | IOServer.Closed                     | IOServer.Tell\n   *    | IOServer.SentOK                     | IOServer.StopReading\n   *    | TickGenerator.Tick                  | IOServer.ResumeReading\n   *    | SslTlsSupport.SSLSessionEstablished |\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | RequestParsing: converts Received events to HttpMessagePart,\n   * |                 generates HttpResponsePartRenderingContext (in case of errors)\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | IOServer.Closed                     | HttpResponsePartRenderingContext\n   *    | IOServer.SentOK                     | IOServer.Tell\n   *    | IOServer.Received                   | IOServer.StopReading\n   *    | TickGenerator.Tick                  | IOServer.ResumeReading\n   *    | SslTlsSupport.SSLSessionEstablished |\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | ResponseRendering: converts HttpResponsePartRenderingContext\n   * |                    to Send and Close commands\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | IOServer.Closed                     | IOServer.Send\n   *    | IOServer.SentOK                     | IOServer.Close\n   *    | IOServer.Received                   | IOServer.Tell\n   *    | TickGenerator.Tick                  | IOServer.StopReading\n   *    | SslTlsSupport.SSLSessionEstablished | IOServer.ResumeReading\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | ConnectionTimeouts: listens to Received events and Send commands and\n   * |                     TickGenerator.Tick, generates Close commands\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | IOServer.Closed                     | IOServer.Send\n   *    | IOServer.SentOK                     | IOServer.Close\n   *    | IOServer.Received                   | IOServer.Tell\n   *    | TickGenerator.Tick                  | IOServer.StopReading\n   *    | SslTlsSupport.SSLSessionEstablished | IOServer.ResumeReading\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | SslTlsSupport: listens to event Send and Close commands and Received events,\n   * |                provides transparent encryption/decryption in both directions\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | IOServer.Closed                     | IOServer.Send\n   *    | IOServer.SentOK                     | IOServer.Close\n   *    | IOServer.Received                   | IOServer.Tell\n   *    | TickGenerator.Tick                  | IOServer.StopReading\n   *    |                                     | IOServer.ResumeReading\n   *    |                                    \\/\n   * |------------------------------------------------------------------------------------------\n   * | TickGenerator: listens to Closed events,\n   * |                dispatches TickGenerator.Tick events to the head of the event PL\n   * |------------------------------------------------------------------------------------------\n   *    /\\                                    |\n   *    | IOServer.Closed                     | IOServer.Send\n   *    | IOServer.SentOK                     | IOServer.Close\n   *    | IOServer.Received                   | IOServer.Tell\n   *    | TickGenerator.Tick                  | IOServer.StopReading\n   *    |                                     | IOServer.ResumeReading\n   *    |                                    \\/\n   */\n\n\n\u003c/pre\u003e\n\n\u003cp\u003e流水线本身的实现非常简单，\u0026gt;\u0026gt; 操作符只有17行代码，整个 trait 也只有 26 行\u003c/p\u003e\n\n\u003cpre class=\"brush: scala; gutter: true\"\u003etrait RawPipelineStage[-C \u0026lt;: PipelineContext] { left =\u0026gt; \n  type CPL = Pipeline[Command] // alias for brevity \n  type EPL = Pipeline[Event] // alias for brevity \n \n  def apply(context: C, commandPL: CPL, eventPL: EPL): Pipelines \n \n  def \u0026gt;\u0026gt;[R \u0026lt;: C](right: RawPipelineStage[R]): RawPipelineStage[R] = \n    if (right eq EmptyPipelineStage) this \n    else new RawPipelineStage[R] { \n      def apply(ctx: R, cpl: CPL, epl: EPL) = { \n        var cplProxy: CPL = Pipeline.Uninitialized \n        var eplProxy: EPL = Pipeline.Uninitialized \n        val cplProxyPoint: CPL = cplProxy(_) \n        val eplProxyPoint: EPL = eplProxy(_) \n        val leftPL = left(ctx, cplProxyPoint, epl) \n        val rightPL = right(ctx, cpl, eplProxyPoint) \n        cplProxy = rightPL.commandPipeline \n        eplProxy = leftPL.eventPipeline \n        Pipelines( \n          commandPL = (if (leftPL.commandPipeline eq cplProxyPoint) rightPL else leftPL).commandPipeline, \n          eventPL = (if (rightPL.eventPipeline eq eplProxyPoint) leftPL else rightPL).eventPipeline) \n      } \n    } \n \n  def ?(condition: Boolean): RawPipelineStage[C] = macro RawPipelineStage.enabled[C] \n}\n\n\u003c/pre\u003e\n\n\u003cp\u003e这里解释一下这个拼接的实现：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003cspan lang=\"en-US\"\u003eRawPipeline\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003eStage\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e自己是\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e left（左级），被拼接的是right（右级），拼接的结果仍然是 RawPipeline，可以拼接下一级\u003c/span\u003e\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp style=\"margin: 0in; font-size: 11.0pt;\"\u003e\u003cspan lang=\"en-US\" style=\"font-family: Calibri;\"\u003e\u003cspan lang=\"en-US\"\u003eRawPipelineStage 有 \u003c/span\u003eapply\u003c/span\u003e\u003cspan lang=\"zh-CN\" style=\"font-family: \u0026lt;br /\u0026gt;SimSun;\"\u003e方法，这个方法应该带有参数\u003c/span\u003e\u003cspan lang=\"en-US\" style=\"font-family: Calibri;\"\u003e(Context,CPL, EPL)\u003c/span\u003e\u003cspan lang=\"zh-CN\" style=\"font-family: SimSun;\"\u003e，返回\u003c/span\u003e\u003cspan lang=\"en-US\" style=\"font-family: Calibri;\"\u003e Pipelines，Pipelines 就是两条流水线，Command Pipeline (CPL) 是下行的命令处理，Event Pipeline (EPL) 是上行的事件处理，每个实际都是一个 Command 或 Event 处理的方法(Command =\u0026gt; Unit 或 Event =\u0026gt; Unit)\u003c/span\u003e\u003c!--EndFragment--\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e在拼接时，\n\n\u003cul\u003e\n\n\u003cli\u003e如果右侧是空的，那么拼接的结果就是自己\u003c/li\u003e\n\n\u003cli\u003e如果右侧不是空的，那么拼接的结果是一个RawPipelineStage，大意是：\n\n\u003cul\u003e\n\n\u003cli\u003e\u003cspan lang=\"zh-CN\"\u003e构造一个新的\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003eRawPipeline\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e的\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003eapply\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e方法，参数为\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e ctx, cpl, epl\u003c/span\u003e\u003c/li\u003e\n\n\u003cli\u003e如果左级不改变 cmd pipeline 的话，就调用右级的 cpl，否则用左级的cpl，但把右级的 cpl 当参数传给左级；对 cmd 来说，右级是左级的下一级，左级处理过交给右级\u003c/li\u003e\n\n\u003cli\u003e如果右级不改变 event pipeline 的话，就用左级的 epl，否则用右级的 epl，但把左级的 epl当作参数传给右级；对event来说，左级是右级的下一级，右级处理过交给左级\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e以一个方向为例：\n\n\u003cul\u003e\n\n\u003cli\u003e首先初始化 cplProxy 是一个处理 Command 的 Pipeline\u003c/li\u003e\n\n\u003cli\u003eval cplProxyPoint 是调用 cplProxy 的调用方法\u003c/li\u003e\n\n\u003cli\u003eleftPL 调用了左级的 apply，生成一个 Pipelines，而在生成的过程中，CPL 参数传入的就是 cplProxyPoint，也就是会调用 cplProxy\u003c/li\u003e\n\n\u003cli\u003e定 cpl 为 rightPL 的 command pipeline，也就是说，leftPL 的 cpl 可以使用 rightPL 的 cpl\u003c/li\u003e\n\n\u003cli\u003e最后，如果 leftPL 的 cpl 就是 rightPL 的 cpl 的话，也就是说，左级对 command 处理没有任何附加操作，那么就直接使用右级的 command 处理，反之，就使用左级的处理，但是左级可以利用作为参数传进来的右级的command 处理\u003c/li\u003e\n\n\u003cli\u003eevent 处理与此对称\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e\u003cspan lang=\"zh-CN\"\u003e最终调用\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e RawPipelineState \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e的\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e apply \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e的方法是\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e spray-io \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e的\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003eConnectionHandler\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e.running \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e方法，送进来的是\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e baseCommandPipeline \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e和\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e baseEventPipeline\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e，分别作为两者的最后一级\u003c/span\u003e\u003c/p\u003e\n\n\u003cul type=\"disc\"\u003e\n\n\u003cli\u003e\u003cspan lang=\"en-US\"\u003ebaseCommandPipeline \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e送给最右级作为下一级\u003c/span\u003e\n\n\u003cul type=\"circle\"\u003e\n\n\u003cli\u003e\u003cspan lang=\"en-US\"\u003eTcpWriteCommand\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e和\u003c/span\u003e\u003cspan lang=\"en-US\"\u003eTcpCloseCommand \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e送给\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003econnection\u003c/span\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cspan lang=\"zh-CN\"\u003e(Tcp.SuspendReading | Tcp.ResumeReading | Tcp.ResumeWriting)\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003ebackpressure\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e相关的送给\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003econnection\u003c/span\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cspan lang=\"zh-CN\"\u003ePipeline.Tell(receiver, msg, sender)\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e消息，为\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003esender\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e把\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003emsg\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e送给\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003ereceiver\u003c/span\u003e\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\u003cspan lang=\"en-US\"\u003ebaseEventPipeline\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e送给最左级作为下一级\u003c/span\u003e\n\n\u003cul type=\"circle\"\u003e\n\n\u003cli\u003e\u003cspan lang=\"zh-CN\"\u003e处理\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e ConnectionClosed \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e消息，等待\u003c/span\u003e\u003cspan lang=\"en-US\"\u003etcpConnection Actor\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e结束来自杀\u003c/span\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cspan lang=\"zh-CN\"\u003e丢弃消息，对于\u003c/span\u003e\u003cspan lang=\"en-US\"\u003e Droppable \u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e的不\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003ewarning\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003e，否则\u003c/span\u003e\u003cspan lang=\"zh-CN\"\u003ewarning\u003c/span\u003e\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e就是这样，完成，非常简洁，有些晦涩。\u003c/p\u003e\n","cover":"","link":"coding/2014/06/04/spray-中协议处理-pipelines-的实现/index.html","preview":"","title":"Spray 中协议处理 Pipelines 的实现"},{"content":"\n\u003cblockquote\u003e自从几个月前带儿子去了一次航空博物馆之后，一直想写blog吐槽一下，不过一直没有档期，终于，今天我抽空写两句吧，有些东西或图以后慢慢补。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e之前带儿子去过环铁的铁道博物馆，展区虽然不是很大，展品也算不上特别多，而且以国产为主，但是孩子可以全方位接触机车，还是挺好玩的。可是，相比之下航空博物馆虽然展区很大，但是既没有什么知识介绍，又没有历史渊源，没有什么太多体验机会，甚至安全方面做得也很不好，一言以蔽之——别带孩子去。\u003c/p\u003e\n\n\u003ch2\u003e介绍缺失 + 谬误\u003c/h2\u003e\n\n\u003cp\u003e航空博物馆有露天展区和洞库展区，有庞大的歼-6机群，也有各种发动机等展品，可是几乎没有任何知识介绍，本来这都是很好的科普材料，帮孩子们认识活塞发动机和涡轮喷气发动机的构造，了解飞机的各种功能。可是，因为连个标牌都没有，就有很多家长在给孩子瞎介绍，比如——\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e有的把副油箱当炸弹\u003c/li\u003e\n\n\u003cli\u003e有的把空速管当大炮\u003c/li\u003e\n\n\u003cli\u003e有的把进气道当大炮\u003c/li\u003e\n\n\u003cli\u003e……\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这些孩子们可能要带着这些错误的认识好多年了，所以，如果各位不知道我上面说的都是什么东西，那最好也别带你的孩子去航空博物馆了。\u003c/p\u003e\n\n\u003cp\u003e这些只是不作为，还有些更离谱的，洞库里有一段科幻小视频，说的是未来某年的先进制造和设计方法，嗯，幻想这东西可以跑点火车哈，可是，你设计个扑翼机还要飞入外太空是闹哪样啊，在真空里扇翅膀真的能飞动么?!\u003c/p\u003e\n\n\u003ch2\u003e来历不明的展品\u003c/h2\u003e\n\n\u003cp\u003e馆藏的丰富程度确实是一个博物馆的硬实力，但是，即使是不很丰富的博物馆，用心做还是可以让大家有很多收获的。可航空博物馆里，确实藏了一些外国飞机，但是，很多飞机都是无型号、无来源、无介绍的展品，不知道摆放在这里干什么\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e有一架飞机没有标型号，据我观察可能是米格-23，我国空军似乎从来没有这个机型，不知来源\u003c/li\u003e\n\n\u003cli\u003e有一家飞机没有标型号，据我观察是达索幻影的某型号，我国空军似乎从来没有这个机型，不知来源\u003c/li\u003e\n\n\u003cli\u003e有一架飞机没有标型号，据我观察是F-104，飞机上写着意大利空军赠送\u003c/li\u003e\n\n\u003cli\u003e有一架飞机没有标型号，据我观察是F-5，应该是从湾湾飞来的\u003c/li\u003e\n\n\u003cli\u003e有一架直升机，应该是米-24，不知来源\u003c/li\u003e\n\n\u003cli\u003e……\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这么多飞机都摆进来了，写个牌子，说说从哪来的，是啥很难么，如果不能说，还摆出来干啥呢？\u003c/p\u003e\n\n\u003cp\u003eupdate，插照片：\u003c/p\u003e\n\n\u003cp\u003e这个是幻影\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://www.flickr.com/photos/gnawux/14132591857/in/photostream/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n\u003cp\u003e这个是 F-104\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://www.flickr.com/photos/gnawux/14317281602/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n\u003cp\u003e这个是 F-5\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://www.flickr.com/photos/gnawux/14318431514/in/photostream/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n\u003cp\u003e这个是 米-24\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://www.flickr.com/photos/gnawux/14315727621/in/photostream/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003ch2\u003e缺乏安全保护\u003c/h2\u003e\n\n\u003cp\u003e某客机的舷梯可以走上去，我就让我儿子上去拍照了，他上去我才发现，舷梯靠飞机那边，有一侧是没有保护，如果孩子玩得太 high，是可能掉下来的，就是下面这张，右边是空的。在此提醒各位，如果你看了我的介绍，还想带着孩子去，那一定要看好了，如果想上啥，看清楚结实不结实，有没有栏杆啥的。\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"https://www.flickr.com/photos/gnawux/14339257733/in/photostream/player/\" width=\"500\" height=\"375\" frameborder=\"0\" allowfullscreen=\"allowfullscreen\"\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n\u003ch2\u003e小结\u003c/h2\u003e\n\n\u003cp\u003e嗯，图先没上，有空发一些，基本上展品乏善可陈，介绍基本没有，很多展品来历不明，维护状况也不怎么好，想想那么大片展区，转一圈累得够呛，可是收获却没啥，真的不怎么值。唯一的优点是，露天展区是免费的，只有进洞库或者进馆才要钱。总评必然是负分。\u003c/p\u003e\n\n\u003cp\u003e顺便说，参观航空博物馆那天是3月8日，看着很多客机，然后忽然听说马航客机失联，心里真不是滋味，加重了我的负面情绪……唉，飞机残骸还没找到，太可怜了……\u003c/p\u003e\n","cover":"","link":"life/2014/06/01/为什么说航空博物馆不适合给孩子做科普/index.html","preview":"","title":"为什么说航空博物馆不适合给孩子做科普"},{"content":"\n\n答案链接：https://www.zhihu.com/question/23364146/answer/24346146\n\n并非完全不可以，但是技术上还是有很大差异的\n\n首先说“移动性”，移动计算中有“移动(mobile)”和“游牧(nomadic)”的区别，移动就是你可以在移动过程中保持连接，而游牧则不然，你可以在任何一个地方连接，但是不能保持连接状态移动。如果不具备“移动”的能力，那么就不能称之为公众移动网络(PLMN)。对于我们上网来说，这个区别就是，如果你移动过程中可以保持IP地址不变，那么理论上你的所有TCP连接都可以保持连接状态，不需要重连，否则就需要重新连接，当然，这对于浏览网页来说，差异不是很大，不过如果你连SSH、VPN 等这些长连接服务的话，就很明显了。移动通信网做了很多工作，可以保持在移动中IP地址始终不变，但WLAN本身没这个功能，如果要实现这个功能的话，需要所有接入路由器具备移动IP的能力，而且有（逻辑上的）中心注册机制保证可以让终端能始终被用同一个地址找到。\n\n其次说移动网络的切换，这个其实只对电话有意义，在用户打电话的时候，用户必须可以“无缝”地从一个基站切换到另一个基站不掉话，这需要一套复杂的机制来保障。当然，IP网络没这么严格的“无缝”要求，所以即使是用3G上网，也只是小区“重选”，没有真的“切换”，这个其实不是严重问题。\n\n再其次说覆盖，移动基站的覆盖能力是公里级的，WLAN的覆盖范围是几十米级的，即使用高增益有向天线，恐怕也难以提供大范围的覆盖，如果要想做到连续覆盖，需要布设的AP数量会非常多。\n\n然后说资源和容量，无线技术归根结蒂还是拼的带宽，新制式通过更高级的信号处理算法，消耗更多的计算力，可以达到更高的频谱利用率，不过这一切还是以频带宽度为基础的。WLAN的频带宽度是10-20MHz，其实比LTE没有绝对优势，而且WLAN本身的可用频点很少，2.4G上相互间无干扰的信道就两三个，5G上略多，但我国也没几个，以这样的频谱资源去进行广域覆盖，同样只有把AP做得很密才可以有比较好的接入效果。\n\n最后说计费，WLAN天然不像电信网络，是为计费而生的，但是，无线与有线不同，有线网络，不论是ADSL还是PON光纤接入，用户到局端都是独享物理链路，互不影响，但对于共享信道的无线通信网络而言，如果直接使用不限流量的包月套餐的话，用户无节制使用带宽是很容易抢占带宽导致服务质量急剧下降的，因此必须能够精确跟踪用户的上网行为，对时间和流量进行统计，这也是普通WLAN所没有的功能。\n\n经过上面这些，基本上就把WLAN改造成了可以连续覆盖的“移动”数据网络了，不过，这个成本并不是买几个路由器就能搞定的，是个大工程。\n","cover":"","link":"zhihu/2014/04/11/wifi/index.html","preview":"\u003cp\u003e经过这些，基本上就把WLAN改造成了可以连续覆盖的“移动”数据网络了，不过，这个成本并不是买几个路由器就能搞定的，是个大工程\u003c/p\u003e\n","title":"[知乎回答] wifi信号像移动信号一样全国覆盖或像3G信号一样包覆大城市的可行性如何？"},{"content":"\n\n答案链接：https://www.zhihu.com/question/22032880/answer/20211878\n\n更新注释在最下面了\n\n---------\u003e8-------- 以下是原文的分割线 ----------\u003e8----------\n\n搜了一下，终于看到这个问题了，我来回答一下，不匿名了，这么久了，我不在乎了哈，小暴点离职过程的内幕，呵呵\n\n我07年毕业到移动研究院工作，业务支撑所，开始在业务支撑相关的组，后来去了云计算的组做 Hadoop HDFS 和 EBS，内部项目不说，从外面看，给 Hadoop 上游改过 bug （嗯，实际就是交换了两行的位置，去掉了一个丢数据风险而已，没啥大不了的），提过 patch，11年离职之前是研究院云计算相关开源和标准化工作的协调人，看起来还算不错吧。\n\n可是这四年间，08年定级之后，就一直没涨过级别，我们所涨得都挺慢，但像我这样得过14个C，没得过A、B，从不涨级的也不多见吧，研究院里，我有很多师兄、同学、师弟师妹，没一个我这么二的，我得说，我赞同匿名的那位同学说的“技术狗毫无归属感”，呵呵。\n\n后来啊，我就去找组长谈，找所长谈，组长说他给我打了B（或A，我不记得了），但是我还是没有见到，所长后来对我说“会考虑平衡老同志的”这句话之后，我就开始严肃地找工作了，我需要的是对我工作成果的肯定，或者是不足的批评，我不是混日子的，为啥要平衡呢，既然自己在这里无法发挥自己的价值，索性走了算了。我承认我小心眼，领导这样的话本无恶意，只是触发了我当时敏感的神经而已。\n\n在离职之前还有一组谈话，以谈理想谈人生为主，让我非常诧异的是，我的组长还记得我刚到云计算这个组的时候，通过查找问题，调整参数，重编译内核，让测试环境的性能提升十倍的事（实际是发现个错误，让性能回归正常而已），我没问出来的一句话是，那为啥我的绩效还是C呢，而且连得14个？\n\n倒是最后，Bill 的谈话更让我受宠若惊，当时HR老大是这么跟我说的，“Bill 看到你要离职，他要亲自跟你谈谈，我们这也走过人，而且绩效啥的都不错的，Bill 都没谈，我也不知道为啥要跟你谈，不过呢，既然 Bill 要跟你谈，我就得为领导分忧，先和你谈一下……” 嗯 …… 我没啥可说的了\n\n说句实话，我真正决定离开移动研究院是两点原因：\n\n- 移动研究院里，做技术是没有前途的，你是无法单纯靠技术获得足够的上升空间的。我总结的结论是，世界上最难的事情是猜领导在想什么，更难的事情是猜领导是怎么猜他的领导在想什么。而我本人，还是热衷猜计算机们是在想什么\n- 移动在互联网领域是没有啥前途的，一贯起大早赶晚集。大云的同学们很用心了，可是一期一期地做，也很少有落地，一个二期就已经还算不错的数据挖掘/工作流工具，还是要做四五期也不见声音，oozie 啥的都开源了。\n\n呵呵，第一次离职，当时觉得刻骨铭心，记下了 [blog：一个艰难的决定](/life/2011/05/10/%E4%B8%80%E4%B8%AA%E8%89%B0%E9%9A%BE%E7%9A%84%E5%86%B3%E5%AE%9A/)，现在回想起来，仍然觉得和同事关系很好，很不舍得的样子，也不觉得移动有多么不好，只是不适合自己罢了，我觉得我的选择是对的\n\n---------\u003e8-------- 以下是更新注释的分割线 ----------\u003e8----------\n\n\u003e **20140318 update:**\n\u003e\n\u003e 有前同事告诉我这个被转载到别处了，嗯，我实名回答了这个问题表示我认为我说的是我真实的看法，如果有人非要把这种个人看法转载，请注明是谁说的，出处是哪里，尊重作者，也方便别人知道上下文，我不想对什么人造成正面或负面的结果，文责自负，谢谢。\n\n\u003e **20140430 update:**\n\u003e\n\u003e 居然有很多人去我死慢死慢的Blog去看了，甚至去留言了，十分感动，并对死慢死慢的Blog给大家带来的困扰表示歉意。\n\u003e\n\u003e 关于我的近况，这里是我的个人空间，我不想在这里做公司的PR，只说一句——我不仅不后悔，而且不需要后悔，因为我很充实也很快乐，工作和家庭平衡得不错，单从收入看，也比在移动时强不少。\n\u003e\n\u003e 对于向往移动的同学们，你们根据你们自己的情况来决定，想做什么、能做什么、该做什么，这对每一个出身、资质、际遇不同的人都是不同的，我在这里说的是我为什么从中移动离职，这或许对你并无正面参考价值。\n\u003e\n\u003e 顺便对那些鄙视我当年去盛大云的前领导说，在盛大云我的产出对得起我的薪水，我的收获对得起我的时间，而当我离开盛大云的时候，我的职业生涯也没有因此蒙上阴影，我的近况如我所说让我满意，即使当时去盛大云不是最佳选择，但离开移动绝对是个正确决定，而且只迟不早。\n\n\u003e **20150324 update:** 更新 blog 链接\n","cover":"","link":"zhihu/2014/03/18/cmcc/index.html","preview":"\u003cp\u003e我实名回答了这个问题表示我认为我说的是我真实的看法，如果有人非要把这种个人看法转载，请注明是谁说的，出处是哪里，尊重作者，也方便别人知道上下文，我不想对什么人造成正面或负面的结果，文责自负，谢谢\u003c/p\u003e\n","title":"[知乎回答] 你为什么从中国移动离职？"},{"content":"\n\u003ch2\u003e从IaaS到PaaS\u003c/h2\u003e\n\n\u003cp\u003e我这里不是说PaaS要取代IaaS，而是说，IaaS和PaaS两点之间已经连成一条渐变的线了，两者不再是泾渭分明的了，中间遍布了很多介于两者之间的服务，这之间的很多创新点都在过去一段时间里逐步成熟了。\u003c/p\u003e\n\n\u003cp\u003eIaaS与PaaS的差距在哪里，其中一个视角是他们所面向用户的不同——\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003ePaaS 所面向的用户是开发人员，他们设计架构、写代码、有时候做集成测试和 Code Review，然后就发布代码，让用户使用了，也就是说，PaaS把代码变成产品（网站、服务或是什么其他的东西）\u003c/li\u003e\n\n\u003cli\u003eIaaS 所面向的用户则是运维人员，他们根据架构师或开发人员的要求构建基础设施，部署和配置软件系统和各种基础服务，部署和升级开发人员完成的代码，监控并处理故障，根据负载调整系统规模等\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e当然，各位可能已经看到，这里IaaS上运维人员的很多职责实际已经有服务在帮助完成了，比如预先部署好的数据库服务、消息队列服务、负载均衡服务、MapReduce服务等，监控系统运行的各种监控服务以及一些自动扩展和自动故障恢复服务等。\u003c/p\u003e\n\n\u003cp\u003e现在已经没有单纯占据资源层的“纯IaaS”服务了，构建在IaaS服务基础上的各种附加服务正在解放云上的运维人员，云服务的用户可以根据自己的能力、财力和具体需求，挑选一些服务，结合自己的工作量身打造适于自己的系统。\u003c/p\u003e\n\n\u003cp\u003e这样，云服务的层次就变得更丰富一些了\u003c/p\u003e\n\n\u003cpre\u003e\n----------------------------\n           PaaS\n----------------------------\n预部署服务 | 监控管理  |\n-------------------  \u0026gt;IaaS+\n       资源服务      |\n----------------------------\n\n\u003c/pre\u003e\n\n\u003cp\u003e并且，资源服务也不再只是传统的主机+对象存储+块存储+IP地址了，再过去一段时间，云服务的引领者亚马逊AWS一直在积极推进VPC（虚拟私有云），帮助用户可以通过子网结构化地组织系统，通过网关、路由、虚拟设备和各种其他规则，更安全、更有效地使用云上资源。这些日益丰富的资源让人们可以更方便地使用云服务，降低了云上运维的很多困难，不过也让很多选择和配置变得更加复杂了。\u003c/p\u003e\n\n\u003ch2\u003eOrchestration\u003c/h2\u003e\n\n\u003cp\u003e前面我提到，PaaS 帮助用户“把Code变成产品”，又说，IaaS用户相比之下还要做部署、升级、监控、事件处理这些事情，于是，一个自然地想法是，如果“部署...事件处理”这些事情可以变成Code，那么，用户所使用的到底是PaaS 还是 IaaS 呢？\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eInfrastructure as Code\u003c/em\u003e 是 DevOps 粉丝们特别喜欢的一个概念，代码化的描述，让整个系统的部署更加严谨可控，并且可以通过版本管理来追踪发现问题、调整部署。\u003c/p\u003e\n\n\u003cp\u003e在云上，由于亚马逊等主流云服务商丰富的API支持，甚至是监控、系统级的事件处理（比如硬件故障导致宕机）这些传统的运维工作也可以通过代码进行自动化的处理，这就演化出了近两年走红的 \u003cem\u003eOrchestration\u003c/em\u003e 的概念.\u003c/p\u003e\n\n\u003cpre\u003e\n----------------------------\n           PaaS\n----------------------------\n      Orchestration\n----------------------------\n预部署服务 | 监控管理 |\n-------------------  \n          资源服务      \n----------------------------\n\n\u003c/pre\u003e\n\n\u003cp\u003e这实际是通过一些代码，把 IaaS 用得像 PaaS 服务一样。当然，这些代码不是非常容易写的，于是就有了很多帮助用户在 IaaS 的灵活和 PaaS 的易用之间进行折衷，我所在的 MadeiraCloud 也是在这一领域进行工作，通过图形化的交互界面，把复杂的集群部署和管理工作变得直观而高效。\u003c/p\u003e\n\n\u003cp\u003e当然，Orchestration 是帮用户简化不必要的劳动，通过各种附加资源和引导方法协助用户快速地进行系统设计和部署，避免因为繁琐而造成的出错，用户仍然需要相应的知识，理解他所做的选择，才能藉此灵活高效地使用云服务资源，Orchestration 并非要直接取代 PaaS。\u003c/p\u003e\n\n\u003ch2\u003eContainer \u0026amp; Docker\u003c/h2\u003e\n\n\u003cp\u003e从去年云计算大会之后，Docker 所代表的 Container 技术快速走红，以至于不论是否明白 Docker 意味着什么的人，都在茶余饭后大谈 Docker 和 CoreOS 云云。\u003c/p\u003e\n\n\u003cp\u003eContainer 技术实际历史非常悠久，而且不同的 Container 之间也有不少差别，作为 PaaS 服务商 dotCloud 开源的技术，Docker 所带来的影响，实际上更提现在运维方面，而不仅仅是在计算虚拟化的层面。\u003c/p\u003e\n\n\u003cp\u003e传统的云上部署，运维人员面临两个抉择：部署快、可重用、很少出错的自定义 Image；灵活、可以经常升级、调整的 DevOps 工具。两者各自的优点就是对方的缺点，如今，docker 的 OS Image 分层装配机制会让系统的部署工作产生这样的变化\u003c/p\u003e\n\n\u003cpre\u003e\n|     /\\         DevOps Tools   |        /\\      \u0026lt;-- DevOps Tool\n|    /  \\    \u0026lt;-- e.g. chef,     |       /--\\\n|   /    \\       puppet, salt   |==\u0026gt;   /    \\    \u0026lt;-- Docker Layers\n|  /------\\                     |     /------\\\n| /        \\ \u0026lt;-- OS Image       |    /        \\  \u0026lt;-- Base OS Image\n|/__________\\                   |   /__________\\\n\n\u003c/pre\u003e\n\n\u003cp\u003e这是因为 docker 具有如下优点：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e分层装配，比 OS Image 更灵活\u003c/li\u003e\n\n\u003cli\u003e每层更完备，recipe 会比传统 DevOps 工具短得多，更简单，更少犯错\u003c/li\u003e\n\n\u003cli\u003e可以和集成测试结合起来\u003c/li\u003e\n\n\u003cli\u003e增量分发，且装配速度比 DevOps 工具逐条执行快\u003c/li\u003e\n\n\u003cli\u003e甚至可以撤回出错的变更，这一点 DevOps 工具的传统工作方式很难做到\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e此外，分层的文件系统让不同的 container 之间可以共享更多的文件，这样，从硬盘空间到内存缓存都可以极大的降低每个 container 的开销，使得“一个应用一个Container”的目标更容易实现。\u003c/p\u003e\n\n\u003ch2\u003e小结\u003c/h2\u003e\n\n\u003cp\u003e以上是我作为一个在云计算领域淫浸了几年，对运维领域有偏爱的开发者，对于云计算的近期发展趋势的观察，仅供参考，不周或不对的地方还请谅解，不对判断和预测承担任何责任。\u003c/p\u003e\n","cover":"","link":"cloud/2014/02/17/近期云计算技术的发展与热点技术/index.html","preview":"","title":"近期云计算技术的发展与热点技术"},{"content":"\n\u003cp\u003e2013就这样，势不可挡地奔向了终点，当我们又一次将圣诞树装饰好的时候，去年的平安夜仍然历历在目，今年却换成了不一样的感动，从那时起，我便决定，要记下这份心境。今天，冬至日，竟得到难得的一个小时空闲，我想，我该放下一切，来回首这过去的一年了。\u003c/p\u003e\n\n\u003ch2\u003e\u003cb\u003e岁岁年年心不同\u003c/b\u003e\u003c/h2\u003e\n\n\u003cp\u003e去年的圣诞，妻子、儿子和我，一家人围着点亮的圣诞树，唱起了“Jingle Bells”，我和爱人不由得相拥无言，结婚这些年，算不上颠沛流离，却也经历了不少风风雨雨，一家人享受着难得的平安夜，什么都没有发生，却又那么的不寻常，怎能不让人感动呢。\u003c/p\u003e\n\n\u003cp\u003e\u003cembed src=\"http://player.youku.com/player.php/sid/XNjUxNzE1NTky/v.swf\" allowfullscreen=\"true\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"always\" type=\"application/x-shockwave-flash\"\u003e\u003c/embed\u003e\u003cp\u003e今年的圣诞节前，我们收获了一个健康的女儿，儿子也长大了，我和儿子一起采购了很多的饰品，把那颗圣诞树装饰得满满当当，彩灯再次亮起，我和儿子不由得再次唱起了“Jingle Bells”，儿子甚至还能记住那歌词，仿佛回到了去年。但就在这短短的一年里，我们居然又收获了一个女儿，我也让自己的职业生涯来了一个转弯，这都是在前一年还毫无打算的，也让我们对人生充满了敬畏。\u003c/p\u003e\n\n\u003cp\u003e\u003ciframe src=\"http://www.flickr.com/photos/gnawux/11497432434/player/\" width=\"282\" height=\"500\" frameborder=\"0\" allowfullscreen webkitallowfullscreen mozallowfullscreen oallowfullscreen msallowfullscreen\u003e\u003c/iframe\u003e\u003c/p\u003e\n\n\u003cp\u003e看着绚丽的圣诞树，今天的我所想的，是珍惜眼前的每一天，珍惜身边的每个人，珍惜内心的每一分感动，投入地享受生活的每一个瞬间，让亲人和朋友也不后悔与我分享的每一刻。\u003c/p\u003e\n\n\u003ch2\u003e\u003cb\u003e我们的女儿\u003c/b\u003e\u003c/h2\u003e\n\n\u003cp\u003e直到今天，在我的潜意识里，仍然感到\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我孩子 == 我儿子 == 我唯一的儿子\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e可是，我知道，已经不同了，当我看到她的那一眼起，我的孩子已经包括了我的儿子和我的女儿，两个小生命了。女儿在圣诞节前刚刚回到家，她很健康，很精神，也很像她哥哥刚出生的时候，看着小小的她，我再次找到那种被依赖的感觉，一种因为付出而带来的幸福。\u003c/p\u003e\n\n\u003cp\u003e我和爱人并没有执着于“儿女双全”，也并不坚信独生子的孤独，我们偶尔只是希望自己可以有两个孩子，希望我们的爱有更多的寄托，怀孕甚至有些意外的成分，而且我们也没有预料到怀孕会给老婆带来如此大的风险，如果当初预计到的话，可能我们不会选择冒着生命危险生下她吧，这也算是她和我们特殊缘分的一部分吧。\u003c/p\u003e\n\n\u003cp\u003e从怀孕初期的险些流产，到怀孕末期子宫伤口的危险裂痕，这一切的坎坷，如今都已经过去，王斯诺已经不可逆转地健康地来到我们身边，而这些还要感谢用手术刀为我们迎来第二个小生命的杨孜大夫，王斯屹也是由她接出的，真的非常感谢她。\u003c/p\u003e\n\n\u003cp\u003e女儿如今刚刚6天大，希望一年后，她可以与我们一起围坐在圣诞树旁，两年后，能和我们一起唱圣诞歌，三年后，能和我们一起装饰圣诞树，年年快乐……\u003c/p\u003e\n\n\u003ch2\u003e\u003cb\u003e儿子的成长\u003c/b\u003e\u003c/h2\u003e\n\n\u003cp\u003e孩子的成长，总是最让人赞叹的，他在你眼里，总是那么小，那么需要保护，以至于他的进步总是超出我们的预料，王斯屹的这一年，进步同样是这样的惊人。\u003c/p\u003e\n\n\u003cp\u003e在和我一起去马来西亚旅游之后，他的英语课表现开始有了巨大的进步，而且由于我们加强了复习和辅导，如今他在英语课上也表现十分突出，那次小广播更是表现得非常棒。\u003c/p\u003e\n\n\u003cp\u003e\u003cobject width=\"480\" height=\"400\" classid=\"clsid:d27cdb6e-ae6d-11cf-96b8-444553540000\" codebase=\"http://download.macromedia.com/pub/shockwave/cabs/flash/swflash.cab#version=6,0,40,0\" align=\"middle\"\u003e\u003cparam name=\"src\" value=\"http://player.youku.com/player.php/sid/XNjQwMDgyMTk2/v.swf\" /\u003e\u003cparam name=\"allowfullscreen\" value=\"true\" /\u003e\u003cparam name=\"quality\" value=\"high\" /\u003e\u003cparam name=\"allowscriptaccess\" value=\"always\" /\u003e\u003cembed width=\"480\" height=\"400\" type=\"application/x-shockwave-flash\" src=\"http://player.youku.com/player.php/sid/XNjQwMDgyMTk2/v.swf\" allowfullscreen=\"true\" quality=\"high\" allowscriptaccess=\"always\" align=\"middle\" /\u003e\u003c/object\u003e\u003c/p\u003e\n\n\u003cp\u003e他在幼儿园的拼音课和思维课上也表现得很不错，甚至在晚上讲故事的时候，也能经常拼出一些字来，对于很少刻意教他识字的我们来说，这已经算是惊喜了。\u003c/p\u003e\n\n\u003cp\u003e而且，在其他方面，现在的斯屹，不仅能非常自如地骑他的自行车了，而且也学会了跳绳，游泳学习也取得了不少进步……\u003c/p\u003e\n\n\u003cp\u003e但是，对于我们这些父母而言，孩子最大的进步是他在性格和气质方面的进步，如今的王斯屹，言语行为之间表现出了相当的自信，更积极、更主动一直是我们对孩子的期望。\u003c/p\u003e\n\n\u003cp\u003e女儿出生之前，我们非常注重和儿子的沟通，一方面让他有准备要有一个妹妹出生，另一方面，也不断向他强化，尽管有妹妹出生，我们依然非常关心爱护他，他和妹妹之间没有冲突，让我们非常满意的是，王斯屹不仅对妹妹没有什么反感，甚至经常主动来帮爸爸妈妈照顾妹妹。\u003c/p\u003e\n\n\u003cp\u003e希望我们的儿子，在未来能够更加聪明、健康、自信、有进取心、有责任感、会照顾人，成为一个优秀的男子汉。\u003c/p\u003e\n\n\u003ch2\u003e\u003cb\u003e家庭的变化\u003c/b\u003e\u003c/h2\u003e\n\n\u003cp\u003e孩子是家庭的重要部分，不是唯一，我们小家庭的另一个支柱就是我的爱人，她这一年，尤其是怀胎十月，真是太不容易了，中间损失了一次马来西亚海岛游。如今孩子已经健康出生，妈妈却还没完全复原，希望她能够快快康复。\u003c/p\u003e\n\n\u003cp\u003e由于之前怀斯屹的时候胎心不好，提前将斯屹剖宫产出，老婆的子宫上是有疤痕的，这在胎儿足月生产的时候，会有破裂大出血的风险，再次怀孕绝对是冒着生命危险的行动，这些“好了伤疤忘了疼”的妈妈，是她们的宝宝的勇敢的救世主。这种危险并不是一个虚幻的概率，而是切实的存在，斯诺出生后送入婴儿室处理，而她的妈妈迟迟在四十多分钟之后才从手术室推回病房，我在外面心急如焚。之后，杨孜大夫随这老婆一起来到病房，她告诉我老婆的子宫已经有了5cm的裂痕，极其危险，如果不是及时剖出的话，后果不堪设想。\u003c/p\u003e\n\n\u003cp\u003e我想我们不会再要下一个宝宝了，希望老婆身体尽快复原，我们明年全家一起去旅行。\u003c/p\u003e\n\n\u003cp\u003e此外，这一年间父母乃至奶奶的身体都在向着不好的方向发展，尤其是父亲的心脏和肾脏，都很让人揪心，希望他可以配合医生检查、治疗，我们还等着让他健康地看着孩子们长大，乃至结婚生子，一家人享天伦之乐呢。\u003c/p\u003e\n\n\u003ch2\u003e\u003cb\u003e职业生涯的改变\u003c/b\u003e\u003c/h2\u003e\n\n\u003cp\u003e如果不是王斯诺的出生，5月17日离职盛大云，6月4日加入麦德云本应是我的年度头条新闻的。人的职业生涯随时可能改变，况且以盛大的背景，加入的那天起就只愿一起拼搏一阵，不曾期望共度余生。不过，从盛大离职，加入Madeira Cloud这家只有十几个人的小公司，仍然是让我始料未及的。\u003c/p\u003e\n\n\u003cp\u003e我本来尝试了一些跨国大公司的，不过，一方面过程并不顺利，另一方面我也反思自己，觉得自己的能力更适合于在小团队中发挥，所以还是决定加入了这家我看好的小公司，用我自己的话说，就是趁着自己还不算老，抓紧做点不靠谱的事情。这个转变过程，我还要特别感谢我爱人的支持和鼓励，人迈出自己的舒适区不是一件容易的事情，爱人的认同和支持，是我做出这个决定的坚强后盾。\u003c/p\u003e\n\n\u003ch2\u003e\u003cb\u003e各种未尽\u003c/b\u003e\u003c/h2\u003e\n\n\u003cp\u003e2013年，各种变化让我应接不暇，现在我还处在一个“不稳定”的状态中，在家里，不断有新的小状况出现，需要一一处理，在工作中，我也还没有完全做到通过努力证明自己的选择是正确的，这种种未尽之处正是我接下来要努力征服的。\u003c/p\u003e\n\n\u003ch2\u003e\u003cb\u003e尾声\u003c/b\u003e\u003c/h2\u003e\n\n\u003cp\u003e2013年，别了，这一年是如此的不同寻常，我会想你的；2014年，让我们更进一步。\u003c/p\u003e\u003c/p\u003e\n","cover":"","link":"life/2013/12/22/2013回望/index.html","preview":"","title":"2013回望"},{"content":"\n\n作者：Wang Xu\n链接：https://www.zhihu.com/question/22138976/answer/20428238\n来源：知乎\n著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。\n\n谢邀\n\n这实际是两个问题，是否关机、有没有信号，是一部终端的状态问题，这个属于移动性管理的内容；而通话状态如何，是两部终端的关系问题，属于呼叫控制，得分别来说。\n\n简单说下传统移动网络的结构，用 GSM/WCDMA R4 的经典架构来解释，其他能见到的移动网络略同，不一样的都在未来呢。和手机直接无线连接的东西是基站，这东西只处理无线曾的连接，管理基站的东西GSM叫BSC，WCDMA叫RNC，这些东西负责下辖基站链路资源的管理，上述两部分统称为无线接入网；无线接入网向上接入核心网，这部分才是第三层管理，包括用户的位置/状态管理、会话管理、呼叫控制，主要角色是交换机（MSC，移动交换中心），这个随着用户移动，可能会处于不同的交换机控制之下，而用户的归属地，会有一个归属位置的数据库HLR，来存储用户的状态信息，记录用户是否可以使用某种服务、保证用户可以被其他人找到\n\n对于移动性管理（MM），是由所在的交换机负责的，主要事件包括 Attach（开机注册），Location Update（位置更新，LU），和 Detach （关机注销）。开机关机没什么好说的，位置更新是位置区变动后会进行的，这样就知道手机在什么位置了，并且，如果用户在办公室一天没动，那么，每过两个小时（或指定时间），手机会周期性进行LU，告诉网络，虽然我没动，但我还活着。问题在于，如果手机忽然失去通信能力，比如，掉进厕所、没信号、抠电池等，是没机会进行关机注销的，而交换机在没接到信令的时候，也无法判定手机是否关机了，就要等若干个位置更新周期之后，手机仍然不更新，那么就“隐式IMSI分离”，判定手机关机。也就是说，从没信号到被判定关机，是有很长一段时间的，这个网络也无能为力。\n\n对于呼叫，实际是双发终端和双方交换机参与的过程，主叫方称为MO，被叫方称为MT，建立电话链路的过程属于呼叫控制（CC）的范畴，呼叫控制协议虽然有过很多演进，但基本原理还是和7号信令差不多，甚至说和固网没太大区别，主叫交换机找到被叫交换机，如果被叫可达，就会震铃，被叫摘机接通，双方通话。但是，不论是被叫正在呼叫，还是被叫正在通话中，主叫交换机能拿到的信息都是BUSY，所以，主叫方就不会了解被叫方具体在进行呼叫的哪个阶段了。\n\n关于呼叫的特殊控制，有一些补充业务，这些刚好反应了网络/终端可以知道的对方的状态，比如，有四种呼叫前转（Call Forwarding）服务\n\n- 无条件呼转，这是无条件的\n- 遇忙前转，这个是BUSY的\n- 不可达前转，这个是关机、不在服务区的\n- 无应答前转，这个是用户震铃响完也没接的\n\n顺便说，移动有个漏接电话短信提醒服务，其实就是用的后两种（或三种，不确定）前转，转到一个秘书台，记录下呼叫情况，再给被叫发短信的。\n\n此外，被叫方如果使用呼叫等待（Call Waiting）服务，那么，主叫打入的时候，如果被叫在通话中，会听到“您拨打的用户在通话中，请等待”，然后就变成震铃音而非忙音，被叫方会在呼叫中听到嘟嘟声，看到来电，这时，可以选择长话短说停了现在的，听新来的，或者用呼叫保持（Call Holding）保持住当前的，先听新来的，接入新来的之后，甚至可以做多方通话，接入保持中的电话，成为多方会议。\n\n综上，对你的问题，简单的答案是——协议如此，当然，具体为什么这样，和成本、复杂度、可实现性、有多大实际意义都有关系\n","cover":"","link":"zhihu/2013/11/29/cc-mm-cn/index.html","preview":"\u003cp\u003e这实际是两个问题，是否关机、有没有信号，是一部终端的状态问题，这个属于移动性管理的内容；而通话状态如何，是两部终端的关系问题，属于呼叫控制\u003c/p\u003e\n","title":"[知乎回答] 通讯公司(运营商)无法确切的区分某个手机号的通话状态么？关机，没信号，正在通话中或者正在呼叫其他用户？"},{"content":"\n\n答案链接：https://www.zhihu.com/question/20431197/answer/20123514\n\n咦？这问题又被挖出来了，作为写过一本（自己喜欢但不太成功的） Debian 的书的人，说两句自己的看法吧，前面答案太多太长，都没怎么仔细看，有什么重复的地方请谅解\n\n话说虽说 Debian 在国内人气不旺，在国外就很旺么？其实自从 Ubuntu 发布之后， Debian 的社区活跃度就受到了直接的影响，不论国内国外都是如此；但另一方面，Ubuntu 的存在，对 Debian 并非是纯粹的坏事，反而可能是好事。\n\nDebian 起源于93年，1000名左右的志愿者，基于纲领性文件的严密约束，有效管理着世界最大的开源软件包仓库，这本身很伟大，但也很艰难，因为本身是非盈利组织，DD们不收报酬的工作在相当程度上决定了他们无法全身心投入到 Debian 社区的工作中去，而 Ubuntu 的一个意义是付费资助了一部分的 DD，使他们可以专职地投入到社区工作中去，很多 Ubuntu 包的维护者同时也是 Debian 的包维护者。这本身对于 Debian 社区的继续发展是有好处的，同时，中立的 Debian 和商业的 Ubuntu 的衍生关系和兼容性，也让用户们可以更平滑过渡、更轻易迁移。\n\n从 Debian 与 Ubuntu 的关系看，我觉得一个社区版本和一个商业版本彼此配合，社区版支持更广泛，运作良好，商业公司发布版有商业支持，有些不同的附加值这样很不错，一个好的 distro 不一定每个人都用，apt 的发扬光大在一定程度上就是 debian 社区的成功。\n\n对于 Debian 社区自己的面临的问题，除了经济层面的，最重要的就是其发布机制了，Debian 的发布机制有这么几个特点\n\n- 基于 feature 和 bug 数量发布版本，而不像 Ubuntu, Fedora 这样严格的依据时间的发布方式；软件包的版本进入 sid，一段时间没有严重 bug 就进入 testing，进入发布阶段，当整个 testing 足够稳定，严重 bug 数量降低到可以接受的时候就整体发布为 stable。这个过程常常持续一两年，对于不明真像的 stable 用户，或者担心 unstable 不稳定的生产环境用户，自然觉得软件包不够新了\n- Debian 的多架构支持，Debian 很久就支持包括 arm、mips 在内的超过十种众多架构，甚至支持 Linux 之外的 hurd 和 kFreeBSD 内核。几乎所有软件包都要在所有架构上更新发布，这对于测试的要求很严苛，一定程度上影响了新软件包进入 Debian，当然，反过来说，这么多架构的支持也帮助 Debian 可以在各种嵌入式系统中得到广泛应用\n- Debian 对软件许可证要求很高，要求严格遵循 DFSG (Debian free software guide)，影响了很多有奇怪许可证的软件在 Debian 下的打包\n\n嗯，总体说，作为历史最悠久的主要 distro 之一，作为历史最悠久的 Linux distro 社区，Debian 的延续性还是很不错，我个人不认为这有严重问题，没必要要求大家都用 debian，各有各的好处\n","cover":"","link":"zhihu/2013/11/16/debian/index.html","preview":"\u003cp\u003e作为历史最悠久的主要 distro 之一，作为历史最悠久的 Linux distro 社区，Debian 的延续性还是很不错，我个人不认为这有严重问题，没必要要求大家都用 debian，各有各的好处\u003c/p\u003e\n","title":"[知乎回答] 为什么 Debian 在国内的人气远不如国外？"},{"content":"\n\n答案链接：https://www.zhihu.com/question/21563739/answer/18628713\n\n智能天线不算我国提出来的吧，只是在 TD-SCDMA 里使用了而已\n\n智能天线又叫自适应天线阵列（AAA），利用数字信号处理技术，将多根天线接收到的信号进行处理，从而形成定向性很强的所谓波束，区分不同位置的终端，降低其他位置的终端的干扰。这个技术实际上在军事/雷达技术中，很早就采用了，就是所谓的相控阵雷达，嗯，宙斯盾听说过吧，就是类似的技术。\n\n优点：波束定位的越精确，不同终端之间的干扰就越小，因为两个终端能在同一个位置的可能性大大降低了，从而提高了频谱利用率。同时，这个技术主要是在基站端计算，对终端的要求不是特别高，所以，不太消耗终端的计算能力。\n\n缺点：\n\n- 基站天线体积大，TD的是8根天线，不论是定向的面板，还是无向的圆桶，体积都很大，安装天线的工程复杂度和审批要求都高，还容易引起周围居民的恐慌，基站到天线的馈管也因此也一根变8根，安装复杂度和成本都变高了，在移动的努力投入下，这些都有了不少改进，但还是不可能从根本上解决\n- 过于依赖信号处理技术，不但提高了计算量需求，而且因为发送接收都要根据移动台发射的信号进行精确地信道估计，遇到高速移动等无法有效估算信道的情况，通信质量必然大幅度下降。\n\n为什么TD要采用智能天线，或者为什么只有TD采用智能天线。这是由TD的特点决定的：\n\n- TD的带宽低，是非对称1.6MHz，WCDMA 是对称5MHz，上下行一共10MHz，两者是6倍的关系，所以要达到3G要求的速率，TD必须有更高的频谱利用率，智能天线就是为了提高频谱利用率而采用的。\n- TD 的上下行在一个频率上，接收到的上行信号可以用来估算下行信道，进行联合接收、联合发送，而 WCDMA 有 190MHz 的上下行双工间隔，无法利用上行估算下行信道，智能天线的作用会大打折扣，所以也就没什么采用的必要了\n\n很久不干这个了，嗯，不一定全，凑合看吧\n","cover":"","link":"zhihu/2013/08/29/smart-antenna/index.html","preview":"\u003cp\u003e智能天线又叫自适应天线阵列（AAA），利用数字信号处理技术，将多根天线接收到的信号进行处理，从而形成定向性很强的所谓波束，区分不同位置的终端，降低其他位置的终端的干扰。这个技术实际上在军事/雷达技术中，很早就采用了，就是所谓的相控阵雷达，嗯，宙斯盾听说过吧，就是类似的技术\u003c/p\u003e\n","title":"[知乎回答] 智能天线技术是一个好技术吗，具不具备实用性？"},{"content":"\n\n答案链接：https://www.zhihu.com/question/21553561/answer/18597599\n\n我们先不提频率，先用信道(channel)这个抽象概念。一个基站可以支持很多信道，但大体上说，分为公共信道和专用信道两类，所谓公共信道就是大家共用的，专用信道就是专门给你打电话或者传数据的。\n\n首先并不是每个人开机就都占有专用信道，它们平常开机接入网络之后，处在一个等待状态，核心网络网络（你可以理解成用来找到你并建立连接的一个巨大的交换机），并不确切知道你在哪个基站，只确定你处于一大片区域，对于电话网，这篇区域叫位置区（LA），包含了很多基站的管辖范围。\n\n当有来话的时候，网络首先向这个位置区中进行广播，这使用了“寻呼（paging）”信道（PCH），每部手机都听这个信道，当它发现自己被寻呼到的时候，就开始申请建立专用信道，这个申请的过程一般是所谓的“随机接入（RA）”，使用了随机接入信道（RACH），大致的过程就是，使用一个估计的功率向基站发起请求，如果基站没响应就随机时延后重试并加强信号，直到接入完成并建立连接。\n\n建立连接后就分配了专用信道（DCH），用来进行通信，通信结束后释放。\n\n网络资源规划这个事，当然不是满足所有人同时通话的，那样成本就太高了，这是一个概率问题，根据估计的同时打电话的人数、每个电话的时间、资源成本，估算需要的容量。所以，网络规划常常讲，初期（刚刚建网，没人用）是覆盖问题，保证哪里都有信号，后期（很多人用）是容量问题，保证有需要的人基本都可以打电话。\n\n回到频率的问题上，无线通信发生在开放空间，在同一时间、同一地点，大家共享同样的频谱空间。于是就用到了多址接入技术，或者说让多个收发信机的接入需要分享 时间、空间、频率和能量这些因素构成的信号空间。FDMA是不同信号占用不同的频点，TDMA如GSM是不同信道占用不同时隙，CDMA是不同信道划分同一频率和时间上功率空间。\n\n当然，对于任一发射机，有效利用的频率范围或宽或窄，总是有限的，当时间、功率空间、空间（TD-SCDMA的智能天线会进行精细的空间位置划分）都用完的时候，自然需要另外的频段，这就是说的，WCDMA 是5MHz对称频带，TD-SCDMA 是 1.6MHz频带，用完就需要更多的，但这个频率空间是靠国家颁发（或出售）的牌照规定的，不可以随便用的，是在网络规划的时候就划分好的，不是打电话打不出去了就可以临时增加的。\n","cover":"","link":"zhihu/2013/08/28/cell/index.html","preview":"\u003cp\u003e一个基站可以支持很多信道，但大体上说，分为公共信道和专用信道两类，所谓公共信道就是大家共用的，专用信道就是专门给你打电话或者传数据的\u003c/p\u003e\n","title":"[知乎回答] 手机是如何从与基站的信号交换中识别自身是否正在被呼叫的？"},{"content":"\n\n答案链接：https://www.zhihu.com/question/21517264/answer/18484872\n\n地铁掉下去触电的概率并不高，更主要的是别被车撞到。\n\n地铁的供电方式主要有触网供电和三轨供电两种，触网供电时，是靠列车上方的电弓和触网接触供电的，这种方式跌落轨行区也不可能触电；另一种方式是三轨方式，是由列车行走的铁轨（行走轨）之外的，位于侧面，离地面有一定距离的第三轨来供电的，列车上的受流器和三轨的上表面或下表面接触供电，如果接触第三轨可能导致触电。\n\n三轨供电的电压以DC750V为主，广州有DC1500V三轨，北京在建的7号线也会使用直流1500V三轨下部受流方式供电。这样的电压只要保持距离，不近距离接触一般没有危险。而且第三轨会有三轨护板，其结实程度可以让一个成年人在上面行走，所以从上面跌落直接砸到三轨触电的机率也不高。有些线路三轨在贴近站台一侧，有些线路在对面，建议到站台上的时候看一眼，如果上面没有触网，对面也没有三轨，那三轨就在自己的站台这一侧了。其实掉下去碰到三轨不是很容易，想想别摔伤扭伤啥的更重要。\n\n有人跌落之后，站务人员在处理时会断电的，正常流程不会让人在救人过程中再次触电的。\n\n跌落地铁的危险之处在于，铁轨是跑地铁的，地铁紧急制动也是要滑一段距离的，如果列车进站时就在车跟前掉下去，那就九死一生了。如果掉下去\n\n1. 别冲着三轨去\n1. 尽量让别人发现自己，好让站务断电，司机制动，其他人看见也尽快通知站务人员\n1. 如果还能跑，向着列车出站的方向跑，如果你跑得够快，能跑到停车标那里，就算是司机没看到你，车也得停了\n1. 如果跑不到那边，如果站台对面那边没有三轨，在那边贴墙站着可能能过一劫，这个跟胖瘦以及不同的站台结构有关\n1. 如果这也不行，在铁轨之间趴下，也有这么着活下来，毫发无损的，不过，这个还得看命啊\n\n以上都是万一掉下去的事情，那么高，不注意掉下去还能跑的，其实也不容易，所以各位小心点，没安全门的站台，站得远一点，背靠柱子啥的，保命要紧啊。\n\n原题还问如何救人了，嗯\n\n1. 一般情况下，自己别往下跳\n1. 尽快通知站务处理，断电、要求紧急停车\n1. 站台尽头可能有紧急求助的按钮\n1. 指导掉下去的人（如果还没吓傻的话）像上面说的那么干\n\n**Update:**\n\n想不到回答了半年的题今天漂起来了，应要求配个图，这个就是三轨，摄于北京地铁13号线五道口站站台尽头\n\n![三轨示意图1](/assets/metro1.jpg)\n\n放大一点：\n\n![三轨示意图2](/assets/metro2.jpg)\n","cover":"","link":"zhihu/2013/08/21/metro-safety/index.html","preview":"\u003cp\u003e地铁的供电方式主要有触网供电和三轨供电两种，触网供电时，是靠列车上方的电弓和触网接触供电的，这种方式跌落轨行区也不可能触电；另一种方式是三轨方式，是由列车行走的铁轨（行走轨）之外的，位于侧面，离地面有一定距离的第三轨来供电的，列车上的受流器和三轨的上表面或下表面接触供电，如果接触第三轨可能导致触电\u003c/p\u003e\n","title":"[知乎回答] 地铁到底是怎么供电的？无意中掉到站台下，应该怎么避免触电？"},{"content":"\n\u003cp\u003e原标题: LSFMM: Caching — dm-cache and bcache\u003cbr /\u003e\n原作者: Jake Edge\u003cbr /\u003e\n原文链接: https://lwn.net/Articles/548348/\u003cbr /\u003e\n原文发布时间: May 1, 2013\u003cbr /\u003e\n译者: 王旭 ( @gnawux )\u003cbr /\u003e\n译文时间: 2013年6月2日\u003c/p\u003e\n\n\u003cp\u003e在 \u003ca href=\"https://lwn.net/Articles/LSFMM2013/\"\u003eLSFMM 2013 峰会\u003c/a\u003e上，Mike Snitzer, Kent Overstreet, Alasdair Kergon, 和 Darrick Wong 共同主持了一个讨论，内容是关于两个彼此独立的块设备层缓存方案 —— dm-cache 和 bcache。 Snitzer 首先介绍了 3.9 kernel 引入的 \u003ca href=\"https://lwn.net/Articles/540996/\"\u003edm-cache\u003c/a\u003e。这个方案使用率内核中的 device mapper 框架，实现了快速设备对慢速的“原始”设备的 writeback 或 writethrough 缓存。\u003c/p\u003e\n\n\u003cp\u003eSnitzer 介绍到，dm-cache 的原理是使用 device mapper 核心，并在上面增加一个策略层。这个策略层“非常类似”一个插件接口，可以实现不同的策略。这些策略（以及缓存的内容）决定了缓存是否可以命中，是否需要进行数据迁移（在原始设备与缓存设备之间进行某个方向的数据移动）。目前已经实现了包括最近最少用（LRU）、最常使用（MFU）等策略，但目前只有缺省的“mq”策略合并到内核中了，以便减少起初需要测试到的策略数量。\u003c/p\u003e\n\n\u003cp\u003e文件系统可以为策略提供 hints，比如某些块脏了，或是某些块已经被放弃了。这些信息有助于策略更好地决定块要存储到的位置。\u003c/p\u003e\n\n\u003cp\u003e之后，Overstreet 介绍了 \u003ca href=\"https://lwn.net/Articles/497024/\"\u003ebcache\u003c/a\u003e 的状态更新，后者已经在排队进入 3.10 了。他介绍到，bcache 已经有“很多用户”了，而且代码已经比较稳定了。他最近主要是在进行 bug fix。与 dm-cache 实现的的分级存储不同，按照 Overstreet 的介绍，bcache 更像一个传统的缓存。它可以用来存储任何 extents，甚至是是一个扇区，而 dm-cache 只能对整块数据进行缓存。\u003c/p\u003e\n\n\u003cp\u003e就在峰会开始前，Wong 给多个邮件列表（包括 dm-devel, linux-bcache, linux-kernel）发出过一封 \u003ca href=\"https://www.redhat.com/archives/dm-devel/2013-April/msg00068.html\"\u003eemail\u003c/a\u003e 来比较 bcache, dm-cache, 和 EnhanceIO。他分别编译了带有上述各个特性的内核，进行了一些测试。他发现，EnhanceIO 是最慢的，bcache 是它的 4-6 倍，而 dm-cache 更快，达到了 15 倍，不过 dm-cache 无法完成有些测试。所有比较都在一块普通硬盘上进行了相同的测试，有时，由于未知的原因，dm-cache 的表现或多或少的和硬盘完全一样。他指出，有些测试会导致 mkfs 创建的 inode table 倍缓存住，而通常这并不是一种有效的使用缓存的方法。\u003c/p\u003e\n\n\u003cp\u003eSnitzer 表示，他曾试着去重现 Wong 的测试结果，但结果对 bcache 和 dm-cache 都得倒了更差的成绩。他说他希望和 Overstreet 一起去找出原因。而 Overstreet 则表示，不应该过多地看综合测试的成绩，这些测试是游泳的，但可能带有误导性。Ric Wheeler 提问，Snitzer 是否“在真实工作负载下看到了实质性的性能提升”，Snitzer提到，在不同的 Git 标签之间进行切换就是 dm-cache 可以完胜的一个例子，不过他需要一些帮助来获得更贴近实际使用的负载。\u003c/p\u003e\n\n\u003cp\u003e一个参会者问道，这些方案是否假设缓存设备总是存在。Snitzer 说，dm-cache 确实如此假设，但这是需要改进的地方。Overstreet 说， bcache 并不要求 cache 设备一直都在。因为 bcache 已经在实际产品中使用了，所以它有机会去碰到这些疑难场景，并可以处理这些缓存设备无法工作的情形。\u003c/p\u003e\n\n\u003cp\u003eSnitzer 表示，dm-cache 确实还有很多事情要做。起初，它是进行 cache 和原始设备的并行 IO，但最终不得不回到顺序 IO。而且，对于流水线中有 NVM 设备的情况下，存储层次也是如此。因为 dm “到处都是分层”，dm-cache 刚好适合进行存储分层，不过 Overstreet 指出，bcache 也可以做到分级存储。\u003c/p\u003e\n\n\u003cp\u003e这个讨论最终没有一个明确的结论，只是提到需要让两个方案的“真实世界”性能读数变得更好。同时也指出了，不同的测试者进行的测试得到的结论差异是巨大的，这也是真实世界的情况的一个写照。\u003c/p\u003e\n","cover":"","link":"translation/2013/06/02/【译文】lsfmm:-缓存-—-dm-cache-与-bcache/index.html","preview":"","title":"【译文】LSFMM: 缓存 — dm-cache 与 bcache"},{"content":"\n\u003cblockquote\u003e\n\n\u003cp\u003e按：这是一次旅游的记录，不是攻略，所述内容仅供参考\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e5月12-18日，原定一家三口的马来西亚兰卡威之旅最后成行的是我和我儿子两个人，打破了我家以往旅游的规律\u0026mdash;\u0026mdash;我家旅游不能只有男人\u0026mdash;\u0026mdash;可以是我老婆一个人，也可以是老婆和其他一个或多个任意家庭成员。不论如何，兰卡威确实是个漂亮的小岛，整个环岛自驾游还是很让人兴奋的，将来有一天，我们一家三口还是会一起出来旅游的，希望还有机会再来这里。\u003c/p\u003e\n\n\u003cp\u003e首先简单标记一下我们在兰卡威岛的主要落脚点：\u003c/p\u003e\n\n\u003cp\u003e\u003ca title=\"兰卡威自驾游主要活动区域 by gnawux, on Flickr\" href=\"http://www.flickr.com/photos/gnawux/8913641474/\"\u003e\u003cimg src=\"/assets/8913641474_4291fb602b.jpg\" alt=\"兰卡威自驾游主要活动区域\" width=\"500\" height=\"413\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e我们在岛上活动了5天，此外还有一晚住在吉隆坡，全程一共7天6晚，疲劳而充实，行程是这样的：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e11日晚上北京出发，亚航航班\u003c/li\u003e\n\n\u003cli\u003e12日早上到达吉隆坡LCCT，中午到达市区、入住，下午在双子塔附近闲逛，看了看夜景\u003c/li\u003e\n\n\u003cli\u003e13日上午出发，中午到KLIA，乘坐马航的航班，下午到兰卡威，租车，到珍南海岸，入住，在这里住两天\u003c/li\u003e\n\n\u003cli\u003e14日环岛一圈，去了东方村坐缆车，去看了黑沙海滩，去看了总理展览馆，去游荡了红树林，看了喂老鹰\u003c/li\u003e\n\n\u003cli\u003e15日去芭雅岛浮潜，看小鱼，当晚到兰卡苏卡码头，乘坐小船上了里巴克岛，晚上在海滩抓小螃蟹\u003c/li\u003e\n\n\u003cli\u003e16日上午在里巴克岛休闲，下午上兰卡威岛，去海底世界看了一下\u003c/li\u003e\n\n\u003cli\u003e17日上午在里巴克岛休闲，抓小螃蟹，游泳，中午下岛，去瓜镇入住，当天下午进行了一些采购，还看了兰卡威的标志性建筑，巨鹰广场\u003c/li\u003e\n\n\u003cli\u003e18日上午去丹容鲁海滩看了两个小时海，然后又去看了下黑沙海滩，之后直奔机场，还车，乘坐马航班机回吉隆坡KLIA，转到LCCT，再乘坐晚上的班机回北京\u003c/li\u003e\n\n\u003cli\u003e到北京已经是19日凌晨了\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e下面分几个主题讲讲\u003c/p\u003e\n\n\u003ch2\u003e海滩\u003c/h2\u003e\n\n\u003cp\u003e我们最早入住的是珍南海滩（Pantai Cenang）是兰卡威开发得最丰富的旅游区，有漂亮的海滩，各式餐馆，免税店和Mall，还有大型水族馆Under Water World。海滩不错，我和儿子去泡了泡，可惜时间有限，从去芭雅岛那天开始，就再也没工夫在这个海滩上转悠了。这里的缺点可能就是人比较多了，毕竟是开发比较充分的海滩嘛。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.flickr.com/photos/gnawux/8770570402/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8770570402_9782a9d0c4.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e黑沙海滩（Pantai Pasir Hitam）我们去过两次，第一次去的时候大概是午后的高潮位，基本没看到什么海滩，第二次去是要走之前，最后停留一下，因为这个海滩差不多就在丹容鲁海滩到机场的路上，这次看到海滩了，其实很漂亮，水非常清透\u0026mdash;\u0026mdash;实际上整个兰卡威的海滩的海水都很透，黑色的沙滩是因为历史上火山喷发出来的石油类东西掺在沙子里。嗯，我不抽烟，没带打火机，所以也没去试试能不能点着哈。另外，这里还是每年帆船赛的时候。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.flickr.com/photos/gnawux/8771514738/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8771514738_bdd9998f9e.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e丹容鲁海滩（Pantai Tanjung Rhu），最后一天我们才去的这里，就是想看看就走的，不过这里很清净，沙滩、海面都很漂亮，可能是岛上最漂亮的海滩了，虽然没看到传说中的海豚，我们还是觉得最后一天多加了10块钱的油来这里一趟是很值的。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.flickr.com/photos/gnawux/8766792049/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8766792049_181b337f82.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003cbr /\u003e\n\n\u003ca href=\"http://www.flickr.com/photos/gnawux/8771506860/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8771506860_1444b48a02.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e里巴克岛（Rebak Island），这里是 Taj Hotel 的独家海岛（滩），和其他海滩一样漂亮，人不多，小螃蟹之类的动物很多，居然还能抓到挺大号的寄居蟹，岛上很舒服，上岛的独家小码头兰卡苏卡码头（Langkasuka Port）景色也很漂亮。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.flickr.com/photos/gnawux/8771446610/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8771446610_8e0b75abe2.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003cbr /\u003e\n\n\u003ca href=\"http://www.flickr.com/photos/gnawux/8771438880/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8771438880_715fd78130.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e其他还有传说中的 Pantai Teluk Datai 和 Pantai Teluk Burau 两片海滩，我们都没顾上去，不过后者我们在东方村应该俯瞰倒了。\u003c/p\u003e\n\n\u003ch2\u003e主要观光活动\u003c/h2\u003e\n\n\u003cp\u003e东方村的缆车挺不错的，风景非常好。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.flickr.com/photos/gnawux/8766676321/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8766676321_46128ed21a.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003cbr /\u003e\n\n\u003ca href=\"http://www.flickr.com/photos/gnawux/8766680073/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8766680073_1d32fa74b3.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e芭雅岛的浮潜不能错过，水非常清透，而且里面鱼很多，游得旁若无人，还有不咬人的小鲨鱼出没。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.flickr.com/photos/gnawux/8771416646/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8771416646_532c8c7499.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e蝙蝠洞、红树林。这里是必须租船出去的，按船租，1小时的套餐包含了蝙蝠洞、小鱼农场、红树林+遥望泰国，以及喂食老鹰，要价250马币，合500块钱人民币。我的感觉是这个价钱是值的，整个过程非常棒，尤其是可以近距离观察老鹰，当然，一条船可以坐不止七八个人，现场想要找人share一艘船非常困难，如果能在酒店找到同行的人的话会更值一些。兰卡威岛离泰国非常近，从红树林这里的河口可以直接遥望泰国，手机都收到\u0026ldquo;泰国移动欢迎您\u0026rdquo;的短信了。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.flickr.com/photos/gnawux/8771409134/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8771409134_f508218fca.jpg\" width=\"500\" height=\"375\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e瓜镇的Eagle广场自然是要去的，巨大的老鹰就是兰卡威的地标，兰卡威的意思就是鹰。广场的喷泉里还有七八只大乌龟，嗯，类似最近北京立交桥匝道处经常有人提着的大龟那么大。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.flickr.com/photos/gnawux/8766785457/\" title=\"Untitled by gnawux, on Flickr\"\u003e\u003cimg src=\"/assets/8766785457_59cc888b80.jpg\" width=\"500\" height=\"500\" alt=\"Untitled\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003e购物\u003c/h2\u003e\n\n\u003cp\u003e瓜镇的几家免税店里的巧克力都很便宜，我们买了一些，其他觉得没啥可买的了。某些免税店搞得杂货铺似的，一点都不高端大气，实在难以接受啊。\u003c/p\u003e\n\n\u003ch2\u003e自驾相关\u003c/h2\u003e\n\n\u003cp\u003e关于自驾，这里的车是右舵的，非常不适应，最后一天从黑沙海滩出来去机场的时候，还直接开到逆行了呢\u0026hellip;\u0026hellip;不过这里的油很便宜，这么多天就用了40马币的油，合大概80块钱人民币。租车是70马币一天，自动档的，水平大概和夏利相仿吧，我还给儿子租了一个儿童座椅，多加了70，不过为了安全，我觉得这个钱不能省。\u003c/p\u003e\n\n\u003cp\u003e自驾必须有导航才爽，我带上了之前在淘宝九块九包邮买的吸盘夹子，把手机固定住用来导航，还是很物有所值的。期间前几天用的 Google Maps，后几天用的Waze。实际上 iOS 的 Google Maps 对自驾游基本够了，而且，只要计算路线的时候有网络接入就行，开车期间没有信号也没关系。Waze的好处是，有语音导航（iOS 的 Google Map 传说也有，没找到），显示信息比较丰富，而且也比较好玩。\u003c/p\u003e\n\n\u003ch2\u003e各种槽点\u003c/h2\u003e\n\n\u003cp\u003e说道槽点，先说说语言吧，据传说马来西亚有接近三成的华人，不过实际感受好像没那么多，到处都是印度味儿的英语\u0026hellip;\u0026hellip; 偶尔有几个用中文招揽生意的黑车，嗯。不过真到需要的时候努力找，还是能找到说中文的人的。\u003c/p\u003e\n\n\u003cp\u003e然后是电话，Digi 的套餐流量不错，450MB/week，打国内也蛮便宜，0.1马币1分钟，合人民币2毛钱一分钟，嗯，这是国际长途啊，就是信号太不好，在吉隆坡和瓜镇有3G，但珍南海滩就没有3G，甚至岛上有些地方都没有覆盖。更有甚者，我刚在微博上吐槽了他们的覆盖，结果半个岛的线路故障，持续了两天，连电话都打不了，大家一定选 Hotlink 啊。\u003c/p\u003e\n\n\u003ch2\u003e吉隆坡相关\u003c/h2\u003e\n\n\u003cp\u003e嗯，吉隆坡停留时间太短，没啥可说的，机场到市区非常非常远，亚航的 LCCT 和马航的 KLIA 是吉隆坡国际机场的两个航站楼，之间有大巴，大概15分钟车程。\u003c/p\u003e\n\n\u003ch2\u003e总结\u003c/h2\u003e\n\n\u003cp\u003e总的说，来兰卡威就是各种看海，而且海水也确实非常清澈，透明度很好。沙滩算不上非常细，但差不多每个沙滩上都能找到螃蟹这样的小动物，显得很有趣。\u003c/p\u003e\n\n\u003cp\u003e更多照片在 flickr 上\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003ehttp://www.flickr.com/photos/gnawux/sets/72157633549200771/\u003c/p\u003e\n\n\u003c/blockquote\u003e\n","cover":"","link":"life/2013/06/01/兰卡威环岛自驾游/index.html","preview":"","title":"兰卡威环岛自驾游"},{"content":"\n\u003cp\u003e前两天采购了一台“全球首发\"的 \u003ca title=\"京东链接\" href=\"http://item.jd.com/894057.html\" target=\"_blank\"\u003eThinkpad S3 超级本\u003c/a\u003e，激动之余，就把不会用的 Windows 8 给抹掉，装上 Linux 了。这台机器的配置如下\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cspan style=\"font-family: courier new,courier;\"\u003eCPU i5-3337U\u003cbr /\u003e\n内存 8GB\u003cbr /\u003e\n芯片组 Intel HM77\u003cbr /\u003e\n显卡 CPU集成 + \u003c/span\u003eRadeon HD 8670M\u003cbr /\u003e\n硬盘 500GB SATA + 24GB mSATA SSD\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e嗯，其他先不说了，亮点基本就这些。新机器，一大堆支持得不好的东西，比如 suspend to ram 我到现在还没配好，先不说了，这次主要说硬盘。\u003c/p\u003e\n\n\u003ch2\u003e基本思路\u003c/h2\u003e\n\n\u003cp\u003e这台机器有一块过小的 SSD 和一块主硬盘，因为SSD太小了，以至于我不想把哪个分区整体放到上面，于是，想到了分级存储的策略——使用SSD作为缓存，让热数据缓存在SSD上，冷数据留在机械硬盘上，是的，这个和被广泛宣传的 Apple 的 Fusion Drive 很类似，当然，Apple 不是第一个开发这种技术的公司。\u003c/p\u003e\n\n\u003cp\u003e在 Linux 上，最广为传颂的这类技术就是\u003ca title=\"Bcache Homepage\" href=\"http://bcache.evilpiepirate.org\" target=\"_blank\"\u003e bcache \u003c/a\u003e了，但有一个问题，bcache 直到 3.10 才进入 kernel，而 3.10 到目前为止还只是 -rc3。也就是说，如果要装 Debian、Ubuntu、Fedora 的话，你至少要等半年，才能找到一张支持 bcache 的启动盘。不过，我还是想用下这个个 Distro，于是，就采用了这样一个思路（思路抄袭自\u003ca href=\"https://wiki.archlinux.org/index.php/Bcache\" target=\"_blank\"\u003e这个 Arch 的 Wikipage\u003c/a\u003e，有调整）:\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e先在 SSD 上装一个临时的系统\u003c/li\u003e\n\n\u003cli\u003e升级内核，支持 bcache\u003c/li\u003e\n\n\u003cli\u003e在主硬盘上做一个分区，作为 bcache 的后端存储\u003c/li\u003e\n\n\u003cli\u003e把装好的系统迁移到上面的 bcache 分区\u003c/li\u003e\n\n\u003cli\u003e修改 grub 重新启动，引导到 bcache 上去\u003c/li\u003e\n\n\u003cli\u003e干掉 SSD 上的分区，作为 bcache 的缓存\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e整体过程就是这样，中间波折无数，下面就介绍一下。具体的折腾过程中，有多次反复操作（不过装系统只有一次，我的系统观是——重装就是认输，只要有一丝希望，就反复折腾，拒绝重装，不抛弃、不放弃），后面的介绍省掉了一些无畏的折腾，尽量直接的介绍，不过各位重试的时候有什么我没写的问题，可以和我交流一下哈，没准我也遇到过了。\u003c/p\u003e\n\n\u003ch2\u003e引导、初次安装、定制内核\u003c/h2\u003e\n\n\u003cp\u003e装系统之前，我手头没有方便可用的 X86_64 架构的 Linux，只有一台 MBP，所以，有些东西比较费劲。启动盘的制作是在 MBP 上进行的，下载这个镜像\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cpre\u003eubuntu-13.04-desktop-amd64.iso\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e不要那个 +mac 的，这样才能 UEFI 模式启动，在 Mac 下制作启动U盘的方法其实不困难：\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;hdiutil convert ubuntu-13.04-desktop-amd64.iso -format UDRW -o ubuntu-1304.img\ndd if=ubuntu-1304.img.dmg of=/dev/disk2 bs=1m\ndiskutil ej\u0026lt;/code\u0026gt;ect /dev/disk2\u003c/pre\u003e\n\n\u003cp\u003e简单地说就是，先从光盘变成镜像，然后再把镜像 dd 到 U 盘去，嗯，各位用的时候小心点顺序 disk2 是我的 U 盘，我的 Mac 物理上有 SSD 和 SATA，所以 U 盘是 disk2 。\u003c/p\u003e\n\n\u003cp\u003e这个镜像制作的 U 盘是可以在超级本上 UEFI 引导的，能 UEFI 引导非常重要，因为这样才能安装支持 EFI 的 grub，我一开始没注意这点，后来又修复了半天引导程序。\u003c/p\u003e\n\n\u003cp\u003e嗯，另外，分区的时候，要留出单独的 boot 分区，毕竟 grub 是不认 bcache 的。原有的 EFI 分区啥的也没有动，我把 grub 也做在 HDD 上了。\u003c/p\u003e\n\n\u003cp\u003e然后是定制内核，本来我注意到 Ubuntu PPA 里面有主线内核的 Builds，于是就下了 3.10.0-rc3 的 deb，启动之后发现没有 bcache，拿来 config 一看，居然没选上 bcache，摔。只好自己下 kernel 来 build。为了图省事，直接拿了 ubuntu 的 config，只多选上了 bcache （在 device drivers --\u0026gt; md 里面，和 raid 之类的在一起 ），不过，话说时间是守恒的，你在 config 的时候偷懒没做精简，就在 build 的时候遇到麻烦…… 那些没用的杂七杂八模块好废时间啊，build 了一个小时…… 下次一定好好精简。\u003c/p\u003e\n\n\u003cp\u003e顺便说一句，在 debian/ubuntu 下 build kernel，最好安装 kernel-package 包，然后用 fakeroot make-kpkg 来制作 kernel deb 包，这样比较好管理。我的新 kernel 看起来是这样的\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;gnawux@square:~$ ls src/*.deb\nsrc/linux-image-3.10.0-rc3-bcache_3.10.0-rc3-bcache-10.00.Custom_amd64.deb\ngnawux@square:~$ uname -a\nLinux square 3.10.0-rc3-bcache #1 SMP Wed May 29 11:28:22 CST 2013 x86_64 x86_64 x86_64 GNU/Linux\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e-bcache 是我自己加的后缀，嗯，接下来重启到新内核，就支持 bcache 了\u003c/p\u003e\n\n\u003ch2\u003e启用 bcache，引导系统\u003c/h2\u003e\n\n\u003cp\u003e现在重启之后，系统已经支持 bcache 了。需要做三件事情\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e打开 bcache\u003c/li\u003e\n\n\u003cli\u003e把系统迁移上去\u003c/li\u003e\n\n\u003cli\u003e修改 grub，引导新系统\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e打开 bcache 之前，最好准备一下用户态工具\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003ehttp://evilpiepirate.org/git/linux-bcache.git\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003egit下来，然后 \u003ccode\u003emake install\u003c/code\u003e 就可以了，需要 \u003ccode\u003euuid-dev\u003c/code\u003e 包。用户态工具主要包含了 udev 工具链上的规则，并且会加入到 initramfs 里面去，还包含了制作 bcache 分区的工具。\u003c/p\u003e\n\n\u003cp\u003e下面要制作 bcache 后端分区，后端就是机械硬盘上的大分区\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;make-bcache -B /dev/sda8\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e就酱紫就可以了，然后告诉 kernel 这货可以用了\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;echo /dev/sda8 \u0026amp;gt; /sys/fs/bcache/register\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e不过我记得有了 udev rule，这个实际不用 echo 了，当然，多来一次没啥坏影响。\u003c/p\u003e\n\n\u003cp\u003e之后，在 /dev/bcache0 上 makefs，然后迁移系统。我是懒得再用 bootstrap 方式重装一个系统了，我选择直接复制，大概过程是这样的：\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;mount -o bind / /mnt/orig\nmount /dev/bcache0 /mnt/new\ncd /mnt/orig\ntar -cvpf - * | tar -C /mnt/new/ -xf -\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e然后修改新系统的 fstab、修改 grub.cfg 的 kernel 命令行，让 root 指向 bcache0，然后重启就可以成功了。\u003c/p\u003e\n\n\u003cp\u003e成功引导之后，把 SSD 上的老的系统做掉，变成 bcache 的 cache 分区\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;make-bcache -C /dev/sdb1\necho /dev/sdb1 \u0026amp;gt; /sys/fs/bcache/register\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e这时，/sys/fs/bcache/ 下就会出现这个 cache 分区的 UUID，比如\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;root@square:~# ls /sys/fs/bcache/\n6a6b9acd-e205-4a10-a64f-6c048841c824  register  register_quiet\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e现在，让这个 cache 服务于 bcache0 ，这既可以在 bcache0 上操作，也可以在后端设备 sda8 (我的分区号是这个)上操作，比如\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;echo 6a6b9acd-e205-4a10-a64f-6c048841c824 \u0026amp;gt; /sys/block/bcache0/bcache/attach\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e或者\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;echo 6a6b9acd-e205-4a10-a64f-6c048841c824 \u0026amp;gt; /sys/block/sda/sda8/bcache/attach\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e之所以给出后面的方法，是因为如果由于没挂上 cache 之类的问题，bcache0 没有出现，仍然可以用后面的操作。现在再来，就已经完全打开 bcache 了。\u003c/p\u003e\n\n\u003ch2\u003e修复关机和开机的问题\u003c/h2\u003e\n\n\u003cp\u003e完全打开 bcache 之后，发现关机不能……开机没问题，但关机按电源是无法接受的啊，因为这之后有 IOError，判断应该是 driver 的某个问题导致导致的，比如和 bcache 在关机过程中的操作顺序有关系，研究之后，发现在关机的时候 detach 掉 cache 分区就可以正常关机了，编辑 \u003ccode\u003e/etc/init.d/umountroot\u003c/code\u003e 文件，在 ro remount 跟分区之前，加入一段\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003e    while [ -e /sys/block/bcache0/bcache/cache ]\n    do\n            echo \u0026quot;detach bcache\u0026quot;\n            echo \u0026quot;6a6b9acd-e205-4a10-a64f-6c048841c824\u0026quot; \u0026gt; /sys/block/bcache0/bcache/detach\n            sleep 2\n    done\u003c/pre\u003e\n\n\u003cp\u003e这段的意思是，只要 cache 还在，或者说还没有完全把 cache 刷入磁盘，就一直 detach，这样，关机就正常了。\u003c/p\u003e\n\n\u003cp\u003e关机正常之后，开机进不了根分区了，似乎是只要关机前 detach 掉 cache，开机的时候 bcache0 就不会正常产生了，因为我们没有支持 bcache 的启动盘，所以必须在没有系统的情况下就地解决这个问题。这时，在 initramfs 的界面里，输入上面那句：\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;code\u0026gt;echo 6a6b9acd-e205-4a10-a64f-6c048841c824 \u0026amp;gt; /sys/block/sda/sda8/bcache/attach\n\u0026lt;/code\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e然后，ctrl-d 退出 busybox，就可以继续正常启动了，下面的操作显然是要对 initramfs 下手了。对于 ubuntu 的 \u003ccode\u003einitramfs-tools(8)\u003c/code\u003e 来说，启动脚本位于 \u003ccode\u003e/etc/initramfs-tools/scripts/\u003c/code\u003e 下面，其中，\u003ccode\u003elocal-top/\u003c/code\u003e 目录中的脚本是在本地文件系统设备出现之前执行的，我们要在这里确保根分区设备 \u003ccode\u003e/dev/bcache0\u003c/code\u003e 就位，最后我是使用了这样一个脚本：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eroot@square:~# cat /etc/initramfs-tools/scripts/local-top/bcache\nPREREQ=\u0026quot;udev\u0026quot;\nprereqs()\n{\n    echo \u0026quot;$PREREQ\u0026quot;\n}\ncase $1 in\n# get pre-requisites\nprereqs)\n    prereqs\n    exit 0\n    ;;\nesac\n\n#. /scripts/functions\n\ntimeout=16\nwhile [ ! -d /sys/block/sda/sda8/bcache ] ;\ndo\n   if [ $timeout -eq 0 ] ; then\n    break\n   fi\n   echo  \u0026quot;$((timeout=timeout-1))\u0026quot; \u0026gt; /dev/null\n   sleep 1\ndone\n\n[ ! -e /sys/block/sda/sda8/bcache/cache ] \u0026amp;\u0026amp; echo 6a6b9acd-e205-4a10-a64f-6c048841c824 \u0026gt; /sys/block/sda/sda8/bcache/attach\u003c/pre\u003e\n\n\u003cp\u003e原理就是等待 bcache 设备出现，然后把 cache 给它 attach 上，然后用 update-initramfs 重新生成 initrd 就行了。\u003c/p\u003e\n\n\u003ch2\u003e小结和一些有用的链接\u003c/h2\u003e\n\n\u003cp\u003e总结起来就是——别怕出错，一直往下做，不管咋的，都会有办法的，计算机就在手上，电源都可以按，还怕啥。出了问题要冷静，找到问题，捅一下可能就好了，不行就多试几次。\u003c/p\u003e\n\n\u003cp\u003e给一个参考链接吧，用来修复Ubuntu的引导程序的，有时候有用，嗯\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003ehttps://help.ubuntu.com/community/Boot-Repair\u003c/li\u003e\n\n\u003c/ul\u003e\n","cover":"","link":"linux/2013/06/01/在新-thinkpad-s3-上使用-bcache-作为-linux-的根分区/index.html","preview":"","title":"在新 Thinkpad S3 上使用 bcache 作为 Linux 的根分区"},{"content":"\n\u003cblockquote\u003e困难是机会，别人不想做的事情是机会，明白这个道理就算长大了 （\u003ca href=\"http://www.facebook.com/l.php?u=http%3A%2F%2Fweibo.com%2F1494932200%2FzuhqmjUne\u0026amp;h=WAQGsu3r3\u0026amp;s=1\" target=\"_blank\" rel=\"nofollow\"\u003ehttp://weibo.com/1494932200/zuhqmjUne\u003c/a\u003e）\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e不过，我似乎还没有长大……\u003c/p\u003e\n\n\u003cp\u003e我终于确切地知道，我不打算继续坚持，决定离职了，距离我上一次离职的时间，刚好2年。具体的工作内容就不透露了，省得和公司的公关策略有啥关系，反正该知道的人都知道是怎么回事。\u003c/p\u003e\n\n\u003cp\u003e在云计算的圈子里，度过了这么多日子，见了这么多人，做了这么多事，吵过架也犯过错，登过台也背过黑锅，谈谈我自己对这个圈子的理解：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e作为随着互联网生态环境细分而产生的一个层次，基础设施级的云计算已经是互联网的一部分了，并逐渐不可或缺，直到被尚未可知的下一次革命所取代。\u003c/li\u003e\n\n\u003cli\u003e国内的公有云服务各有各的问题，有钱的没找对路，找对路的缺老大支持，鼎力发展的没技术，有技术的小公司又没钱没规模…… 大多数都表现出一副将被后浪拍在沙滩上的面相。（抱歉这里可能有所得罪，不过我说得是大部分，看这篇文章的从业者不算，您是特殊的）\u003c/li\u003e\n\n\u003cli\u003e有资源或有资金的运营商们+传统IDC服务商们难以进入互联网角色，有机会搅局市场，但似乎还无法占据这个市场。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003eOK，截至到目前为止，我似乎都在表达我的绝望，确实如此，我觉得，这种机会（困难+不想做，如开头引用）暂时留给已经长大的人吧，我再年轻一会儿。\u003c/p\u003e\n\n\u003cp\u003e对于我自己的未来，嗯，是的，我希望再年轻一会儿，再不靠谱一点，最近看了不少机会，都很不错（估计也不容易挣到offer），不过我忽然在想，我还不老哈，似乎应该再挑战一下自己，何必急于挤进一家大公司呢？大公司是否适合自己，是否能取得更好的发展呢？改简历的时候，我在反复审视自己：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e我并不是在某个方面有及其非凡的技能，但我可以适应多种角色，擅长综合多种方法，解决问题——如果在大团队中做一枚螺丝钉，放在哪个角色都不算杰出，但又有很多方面“屈才”。\u003c/li\u003e\n\n\u003cli\u003e我有技术热情，我乐于从事从开发到运维的各种技术工作，并以此为乐。非常渴望尝试不同的新技术，解决各种问题。\u003c/li\u003e\n\n\u003cli\u003e我是个自由主义者，乐于交流和分享，不喜欢约束，不追求稳定。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e于是，我希望加入一个小团队，有我所相信的领域和方向，有很多的挑战……当然，我这么写的时候，我已经想好我到底要去哪里了，而且，幸运的是，我的家人也同样支持我。\u003c/p\u003e\n\n\u003cp\u003e在这个离别的时刻，我想感谢这个和我一起走过两年的团队，每一位同事都非常优秀，包括中间离开的和仍然坚持的，我从每个人身上都学到了很多东西，未来的日子里，我们仍然可能会再次相聚。\u003c/p\u003e\n\n\u003cp\u003e我同样感谢两位CEO，招我进来的老大和送我离开的老大，他们给了我很多信任、鼓励和机会，改变了我的很多技术观/产品观，还给了我一份不错的薪水和2年间总共25%的工资涨幅。\u003c/p\u003e\n\n\u003cp\u003e是时候准备开始下一段旅程了。\u003c/p\u003e\n","cover":"","link":"life/2013/04/28/两年之后，再次告别/index.html","preview":"","title":"两年之后，再次告别"},{"content":"\n\u003cblockquote\u003e按：事情从“微信收费”一说起来的，看到\u003ca href=\"http://shell909090.com/blog/2013/04/%E4%BB%8E%E5%BE%AE%E4%BF%A1%E5%92%8C%E7%A7%BB%E5%8A%A8%E7%9A%84%E5%AE%98%E5%8F%B8%E8%AF%B4%E5%A4%9A%E7%BD%91%E8%9E%8D%E5%90%88/\"\u003eShell发了一篇blog\u003c/a\u003e，深感电信和互联网两个领域互相不知根知底啊，作为前兼职3G讲师，来简单介绍一点吧。首先，这篇blog和微信一事的关系仅限于此段，我个人认为这纯粹是某公司的炒作，看了移动的\u003ca href=\"http://blog.sina.com.cn/s/blog_7e63cdbb010189f9.html\"\u003e宁宇的博客\u003c/a\u003e，我更确信这一判断；其次，这篇文章不涉及所有运营商网络，运营商网络各有不同，我主要说说我更熟悉的移动网领域，尤其是 GSM/GPRS/EDGE/WCDMA（部分地包含TD），如果没有特殊说明，不包含固话网和CDMA/CDMA2000。嗯，这么说明严谨了吧，呵呵。\u003c/p\u003e\n\n\u003cp\u003e另外，其实从领域说，一般叫电信网，我怕大家和中国电信混了，所以改说运营商网络，下文凡是提到电信网，而不是中国电信的，泛指全球电信运营商的网络，而非中国电信。另外，全球电信运营商如一丘之貉，对比看，其实中国的也不过分，所以，骂的时候不必对比啊。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003ch2\u003e运营商网络是什么样的\u003c/h2\u003e\n\n\u003cp\u003e从大面上说，电信网络分为三大部分：接入网、交换网和传送网。从大家的终端设备，到电信网络的交换机，这是接入网，选择目的地，进行电话交换的那个是交换网，长途传输的是传送网。从传输的内容看，还要分成数据平面和控制平面，控制信令（signaling）的传输一般是走专用的信令网的，比如著名的7号信令系统（SS7），以及为了在IP上承载信令网而搞的SCTP……\u003c/p\u003e\n\n\u003cp\u003e继续，传统地说，固话的接入网是从各位的家里一直到交换机的那根双绞线，这对线是独享的，电话56Kbps，DSL可以超过8Mbps，都是用的这一对线，除非别人盗用，否则这对线是你独享的，线路质量越好，你能达到的DSL速度也越高，当然，这是接入速度，端到端速度还有很多制约因素，这个大家都懂。\u003c/p\u003e\n\n\u003cp\u003e但无线网络有一点不同，没有电话线区分开大家，所以，大家是共享同一个“信号空间”的，这个空间由时间、频率、空间以及功率组成，毫无疑问，共享信道系统的资源总是很紧张。\u003c/p\u003e\n\n\u003cp\u003e历史上，让无线/移动通信第一次成为公众可以使用的服务，就来自于对空间的划分。无线信号总是会衰减的，而且衰减的很快，所以，把上述“信号空间”中的“空间”提取出来，将地面划分为很多蜂窝状的小块，相邻小区的其他信号空间要素不同，同样要素相邻一段再重新使用，互相的干扰会接近忽略，这样，就把资源的利用率极大提高了，于是，人人都可以用手机了。这也就是为什么移动网络又叫蜂窝网络了。顺便说一句，中国移动的LOGO就是一个蜂窝的形状，多数人应该看不出来，呵呵，反正中国移动员工知道这个的都不多，呵呵。\u003c/p\u003e\n\n\u003cp\u003e但是，划分小区不是没有代价的，系统需要知道你在哪个小区，才能和你通信，尤其有了终端耗电和节省信号空间的资源约束，移动网络的控制开销是比固定网络大的（包括网络结构上的开销和信令传输量的开销），小区越多，用户移动产生切换的概率就越高，随之而来的消耗就越高，所以1G-4G的在接入网演进的重点就在于频谱利用率的提高。各位可能觉得不移动就不需要有这些开销了，实际也是不准确的，网络需要知道用户的状态，来在有通信的时候找到用户，所以，即使是没有移动，也会在小时级的时间内（一般是2小时左右吧），进行周期性位置更新。所以，大家抠掉电池之后（神马？iPhone用户抠不掉？可以扔到水里啊），拨打它，首先是无法接通（或不在服务区），过一两个小时再播，就是“已关机”，因为它没有定时汇报。\u003c/p\u003e\n\n\u003cp\u003e微信带来的开销有可能和长时间连接带来的更多小区重选、位置更新有关，我不确定，但我认为核心问题是，网络是按照旧业务规划的，不适应新应用的新用法，移动希望双方合作，共同优化，这是一个合理的提议，收费的说法，我觉得炒作成分很大。\u003c/p\u003e\n\n\u003ch2\u003e为什么会有电话网和数据网\u003c/h2\u003e\n\n\u003cp\u003eShell表示，他完全无法理解，在VoIP技术如此成熟的今天，为什么运营商还死抱着电路交换不放。实际上，简单地说，现在运营商的电话网全都是“软交换”（Soft switch）网络，就是一种VoIP技术，也靠这项技术节约了不少成本，大家电话资费的下降，和上面说的频谱利用率提高以及软交换的使用都密不可分，话说，要不是技术提高节约成本了，运营商会发善心，出让利润，给咱们省电话费么。不过，细说起来，电话网和数据网仍然不是一个网络，至少要到4G的核心网技术非常成熟的时候，才会逐渐统一起来。\u003c/p\u003e\n\n\u003cp\u003e在GSM的时代，用户的电话是占用一条专用链路的（电路交换称为CS），当然，电话本身就是双向实时传输的这不算浪费。但如果用来上网就比较浪费了，大家连上网，一般不会不停上传下载，占满线速，所以，虽然GSM电路交换体制下，有高速（其实也不快，跟3G差远了）数据的支持（HSCSD），但太浪费资源，不会有运营商采用的。运营商采用的方式是，小区基站那里不懂，叠加一张数据专用的交换网络让用户看起来一直在，但是只有在传送数据的时候裁占据资源，这个就是GPRS。因为GPRS是后加入的，GPRS和GSM 是几乎两张独立的网络，它们分别要管理各自用户的接入状态等，比如位置更新系统就有两套，因为GPRS同时有通信的用户远比电话网多，所以，为了控制信令规模，它的位置更新机制要更细一些，所以，网络的一直在线，比电话的一直在线开销高，这个不是扯淡，是真的。\u003c/p\u003e\n\n\u003cp\u003e这个CS/PS彼此独立，从GSM/GPRS开始，到3G仍是如此，EDGE只是提高了频谱利用率，3G（确切说是R4以后）进一步提高了频谱利用率，并在核心网引入了软交换，但一方面为了向前兼容，一方面为了在低资源消耗的情况下保障语音和视频电话网络的QoS，电路和是分组交换网一直是分离的，在未来4G的时代，趋势是两者统一，但短时间内，还是彼此独立的。\u003c/p\u003e\n\n\u003cp\u003e至于为什么IP电话还要加拨前缀，我得说，其实电话都是IP的，只是有些更IP一些—— 有质量保障上面的差异，当然也有纯营销手段在里面，大家都是做技术的，但技术和商品名之间的不同，应该还是可以理解的吧。\u003c/p\u003e\n\n\u003ch2\u003e后记\u003c/h2\u003e\n\n\u003cp\u003e嗯，不在电信网络圈子很多年了，这些东西不一定非常确切，也不算是中立立场，仅供互联网圈子的朋友们参考下吧。\u003c/p\u003e\n","cover":"","link":"读后感/2013/04/12/给互联网圈子的朋友们介绍下运营商网络/index.html","preview":"","title":"给互联网圈子的朋友们介绍下运营商网络"},{"content":"\n\u003cp\u003e在上次(\u003ca href=\"http://wangxu.me/blog/p/758\"\u003ehttp://wangxu.me/blog/p/758\u003c/a\u003e)之后，再次改动了 tornado-memcache 模块，\u003ca href=\"https://github.com/gnawux/tornado-memcache/commit/10c5236cb7df764e20986db5cca6868c26e845a7\" target=\"_blank\"\u003ecommit 信息\u003c/a\u003e如下：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eAdd gets method and simplify connection estabilish\u003c/p\u003e\n\n\u003cdiv\u003e\n\n\u003cpre\u003e- simplify connection estabilish procedure, as tornado.iostream\n  permit write before connection estabilished, I removed the\n  callback and connection timeout procedure in _get_server()\n- add `gets(self, keys, callback, failcallback)` method, receive\n  a list of keys as parameter and return a dictionary of results\n  result = {key1:value1, key2:value2...}, only return the got\n  keys from memcached\n- some debug info, might be cleanup later\n\nSigned-off-by: Wang Xu \u0026lt;gnawux……\u003c/pre\u003e\n\n\u003c/div\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e简单地说就是两件事情：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003cspan style=\"line-height: 13px;\"\u003e读了\u003ca href=\"http://www.tornadoweb.org/documentation/iostream.html#tornado.iostream.IOStream.connect\" target=\"_blank\"\u003e文档\u003c/a\u003e，发现 tornado 的 iostream 允许在连接建立未完成的时候就write，既然我之前已经用 iostream 管理 socket 了，这里就省掉上次在这里加上的callback 和 timeout，直接 write command，等 write 的超时或返回就好了；\u003c/span\u003e\u003c/li\u003e\n\n\u003cli\u003e读了\u003ca href=\"https://github.com/memcached/memcached/blob/master/doc/protocol.txt\" target=\"_blank\"\u003ememcached 协议\u003c/a\u003e，发现取信息(get)，是支持一次取多条信息的，于是加入了这个支持，这样，批处理操作时会提高不少效率。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e里面还插入了好多调试的时候的 debug 信息，差不多都注掉了，回头都稳定了再清理一下。\u003c/p\u003e\n\n\u003cp\u003e嗯，代码都在 github 了：\u003ca href=\"https://github.com/gnawux/tornado-memcache\" target=\"_blank\"\u003ehttps://github.com/gnawux/tornado-memcache\u003c/a\u003e\u003c/p\u003e\n","cover":"","link":"scripts/2013/03/07/tornado-memcache/index.html","preview":"","title":"再次改动了 tornado-memcache"},{"content":"\n\u003cblockquote\u003e按：本人 python 菜鸟，对 tornado 更没什么研究，这两天小摆弄了一下，记一下，有不对的还请指正\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这两天在用 \u003ca title=\"Tornado\" href=\"http://www.tornadoweb.org/\" target=\"_blank\"\u003etornado\u003c/a\u003e 做一个 memcached 的 proxy，作为一个 Python 的高性能异步框架，tornado （实际是 epoll/kqueue... ）的思想是——单线程+异步化，线程的运行时间不等待任何东西，这样就要求 memcached 的访问也必须异步化。如果线程在等待中消耗了，就无法达到高并发的目的，这个问题是无法通过简单地交给线程池或什么其他东西来达到的。\u003c/p\u003e\n\n\u003cp\u003e于是，这里就不能用常用的 python-memcache 来做了，实际上有几个基于 tornado 的 memcache 客户端，\u003ca href=\"https://github.com/dpnova/tornado-memcache\" target=\"_blank\"\u003e这个\u003c/a\u003e是维护得相对好的一个，也是一年前的了，而且，有两个问题：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e连接建立是同步的，不是异步的\u003c/li\u003e\n\n\u003cli\u003e没有超时机制\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这样，在 server 或网络出现问题的时候，就可能遇到大麻烦，所以，我的目的就是绞尽脑汁加入超时机制，这个初步做出来了，等把 get 之外的方法也都异步化之后就反馈出来。这里主要依赖的机制就是 tornado 的 stack context——再次声明，我是这个方面的菜鸟，有什么不对的地方大家嘘之余给指出来呗。\u003c/p\u003e\n\n\u003cp\u003eStack context 的意图就是为执行程序保存一个上下文，在需要的时候，可以回到这个上下文执行，包括异常，都可以更好地、统一地处理。这个功能的代码不是很多，也比较清晰，但是文档……嗯，至少我是没看明白，结合 httpclient 的源码作为例子，加上看 stack_context 的代码，大概明白了是怎么用了。\u003c/p\u003e\n\n\u003cp\u003e首先，在希望抓住问题的入口的地方要留住上下文：\u003c/p\u003e\n\n\u003cpre class=\"brush: python; gutter: true\"\u003e        #......\n        context = partial(self._cleanup, fail_callback = fail_callback)\n        with stack_context.StackContext(context):\n            getattr(c, cmd)(*args, **kwargs)\u003c/pre\u003e\n\n\u003cp\u003e这里，后面的执行内容，包括回调、触发事件，都可以通过抛出异常退到这里，而管理异常的就是 context，这里，用 functools.partial 包装了一下 _cleanup，_cleanup 的写法大致是这样的:\u003c/p\u003e\n\n\u003cpre class=\"brush: python; gutter: true\"\u003e    @contextlib.contextmanager\n    def _cleanup(self, fail_callback = None):\n        try:\n            yield\n        except _Error as e:\n            print \u0026quot;gotcha\u0026quot;, e\n            if fail_callback:\n                fail_callback(e.args)\u003c/pre\u003e\n\n\u003cp\u003e这里，异常会被捕获，并调用用户指定的出错回调函数进行处理。后面的代码里，遇到故障，抛出异常就可以了，比如，可以用这个异常来返回超时：\u003c/p\u003e\n\n\u003cpre class=\"brush: python; gutter: true\"\u003e    def _on_timeout(self, server):\n        self._timeout = None\n        server.mark_dead(\u0026#039;Time out\u0026#039;)\n        raise _Error(\u0026#039;memcache call timeout\u0026#039;)\u003c/pre\u003e\n\n\u003cp\u003e这个异常是通过 io_loop 的 timeout 方法来触发的:\u003c/p\u003e\n\n\u003cpre class=\"brush: python; gutter: true\"\u003e            self._timeout = self.io_loop.add_timeout(\n                    time.time() + self.request_timeout,\n                    stack_context.wrap(partial(self._on_timeout, server)))\u003c/pre\u003e\n\n\u003cp\u003e这样，就可以在异步程序里比较干净地处理掉超时问题了。\u003c/p\u003e\n\n\u003cp\u003e这个代码对我这个水平的初学者还是比较晦涩的，大家可以参考下 HTTPClient 的源码，等我把这个 memcached client 的代码改完之后，也会放出来供参考指正的。\u003c/p\u003e\n\n\u003cp\u003e----\u003c/p\u003e\n\n\u003cp\u003eupdate2: 放这里了\u003ca href=\" https://github.com/gnawux/tornado-memcache\"\u003e https://github.com/gnawux/tornado-memcache\u003c/a\u003e , get 测试过，其他还没有，另外，我不是多个 server sharding 的应用场景，相关的还没测试。\u003c/p\u003e\n\n\u003cp\u003eupdate :对于 timeout，设上了表忘了清除，如果是其他方式抛异常退出的话，也在抛异常的地方或者是最后处理异常的时候，把超时去掉\u003c/p\u003e\n\n\u003cpre class=\"brush: python; gutter: true\"\u003e        if self._timeout is not None:\n            self.io_loop.remove_timeout(self._timeout)\n            self._timeout = None\u003c/pre\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"scripts/2013/02/23/tornado-stack-context/index.html","preview":"","title":"Tornado 的 stack context"},{"content":"\n\u003cp\u003e最近用了几下 expect,  记几个心得，以备不时之需\u003c/p\u003e\n\n\u003ch2\u003e循环式匹配: exp_continue\u003c/h2\u003e\n\n\u003cp\u003eexpect 的匹配可以看做是一个循环，通常匹配之后都会退出语句，但如果有 exp_continue 则可以不断循环匹配，输入多条命令\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eexpect{\n    \u0026quot;$passprompt\u0026quot;    { send \u0026quot;$password\u0026quot;; exp_continue }\n    \u0026quot;$prompt\u0026quot; {send \u0026quot;$c\\r\u0026quot;}\n}\u003c/pre\u003e\n\n\u003cp\u003e在这个例子里，遇到密码提示的时候，送出密码，然后继续 expect，遇到命令提示，送出命令，然后退出 expect，当然，可以做得更复杂，一条一条送命令，送没了再退出。这样，expect 的结构会比较漂亮，而且容易扩展。\u003c/p\u003e\n\n\u003ch2\u003e正则匹配: -re\u003c/h2\u003e\n\n\u003cp\u003e作为一种 tcl 的分支，expect 支持 tcl 的正则表达式，正则表达式这里就不多说了，正则匹配的一个重要用途是，对多个匹配关键字进行相同的操作，比如\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eexpect {\n    -re \u0026quot;$prompt|$rootprompt\u0026quot; { send \u0026quot;$c\\r\u0026quot; }\n}\u003c/pre\u003e\n\n\u003cp\u003e这里是对普通用户的提示和root用户的提示进行同样的操作。\u003c/p\u003e\n\n\u003ch2\u003e利用PS1环境变量\u003c/h2\u003e\n\n\u003cp\u003e在 expect 里，根据程序的返回状态做操作不是件容易事，很多做法都不是十分干净，我的一个方法是，根据 $? 的值设置 PS1 环境变量，这样，下一次出现的 Shell 提示就不是之前的提示了，只要特别 expect 这个提示，进行操作就行了。\u003c/p\u003e\n\n\u003cp\u003e嗯，这算是个野路子，不正规哈，欢迎指正。\u003c/p\u003e\n\n\u003ch2\u003e抓取远程的输出到本地：expect_out 和 full_buffer\u003c/h2\u003e\n\n\u003cp\u003e我们经常需要抓取远程的输出，这时，可以借助 expect_out 来抓取两次 expect 之间的内容，它有两个用法：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eexpect_out(buffer) 这个直接抓取两次 expect 之间的全部 buffer\u003c/li\u003e\n\n\u003cli\u003eexpect_out(1,buffer) 这个抓取正则匹配的部分\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e后者这里不多说了，前者有个问题，就是当两条命令之间输出很多时，可能 buffer 会满，在这种情况下，expect_out(buffer) 不是全部的 buffer 内容，而是最后的，这时要靠 full_buffer 帮助了，这里举个例子\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eset result \u0026quot;\u0026quot;\nexpect {\n    \u0026quot;$prompt\u0026quot; {\n        append result $expect_out(buffer)\n        puts stderr $result\n        set result \u0026quot;\u0026quot;\n        send \u0026quot;$newcmd\u0026quot;\n        exp_continue \n    }\n    full_buffer {\n        append result $expect_out(buffer)\n        exp_continue\n    }\n}\u003c/pre\u003e\n\n\u003cp\u003e这时个示例，注意 full_buffer 是特殊匹配事件，类似 timeout，不是字符串。\u003c/p\u003e\n\n\u003cp\u003e嗯，暂时记这些吧。\u003c/p\u003e\n","cover":"","link":"scripts/2012/12/06/expect/index.html","preview":"","title":"一点expect心得"},{"content":"\n\u003cp\u003eMac下的 Tunnelblick 是个很好用的 openvpn 管理工具，嗯，这年月谁还没几个 VPN 啊，你懂的。\u003c/p\u003e\n\n\u003cp\u003e不过呢，总有一些路由希望不走 VPN，比如内网，又比如某些网站，话说原来是在 ovpn 配置文件里用 route 命令配置路由到 net_gateway 的，比如\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eroute 192.168.0.0 255.255.0.0 net_gateway\u003c/pre\u003e\n\n\u003cp\u003e不过，如果有多个VPN配置文件，要修改 IP 列表的时候就很麻烦，放在脚本里，集中起来保持同步才是好办法，根据 openvpn 的文档（ https://community.openvpn.net/openvpn/wiki/Openvpn23ManPage ），这是可以通过 up/down 或 route-up/route-pre-down 做到的，简单说一下，以 up 为例，配置文件要这么写\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eup \u0026quot;/path/to/your/up-script optional parameters\u0026quot;\u003c/pre\u003e\n\n\u003cp\u003e之后，脚本里还会跟进一些 openvpn 送来的参数，比如设备名、mtu、本机和远端 ip 地址等，还有很多环境变量，我们要用的是 route_net_gateway ，这个是开 VPN 之前的缺省网关。\u003c/p\u003e\n\n\u003cp\u003e但是，这么放脚本之后，你会几乎无可置疑地发现脚本根本就没有运行，这个脚本并没有被执行，通过日志可以看出，原因在于——Tunnelblick 会用命令行加入它的自定义脚本，覆盖掉我们指定的，这样我们的就白写了。\u003c/p\u003e\n\n\u003cp\u003e根据 Tunnelblick 的文档（http://code.google.com/p/tunnelblick/wiki/cUsingScripts ），我们知道，这组脚本是用来获取/设置 DNS 的，只要在配置中选择不设置DNS，就可以执行我们的自定义脚本了。\u003c/p\u003e\n\n\u003cp\u003e但是，我们还是需要这组脚本运行的，我们可以替它调用这些脚本的，这样办法就来了——在配置文件里这么写：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eup-restart\nup \u0026quot;/Users/gnawux/bin/bypass-route.sh up\u0026quot;\ndown /Users/gnawux/bin/bypass-route.sh\nroute-pre-down \u0026quot;/Applications/Tunnelblick.app/Contents/Resources/client.route-pre-down.tunnelblick.sh -m -w -d -atADGNWradsgnw\u0026quot;\u003c/pre\u003e\n\n\u003cp\u003e上面第二、三行是指定到我们的脚本，用一个参数区分up和down就可以了，第四行是 tunnelblick 的 route-pre-down 脚本，up和down脚本我们会通过我们自己的脚本来调用，脚本如下，注意最后调用了 tunnelblick 的脚本\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003e#!/bin/bash\n\nPREFIX=/Users/gnawux\nLOGFILE=${PREFIX}/bin/route.log\n\necho \u0026quot;Cmd run on `date` with arguments: $@; Original Net Gateway: ${route_net_gateway}\u0026quot; \u0026gt; ${LOGFILE}\n\nif [ $# -lt 6 ] ; then\n\techo \u0026quot;[WARN] not enough arguments: $@\u0026quot; \u0026gt;\u0026gt; ${LOGFILE}\n\texit 1\nfi\n\nOPERATION=delete\nTB_SCRIPT=/Applications/Tunnelblick.app/Contents/Resources/client.down.tunnelblick.sh\nif [ \u0026quot;$1\u0026quot; = \u0026quot;up\u0026quot; ] ; then\n\tOPERATION=add\n\tTB_SCRIPT=/Applications/Tunnelblick.app/Contents/Resources/client.up.tunnelblick.sh\nfi\n\nwhile read scope ; do\n\techo /sbin/route ${OPERATION} -net ${scope} ${route_net_gateway} \u0026gt;\u0026gt; ${LOGFILE}\n\t/sbin/route ${OPERATION} -net ${scope} ${route_net_gateway} 2\u0026gt;\u0026gt; ${LOGFILE}\ndone \u0026lt;\u0026lt;ENDLIST\n10.53.0.0/16\n58.215.0.0/16\nENDLIST\n\nexec bash ${TB_SCRIPT} -m -w -d -atADGNWradsgnw $@\n#route-pre-down /Applications/Tunnelblick.app/Contents/Resources/client.route-pre-down.tunnelblick.sh -m -w -d -atADGNWradsgnw\n\n\u003c/pre\u003e\n\n\u003cp\u003e中间的 IP 网段列表各位就自行选择吧，最后，别忘了给这个文件执行权限就好了。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"scripts/2012/10/10/mac-下用自定义脚本配置-tunnelblick-的自定义路由/index.html","preview":"","title":"Mac 下用自定义脚本配置 Tunnelblick 的自定义路由"},{"content":"\n\u003cp\u003e10年了，今天太阳升起的时候，我们将重新踏进母校的校门，不过这次没有挂科的压力了……不仅是成功校友，我们屌丝也可以找个黄道吉日回到母校，真是神奇啊。\u003c/p\u003e\n\n\u003cp\u003e在开始多愁善感的日志之前，我想问问我上铺的兄弟——张世谦：你还记得十四年前的九一八，你放在自己钱包里的那张纸条么？你还记得那一晚，我们军训宿舍里的那些散落一地的伤感么？\u003c/p\u003e\n\n\u003cp\u003e大学影响了每个人，即使不是成功人士，我也被位列“四大染缸”之首的母校改变了很多，不仅是老师，更是那些朝夕相处的同学们。在今天，回头看，我不知道自己是否在正确的路上，但知道，现在这条路的起点就是大学，确切地说是拿到工大录取通知书的一刻。\u003c/p\u003e\n\n\u003cp\u003e十八岁的生日，我拿到了大学的录取通知书，好吧，说点开心的，这是我第一次被自己填写在《志愿书》上的一个学校、一个专业接受了，即使它是第二行。这太神奇了，之前的两次，我都是靠“服从调剂”那个勾来摇奖决定未来三年的，这次毫无疑问是个巨大的成功。当然，回头看是如此的轻松，不过你只要问问曾经往钱包里塞纸条的张世谦，或者想想差点挂掉的陈峥宇，还有那个开学时还在学车的袁方就知道，那几天真的不好过，真的很漫长……\u003c/p\u003e\n\n\u003cp\u003e呃……重复失败不是什么让人开心的事，对我这样的缺心眼儿也是如此，但还能怎么办呢？这么痛苦的一个大学的开始，也在刺激我更深刻的自省（嗯，我们班居然有个同学叫申科，但我说的是深刻的自省，和这位隔壁的同学关系不太直接）。回头看看，我今天总结出来的一句话是——“做人是自己学的，不是别人教的”，之前的挫折不止是改变了我人生的轨迹，更让我开始努力去学习该怎么做人，我觉得这才是真正的财富。在整个大学期间，我做了几件让我回忆起来很满足的事情：\u003c/p\u003e\n\n\u003cp\u003e首先，是我在学习面对，是的，不再躲避、不再逃避，面对问题，接受问题，承认问题，同时学会的还有把所谓的“自尊”踩在脚下，当我开始颤抖着嘲笑自己的弱点的时候，我发现，我真的开始改变它、征服它了。真正的自尊不怕嘲解，真正的自信源于自我认知。面对、接受了自己的缺陷、不足、过错之后，我逐渐成长为一个强大而不要脸的屌丝了。\u003c/p\u003e\n\n\u003cp\u003e然后，我开始不断把自己推出自己的“安全区”，不断强迫自己面对挑战。在上大学之前，我从来都是反应慢+手笨+协调性不足的，可大学一开始我就强迫自己在各种实验课上到处出溜，到处乱捅乱动，我不知道当时的同学到底是怎么看这个手笨脸皮厚的家伙的，他们可能想看我出更多丑吧，居然说我动手能力强，在大一假期就把我扔到实验室去了，在这里还真觉得对不起张印春老师的实验室啊。后来，我觉得自己胆子小，不敢在大场面说话，还一有机会就把自己推上讲台去，颤颤巍巍地讲东西去，我不知道当时被我代表的同学们都什么心情，应该有不少人觉得自己上去会比我说得好多了吧。\u003c/p\u003e\n\n\u003cp\u003e再然后，我也想不起来了，我能记得的自己的变化大概就是这样一个趋势。在这些变化里，少不了老师和同学们对我的影响，我相信他们中的很多人可能都没有想到自己的那句话或那件事对我影响那么大，不过，这真的发生了，这里挑几个比较有代表性的：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e第一个影响就是第一任班长李学峰，他一开学就交了14页的思想汇报，从此我就和党组织绝缘了，我相信，写这样的思想报告的人和我，绝对不是一个组织的；\u003c/li\u003e\n\n\u003cli\u003e还有一个是第一任班主任张延华，呃……这个是好事啊……我记得他第一次来我们宿舍——可能是唯一一次？至少是我记住的唯一一句话，他告诉我们，在宿舍里打牌是浪费时间的，没有意义的，从此，我们班的宿舍在开学的时候差不多从来没打过牌，当然了，那些打游戏的同学都出去打游戏了，那些上自习的同学都去自习室了，留下我这样的一两个，想打也打不起来啊；\u003c/li\u003e\n\n\u003cli\u003e另一个影响就是几个四中的同学，他们彪悍的表现让我坚信，以后孩子要是能上四中就好了；\u003c/li\u003e\n\n\u003cli\u003e还有堡哥和袁方啊，他们对数学的热爱和执着让我这个曾经在小学时候当过数学科代表的人不得不承认，人和人是有差距的，我真不是这块料；\u003c/li\u003e\n\n\u003cli\u003e还有张世谦，他的很多言论都让我记到现在且深以为然，比如那个“自卑”理论，基本就是把一切性格或多或少缺陷的表现都认定是自卑的表现，我觉得这个基本可以解释一切，更重要的是，这个理论也在迫使我不断的自嘲啥的，以免被人发现我内心的自卑啊；\u003c/li\u003e\n\n\u003cli\u003e还有那谁，他告诉我做人是不能这样的；\u003c/li\u003e\n\n\u003cli\u003e还有头人，嗯，这个我们私下说啊。\u003c/li\u003e\n\n\u003cli\u003e……\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，算了，就这么多吧。\u003c/p\u003e\n\n\u003cp\u003e其实呢，如果不说这是10年，一切都会这么继续过下去，生活一直在变，从没停下，可能再10年之后，我发现我写的这一切十分2B，也可能10年之后，咱成温拿了，会拼命掩饰，不让人看到这么落魄时对人生的吐槽。可是，我还是愿意，在今天把这一切记下来，这就是我的生活，我的心声。\u003c/p\u003e\n","cover":"","link":"life/2012/09/15/十年/index.html","preview":"","title":"十年"},{"content":"\n\u003cp\u003eShell这东西，如果你真会用的话，你可能永远不敢说你会用。\u003c/p\u003e\n\n\u003cp\u003e前两天看了Process Sub，一种结合了管道和命令替换（command sub）的使用方式，非常有趣。\u003c/p\u003e\n\n\u003cp\u003e嗯，这得先说说命令替换，就是反引号或者 \"$()\"，非常好用，但是，你能把它当成文件用么，有点时候，你要把命令输出送给其他命令处理，而这个命令只是接受文件参数，无法用管道，或者，你要两个命令的输出，没法用管道，怎么办呢，process_sub 来啦，看这个：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003ediff -u \u0026lt;(grep \u0026quot;^5076\u0026quot; strace.log |sed -ne \u0026#039;s/.*futex(\\(0x[0-9a-f]\\),.*//p\u0026#039; |sort|uniq) \u0026lt;(grep \u0026quot;^5061\u0026quot; strace.log |sed -ne \u0026#039;s/.*futex(\\(0x[0-9a-f]\\),.*//p\u0026#039; |sort|uniq)\u003c/pre\u003e\n\n\u003cp\u003e嗯，不解释了，自己理解哈。\u003c/p\u003e\n\n\u003cp\u003eProcess sub 的另一种场合，下面这两个命令几乎是等价的，试图用个循环来做 wc 的工作：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003ewhile read x; do ((y++)); done \u0026lt; \u0026lt;(netstat -nr)\n\nnetstat -nr | while read x; do ((y++)); done\u003c/pre\u003e\n\n\u003cp\u003e不留心很难看出差别，但是，如果这两条命令之前，先把 y 置空，那么，第一个命令之后，y是有值的，第二个则不会。这是因为，管道命令可以看作是\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003ecmd1 | (cmd2)\u003c/pre\u003e\n\n\u003cp\u003e也就是说，后面的命令是在子 shell 里运行的，因此，无法改动父 shell 的内部状态，而 process sub 方式运行的命令则没有这个问题。\u003c/p\u003e\n\n\u003cp\u003e嗯，则个很好玩，前两天刚看到的，参考了 TLDP 的 Advanced Bash-Scripting Guide 。\u003c/p\u003e\n","cover":"","link":"scripts/2012/07/26/bash-process-sub/index.html","preview":"","title":"Bash 的 Process Sub"},{"content":"\n\u003cp\u003e前几天，亚马逊的云服务（AWS）连续发生大规模服务中断，使得默默无闻的EBS（弹性块存储）服务再次被推上风口浪尖。实际上，过去一两年间，差不多所有AWS服务大规模中断，都可以听到EBS的叹息，难怪新浪的程辉兄说：“EBS仍然是公有云最大的难点和故障点”。\u003c/p\u003e\n\n\u003cp\u003e作为国内为数不多的，也大概是最早提供商用EBS服务的团队成员，我当即跳出来为EBS说了几句“公道话”，之后的图灵生日会上，和刘江老师聊天的过程中，他建议我把这些想法写出来，也让用户和相关产业了解，一个EBS服务的设计者是怎么看待自己这个“故障点”的。\u003c/p\u003e\n\n\u003cp\u003e首先说说我的总体观点，EBS是最后一道防线，所以重大故障才往往在EBS身上体现出来。只要存储不出问题，再大的问题也不容易造成长时间、大范围的停机，不论是网络还是计算，都是无状态的，有电、有链路就可以工作，而这些也是最容易通过冗余来保障可用性的；但存储则不同，对存储来说，数据正确是我们第一要保障的，如果真发生严重故障，我们不可以为用户迫切要求的可用性而冒险牺牲正确性。\u003c/p\u003e\n\n\u003ch2\u003e系统设计的哲学：熔断器与冗余\u003c/h2\u003e\n\n\u003cp\u003e没有系统能避免异常情况的出现，大系统的设计中，最复杂、最难处理的地方往往是不常遇到的意外（超负荷）情况，在这里经常用到的两种策略是熔断器和冗余——\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e系统常常设计为可以承担远高于其标称值的负荷，从而在出现异常的情况下，也能持续工作，这是所谓服务能力的冗余\u003c/li\u003e\n\n\u003cli\u003e对于另外一些情况，我们会采取一种看起来和服务可用性背道而驰的策略——停止服务，以避免更严重的损失，这个就类似于电子设备中的熔断器，或者叫保险丝。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这两种策略几乎总是同时用到的——对普通的困难，我们争取用设计上的冗余来克服，让它对用户透明。但是，当系统无法承受的时候，就需要果断地中断服务。什么情况下中断服务，总是设计者最为头痛的地方，他们不愿意向用户暴露自己脆弱的一面，但也不能背弃对用户的承诺——如果你无法保证数据的持久写入，就不能欺骗用户说数据你已经存储好了。\u003c/p\u003e\n\n\u003cp\u003e而没有程序是没有Bug的，这些最极端的情况，往往是设计实现者自己也最难以枚举的，他们的测试很难涵盖到类似的情况，于是，对于包容性比较好的存储系统设计，在这样的困境下，尽力保持现场地退出服务，让独立的运维程序，甚至是人工来介入，恢复服务状态是一种负责任的态度。对于亚马逊的EBS故障情况，我个人基本是这么理解的。\u003c/p\u003e\n\n\u003cp\u003e那么好了，我想，一定有人要问一个问题，既然EBS可能会造成这样的窘境，为什么一定需要这么一个服务呢。\u003c/p\u003e\n\n\u003ch2\u003e让人又爱又恨的EBS服务\u003c/h2\u003e\n\n\u003cp\u003e如果你想成为最好的云服务商，请做EBS服务，这是杀手服务；如果你想成为被人唾骂的云服务商，请做EBS服务，这是你的最大故障点。（改自《北京人在纽约》的经典台词）\u003c/p\u003e\n\n\u003cp\u003e亚马逊大多数的AMI（操作系统镜像）都放在EBS上，亚马逊很多虚拟机都用到了EBS服务，很多数据库都放在EBS磁盘上……亚马逊的EBS需要额外付费，亚马逊的EBS的性能并不稳定，甚至可以说亚马逊的EBS性能公认的不好……这一系列的事实同样是这么矛盾，一遍又一遍地问：为什么人们要用EBS服务呢？\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eEBS服务是便宜的——是的，单独额外付费的EBS反而可能是更便宜的，使用EBS作为操作系统镜像，这会让虚拟机在不需要工作的时候，可以处于stop状态，这个状态是不计费的；而且，使用EBS作为数据盘，可以在不需要计算的时候，销毁虚拟机实例，而在需要时在申请新的虚拟机，直接使用已有EBS上的数据。（后者盛大云已经提供，前者即将提供）\u003c/li\u003e\n\n\u003cli\u003eEBS服务是可靠的——即使虚拟机发生故障，服务器的硬盘发生故障或其他问题，EBS作为一种可靠的持久化存储服务，仍然可以保证数据的可靠性。\u003c/li\u003e\n\n\u003cli\u003e在上面两个优异特性的基础上，更让人兴奋的是，EBS服务居然真是能用的，而且，你的程序可以直接像用本地磁盘一样用EBS，这简直是上天赐予我们的礼物。\u003c/li\u003e\n\n\u003cli\u003e此外，EBS服务有更多的玩法——可以使用RAID，组合多块EBS盘，在一定程度上提高EBS的性能；可以创建快照，可以用快照来恢复成多块EBS盘。(盛大云硬盘的快照功能即将提供)\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e概括地说，EBS提供了持久化的、具有独立于主机的生命周期的、高可用的块存储设备，在这一设备上可以创建支持POSIX语义的本地文件系统（或是Windows本地文件系统）。这些独一无二的特征，让用户们在口诛笔伐这个服务的同时，也离不开这个服务。\u003c/p\u003e\n\n\u003ch2\u003e云中的存储服务的差异\u003c/h2\u003e\n\n\u003cp\u003e实际上，云服务里的存储服务并不少，有对象存储服务（亚马逊的S3和盛大的云存储服务皆在此列），也有块存储服务（亚马逊的EBS和盛大的云硬盘），当然，还有各种关系型、非关系型的云数据库…… 但是，为什么只有EBS服务受到这么大的争议呢。我们知道，数据存储服务可以分为结构化和非结构化，或分为块、对象、文件……但是，抛开数据的形式，不同的存储系统仍然有一类决定性的参数——时延。\u003c/p\u003e\n\n\u003cp\u003eGoogle的Jeff Dean在一次演讲中，引用了这样一组时延数字（节选, 引用链接： https://gist.github.com/2841832）：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eMain memory reference 100 ns\u003c/li\u003e\n\n\u003cli\u003eRound trip within same datacenter 0.5 ms\u003c/li\u003e\n\n\u003cli\u003eDisk seek 10 ms\u003c/li\u003e\n\n\u003cli\u003eSend packet CA-\u0026gt;Netherlands-\u0026gt;CA 150 ms\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这也就是说，使用硬盘的本地程序，期待的是毫秒级的时延，而对于 Web 应用来说，上百毫秒的时延仍然是可以忍受的。\u003c/p\u003e\n\n\u003cp\u003e这也就决定了按照毫秒级时延设计的EBS系统的服务对象是运行在虚拟机上的本地应用，其最主要用法就是包括Ext2/¾, XFS, NTFS在内的各种本地文件系统，这些文件系统将数据和元数据存放在存储设备上，并认为存储是不常出错误的，相信存储设备一定会在可以盼望的时间里返回，而不需要考虑设备突然消失之类的事情。\u003c/p\u003e\n\n\u003cp\u003e与此相反，设计为面向Web应用的对象存储服务的客户应用，包括浏览器中的静态或动态网页、各种客户端的API请求。所有这些访问都通过HTTP API来执行，调用者期待这些服务在上百毫秒，甚至几秒钟内返回，甚至暂时的无法获取也不会对应用有太大的影响。\u003c/p\u003e\n\n\u003cp\u003e既然EBS需要满足毫秒级的时延需求，它的访问方式就必然是在一个数据中心内部的，而且，为保证数据可靠的多副本也必须在一个数据中心内部，否则，数据副本复制的时延和副本故障的切换将很难满足需求。当然，这不是说不可以进行跨数据中心的备份，只是，不可能实现跨数据中心的强一致性副本。\u003c/p\u003e\n\n\u003cp\u003e这样，我们可以发现两点：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e虚拟机中运行的应用强烈依赖EBS存储自身的可靠性，没有考虑，也很难特别考虑EBS的特殊性；\u003c/li\u003e\n\n\u003cli\u003e如果一个数据中心出现大规模断电，比如这次亚马逊的事故，任何EBS服务都是不能保证0服务中断的，因为完美恢复只能依赖这个数据中心中的数据，而存储这些数据的服务器集体断电，需要时间来确保这些数据的正确性。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch2\u003eEBS做了什么\u003c/h2\u003e\n\n\u003cp\u003e尽管我们知道EBS的脆弱性了，但是，我们得说，这种整个数据中心多路断电，同时切换到油机供电也发生故障的情况是极为罕见的，面对这样或更严重的（比如911）的事故，任何机构的民用级别的数据中心中的计算机也很难幸免，这样的故障可能暴露了亚马逊的某个Bug，但并不是说云服务商就比“前云时代”的主机托管安全性差了。\u003c/p\u003e\n\n\u003cp\u003e相反，具备了EBS服务的亚马逊AWS或盛大云服务会给用户更多安全保障，这些保障包括：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e不依赖于虚拟化服务器的本地硬盘。硬盘是PC服务器故障的重灾区，而且不论是服务器的电路故障还是硬盘物理故障，都会导致依赖于本地硬盘的服务无法继续；\u003c/li\u003e\n\n\u003cli\u003e可以透明处理单机/单块硬盘的故障，在系统内任何一台服务器出现故障时，都不会影响存储服务的正常工作；\u003c/li\u003e\n\n\u003cli\u003e良好设计的EBS系统，在更严酷的故障面前，可以进行较好的自我保护，在服务被迫中断时，也尽量避免数据不一致等问题出现；\u003c/li\u003e\n\n\u003cli\u003e相对于SAN设备，成本低廉，对于用户来说，成本同样也更低。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e基于这些考虑，我为EBS追加的辩护词里写到：虽然在极端故障下，EBS可能成为命门，但在更多情况下，EBS为云服务提供了更好的保障。持久存储仍然是故障面前你最可以依赖的。\u003c/p\u003e\n\n\u003ch2\u003e如何使用EBS\u003c/h2\u003e\n\n\u003cp\u003e对于EBS的使用，实际上和本地硬盘区别不大，可以直接使用，甚至做RAID，利用条带化来提高一定的性能。所有这些都非常简单易用。但是，EBS毕竟和本地磁盘还是有一定差异的，尽管应用无法感知，但用户还是需要在使用时有所注意。\u003c/p\u003e\n\n\u003cp\u003e首先，EBS的时延略高于本地磁盘。由于加入了网络传输过程，EBS的时延会比本地磁盘访问略高一点，这样，单线程、串行小请求的qps一定会受到比较大的影响，无法充分利用EBS的带宽。因此，在应用选择与架构设置时，如果可以更多地并发进行IO访问，会在IO性能方面有不错的收益。在Windows上观测，用FastCopy复制数据就会比Windows自带的复制程序快，用IOMeter加高outstanding IO值，就会获得很好的性能数据。特别地，对于Linux，利用预读设置\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003e/sbin/blockdev --setra 1024 /dev/xvdb\u003c/pre\u003e\n\n\u003cpre\u003e\u0026lt;span class=\u0026quot;Apple-style-span\u0026quot; style=\u0026quot;font-family: Georgia, \u0026#039;Times New Roman\u0026#039;, \u0026#039;Bitstream Charter\u0026#039;, Times, serif; font-size: 13px; line-height: 19px; white-space: normal;\u0026quot;\u0026gt;来增大块设备预读大小，可以明显地提升顺序读的性能，对于其他读写操作没有影响。我们也已经对盛大云计算的EBS缺省加入了这个设置参数。\u0026lt;/span\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e其次，EBS是共享存储带宽的服务，因为在很多应用中，存储本身不像CPU那样，是持续访问的，而是簇发方式地读写，为充分利用带宽，也为了让有需要的主机得到更好的性能，在其他卷不工作时，是允许某些卷占据超出平均值的存储带宽的。这样，在不同的时间，不同虚拟机得到的IO带宽是会有比较大的波动的。用户无法应该期待所有IO访问性能都是一致的。用户需要合理地利用系统缓存或缓存服务，并在必要时对数据进行分区，从而满足应用的需求。\u003c/p\u003e\n","cover":"","link":"cloud/2012/07/05/云计算中的持久化与安全性/index.html","preview":"","title":"云计算中的持久化与安全性"},{"content":"\n\u003cblockquote\u003e原文发于5月号《程序员》\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003ch2\u003e\u003cstrong\u003e改变互联网的\u003c/strong\u003e\u003cstrong\u003e \u003c/strong\u003e\u003cstrong\u003eIaaS服务\u003c/strong\u003e\u003c/h2\u003e\n\n\u003cp\u003e4月10 日早上，我和老婆提起，“今天早上的大新闻是 Instagram被Facebook 收购了， 10亿美金，iOS 平台上最受欢迎的拍照分享服务”，我故意顿了一下，说“这家公司现在只有 13个人。”老婆立刻惊问，“他们怎么做到的？”确实难以置信，在去年年底冯大辉先生在DBANotes的《Instagram 架构笔记》（\u003ca href=\"http://www.dbanotes.net/arch/instagram.html\"\u003ehttp://www.dbanotes.net/arch/instagram.html\u003c/a\u003e）里提到，“只有三名工程师，所以自己部署机器到 IDC是不靠谱的事情。幸好有亚马逊。” 是的，是亚马逊的IaaS服务—— AWS改变了游戏规则。\u003c/p\u003e\n\n\u003cp\u003e本文希望从技术角度，介绍IaaS服务商借助哪些核心技术提供了这样的能力，而创业者如果希望将来能和Instagram一样，服务上千万的用户、存储上亿张照片的话，应该如何更合理地使用IaaS云服务。\u003c/p\u003e\n\n\u003ch2\u003e\u003cstrong\u003e互联网创业的后AWS时代\u003c/strong\u003e\u003c/h2\u003e\n\n\u003cp\u003e实际上，互联网的从业者都知道，在AWS上的成功案例远不止这一家，去年QCon杭州的云计算主题的引言里，笔者就提到了Dropbox的案例，Zynga的成长也是AWS的受益者，同样的受益者还包括Foursquare, Quora… 正是AWS，或者说靠谱的IaaS服务的存在，才为这些创业公司的成长铺就了道路，以至于业界有了“后AWS时代”的提法。具体地说，后AWS时代都包含了那些特征呢：\u003c/p\u003e\n\n\u003cp\u003e随时可用的资源池——服务上线之前，创业者不需要租用IDC的机架位，也不需要购买服务器，更不需要去机房插网线，当服务需要上线的时候，在资源池里租用刚好够用的服务即可，没有固定资产投入，运维投入也是从服务上线部署才开始的。根据Zynga的案例（Zynga在没用AWS时，用户增加，运维加班严重，运维老大怀孕的老婆都来机房帮忙插网线，后来用了AWS，就再也无此窘境了 \u003ca href=\"https://blog.khsing.net/2011/10/%E6%94%BEamazon%E7%9A%84%E6%88%90%E6%9C%AC.html\"\u003ehttps://blog.khsing.net/2011/10/%E6%94%BEamazon%E7%9A%84%E6%88%90%E6%9C%AC.html\u003c/a\u003e），网友曾经杜撰过一条广告词——“AWS，让你的老婆在家安心待产”。\u003c/p\u003e\n\n\u003cp\u003e快速弹性——如果仅仅是方便的主机资源，那么也就不需要所谓“云计算”了，VPS们已经做得很好了。但是，Draw Something只用了几周就有每日1500万活跃用户和每秒3000张图片，Animoto 需要在3天之内将主机从5台增长到5000台（\u003ca href=\"http://www.weibo.com/1642316384/yaS0on3xm\"\u003ehttp://www.weibo.com/1642316384/yaS0on3xm\u003c/a\u003e），这样的规模和扩展速度，不仅依赖于网站的良好架构，也依赖于基础设施服务的高弹性。换一个角度考虑，如果你期望自己的服务也可以以这样梦幻速度增长，却不希望一下就准备这么多资源的话，具有快速弹性的IaaS服务无疑是你的首选。\u003c/p\u003e\n\n\u003cp\u003e用量计费——有了上面两项特性，相应地，成本也需要细粒度地按照用量来计算才划算，对于主机，只需要为运行的时间付费（随时可以新申请或释放掉主机资源），对于存储，只为使用的空间和流量付费，对于网络，只需要关心实际使用了多少流量。这样更能为小型的刚刚起步的服务节约成本。\u003c/p\u003e\n\n\u003cp\u003e按需自服务——所有上面的特征都依赖于便捷的使用，IaaS服务不仅可以通过页面点击完成资源的申请和释放，而且可以通过API，直接编程进行资源操作，配合自助的监控服务，IaaS的用户可以根据服务的负载情况，自动的增加或删除使用的资源，既保证终端用户的体验，又无需无谓付出成本。\u003c/p\u003e\n\n\u003cp\u003e新的互联网创业模式正式建立在这些特征之上的，他们可以更专注于应用的开发、低成本地提供服务。下面我们就来看具体提供这些特征的核心技术，以及如何使用这些技术和服务，确实获得这些期望的特征。\u003c/p\u003e\n\n\u003ch2\u003e\u003cstrong\u003e弹性的基础设施\u003c/strong\u003e\u003c/h2\u003e\n\n\u003cp\u003eIaaS的基础设施提供了从计算到存储一整套和传统计算机平台完全一致的环境，从而最大程度地方便了既有应用向云平台的迁移，但是云平台也不是“银弹”，并不是一切传统应用迁移到云上就可以无限扩展了。要想引爆云平台带来的弹性，还需要可扩展的网站架构以及合理利用云基础设施的各项实用功能。\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003e面向扩展的服务架构\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003e成为“合格”的云应用，服务架构自身的体质是最重要的。可扩展性，或者说弹性、可伸缩性，追求的是，当服务的节点规模增加时，服务能力也可以线性或近似线性的提升。这就需要服务请求可以被良好地、互不干扰地分配到多个节点上执行。\u003c/p\u003e\n\n\u003cp\u003e简单地，我们可以把一般的网站架构分成“服务”和“数据”两个大的层次，前者接纳用户的访问请求，执行各种计算任务，从数据层获取状态信息，并将可能存在的处理结果持久化到数据层；而数据层则要保证数据的正确性、一致性和可用性。\u003c/p\u003e\n\n\u003cp\u003e为了线性扩展，服务层就必须做到无状态，这样，任何新上线的节点都可以分担同样的负载请求。同时，要对数据和对数据的访问进行均匀的分片（sharding），在著名的eBay的分布式实践（\u003ca href=\"http://www.infoq.com/cn/articles/ebay-scalability-best-practices\"\u003ehttp://www.infoq.com/cn/articles/ebay-scalability-best-practices\u003c/a\u003e）中，强调任何数据都要被分片，并避免分布式事务，这样，当面临海量请求的时候，才可以分而治之，而不是互相影响导致崩溃，重蹈火车订票系统的覆辙。尽管“分治”的思路很简单，但要做到均匀且可动态扩展却并不容易，一方面需要合理选择划分依据，另一方面需要数据存储层面的一些配合，后面的内容还会继续介绍多种云中的和分布式的存储技术。\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003e虚拟化技术：弹性的基础\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003e笔者个人并不赞同过度夸大虚拟化对云计算中的意义，显然虚拟服务器上的服务不能被称为“云服务”，但也无法否认，正是日益成熟的虚拟化技术，才让云计算的IaaS服务真正可以成功地大规模投入商业运营。\u003c/p\u003e\n\n\u003cp\u003eDavid Wheeler的有一句名言：“计算机科学中的一切问题，都可以通过再增加一个中间层来解决”（Diomidis Spinellis. \u003ca href=\"http://www.dmst.aueb.gr/dds/pubs/inbook/beautiful_code/html/Spi07g.html\"\u003eAnother level of indirection\u003c/a\u003e. In Andy Oram and Greg Wilson, editors, \u003cem\u003eBeautiful Code: Leading Programmers Explain How They Think\u003c/em\u003e, chapter 17, pages 279–291. O'Reilly and Associates, Sebastopol, CA, 2007.），虚拟化计算技术就是这个在多任务操作系统出现之后，又在操作系统和硬件之间插入的中间层，它解决的问题包括：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e一台计算机的处理能力已经足够满足多个用户的需求了，但在分给多个租户的时候，他们需要的操作系统环境不尽相同，也需要彼此安全地隔离；\u003c/li\u003e\n\n\u003cli\u003e动态的调整一台计算机（或者说操作系统）的物理资源不够容易，至少不容易自动化；\u003c/li\u003e\n\n\u003cli\u003e安装或迁移一台服务器需要大量的时间，而且不灵活。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e虚拟化技术主要是一种隔离与监视技术，让不同的虚拟机分享同一套物理机（主要指CPU/内存子系统）而彼此隔离、互不干扰，同时，为虚拟机代理访问网络、磁盘IO等共享的外部资源。由于虚拟化技术对CPU/内存子系统工作的干扰很少，因此，计算能力方面很少有开销，相比之下，IO的性能受到的影响会略大一些，但也是可以接受的。\u003c/p\u003e\n\n\u003cp\u003e目前的IaaS服务中，主要的虚拟化技术包括开源的Xen、KVM，以及VMWare的ESX和微软的Hyper-V。它们的工作原理都比较接近，以Xen为例，它通过一个hypervisor来监控管理多个不同的虚拟机（称为Domain），并将IO等访问特权资源的操作在专门的特权域（Dom0）中执行，其他的运行客户操作系统的虚拟机称为用户域（DomU）。某些DomU操作系统是被修改过的操作系统，它们知道自己运行在虚拟化环境中，并不直接和硬件打交道，于是，它可以将IO请求通过“XenBus”直接发送到Dom0，由Dom0代理完成，这种方法效率很高，称为半虚拟化（PV, ParaVirtualization）。对于不支持以PV方式运行的虚拟机，我们需要首先实现一个虚拟的设备（在Linux下，Xen和KVM的虚拟设备都是基于Qemu的），提供给虚拟机，它再将这些IO请求代理发出，这种方式的IO相比之下更加繁琐，效率更低，称为完全虚拟化（FV, Full Virtualization），优点是可以兼容任何操作系统，无需修改。\u003c/p\u003e\n\n\u003cp\u003e实际上，在VPS主机服务和各种内部的虚拟化服务方案中，还使用另一种虚拟化技术，包括Linux的OpenVZ、vServer以及Sun的Zone等技术，这些技术利用操作系统内核本身的特性，在操作系统中划分出多个强隔离分区，从而解决资源共享的问题。但是，这种方案下，多个虚拟机是共用同一个内核的，隔离性不高，也不可能支持不同虚拟机使用不同类型的操作系统，因此，IaaS服务普遍不会使用这项技术。\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003e实现快速扩展的公有云运维技术\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003e即使虚拟机可以快速分配、部署了，用户的服务程序的部署也不见得是一个简单的过程，尤其要在服务提供的过程，自动化地扩充服务器，更需要费一番力气。实际上，除了使用配置服务等“传统手段”之外，IaaS服务商们还提供自己的一些运维用工具，帮助用户更好地实现弹性服务。\u003c/p\u003e\n\n\u003cp\u003e这些技术之一就是快照/镜像服务，很多云服务商都已经提供了这项功能，它可以帮助用户保存虚拟机的一个快照性质的副本，一旦用户的虚拟机发生故障，可以用于恢复虚拟机；同时，因为用户的应用服务器一般是无状态的，这样，通过定制镜像可以直接快速复制出大量的包含用户应用的，相同配置的虚拟机。而且，对于实现良好的IaaS服务，镜像服务系统可以加速热点镜像的传播，进一步加速了用户服务的扩展。\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003e通过API实现自动扩展\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003eIaaS的目标之一就是帮助用户尽可能的降低运维的复杂度，即使用户需要随着服务规模的增长迅速扩展服务能力，仍然能够举重若轻。这里，不可忽视的一个方面就是云服务的API，对于一个“可编程”的IaaS服务，用户可以在业务需要时，通过RESTful API请求来直接创建新的虚拟机，而无需登陆管理页面。\u003c/p\u003e\n\n\u003cp\u003e更进一步，与监控程序配合，用户的扩展脚本可以根据性能监控的数据，用户可以实现在业务流量在一定范围内发生变化时，无人值守地扩展或缩小服务规模，既不浪费资源，又不影响服务质量。通过云监控、API和扩展脚本，以及上面提到的镜像服务的配合，用户可以实现高效可靠的自动化扩展能力。\u003c/p\u003e\n\n\u003ch2\u003e\u003cstrong\u003e善用存储服务\u003c/strong\u003e\u003c/h2\u003e\n\n\u003cp\u003e前面提到数据层对于网站可扩展性的重要性，这里就要展开介绍云中的各种存储服务。存储本身说来简单，但实际需求却很多样，有提供客户端访问的，也有服务自己的元数据；有需要持久化的，也有用于加速的缓存；有要求严格一致的交易数据，也有不太重要的状态更新；有结构化的，也有非结构化的。而不同的存储系统、存储服务也是为不同的用途所准备的，要真的做到高效、低成本、可扩展，就需要为服务选择合理的存储服务。\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003e对象存储服务\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003e对象存储服务是指可以通过HTTP RESTful接口的API，以键值访问的数据对象，典型的对象存储服务是亚马逊的S3服务以及国内相应的云服务商的云存储服务。通常对象就是一个文件，如图片或文档、音乐、压缩包等，而用于标识对象的键值可以看作是文件名。对象被组织在称为桶（bucket）的容器中，每个桶可以指定特定的访问权限等属性。与网盘或分布式文件系统不同，对象存储服务不提供全局的命名空间和复杂的目录树，只有桶-对象二级结构，这简化了系统的实现、也提高了访问效率，当然，要把直接使用既有服务迁移到对象存储服务上来，需要进行一定的调整：\u003c/p\u003e\n\n\u003cp\u003e对象存储服务的访问URL一般是类似下面的形式：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://s3.amazonaws.com/ppt-download/cloud-bupt-phpapp01.pdf?\"\u003ehttp://s3.amazonaws.com/ppt-download/cloud-bupt-phpapp01.pdf?\u003c/a\u003e...\u003c/p\u003e\n\n\u003cp\u003eURL的路径部分就是对象的逻辑结构，而“?”之后的参数部分会包含请求的Token和其他相关参数。在页面中，将附件、图片等托管到对象存储中实际并不需要太多的调整。\u003c/p\u003e\n\n\u003cp\u003e对于使用IaaS云搭建的云服务，推荐使用云存储服务存放需要浏览器或是客户端直接下载的静态内容，因为这样一方面可以直接使用云服务带来的高可靠、高可用性，利用云服务商提供的网络加速功能，同时，相对于虚拟机存储空间的局限性和其他存储服务的成本来说更低廉，也不会占用虚拟机服务的带宽，是一种性价比更高的存储服务。\u003c/p\u003e\n\n\u003cp\u003e在网页的图片和附件之外，对象存储还胜任很多其他场合，如网盘和计算机间的数据同步，著名的同步服务Dropbox就构建在亚马逊的S3上，而苹果的iCloud也被认为可能构建在亚马逊的云上。时至今日，亚马逊的S3已经是最受欢迎的云基础设施服务了，截止到2012年1月，亚马逊S3中已经存储了7620亿个对象了（\u003ca href=\"http://www.36kr.com/p/79515.html\"\u003ehttp://www.36kr.com/p/79515.html\u003c/a\u003e）。在国内，IaaS服务商们也提供了类似的服务，但国内的用户市场还在培育之中。\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003e云硬盘服务\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003e云硬盘服务或弹性快存储服务（EBS, Elastic Block Store）并不是网盘，而是一种提供给弹性计算中的虚拟机使用的，具有独立于虚拟机的永久存储能力和高可用性的存储服务。对于虚拟机来说，云硬盘使用起来就是一块硬盘。用户可以申请一块任意大小（一般是1-1000GB之间的整数GB）的云硬盘，将它挂载到自己的任意虚拟机上使用，也可以将它同一台虚拟机上卸载，并挂载到另一台虚拟机上，甚至于可以删除所有虚拟机，只保留云硬盘。\u003c/p\u003e\n\n\u003cp\u003e相对于虚拟机自己的存储空间，云硬盘的大小更灵活、可以由用户指定；云硬盘具有更高的可靠性，即使虚拟机发生故障，云硬盘由于有后台的类似RAID的多副本保障，仍然可以保障数据的可靠；云硬盘的生命周期与虚拟机彼此独立，弹性计算服务鼓励用户在不使用时，释放虚拟机，让出资源，同时也节约自己的开销，这样的情况下，云硬盘可以承担数据持久化的功能，不必因为释放虚拟机就丢弃数据。\u003c/p\u003e\n\n\u003cp\u003e尽管作为一块硬盘，云硬盘显然可以存放图片、附件等内容，但并不意味着云硬盘是比对象存储更好的存储系统。两者是面向不同用途的，如上所说，使用对象存储意味着更低的成本和往往更好的客户端访问性能，可以利用服务商的网络加速能力，并且不占用虚拟机的网络流量；作为对比，云硬盘可以从虚拟机更快的访问（读取操作平均响应时间一般是小于10毫秒的），各种程序可以像访问本地磁盘一样使用云硬盘中的数据，当然，云硬盘会比云存储贵一些，因此，相对于面向客户端请求的对象存储服务，云硬盘更倾向于存放数据库等供虚拟机直接使用的持久化数据。\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003e云中的关系型与非关系型数据库\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003e毫无疑问，Web 2.0时代的基石之一是一种开源的关系型数据库——MySQL，但随着移动互联网和社交网络的发展导致的数据爆炸性增长，关系型数据库的范式模型和事务性限制了它们在保持原有功能性的情况下，水平扩展到更多节点上。于是，在“大数据（BigData）”时代，很多非关系型数据库（NoSQL）开始受到越来越多的推崇。\u003c/p\u003e\n\n\u003cp\u003e根据Brewer的CAP原理，对于一个分布式系统，一致性（Consistency）、可用性（Availability）和分区耐受性（Partition Tolerance）三个特性，只能强化其中两个。作为面向大数据的分布式存储系统，分区耐受性是必须的选择，因此，就不得不在一致性和可用性之间抉择，选择一致性的系统不得不在有些情况下无法提供服务，而那些强化可用性的服务则允许系统在某些时刻不完全一致，也就是所谓的“最终一致性”。用户在选择一个存储系统时需要选择，自己的数据模型怎样、是否需要强一致性。当然，NoSQL和MySQL之间并非取代关系，两者各有优势，并且，笔者负责任的说，大部分的应用还没到MySQL无法承受的数据规模，只是有的需要更良好的架构设计而已。\u003c/p\u003e\n\n\u003cp\u003e而对于NoSQL，也有很多可以选择的，比较流行的包括面向JSON文档的、灵活的MongoDB，主要用于内存缓存的、高性能的、通过键值方式访问的Redis，基于Hadoop、提供列族模型的HBase，以及同样提供列族模型的、写入性能很高的、无中心的Cassandra等。\u003c/p\u003e\n\n\u003cp\u003e很多IaaS云服务商也提供了SQL与NoSQL的增值服务，用户可以选择安装、调优好的虚拟机，作为云数据库服务。\u003c/p\u003e\n\n\u003ch3\u003e\u003cstrong\u003eCDN服务\u003c/strong\u003e\u003c/h3\u003e\n\n\u003cp\u003eCDN（内容推送网）服务很难确切定位为存储还是网络服务，它是用于加速用户的网络访问的，其加速手段是通过部署在接近终端用户位置的缓存服务器，向他们提供高速内容服务的。\u003c/p\u003e\n\n\u003cp\u003e传统的CDN服务一般是面向访问量很大的客户的加速服务，不仅贵，而且购买、调整不方便。而IaaS云服务商面向他们的客户，提供了自助化的CDN加速服务，使得中小网站也可以享受到同样的加速服务。\u003c/p\u003e\n\n\u003ch2\u003e \u003cstrong\u003e展望：从IaaS到PaaS\u003c/strong\u003e\u003c/h2\u003e\n\n\u003cp\u003e虽然相对于IaaS，PaaS还没有大量的改变我们生活，但并不妨碍很多业内人士将其视为公有云的未来 。与IaaS的简单直接不同，PaaS服务并不直接提供资源，而是提供运行环境和功能组件（库）以及附加的服务，如数据库、队列及其他特殊功能，更方便开发者的开发、部署，而将伸缩、扩展等复杂性进一步屏蔽。\u003c/p\u003e\n\n\u003cp\u003e在PaaS服务逐渐成熟的同时，一些开构建在的IaaS层之上的PaaS服务也开始出现，成为IaaS的增值服务，使得两者的界限逐步开始模糊。此外，一些可以构建在多种IaaS服务上的“开放PaaS”平台的出现，更进一步方便了IaaS服务商提供附加的PaaS服务，给用户更多的选择。这一演进将进一步降低运维开销，让创业者把精力更多专注于创新和提高用户体验上，彼此共赢。\u003c/p\u003e\n","cover":"","link":"cloud/2012/07/05/改变互联网的iaas服务/index.html","preview":"","title":"改变互联网的IaaS服务"},{"content":"\n\u003cp\u003e前几天看了 ZeroMQ 的文档，真心喜欢，自己写了几个小例子摆弄了一下，最后写了这个极为简单的幻灯片，供有兴趣的同学参考 :)\u003c/p\u003e\n\n\u003cp\u003e链接在这里：\u003ca href=\"http://www.slideshare.net/gnawux/zeromq-13429542\"\u003ehttp://www.slideshare.net/gnawux/zeromq-13429542\u003c/a\u003e\u003c/p\u003e\n\n\u003cdiv style=\"width:425px\" id=\"__ss_13429542\"\u003e \u003cstrong style=\"display:block;margin:12px 0 4px\"\u003e\u003ca href=\"http://www.slideshare.net/gnawux/zeromq-13429542\" title=\"ZeroMQ简介\" target=\"_blank\"\u003eZeroMQ简介\u003c/a\u003e\u003c/strong\u003e \u003ciframe src=\"http://www.slideshare.net/slideshow/embed_code/13429542\" width=\"425\" height=\"355\" frameborder=\"0\" marginwidth=\"0\" marginheight=\"0\" scrolling=\"no\" style=\"border:1px solid #CCC;border-width:1px 1px 0\" allowfullscreen\u003e\u003c/iframe\u003e\n\n\u003cdiv style=\"padding:5px 0 12px\"\u003e View more \u003ca href=\"http://www.slideshare.net/\" target=\"_blank\"\u003epresentations\u003c/a\u003e from \u003ca href=\"http://www.slideshare.net/gnawux\" target=\"_blank\"\u003eXu Wang\u003c/a\u003e \u003c/div\u003e\n\n\u003c/p\u003e\u003c/div\u003e\n","cover":"","link":"works/2012/06/25/zeromq-intro/index.html","preview":"","title":"ZeroMQ简介"},{"content":"\n\u003cp\u003e昨天半夜被季总转发的一篇微博（\u003ca href=\"http://www.weibo.com/1407449582/yowcksTWf\"\u003e这里\u003c/a\u003e）的勾起了多年的《孙子兵法》回忆，在微博连载了对兵法十三篇的前八篇的心得，不过没什么同学感兴趣啊，不论如何，今天贴回到 blog 上吧，纯粹的个人感悟，很可能不对，有兴趣的做参考吧，按前八篇顺序如下（下面的链接是链到原微博的，不是原文哈）：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.weibo.com/1407449582/yowfZFvow\"\u003e始计第一\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e孙子兵法十三篇，寥寥几千字，其实是一本哲学书，和具体战术关系不大，尤其是前八篇，高中的时候曾经蛋疼背过。始计第一：核心是用兵关乎国家存亡，是国家大计，出兵之前，从道、天、地、将、法几方面就可以判断可否得胜，还提到用兵者，诡道也。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.weibo.com/1407449582/yowgRsD8e\"\u003e作战第二\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e作战第二，名为作战，实为后勤，用兵受限于补给支持能力，所以“兵贵胜，不贵久”（常被不当地引申为“兵贵神速”），力求以战养战\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.weibo.com/1407449582/yowhReuH0\"\u003e谋攻第三\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e谋攻第三：这篇讲的是开战后的总体策略，有很多名言核心包括——能不打就不打（“不战而屈人之兵”），以多打少（“识众寡之用”），还有著名的“知彼知己者，百战不殆”\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.weibo.com/1407449582/yowjj5fta\"\u003e军形第四\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e 军形第四：胜败由实力而定，用兵不可以追求超出自己实力范围的目标，胜兵先胜而后求战，败兵先战而后求胜，“故胜兵若以镒称铢；败兵若以铢称镒”。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.weibo.com/1407449582/yowkw7eXw\"\u003e兵势第五\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e兵势第五，就是刚才提到的那篇，上一篇是讲胜负已由形定，这一篇是，通过势构造胜形——“故善战者，求之于势，不责于人故能择人而任势。” ，比喻起来是这样的——“木石之性，安则静，危则动，方则止，圆则行。故善战人之势，如转圆石于千仞之山者，势也。”\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.weibo.com/1407449582/yowlR9yNv\"\u003e虚实第六\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e虚实第六，前两篇是从自己出发，构造胜势，这一篇是讲要关注敌人的弱点，这篇最著名的一句话是——“夫兵形象水，水之形避高而趋下，兵之形避实而击虚；水因地而制流，兵因敌而制胜。故兵无常势，水无常形，能因敌变化而取胜者，谓之神。”\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.weibo.com/1407449582/yownDFeK7\"\u003e军争第七\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e军争第七，军争这篇主要讲如何调动敌人、抓住敌人的弱点，避免被敌人调动、抓住弱点。这篇最著名的一句倒是不太凸显主题，“故其疾如风, 其徐如林，侵掠如火，不动如山”——就是著名的“风林火山”\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.weibo.com/1407449582/yowph1oCO\"\u003e九变第八\u003c/a\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e九变第八，这篇名为九变，却是告诉主将要有主见，目标明确才可以各种变通，可谓“无恃其不来，恃吾有以待也”。有目标之后，其他问题都是可以变通的，任何事情都有利有害，不能纠结在一点上，“覆军杀将，必以五危”中，即使是“爱民”这样的优点，过于执着也会引来杀身之祸。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e当年背了前几篇，感觉很多适合做签名档的句子，不错，后面的行军、地形、九地、火攻和用间都没仔细琢磨过，因为觉得具体的东西随着时间的流逝，有效性会降低。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"读后感/2012/06/19/《孙子兵法》阅读指南/index.html","preview":"","title":"《孙子兵法》阅读指南"},{"content":"\n\u003cp\u003e唉，现在居民楼里无线环境太复杂，缺乏规划，干扰源太多，在一个屋子里的低干扰频点到别的屋子里可能就状况很差了，即使在不到70平米的家里都是如此，只好找来老笔记本，用 hostapd 搭了一个 AP，弥补覆盖的不足……\u003c/p\u003e\n\n\u003cp\u003e本来没想写的，不过还是记记吧，省得荒废了 blog，其实内容不值一提，都是很简单的设置，网上资料很多，这里就是日记一下哈，不算教程。\u003c/p\u003e\n\n\u003cp\u003e先是找来了弃之不用很久的老笔记本——04年的华硕 M2Ne，一代迅驰平台配二代迅驰的CPU（Dophin内核），这个不知道还有多少同学对它有印象啊，呵呵\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003egnawux@case:~$ cat /proc/cpuinfo\nprocessor\t: 0\nvendor_id\t: GenuineIntel\ncpu family\t: 6\nmodel\t\t: 13\nmodel name\t: Intel(R) Pentium(R) M processor 1.50GHz\nstepping\t: 6\nmicrocode\t: 0x17\ncpu MHz\t\t: 600.000\ncache size\t: 2048 KB\nfdiv_bug\t: no\nhlt_bug\t\t: no\nf00f_bug\t: no\ncoma_bug\t: no\nfpu\t\t: yes\nfpu_exception\t: yes\ncpuid level\t: 2\nwp\t\t: yes\nflags\t\t: fpu vme de pse tsc msr mce cx8 apic mtrr pge mca cmov clflush dts acpi mmx fxsr sse sse2 ss tm pbe up bts est tm2\nbogomips\t: 1199.98\nclflush size\t: 64\ncache_alignment\t: 64\naddress sizes\t: 32 bits physical, 32 bits virtual\npower management:\u003c/pre\u003e\n\n\u003cp\u003e嗯，拿来之后看了看手头的东西，装了个 Ubuntu 12.04，本来想装 Debian Sid 的，没想到 Unetbootin 做的 Debian USB 启动盘，居然没 boot，Ubuntu 倒是 boot 了，当然，不是同一个 U 盘，不知道是盘的事还是镜像的事，嗯，无所谓了。装起来之后，果断起不来 hostapd，果不出我所料，Intel IPW2100 网卡是进不了 AP mode 的，3945 以后的使用 mac80211 的才可以。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e嗯，这里插一句，我凭印象说了，不一定对啊。大约在早几年，那会我还没毕业，天天折腾 Linux，知道最早的 ipw 无线网卡的 mac 层驱动是 softmac，后来移植到的 mac80211，这倒不是说后者是 hardmac 哈，实际上都是软件实现 MAC 层，嗯，这是网络第二层的一个子层，不是水果家的东西哈。softmac 写得比较乱，而 mac80211 是一次重构，而且更彻底的把控制挪到软件层来做了，对AP模式之类的模式也支持的更好。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e嗯，大概就是上面的意思，不是很准确，不要拿去引用就好。还好哥翻箱倒柜找到了一块当年二手收的 BCM4318 （bg 双模的，比 ipw2100 强），嗯，当年收来给 linux 玩没问题，不过这个本后来给老婆装 windows 了，居然 windows 一起来只认 intel 的无线网卡，只好换回去，我这次找到这块 BCM4318 的时候，在一个破箱子里，用破纸包着……唉，苦了你苦守寒窑这么多年啊，终于又要发挥余热了。\u003c/p\u003e\n\n\u003cp\u003eBCM43xx 无线网卡目前的驱动模块是 b43，需要 broadcom 家的 firmware，可以用这两个包，自动安装：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eii  b43-fwcutter                     1:015-9                                  Utility for extracting Broadcom 43xx firmware\nii  firmware-b43-installer           1:015-9                                  Installer package for firmware for the b43 driver\u003c/pre\u003e\n\n\u003cp\u003e和大部分略新的无线网卡驱动一样，b43 也是使用 mac80211 的，这东东对 hostapd 来说，用 nl80211 驱动就可以了，嗯，拆机换网卡，给几张照片哈：\u003c/p\u003e\n\n\u003cp\u003e[caption id=\"attachment_710\" align=\"aligncenter\" width=\"300\" caption=\"打开电源面板，卸下键盘，下面的电路板就是插在 minipci 口上的无线网卡\"]\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/2012-05-20-15.31.22.jpg\"\u003e\u003cimg class=\"size-medium wp-image-710\" title=\"2012-05-20 15.31.22\" src=\"/assets/2012-05-20-15.31.22-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e[/caption]\u003c/p\u003e\n\n\u003cp\u003e嗯，在这篇平淡无奇的blog里面，拆机照片也算是个特色吧，呵呵，miniPCI 口边上有卡子，一按，卡会自动翘起来，然后一拔就下来了，装的时候，插进去一按就行了，和笔记本内存很类似。来两张二次出山（二手的，应该是三次出山了）的BCM4318的照片：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/2012-05-20-15.31.58.jpg\"\u003e\u003cimg class=\"size-medium wp-image-711\" title=\"2012-05-20 15.31.58\" src=\"/assets/2012-05-20-15.31.58-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e \u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/2012-05-20-15.31.42.jpg\"\u003e\u003cimg class=\"size-medium wp-image-712\" title=\"2012-05-20 15.31.42\" src=\"/assets/2012-05-20-15.31.42-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e嗯，注意正面(左边那张)的右上角，有两个天线插口，写着main 和 aux 呢，忘了插天线可不行哈。嗯，再来两张刚刚结束半退休，正式退休的 Intel Pro Wireless 2100 (ipw2100) 的照片哈：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/2012-05-20-15.49.09.jpg\"\u003e\u003cimg class=\"alignnone size-medium wp-image-713\" title=\"2012-05-20 15.49.09\" src=\"/assets/2012-05-20-15.49.09-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e  \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/2012-05-20-15.40.15.jpg\"\u003e\u003cimg class=\"alignnone size-medium wp-image-714\" title=\"2012-05-20 15.40.15\" src=\"/assets/2012-05-20-15.40.15-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e嗯，好了，图片到此为止，下面给一个配置，先是 hostapd 的，包自己 apt 装就行了，配置文件这么写就可以：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003egnawux@case:~$ cat /etc/hostapd/hostapd.conf\ninterface=wlan0\nbridge=br0\ndriver=nl80211\nssid=confusion\nchannel=11\nhw_mode=g\nwpa=2\nwpa_key_mgmt=WPA-PSK\nwpa_pairwise=CCMP\nwpa_passphrase=jumpover\u003c/pre\u003e\n\n\u003cp\u003e嗯，这是一个使用 wlan0 做 AP，接入到网桥（br0）（直接桥到以太网，通过以太网那边的路由器分配地址啥的），占用11号频点，802.11g，WPA2认证，SSID是confusion，密码是 jumpover 的配置，当然，我实际的密码肯定不是这个了，嘿嘿。其实呢，我觉得自己做 DHCP，然后配 NAT 路由，甚至是选择缺省翻墙都是可以的，我这次懒得配了，留给下次了，桥着最省事，只要再配好，让 eth0 也在桥里就行了。\u003c/p\u003e\n\n\u003cp\u003e嗯，网桥直接配到 /etc/network/interfaces 里就行，这是 Debian 系的配法，嗯，RH 和 SuSE 之类的自己研究哈，Debian/Ubuntu 的就这么简单：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003egnawux@case:~$ cat /etc/network/interfaces\n# This file describes the network interfaces available on your system\n# and how to activate them. For more information, see interfaces(5).\n\n# The loopback network interface\nauto lo\niface lo inet loopback\n\n# The primary network interface\nauto br0\niface br0 inet dhcp\n\tbridge_ports eth0\u003c/pre\u003e\n\n\u003cp\u003e嗯，关于桥的就是后三行。呃，好了，到此为止，我现在就是接在这个 AP 上写的 Blog，信号满格，哈哈。\u003c/p\u003e\n\n\u003cp\u003e这个周末好充实啊 —— 冲击钻+电锤在墙上打洞，换无线网卡DIY AP，刷手机 ROM 玩应用写 Blog，去公司写程序外加带儿子学英语…… 嗯，期待下个周末哈\u003c/p\u003e\n","cover":"","link":"linux/2012/05/21/整了个-hostapd-搭的-ap/index.html","preview":"","title":"整了个 hostapd 搭的 AP"},{"content":"\n\u003cp\u003e前几天，把我的 Galaxy Note 刷到 CyanogenMod 9 (CM9) Nightly build 了，之前没有刷上来过，主要是想尝试一下，而且，这个 ICS 的 kernel 没有三星的 Kernel 的硬砖问题。经过几天试用之后，有一个感觉 —— 纯粹的 CM 给了一个很好的可定制平台，但却没有提供很方便的用户定制工具，其他开发者基于这个来开发更好用的 ROM 应该不错，但它本身似乎还没有什么很容易摆弄的地方。\u003c/p\u003e\n\n\u003cp\u003e于是，转来转去，今天发现了一个值得关注的 ROM——\u003cstrong\u003e PARANOIDANDROID\u003c/strong\u003e，链接在这里：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003ca href=\"http://forum.xda-developers.com/showthread.php?t=1662802\" target=\"_blank\"\u003ehttp://forum.xda-developers.com/showthread.php?t=1662802\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这个ROM才刚刚发布，就显得很吸引人，由于作者之前成绩不错，我也第一时间刷上了 0.1 来玩。这个 ROM 是基于 CM9 的，从 CM9 过来不需要 wipe，所以很容易就刷上了，它吸引人的地方在于：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eTablet 模式与 Phone 模式的混合体——系统以 Tablet 模式为主，但可以为每个程序指定 DPI\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e是这样的，对于 CM9/AOSP 的 GN Rom 来说，DPI 决定了是平板还是手机，（大约）216 以下是平板，以上是手机，得益于高分辨率 Super HD AMOLED 屏，Galaxy Note 的实际 DPI 值是 320。平板模式时，因为把 DPI 值设得很低，字和按钮都会很小，有些应用字都看不清了（其他一些变小倒是很好看），而且，平板模式下，很多 Launcher，比如 Apex，都没有 dock，布置的桌面也不好看；一般切换平板和手机模式需要重启，很不方便，而且对Market还有些影响。总的说，一般的 ROM 的平板模式都是好看，但很难日常用的。\u003c/p\u003e\n\n\u003cp\u003e但是这个ROM是平板模式和手机模式结合起来的，Launcher 是修改过的 Trebuchet，用起来和手机模式很接近，很方便，更重要的是，每个应用可以指定自己的 DPI，需要有很多字的就指定高分辨率，比如，短信、电话…… 都可以设成 220，字更多的，看书应用、Facebook，可以设到真实值 320，而缺省值是 192，使用平板模式，很漂亮。后面以图为主了。介绍下这个 ROM 和这几天玩/买的有意思的 App（推荐：LectureNotes, FreeNote, Touch Retouch）。\u003c/p\u003e\n\n\u003cp\u003e开始推荐之前插一句，可调分辨率对某些程序是有问题的，这些程序可能对DPI处理不好，但是要插入到别的程序里面显示的程序（输入法、widget），墨迹天气的 widget 根本就无法显示，只好用 Go Weather，百度输入法插到DPI不同的程序里，或是自己设不同的DPI，就时而空出一大块，时而显示不全，只好用Google拼音输入法，不过所幸都有得替代，也没有其他应用有问题。嗯，下面正式开始：\u003c/p\u003e\n\n\u003ch2\u003e总体观感与Google Apps\u003c/h2\u003e\n\n\u003cp\u003e先来两张总体感觉：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-14-12-34.png\"\u003e\u003cimg class=\"size-medium wp-image-692\" title=\"Screenshot_2012-05-20-14-12-34\" src=\"/assets/Screenshot_2012-05-20-14-12-34-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-13-04-13.png\"\u003e\u003cimg class=\"size-medium wp-image-693\" title=\"Screenshot_2012-05-20-13-04-13\" src=\"/assets/Screenshot_2012-05-20-13-04-13-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e还算舒服吧，嗯，那个画图的widget，帆船画得不好看是我的责任哈。再来看看设置界面——\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-14-25-27.png\"\u003e\u003cimg class=\"size-medium wp-image-695\" title=\"Screenshot_2012-05-20-14-25-27\" src=\"/assets/Screenshot_2012-05-20-14-25-27-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-14-23-40.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-696\" title=\"Screenshot_2012-05-20-14-23-40\" src=\"/assets/Screenshot_2012-05-20-14-23-40-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e可以看到咱们的新鲜出炉的 ROM 版本和 kernel build 的时间，以及为每个程序设置 DPI 值的界面。下面看看 GMail 和 Market，给两张横屏的视图：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-13-05-54.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-698\" title=\"Screenshot_2012-05-20-13-05-54\" src=\"/assets/Screenshot_2012-05-20-13-05-54-300x187.png\" alt=\"\" width=\"300\" height=\"187\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-14-19-46.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-699\" title=\"Screenshot_2012-05-20-14-19-46\" src=\"/assets/Screenshot_2012-05-20-14-19-46-300x187.png\" alt=\"\" width=\"300\" height=\"187\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e接下来来几个好玩的 APP：\u003c/p\u003e\n\n\u003ch2\u003eLecture Notes\u003c/h2\u003e\n\n\u003cp\u003e$3.84 收的，嗯，很适合随意写写画画，随便记笔记，没什么限制。支持电磁笔（看stylus配置），而且支持笔上的按钮，用笔画的时候，可以按下按钮，就变成橡皮擦了。可以用小刀工具，选定一块，复制到别的地方，或是移动到别的地方，非常好用。而且可以设置为只有笔能写上，手指写不上，这样可以手指控制缩放移动、笔写字画画，很方便。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-13-11-39.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-700\" title=\"Screenshot_2012-05-20-13-11-39\" src=\"/assets/Screenshot_2012-05-20-13-11-39-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e  \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-13-12-09.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-701\" title=\"Screenshot_2012-05-20-13-12-09\" src=\"/assets/Screenshot_2012-05-20-13-12-09-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003eFreeNote\u003c/h2\u003e\n\n\u003cp\u003e这个是免费的，收费版叫 FreeNote+，$5.99，但免费版已经很好用了。虽然名字叫Free，但用法没有Lecture Notes 那么 Free，有一个功能是画画，上面那个主屏的帆船就是这么画出来的，但更主要的功能是手写输入，又一个基线，写在里面就可以输入进去，然后还可以弄出来画重点啥的，功能也非常强大，界面我还是更喜欢一些 Lecture Notes。同样支持电磁笔，可以只有笔写入，手指不写\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-13-19-18.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-702\" title=\"Screenshot_2012-05-20-13-19-18\" src=\"/assets/Screenshot_2012-05-20-13-19-18-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e  \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-13-18-20.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-703\" title=\"Screenshot_2012-05-20-13-18-20\" src=\"/assets/Screenshot_2012-05-20-13-18-20-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch2\u003eTouch Retouch\u003c/h2\u003e\n\n\u003cp\u003e这不是一个笔记工具，而是一个修图工具，给张对比图哈\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/2012-05-18-09.19.17.jpg\"\u003e\u003cimg class=\"alignnone size-medium wp-image-704\" title=\"2012-05-18 09.19.17\" src=\"/assets/2012-05-18-09.19.17-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/IMG_20120518_091918x.jpg\"\u003e\u003cimg class=\"alignnone size-medium wp-image-705\" title=\"IMG_20120518_091918x\" src=\"/assets/IMG_20120518_091918x-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e看到左侧的鼠标垫了没，用 Touch Retouch 只要用笔把小修掉的地方涂上，然后“start”，就消失了，超好玩，这个应用 $0.99，买来玩玩挺好哈 :)\u003c/p\u003e\n\n\u003ch2\u003eEvernote/Sketch\u003c/h2\u003e\n\n\u003cp\u003e都提到笔记了，不能不说大名鼎鼎的 Evernote 和它收购的 Sketch，嗯，Sketch 也可以写写画画：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-13-16-23.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-706\" title=\"Screenshot_2012-05-20-13-16-23\" src=\"/assets/Screenshot_2012-05-20-13-16-23-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e  \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/05/Screenshot_2012-05-20-13-17-20.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-707\" title=\"Screenshot_2012-05-20-13-17-20\" src=\"/assets/Screenshot_2012-05-20-13-17-20-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e但是，Sketch 似乎没有对笔的优化，而且，放在 Evernote 里也只是附件，还是留着用来勾照片吧。不过 Sketch 有个好处，会对画上的线条自动进行平滑，会更“好看”一点。\u003c/p\u003e\n\n\u003ch2\u003ePapyrus 和 FlipaClip\u003c/h2\u003e\n\n\u003cp\u003e这两个看起来很好玩，一个写起来特别舒服，一个写写画画自动生成动画，可惜了，在我的 ICS Rom 上全跑步起来，嗯，CM9, AOSP, Stock 都跑不起来，遗憾啊，这里就不贴图了。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"life/2012/05/20/一个-rom-和几个-app[多图杀猫]/index.html","preview":"","title":"一个 ROM 和几个 APP[多图杀猫]"},{"content":"\n\u003cp\u003e似乎我用Milestone那么久都没有心思写篇关于手机的blog，用GN没几天就第二次想写了，我得说，这会儿总算对Android有些好感了，使用体验、界面流畅程度啥的都没什么问题了，也没什么冲动想换个个头那么小的 iPhone 了。我不是说 Android 比 iPhone 好了，只是，这些手机已经是各有特色了，iPhone 可能不再是每个人的理想智能手机了（对很多人从来没是过哈，对某些人永远都是）。\u003c/p\u003e\n\n\u003cp\u003e本文所指的ROM和内核，都来自 XDA（ http://forum.xda-developers.com ），由于个人装逼需要，不喜欢安装国内论坛上的“大牛”们做的，比如机锋什么的下 ROM，如果能在官方市场找到的软件也不喜欢用其它来源的，如果是付费软件，又很想要，就想办法伪装成米国用户买下来，偶们码农，得带头尊重软件版权、反对盗版，这个不是因为我们工资已经高到每月能买得起一两刀、三五刀的软件了，而是因为我们自己就是这么活的，我们不能自己偷自己的钱，是吧。\u003c/p\u003e\n\n\u003ch2\u003e目前的Galaxy Note ICS ROM和内核\u003c/h2\u003e\n\n\u003cp\u003eGalaxy Note 目前的两大 ICS ROM 分支是：基于三星官方修订的，以及基于纯开源项目构建的；内核也有两类：三星放出来的和基于纯开源构建的。开源的ROM也可能会用三星放出来的内核，反之大概亦然。\u003c/p\u003e\n\n\u003cp\u003e5月10号，三星欧洲在德国放出了他们的第一个官方的Note ICS ROM，版本号为 LPY，之前，中国泄漏过 LP1, LP5, LP6 三个 ICS ROM（这些似乎最早都是在机锋泄漏的），下面称呼的时候，官方版本的ROM和内核都直接称为LPY，泄漏版的三个，如果不特殊指某一个的话，直接说中国泄漏版。\u003c/p\u003e\n\n\u003cp\u003e在出现这些三星ROM之后，有几个 Team 都对官方版本的ROM做出了自己的 MOD，主要包括：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e换用ApexLauncher 或 NovaLauncher，很多人都不喜欢三星的 TouchWiz ，呵呵\u003c/li\u003e\n\n\u003cli\u003e删掉一些应用，换上另一些（中国泄漏版里有人人、新浪微博之类的一大堆，我看着都想删掉，老外们更不例外了）\u003c/li\u003e\n\n\u003cli\u003e加一些启动的init脚本来做优化\u003c/li\u003e\n\n\u003cli\u003e换主题\u003c/li\u003e\n\n\u003cli\u003e增加一些通知栏 toggle 之类的功能（替换 SystemUI）\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e随后或同时，有一些人开始直接从开源的 AOSP （Android Open Source Project，这个是 google 直接放出的），以及在上面进行了一些修订的 AOKP 项目，这其中比较成熟的一般都使用了三星放出的内核——中国泄漏的或是更新的 LPY，它们的主要特点是：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e应用精简了不少，三星的一个都没有了，当然 S-Pen 应用也没有了（笔还能用，笔的按键不好用了，截屏之类的就不能用笔了）\u003c/li\u003e\n\n\u003cli\u003e一般用 ApexLauncher 或 NovaLauncher，优化、toggle、主题之类的也是有的\u003c/li\u003e\n\n\u003cli\u003e更多的可定制配置，包括锁屏\u003c/li\u003e\n\n\u003cli\u003e可以修改为平板模式，安装平板才可以用的软件，比如 Papyrus 之类的\u003c/li\u003e\n\n\u003cli\u003e早期AOSP官方有录像无法保存之类的 Bug，但后来已经修复了。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e除了AOSP/AOKP之外，还有著名的CM9系列ROM，它们的mod更多，甚至使用了基于 i9100 内核源代码构建的纯开源内核，这个内核目前只是可用，还缺少一些功能（这个变化很快，可能blog发出来的时候已经修复了呢）\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e拍照的预览是黑的\u003c/li\u003e\n\n\u003cli\u003eSpeaker还有部分问题，这个似乎是有人的内核解决了，有人的没有，不同的修复\u003c/li\u003e\n\n\u003cli\u003e其他不确定的问题\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，好了，总结就到这里，下面是重要的安全提示——\u003c/p\u003e\n\n\u003ch2\u003e安全提示\u003c/h2\u003e\n\n\u003cp\u003e根据XDA总结的用户的报告，所有三星放出的内核，LPY或是中国泄漏的，都存在一定的 eMMC IO 缺陷，有可能在大 IO 时导致硬变砖，也就是 hard brick，这对于我们这些质保比较差用户来说更严重一些哈。发生这种情况的风险依次为：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e使用Chainfire 打包的基于三星内核的 CF-root kernel 时，在 Recovery 下进行 Wipe 和 Flash，这种风险是最高的，当然，实际我也在没得到这个安全提示的时候 wipe 过好几次，很多其他人也是，大部分都没变砖，变砖这个事，概率不高，但是风险高就很吓人，是吧\u003c/li\u003e\n\n\u003cli\u003e不使用 CF-Root的时候，也有可能 wipe 的时候出事\u003c/li\u003e\n\n\u003cli\u003e删除大文件的时候据认为也有可能有风险\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这个，说的是个可能性，但有很多用户不以为然，认为变砖不是这会才开始的，历史上也不是没出现过，不用看得这么重，那些手机可能是硬件本身有问题的，有很多变砖和新 kernel 根本没关系。不论如何，鉴于存在有问题的可能，因此XDA的开发者们给出了一个解决方案：\u003c/p\u003e\n\n\u003ch3\u003e安全操作方法与免责声明\u003c/h3\u003e\n\n\u003cp\u003e鉴于 2.3.6 的内核没有问题，于是建议这么操作：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e下 Abyss Kernel 4.2 （点这里: \u003ca href=\"http://www.mediafire.com/?c65mndvpk6ocbaa\" rel=\"nofollow\" target=\"_blank\"\u003ehttp://www.mediafire.com/?c65mndvpk6ocbaa\u003c/a\u003e ），放到手机里\u003c/li\u003e\n\n\u003cli\u003e进 recovery 刷 Abyss 内核\u003c/li\u003e\n\n\u003cli\u003e在 advanced 里选择重启到recovery\u003c/li\u003e\n\n\u003cli\u003e如果想 wipe就wipe，想刷新 Rom 就刷新 Rom\u003c/li\u003e\n\n\u003cli\u003e重启，搞定\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e当然，重复一下，刷机怎么都是有风险的，所以，即使你这么做了，赶上天灾人祸的可能性仍然是存在的，但是，要是啥风险都不承担，就表玩手机了，是吧。\u003c/p\u003e\n\n\u003ch2\u003e ICS使用体验\u003c/h2\u003e\n\n\u003cp\u003e用ICS时间久了，2.3.6 的啥体验记不清了，嗯，总体评价一下ICS吧\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e设置界面的流量显示、电量显示都不错，wifi、蓝牙的设置也更方便了，打开设置就有开关，也可以点进去设置\u003c/li\u003e\n\n\u003cli\u003e流畅度没什么问题，原来有问题么，我不记得了啊，我觉得一直挺流畅的吧，当然，我毕竟是用老 milestone 过来的，对流畅啥的期待本来就不高，说实话，我承认我土鳖，玩 iPhone 4S 和 iPad、iPad 2 的时候也没觉得惊艳的流畅啊……\u003c/li\u003e\n\n\u003cli\u003e电池啥的，跟 Coly 显摆过好几次，我觉得正常情况下，原电坚持一天应该没问题，我的坚持的意思是不以影响使用体验为代价的，不关 wifi、不关背景数据传输，该拍照拍照，该上传上传，该微博微博，该看 RSS 看 RSS……\u003c/li\u003e\n\n\u003cli\u003e人脸解锁说起来拉风，但用一下就知道了，这东西对长得像我这么丑的屌丝完全是自取其辱啊，如果当天没刮胡子，或者干了一天活一脸油光的话，每次解锁都让你感到一阵恶心，嗯，当然了，对改善个人卫生有好处，用人脸解锁的几天，我会一天洗几次脸、刮胡子间隔绝对不会超过两天，嗯，即使这样，后来还是关掉人脸解锁了\u003c/li\u003e\n\n\u003cli\u003e只要有 root，就可以安装 busy box 和 openvpn，你懂的，这个没有任何使用问题\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，再来说下基于三星ROM做的东西\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e用 LPY 吧，毕竟是官方的，没有中文界面，也就是菜单啥的是英文的，中文程序没有任何问题\u003c/li\u003e\n\n\u003cli\u003e如果觉得 instagram 之类的开的时候有点卡的话，disable 掉一片三星自带的程序，什么 weather、news、软件更新啥的，有 root 的话，可以直接移除 /system/app/ 下不需要的程序，当然，有些是不能拿走的，这个见仁见智吧，我移走了50多个，看起来没什么问题\u003c/li\u003e\n\n\u003cli\u003emod啥的都可以手动做，比如 mod 个主题、装个软件啥的，有 root 都可以手工做了，基本不需要装个特殊的ROM版本了。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e然后是 AOKP 的 ROM，我用 stunner 比较多，从 Beta4.1 一直用到 1.4.26.1，说说感受：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e流畅度没问题，内存占用少很多。当然，要我说，内存剩余 200MB 还是 500MB 都是浮云，只要应用不卡，内存不就是用来用的么；\u003c/li\u003e\n\n\u003cli\u003e面板啥的可定制性更强，我喜欢这个，相机有全景相机功能，比免费应用的全景相机功能好用\u003c/li\u003e\n\n\u003cli\u003e平板模式基本不用，字小啊，但支持 Papyrus 和其他一些 Note 软件，还是挺有吸引力的\u003c/li\u003e\n\n\u003cli\u003e没有 S-Pen 按键的功能，心里小不爽，似乎笔的定位比三星 ROM 有偏移，这个是感觉，不是确实量出来的，但心情上确实是这样的\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e总结一下：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e只要有 root，流畅度不是问题，电池也没问题\u003c/li\u003e\n\n\u003cli\u003e应用各有特色，我更倾向于官方的 S-Pen，虽然常常留恋 AOKP 的 ROM\u003c/li\u003e\n\n\u003cli\u003e仅供参考，不承担责任哈\u003c/li\u003e\n\n\u003c/ul\u003e\n","cover":"","link":"life/2012/05/16/那些天一起刷过的galaxy-note-ics-rom/index.html","preview":"","title":"那些天一起刷过的Galaxy Note ICS ROM"},{"content":"\n\u003cp\u003e很久不深入玩Debian系的东西了，最近，乘着工作之便，又打了个deb包，而且是我之前没干过的内核模块的deb包，恩，记一下吧。\u003c/p\u003e\n\n\u003ch2\u003eDebian内核模块的一般构建方法\u003c/h2\u003e\n\n\u003cp\u003e和 RHEL 不同，Debian 很少提供内核匹配的模块的二进制 deb 包，相反，一般会提供一些比较长用的模块的源码包，并配合 module-assistant 工具，生成与用户使用的内核版本一致的内核模块。\u003c/p\u003e\n\n\u003cp\u003emodule-assistant 是一个菜单界面的CLI工具，用户可以在这里选择源码包，当然，也可以用 apt 安装 xxx-source 的源码包（也是deb包），然后，用命令\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003em-a a-i module-name-here\u003c/pre\u003e\n\n\u003cp\u003e来自动生成模块的二进制 deb 包并安装。\u003c/p\u003e\n\n\u003ch2\u003e打包模块源码\u003c/h2\u003e\n\n\u003cp\u003e如果源里没有这个模块的话，就只能自己打包内核模块了。这个工作实际和一般软件的 deb 打包非常相似，可以借助 debhelper 的 dh_make(8) 命令。\u003c/p\u003e\n\n\u003ch3\u003e生成 Debianize 文件\u003c/h3\u003e\n\n\u003cp\u003edh_make 实际上有一个专门的选项/参数 (k)，可以用来制作模块的 deb 包，现在，在源码的顶层目录（目录的命名方式是 package-name-x.x.x）运行 dh_make 命令：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003e# dh_make -e account@examplel.com -k --createorig\n#\u003c/pre\u003e\n\n\u003cp\u003e恩，为了方便，我实际在源码的顶层目录里放了一个叫 driver 的目录，内核模块代码就在里面，这样复制的时候可以直接复制整个目录了。\u003c/p\u003e\n\n\u003cp\u003e执行玩上面的命令之后，你就可以看到，多了一个 debian 目录，这个目录里有很多文件，它们遵循 debian 的一般打包原则，简单介绍几个重要的，具体的参考《Debian新维护人员手册》吧：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003erule：这个最重要，实际是个Makefile，后面具体介绍；\u003c/li\u003e\n\n\u003cli\u003econtrol：这个是软件包的描述，照着内容敲吧，section 之要遵循 debian 的约定，比如 kernel 就是一个 section，其他自便吧；\u003c/li\u003e\n\n\u003cli\u003echangelog：这个是打包版本的变更，每个版本开头里，目标distro一般写 unstable，urgency 一般是 low ；\u003c/li\u003e\n\n\u003cli\u003eREADME.Debian：是对这个包的说明，给人看的；\u003c/li\u003e\n\n\u003cli\u003e可执行脚本：postinst 和 prerm 比较常用，分别是在安装之后进行配置和卸载之前进行清理的，preinst 和 postrm 一般用的不多。其他文件各有各的用处，.ex 结尾的都是例子，如果用的上就用，用不上的可以考虑删除。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch3\u003e内核模块包的特殊文件\u003c/h3\u003e\n\n\u003cp\u003e恩，因为这 kernel module 包的做法是先做 source 的 deb 包，用户用 m-a 根据这个 deb包的内容再做一个二进制的 deb 包，所以需要为他们准备一些配置文件，一般用得上的是这两个：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003econtrol.modules.in  这个用作模块包的 control 文件；\u003c/li\u003e\n\n\u003cli\u003eebs-driver1-modules-_KVERS_.postinst.modules.in 这个用作模块包的 postinst 脚本，比如要插模块、调整 daemon 什么的。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch3\u003e写内核模块包的 rules\u003c/h3\u003e\n\n\u003cp\u003e这是关键折腾的一步，我也是头一次写，没找到什么现成的文档，自己琢磨的，有什么不对的地方还请指出来啊。\u003c/p\u003e\n\n\u003cp\u003e规则里面 kdist_clean, kdist_config, binary-modules 是用来编译内核的，编译内核时，有些规则是从 module-assistant 里导入进来的\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003e# modifieable for experiments or debugging m-a\nMA_DIR ?= /usr/share/modass\n# load generic variable handling\n-include $(MA_DIR)/include/generic.make\n# load default rules, including kdist, kdist_image, ...\n-include $(MA_DIR)/include/common-rules.make\n\n\n\u003c/pre\u003e\n\n\u003cp\u003e这些会帮助我们在正式打包之前，在上面那几个给模块准备的配置文件里，加入内核版本号信息，并用正式的文件名。当然，在一开始 make kdist_clean 规则的时候，这些文件还没生成，所以应该把 dh_testdir 和 dh_clean 注掉，否则做不成的，如：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003ekdist_clean: \n        #dh_testdir\n        rm -f build-arch-stamp build-indep-stamp configure-stamp\n        #dh_clean\n        rm -f driver/*.o driver/*.ko\n\n\n\u003c/pre\u003e\n\n\u003cp\u003e这里可以根据尝试的情况调整内容，稍稍注意一下即可。正式的 binary-module 目标倒是没什么特殊的，简单根据自己需求调整就行了，这里的安装过程会把模块放到\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003edebian/$(PKGNAME)/lib/modules/$(KVERS)\n\n\n\u003c/pre\u003e\n\n\u003cp\u003e目录里，如果有配置文件，也可以相应的放进去，debian 在安装包的时候，如果有配置文件的更改，是会提示用户的。\u003c/p\u003e\n\n\u003cp\u003e如果制作模块包的时候只要做源码包，不用做用户空间工具包的话，binary 目标只要依赖 binary-indep 就可以了，不需要依赖 binary-arch 了。\u003c/p\u003e\n\n\u003ch3\u003e打包\u003c/h3\u003e\n\n\u003cp\u003e写完配置文件之后，在源码顶级目录里，也就是有 debian 目录的目录里，运行\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003edpkg-buildpackage -uc -us -rfakeroot\n\n\n\u003c/pre\u003e\n\n\u003cp\u003e就可以生成源码包了，安装之后，就可以像开头那样用 module-assistant 制作安装二进制模块了。\u003c/p\u003e\n\n\u003ch2\u003e小结\u003c/h2\u003e\n\n\u003cp\u003e实际上做内核模块的 deb 包并不难，只要有点 debian/ubuntu 经验，细心一点就可以做好里。估计短时间内我是不会更新 unleashed 了，就这篇 blog 供大家参考吧。\u003c/p\u003e\n","cover":"","link":"linux/2012/05/14/创建-debian-ubuntu-风格的内核模块包/index.html","preview":"","title":"创建 Debian/Ubuntu 风格的内核模块包"},{"content":"\n\u003cp\u003eiproute2，也就是ip(8)这个命令的功能是非常强大的，之前就曾经用它建隧道之类的，但从来没涉及过路由，毕竟找不到什么不用 route(8) 命令的理由。不过，这次我们找到了一个——当你需要两个缺省路由的时候，该怎么配置？\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e按：这个是新研究出来的，有什么不对的地方敬请指出哈\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003ch2\u003eiproute2\u003c/h2\u003e\n\n\u003cp\u003eiproute2 是一整套网络设置工具，涵盖从网口（link, address）、ARP（neigh）、路由（rule, route）、隧道（tunnel）等各个方面，是 Linux 2.2 （如果没记错的话，应该有十三四年了吧）以来的网络“新”特性的用户态工具，可以替代 arp、ifconfig、route 这些经典但不够完善的工具。\u003c/p\u003e\n\n\u003cp\u003e如果你要搭 ipip 或 gre 隧道，无疑要使用 iproute2 的 ip tunnel 命令了，除此之外，你还能想到第二个用 iproute2 的场景么？我就遇到了一个——\u003c/p\u003e\n\n\u003ch2\u003e问题背景：两张路由表\u003c/h2\u003e\n\n\u003cp\u003e如果你有一台服务器，有两张网卡，对应了两个网络出口，都能连到目标网络，这时，怎么设置下一跳路由呢？经典的 route 设置，只有一个缺省路由条目可以生效的。你当然可以设置，让一部分目标地址走一个路由，另一部分目标地址走另一个路由，但是有两个问题：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e这样，流量很难均衡使用两个路由\u003c/li\u003e\n\n\u003cli\u003e包从哪个网口进来是无法通过自己的路由表选择的，所以，如果按照上面那种划分方法，只要进入的包没有按照我们的期待分区划分，那么就无法正确地回复，也可能会被 rp_filter 直接过滤掉。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，那么，怎么同时用上两块网卡呢——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我们需要按照出发 IP 划分，使用源 IP1 的包，走第一块网卡，使用 IP2 的包，走第二块网卡。（先不考虑未指定的）\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e但是，IP路由的基本哲学是——按照目的地址，从路由表里查询，不可能按照源地址来整路由表，于是，问题就变成了这样——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我们需要为每个 src IP 建立一张路由表：从第一个IP出来的包，进第一张路由表，出第一块网卡；从第二个IP出来的包，进第二张路由表，出第二块网卡。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e思路很简单，但是 route(8) 命令在这里就束手无策了，嗯，看 iproute2 的：\u003c/p\u003e\n\n\u003ch2\u003e多张路由表（rule）\u003c/h2\u003e\n\n\u003cp\u003e好了，不卖关子了，iproute2 本来就支持多张路由表，配置文件位于这里：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eroot@swipe:~# cat /etc/iproute2/rt_tables\n#\n# reserved values\n#\n255\tlocal\n254\tmain\n253\tdefault\n0\tunspec\n#\n# local\n#\n#1\tinr.ruhep\u003c/pre\u003e\n\n\u003cp\u003e已经有三张表了：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eroot@swipe:~# ip rule ls\n0:\tfrom all lookup local\n32766:\tfrom all lookup main\n32767:\tfrom all lookup default\u003c/pre\u003e\n\n\u003cp\u003e这三张表都对所有的IP来源生效（from all），这其中，main 就是我们通常设置的路由规则，\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eroot@swipe:~# ip route ls table main\ndefault via 192.168.12.1 dev eth0  proto static\n169.254.0.0/16 dev eth0  scope link  metric 1000\n192.168.12.0/24 dev eth0  proto kernel  scope link  src 192.168.12.104  metric 1\nroot@swipe:~# route\nKernel IP routing table\nDestination     Gateway         Genmask         Flags Metric Ref    Use Iface\ndefault         localhost       0.0.0.0         UG    0      0        0 eth0\nlink-local      *               255.255.0.0     U     1000   0        0 eth0\n192.168.12.0    *               255.255.255.0   U     1      0        0 eth0\u003c/pre\u003e\n\n\u003cp\u003edefault表是空的，而local表则是本机链路的设置。如果我们需要，可以人为加入新规则（路由表）\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eroot@swipe:~# echo \u0026quot;200 rt2\u0026quot; \u0026gt;\u0026gt; /etc/iproute2/rt_tables\nroot@swipe:~# ip rule add from 192.168.12.111 table rt2\nroot@swipe:~# ip rule ls\n0:\tfrom all lookup local\n32765:\tfrom 192.168.12.111 lookup rt2\n32766:\tfrom all lookup main\n32767:\tfrom all lookup default\u003c/pre\u003e\n\n\u003cp\u003e这样，来自 192.168.12.111 的包就可以先进入 rt2 这张表了\u003c/p\u003e\n\n\u003ch2\u003e路由设置\u003c/h2\u003e\n\n\u003cp\u003e现在要做的是为每张表设置路由\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eroot@swipe:~# ip route add 192.168.12.0/24 dev eth1 table rt2\nroot@swipe:~# ip route add default via 192.168.12.254 dev eth1 table rt2\nroot@swipe:~# ip route flush cache\u003c/pre\u003e\n\n\u003cp\u003e对于本机发出的包，应该可以以某种机会，比较均衡地选择任意路由出去\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eroot@swipe:~# ip route add default scope global nexthop via XX.XX.XX.XX dev eth0 weight 1 \\\n nexthop via XX.XX.XX.XX dev eth1 weight 1\u003c/pre\u003e\n\n\u003cp\u003e当然，这种基于路由表的负载均衡并不能做到完全均匀，毕竟路由表是可以被缓存的。\u003c/p\u003e\n\n\u003cp\u003e说明：上面的设置例子是在一台只有一块网卡的机器上码的，不过在写blog之前是在有两块网卡的机器上操作的，就是那个机器不方便写blog，所以看着细节上可能有点味道不太对，没关系哈\u003c/p\u003e\n\n\u003ch2\u003e参考\u003c/h2\u003e\n\n\u003cp\u003e下面是一些参考文献：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003eLinux Advanced Routing \u0026amp; Traffic Control HOWTO ： http://lartc.org/howto/index.html\u003c/li\u003e\n\n\u003cli\u003eip-cref ： http://users.cis.fiu.edu/~esj/cnt4504/reading/ip-cref.pdf\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cdiv\u003e\u003c/div\u003e\n","cover":"","link":"linux/2012/04/21/使用-iproute2-进行-multihoming-设置/index.html","preview":"","title":"使用 iproute2 进行 MultiHoming 设置"},{"content":"\n\u003cp\u003e今年清明假期，连上请的年假，全家一起去了广西北海，延续了去年开始的每年春天，全家带儿子去南方海边吹海风的活动。我们全家对这次北海之行相当满意，由于去年的武夷山游记（\u003ca title=\"武夷山游记\" href=\"http://wangxu.me/blog/p/555\" target=\"_blank\"\u003ehttp://wangxu.me/blog/p/555\u003c/a\u003e）受到好友的欢迎，在这里也把这次北海之行分享给大家，没准谁能用到呢。\u003c/p\u003e\n\n\u003cp\u003e实际上，路线的勘定，住宿的选择，机票的预定全是老婆（\u003ca title=\"跳舞的金子\" href=\"http://weibo.com/u/2153748074\" target=\"_blank\"\u003e@跳舞的金子\u003c/a\u003e）完成的，攻略也是她查的。也就是说，她先分析学习，然后指导我执行，最后我输出新的游记——这是个很经典的反向工程案例啊。\u003c/p\u003e\n\n\u003ch2\u003e行程概述\u003c/h2\u003e\n\n\u003cp\u003e我们的行程是这样的：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e4月1日搭乘CA1881飞到北海，\u003c/li\u003e\n\n\u003cli\u003e当日到达市区北部湾广场，并在旁边住下\u003c/li\u003e\n\n\u003cli\u003e4月2日乘船登上涠洲岛，之后的时间主要在涠洲岛渡过\u003c/li\u003e\n\n\u003cli\u003e4月5日下午乘船返回北海\u003c/li\u003e\n\n\u003cli\u003e当日住在银滩\u003c/li\u003e\n\n\u003cli\u003e4月6日下午搭乘CA1882回到北京\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cdiv\u003e主要行程标在Google Earth上是这样的，嗯，直接用了foursquare的签到记录，它的那个feed是可以输出KML的，直接用Google Earth打开即可，嗯，当然了，会有些偏移，你懂的，我修正了下位置。这个是北海的全部经停地点：\u003c/div\u003e\n\n\u003cdiv\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/04/屏幕快照-2012-04-18-下午2.16.53.jpg\"\u003e\u003cimg class=\"aligncenter size-medium wp-image-658\" title=\"北海游概览\" src=\"/assets/\u0026#23631;\u0026#24149;\u0026#24555;\u0026#29031;-2012-04-18-\u0026#19979;\u0026#21320;2.16.53-296x300.jpg\" alt=\"\" width=\"296\" height=\"300\" /\u003e\u003c/a\u003e嗯，可以看到，银滩离市中心还是比较近的，码头就在银滩边上，从码头到涠洲岛的距离大概是40公里，必须乘船前往，蹚水是过不去的。银滩上的主要景点概览如下：\u003c/div\u003e\n\n\u003cdiv\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/04/屏幕快照-2012-04-18-下午2.09.46-1.jpg\"\u003e\u003cimg class=\"aligncenter size-medium wp-image-660\" title=\"涠洲岛主要景点\" src=\"/assets/\u0026#23631;\u0026#24149;\u0026#24555;\u0026#29031;-2012-04-18-\u0026#19979;\u0026#21320;2.09.46-1-300x236.jpg\" alt=\"\" width=\"300\" height=\"236\" /\u003e\u003c/a\u003e我们用了一天时间游览小岛的大部分景点，其他时间主要就在住处附近的沙滩活动了，很舒服。 下面这个是北海市区和银滩的示意，实际银滩也是很不错的：\u003c/div\u003e\n\n\u003cdiv\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/04/屏幕快照-2012-04-18-下午2.19.17.jpg\"\u003e\u003cimg class=\"aligncenter size-medium wp-image-661\" title=\"北海市区\" src=\"/assets/\u0026#23631;\u0026#24149;\u0026#24555;\u0026#29031;-2012-04-18-\u0026#19979;\u0026#21320;2.19.17-300x267.jpg\" alt=\"\" width=\"300\" height=\"267\" /\u003e\u003c/a\u003e\u003c/div\u003e\n\n\u003ch2\u003e海滩，各种海滩\u003c/h2\u003e\n\n\u003cp\u003e当我们从涠洲岛回到北海市，到了银滩之后，我在4sq签到的时候写到“对海滩都审美疲劳了⋯⋯”，不过，第二天在银滩的海滩上抓小螃蟹仍然让我们和斯屹兴致勃勃，每处海滩都有它的特点，总的讲，我觉得北海的海滩质量不错，没有三亚那么多的商业开发，没有亚龙湾住宿成本那么高，还是很舒服的度假地点的。\u003c/p\u003e\n\n\u003ch3\u003e贝壳沙滩与渔家\u003c/h3\u003e\n\n\u003cp\u003e我们提前联系了渔民林大哥家里，他们接待还是很热情的。住处在后背塘村，这里距离贝壳沙滩走路三分钟的样子（参见上面的卫星图，嗯，不过具体地点我不太确定哈）。我们用了两天多的时间，陪儿子在这里挖沙子、捡贝壳、蹚水⋯⋯，还搞了烧烤活动\u003c/p\u003e\n\n\u003cp\u003e[caption id=\"attachment_666\" align=\"aligncenter\" width=\"300\" caption=\"“私家”海滩\"]\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/04/ShellBeach.jpg\"\u003e\u003cimg class=\"size-medium wp-image-666\" title=\"贝壳沙滩\" src=\"/assets/ShellBeach-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e[/caption]\u003c/p\u003e\n\n\u003cp\u003e我得说，即使你在亚龙湾，也没有这么大的人均海滩面积。有些贝壳的地方有点扎脚，但大部分地方的沙子还是很细的，接近白色的海滩和清澈的海水让人想起蜈支洲岛，但这里的最大好处是人少，即使在清明假期，仍然很难看到很多人出现在这里，拍到安静的、没有人的海滩易如反掌。而且，这里有很多海螺壳、贝壳之类的，在中午退潮的时候，一些礁石都露出水面，在沙滩上可以很容易地捡到很多海螺壳。\u003c/p\u003e\n\n\u003ch3\u003e涠洲岛的景区\u003c/h3\u003e\n\n\u003cp\u003e涠洲岛上有挺多景区，对于非教徒，天主教堂的意义也并不大，掠过之后，我们依次造访了五彩滩、鳄鱼山、滴水丹屏和石螺口。各有特点。\u003c/p\u003e\n\n\u003cp\u003e[caption id=\"attachment_667\" align=\"aligncenter\" width=\"300\" caption=\"岛上风光\"]\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/04/WeizhouIsland.jpg\"\u003e\u003cimg class=\"size-medium wp-image-667\" title=\"涠洲岛诸景点\" src=\"/assets/WeizhouIsland-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e[/caption]\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e五彩滩（右上角图）是一片石头海滩，据说早上有太阳的话会有五彩，嗯，我们去的时候阴天，没看到，不过这里有很多小螃蟹、寄居蟹啥的，小朋友很喜欢，就是石头滩比较塥脚；\u003c/li\u003e\n\n\u003cli\u003e鳄鱼山是涠洲岛作为国家地质公园的主景区（右下角三张照片和左下角寄居蟹都是在这里拍的），是一个小半岛，需要走上或坐车上山，然后在爬下海边，然后爬上来，再下山去，有一点累，不过我驮着儿子都做到了，应该不算太累；下到海边，可以看到火山口标识，海边有很多活泼的寄居蟹，石头上还有些活的，可能是珊瑚的东西；\u003c/li\u003e\n\n\u003cli\u003e滴水丹屏（背景图，还有“王旭斯屹爱海娟”的沙子组字都是在这里拍的）是涠洲岛上最细腻的沙滩，个人感觉细腻程度绝对不亚于亚龙湾；\u003c/li\u003e\n\n\u003cli\u003e石螺口海滩是和滴水丹屏比较接近的一块海滩，有些水上和沙滩摩托车之类的项目，老婆在这里开了一段摩托车兜风\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cdiv\u003e这几个景点大概是岛上仅有的商业旅游开发吧，嗯，似乎还有个看日出的地方，整个岛上的商业开发程度不高，还算自然吧。\u003c/div\u003e\n\n\u003ch3\u003e银滩\u003c/h3\u003e\n\n\u003cp\u003e银滩应该是北海大陆上最好的海滩了，这块海滩同样细腻、平坦、开阔，而且——小螃蟹太多了\u003c/p\u003e\n\n\u003cp\u003e[caption id=\"attachment_669\" align=\"aligncenter\" width=\"300\" caption=\"到处都有小螃蟹\"]\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/04/SilverBeach.jpg\"\u003e\u003cimg class=\"size-medium wp-image-669\" title=\"银滩\" src=\"/assets/SilverBeach-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e[/caption]\u003c/p\u003e\n\n\u003cp\u003e我们在这里停留了一个下午和一个上午，我们住的地方类似亚龙湾的二线海景，和海滩隔着一条马路，不过这里也没有一线海景，呵呵。第二天上午的时候我们才注意到，这里到处都是小螃蟹的巢穴，小螃蟹很类似泥土里的蚯蚓啊，都是一个小洞，外面很多小土粒。我和儿子转了一圈，儿子动不动就能抓到来不及从外面跑回洞里的小螃蟹，而且——有活物的海滩都是小朋友喜欢的海滩。\u003c/p\u003e\n\n\u003cp\u003e当然，这里沙滩也很好，也有摩托车之类的项目，不过，我们就是来吹吹海风、玩玩沙子、抓抓小螃蟹的，这里也很适合我们。\u003c/p\u003e\n\n\u003ch3\u003e小结\u003c/h3\u003e\n\n\u003cblockquote\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e整个北海的海滩质量都不错，而且各有特点，贝壳、寄居蟹、小螃蟹都有不少\u003c/li\u003e\n\n\u003cli\u003e涠洲岛上住在渔家，然后到贝壳沙滩上休闲、BBQ，还有北海银滩，都是不错的休闲场景\u003c/li\u003e\n\n\u003cli\u003e潜水之类的项目都有，不过我们没尝试\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/blockquote\u003e\n\n\u003ch2\u003e衣食住行及其他\u003c/h2\u003e\n\n\u003cp\u003e衣没什么可说的了，先说吃住：\u003c/p\u003e\n\n\u003cp style=\"text-align: center;\"\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/04/IMG_20120405_135550.jpg\"\u003e\u003cimg class=\"alignnone size-medium wp-image-672\" title=\"IMG_20120405_135550\" src=\"/assets/IMG_20120405_135550-225x300.jpg\" alt=\"\" width=\"225\" height=\"300\" /\u003e\u003c/a\u003e \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/04/IMG_0451.jpg\"\u003e\u003cimg class=\"alignnone size-medium wp-image-671\" title=\"IMG_0451\" src=\"/assets/IMG_0451-225x300.jpg\" alt=\"\" width=\"225\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e北海和涠洲岛渔家的吃东西价格都比较公道，尤其是我们住的涠洲岛渔家，螃蟹、扇贝、生蚝、皮皮虾都物美价廉，吃得我们浑身痒痒⋯⋯\u003c/li\u003e\n\n\u003cli\u003e涠洲岛鳄鱼山顶上的吃饭的地方比较坑爹，价格贵、服务能力差、东西不全，而且不好吃\u003c/li\u003e\n\n\u003cli\u003e渔家住宿很便宜，市内酒店也不贵，用去哪、携程之类的查到酒店价格如何，直接去前台订就可以，基本不需要预定酒店\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e然后说说出行：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e北海的交通费算比较贵的，过路过桥上岛费用都不低，机场到市区的出租车要价100块，不讲价，我们就坐机场大巴进城了，直接到了北部湾广场，不过去机场的大巴并不方便，我们还是打车了\u003c/li\u003e\n\n\u003cli\u003e这里黑车比较猖狂，而且还威胁正规的出租车司机，抢客人\u003c/li\u003e\n\n\u003cli\u003e涠洲岛的游船，B舱120/人，船是小水线面双体船型，属于快速船型，实际航速大约是20节，速度不错，就是比较贵，而且航行中不能上甲板；上岛费（国家地质公园门票）90块/人，这个比较黑\u003c/li\u003e\n\n\u003cli\u003e岛上的载客三轮摩托车，环岛一天游100块、接送码头20，如果会开摩托车的话，可以考虑租摩托车转全岛；岛上没有正规渠道的加油站，所以汽油很贵，嗯，没办法。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cdiv\u003e总的说，北海的吃住都比较实惠，出行比较贵，综合考虑海滩很不错，嗯，趁着开发还不算过度，推荐一下，如果不想出国游，就北海吧，比三亚强。\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"life/2012/04/19/清明假期北海游/index.html","preview":"","title":"清明假期北海游"},{"content":"\n\u003cp\u003e版聚也讨论一些不太严肃的话题（严肃的请进上一篇: \u003ca href=\"http://wangxu.me/blog/p/648\"\u003ehttp://wangxu.me/blog/p/648\u003c/a\u003e）。\u003c/p\u003e\n\n\u003cp\u003e不知怎的，忽然间话题跑到了 Vim 上，是的，在场的卢瑟们不会用 Emacs，只能勉强学会 Vim。李凯童鞋表示——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e一种产生随机字符的方法是，请一位新手退出Vim。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e于是，话题被正式岔到在场童鞋们都不会的 Emacs 上了。\u003c/p\u003e\n\n\u003cp\u003e李凯说\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我退出Emacs的方式是，且到另一个终端，然后 kill 那个 Emacs 进程。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e好吧，他确实比较狠，我当场表示，当年我的操作比这个善良一些——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我是用的 Ctrl-z，放到后台，然后干掉的。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eColyli 童鞋不甘寂寞，问\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eCtrl-d 行不行？\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e但这个方法当场被其他童鞋否定了。\u003c/p\u003e\n\n\u003cp\u003e各位，你们还有什么更2B一些的方法么。\u003c/p\u003e\n","cover":"","link":"linux/2012/03/26/版聚的另一话题——你是如何退出emacs的/index.html","preview":"","title":"版聚的另一话题——你是如何退出Emacs的"},{"content":"\n\u003cp\u003e本月版聚的规格最后是8人座谈 + 晚饭欢送 hzmangel （@hzmangel, @古月圣）同学南下，座谈比讲幻灯片更轻松了一点，不过，还是讨论了一些严肃问题，很多都是开发中的常见误解和误用。废话少说，一一列出，没列的出是我忘了，各位在场同学请补充。\u003c/p\u003e\n\n\u003ch3\u003emmap() 与 read() 哪个快\u003c/h3\u003e\n\n\u003cp\u003e当Coly（@colyli, @淘泊松）抛出这个问题的时候，我们已经猜到 read() 快了，毕竟我们相信他会说些颠覆理解的东西，而且李凯（\u003ca href=\"http://weibo.com/11803445\" target=\"_blank\"\u003e@leekayak\u003c/a\u003e）童鞋表示，他也听朱延海（@2002年一本漫画闯天涯）说过此事。那么，我们来听听 Coly 的解释：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e大家关于“mmap()”更快的认识来自于 read() 是需要内存拷贝的；\u003c/li\u003e\n\n\u003cli\u003e当今硬件技术的发展，使得内存拷贝消耗的时间已经极大降低了；\u003c/li\u003e\n\n\u003cli\u003e但“mmap()”的开销在于一次  pagefault，这个开销相比而言已经更高了，而且 pagefault 的处理任务现在比以前还更多了；\u003c/li\u003e\n\n\u003cli\u003e而且，mmap之后，再有读操作不会经过系统调用，在 LRU 比较最近使用的页的时候不占优势；\u003c/li\u003e\n\n\u003cli\u003e于是，普通读情况下（排除反复读之类的文艺与2B读操作），read() 通常会比 mmap() 来得更快。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch3\u003emmap() 与 brk() 是否都会给分配的内存填0\u003c/h3\u003e\n\n\u003cp\u003e这来自于李凯同学的一次提问，Coly同学断然否认了在这方面两者的不同，表示，自 kernel 0.9 以来，所有的分给用户的页全是初始化过的，没有用户数据的页一定会给0，这是一个安全问题，内核不会把不属于用户的内容给用户看的。而且，文件系统也是如此，空洞文件在读取未初始化过的文件内容时，返回的也一定是0。\u003c/p\u003e\n\n\u003cp\u003e当然，对于用户应用来说，C库提供的 malloc() 有可能会复用内存，而不是每次都从内核取，所以，有可能有未初始化内容。\u003c/p\u003e\n\n\u003ch3\u003esprintf() 的误用\u003c/h3\u003e\n\n\u003cp\u003e提到初始化的时候，Coly 愤愤不平地表示，有童鞋居然这样初始化内存区域：\u003c/p\u003e\n\n\u003cpre class=\"brush: c; gutter: true\"\u003esprintf(buf,\u0026quot;\u0026quot;);\u003c/pre\u003e\n\n\u003cp\u003e并表示，这一操作的行为是未知、未定义的。我和Bergwolf（@oatgnep, @Bergwolf）、李凯现场测试了一下，在使用 -Wall 开关编译的时候，会报出 WARN，提示使用了空的格式字符串。这是 C 库标准未定义行为的情况，这样使用会导致不可预期的情况出现，为什么不直接给 buf[0] 赋值 '\\0' 呢。\u003c/p\u003e\n\n\u003ch3\u003ememset() 初始化内存有什么问题（以及硬盘的FUA/DPO）\u003c/h3\u003e\n\n\u003cp\u003e在场童鞋表示，他们都不会这么写 sprintf()，hzmangel 童鞋表示，他会用 memset() 填 0，于是，又引出了 Coly 的话题。他表示，这样操作在正确性上没有问题，但是会破坏 Cache Line，这些 0 区域将来会被重新写入，是完全没有读意义的，如果他们冲掉了正在很热的被访问的 Cache 中的内容，对于那块内存的访问可能对运行时间有严重的影响。所以，如果一定要写入，最好能够告诉 CPU，默默地写入，不要干扰 L1 Cache，这样可能会让写入更慢，但如果同时有其他 VIP 读 Cache 的内容的话，会因此受益。\u003cdel\u003e（怎么干我忘了，谁告诉我哈）\u003c/del\u003e\u003c/p\u003e\n\n\u003cp\u003eUpdate：Bergwolf 提醒，这一绕过 Cache 的手段称为\u003cem\u003e non-temporal write\u003c/em\u003e，详见这里：http://lwn.net/Articles/255364/\u003c/p\u003e\n\n\u003cp\u003e同时，对磁盘的访问也是如此，某些操作不希望写入\u003cstrong\u003e硬盘的\u003c/strong\u003eCache，防止影响读取告诉缓存的数据，这样的写操作可以利用 SCSI 的 FUA/DPO 标识，在新内核中，对于支持 FUA/DPO 的设备，Ext4的 journal 会使用这种方式写入，而非 barrier，从而提高性能。\u003c/p\u003e\n\n\u003ch3\u003enanosleep() 的开销在新 kernel 上为什么会变大（任何Sleep都会至少睡1毫秒？）\u003c/h3\u003e\n\n\u003cp\u003eColy 同学还提到了在他们的新 Kernel 上，老应用遇到的新问题。其中之一是某应用抱怨 sleep 开销变大，追查下去，是有四个线程频繁地 nanosleep 10 微秒，导致抢锁造成的。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e“关于 sleep 一次至少会消耗1-2毫秒的认识早已经过时了”\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这个问题来自于早期程序员们坚信，sleep会让出CPU，由于调度问题，会有至少1-2毫秒的消耗，于是，甚至会有人用 sleep(0)。但是，高精度计时器（HPET）的引入使得 sleep 的精度已经大幅提升了，你要10微秒，就会给你 10 微妙，于是，锁的时候的 spinlock 争抢变得异常激烈了……\u003c/p\u003e\n\n\u003cp\u003e这个故事告诉我们，那些没有明确承诺过的 feature，也会随着时间的推移，悄悄地消失，成为陷阱，要么避开不用，要么总是留意。\u003c/p\u003e\n\n\u003ch3\u003eiowait% 大了，是否是开销就变大了\u003c/h3\u003e\n\n\u003cp\u003e这也是一个新 kernel 带来的问题，hadoop 运维童鞋会观测到 iowait 比原来的老 kernel 高了 10% 以上，这个究竟是不是问题呢。Coly告诉我们，请看看运行时间——实际任务的运行时间会快 10%……这是为什么呢？\u003c/p\u003e\n\n\u003cp\u003e这个，解释下 wait time 是怎么计算的：内核每次采样看每个 CPU 的状态，如果 CPU 上是 idle，而且有任务在等 IO，就标记为 wait，那么，假设有16个CPU，如果有8个任务，分到16个CPU上，一直等IO，就是 50%，而如果有10个任务，分到两个 CPU上，就是 12.5%。这说明了什么问题呢——wait 并不全面反映等 IO 的严重性，新 kernel 更倾向于均匀地把任务分到更多 CPU 上，于是看起来 wait 值就高了。\u003c/p\u003e\n\n\u003cp\u003e这涉及到一个更科学的数据观的问题——你更关注的应该是任务的执行时间和效率、throughput、qps，而不是 CPU 的 wait time。\u003c/p\u003e\n\n\u003cp\u003e另外，iowait 时间是从 idle 中分化出来的，某些老的监控程序会直接用 （100% - idle%）当成 CPU 占用率，在 iowait 独立出去之后，会显得占用率变高。\u003c/p\u003e\n\n\u003ch3\u003e其他\u003c/h3\u003e\n\n\u003cp\u003e已经写了不少了，其他的不是我不想写，是想不起来了……请补充啊。\u003c/p\u003e\n\n\u003cp\u003e另外，Coly 强烈感谢了马涛（@淘泊瑜）为首的淘宝内核组童鞋们（羡慕嫉妒恨地说，他们还有美女 kernel 程序员……），作为国内互联网公司内，并入主线的 kernel patch 量当之无愧的老大，他们也是我们版聚的很多话题的来源，linuxfb 也感谢你们。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"linux/2012/03/26/mmap--和read--哪个快——linuxfb版聚上谈论的开发中的常见误解与陷阱/index.html","preview":"","title":"mmap()和read()哪个快——linuxfb版聚上谈论的开发中的常见误解与陷阱"},{"content":"\n\u003cp\u003e今天是斯屹的四岁生日，祝你生日快乐，也祝你妈妈青春永驻\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/03/siyi-4years-1.jpg\"\u003e\u003cimg class=\"aligncenter size-medium wp-image-642\" title=\"siyi-4years-1\" src=\"/assets/siyi-4years-1-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/03/siyi-4years-2.jpg\"\u003e\u003cimg class=\"aligncenter size-medium wp-image-643\" title=\"siyi-4years-2\" src=\"/assets/siyi-4years-2-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/03/siyi-4years-3.jpg\"\u003e\u003cimg class=\"aligncenter size-medium wp-image-644\" title=\"siyi-4years-3\" src=\"/assets/siyi-4years-3-300x225.jpg\" alt=\"\" width=\"300\" height=\"225\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"life/2012/03/20/生日快乐，斯屹/index.html","preview":"","title":"生日快乐，斯屹"},{"content":"\n\u003cp\u003e比如 CPU2 上的：\u003c/p\u003e\n\n\u003cpre class=\"brush: bash; gutter: true\"\u003eps -eLo pid,psr,command |sed -ne \u0026#039;/^\\W[0-9]\\W2\\W/p\u0026#039;\u003c/pre\u003e\n\n\u003cp\u003e嗯，后面 sed 匹配串里选第几个CPU，嗯前面的参数里，psr 是 CPU 号，嗯。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"scripts/2012/03/09/列出某一cpu上跑的所有进程-线程/index.html","preview":"","title":"列出某一CPU上跑的所有进程/线程"},{"content":"\n\u003cp\u003e特别声明：主观评测，所有评测意见来自本人主观感受，既不权威也不客观。\u003c/p\u003e\n\n\u003cp\u003e在被 Moto Milestone 伤了心之后，多年的 moto 用户也将目光投向了三星，关注了 Galaxy Nexus  良久之后，终于入手了 Galaxy Note。\u003c/p\u003e\n\n\u003cp\u003eEngaget 的编辑指出“Galaxy Note 是一台不是喜爱到不行就是会饬知以鼻的产品 -- 它之于一般智能型手机尺寸的庞大身躯，实际上并不是每个人都可以接受的。“（来源：\u003ca href=\"http://cn.engadget.com/2011/11/02/samsung-galaxy-note-review/\"\u003ehttp://cn.engadget.com/2011/11/02/samsung-galaxy-note-review/\u003c/a\u003e ） 对我来说也是如此，我总觉得这个身材跨界的怪胎会和我的 iPad 的定位发生冲突，所以一直将目光聚焦在略小一点点，有 ICS 的 Galaxy Nexus，怎奈后者的硬件配置实在是平平，最终，在老婆的预算支持下，还是入手了 Galaxy Note。\u003c/p\u003e\n\n\u003ch2\u003e 物理观感\u003c/h2\u003e\n\n\u003cp\u003e其实连我自己也不确定，5.3寸的手机是否适合自己的手，不过，到手之后的感觉还是很不错的。手机做得很薄很轻，重量上完全没有挑战，当然，想要舒适的单手操作也不太可能了。\u003c/p\u003e\n\n\u003cp\u003e1280x800 的 Super AMOLED 屏，虽然是 pentile 排列的，但看起来还是相当细腻的，这个差不多是前两年 12 寸的笔记本屏的分辨率了吧。不论你是看书、写字、玩游戏，都游刃有余，虚拟键盘的空间也相当宽裕，这个屏幕的体验绝对让你增加很多关注手机的时间。\u003c/p\u003e\n\n\u003cp\u003e当然，劣势也在这里，说实话，手握的时间长了还是有些累的，而且⋯⋯我不太敢在人面前拿着这个手机打电话，效果着实有点震撼，所以这几天我一直是在用蓝牙耳机的。\u003c/p\u003e\n\n\u003ch2\u003e 硬件与系统配置\u003c/h2\u003e\n\n\u003cp\u003e和两年前的 Milestone 相比，Note 的配置不可同日而语了，让我颇为不适应的事情包括——放了这么多应用之后，还有1.5G剩余，RAM也总是很空，我甚至可以肆无忌惮地在主屏上放好多 Widget，这在原来可是能省则省的啊。各种操作相当流畅，很多原来觉得死慢死慢的东西，比如”图库“，也一下就开了，很不适应啊。\u003c/p\u003e\n\n\u003cp\u003e电池方面，昨天晚上试了一下，一宿待机，啥都没关——无线网络、GPS、背景数据传输全开着，睡前还玩了一阵新买的 Sketch Book Mobile 应用，再算上早上端详了半天，掉电大约 10%，我觉得可以接受了，电池问题没有 @colyli 同学说得那么严重，2500mAh 的电池还是相当给力的。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/02/SC20120216-073010.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-625\" title=\"SC20120216-073010\" src=\"/assets/SC20120216-073010-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e  \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/02/SC20120216-072649.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-624\" title=\"SC20120216-072649\" src=\"/assets/SC20120216-072649-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e当然，电力方面部分得益于新刷的一个 kernel，我第一天到手 root 之后，第二天刷了个 ROM，第三天刷了个 kernel，无愧于 Android 用户的忠实爱好——刷机、重启、换电池。感觉 Samsung 对用户还是很开放的，没有像 milestone 那样恶劣的锁 bootloader 的行为，这才像一个真的 linux 手机嘛。\u003c/p\u003e\n\n\u003ch2\u003e 应用情况\u003c/h2\u003e\n\n\u003cp\u003e丢了 iPad 之后，我醒悟到的一点就是 —— iPad 可以吸引用户在丢掉之后立刻就想再买一个的核心价值在于平台上面的体验超棒的优秀应用，特别是那些花钱买来的应用——GoodReader、Keynote、Instapaper 还有很多游戏都在此列，所以，对 Galaxy Note，我的重点也在应用。应用方面，首先说一些兼容性的问题，然后说一点游戏和界面响应的感受，最后说说有啥特别好玩、好用的应用。\u003c/p\u003e\n\n\u003cp\u003e实际上很多应用还不能适应5.3寸的屏幕，原来用得好好的 Moji 天气 widget 在 Note 上完全不能看，找了半天找到 Go Weather，还算好用。Pulse 在 Note 上显示时，字也好大啊，调都很难调好，只好删掉了。而且，在 5.3\" 的屏幕上，摆 Widget 也很有难度，为了摆出一个我看着还顺眼的主屏，费了好大力气啊。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/02/SC20120216-231139.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-626\" title=\"SC20120216-231139\" src=\"/assets/SC20120216-231139-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e对于界面的操控感觉，我觉得在大部分场合都没有什么问题，我装了一些小游戏，比如 Angry Bird, Air Attack, Slice it, Fruit Ninja Free 之类的，都是免费版的，没舍得花钱装收费版本的，呵呵，收费版本的回头到 iPad 上玩吧。都玩了一下，只有 Fruit Ninja 的操控感觉比 iPad 差一些，经常削漏，而且界面似乎被拉扁了，斗胆怀疑是应用本身的适配问题，不过这也在一个侧面说明五花八门的 Android 设备让开发者们有点无所适从。\u003c/p\u003e\n\n\u003cp\u003e再来说说一些有意思的应用，对中国用户，要想买付费应用，首先需要root，用 MarketAccess 把自己的手机设为米国或类似地方的服务商的网络代码，才可以访问米国的市场；另外，Android Market 版本太新就无法购买付费应用，所以还要用 OldMarket，替换回老版本的 Market。\u003c/p\u003e\n\n\u003cp\u003e有几个应用在原来 Milestone 上就很常用：Switch Pro Widget，用来在界面上安放很多开关的，还有 1-VPN，也是用 Widget 点一下就连 VPN 的，这个比不越狱的 iOS 方便。\u003c/p\u003e\n\n\u003cp\u003eGalaxy Note 有自己的 S Pen 和相关应用，点两下就截屏这个很好用，做笔记啥的也很舒服，iPad 要是有这个就好了，呵呵。对于 Galaxy Note 来说，这么大的屏幕，远胜于 iPad 2 的 800万像素摄像头，还有好用的 S Pen，用作笔记和绘图非常方便，Evernote、Skitch 都很好用，还有就是 AutoDesk 的 Sketch Book Mobile 也很好用，这个在 iPad 上也有，界面基本一样，画草图什么的很方便，5.3寸还可以用，太小的屏幕就没什么意思了。当然，这么大屏幕，用来看电子书也是不错的。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/02/SC20120216-214550.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-628\" title=\"SC20120216-214550\" src=\"/assets/SC20120216-214550-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e  \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2012/02/SC20120216-214538.png\"\u003e\u003cimg class=\"alignnone size-medium wp-image-627\" title=\"SC20120216-214538\" src=\"/assets/SC20120216-214538-187x300.png\" alt=\"\" width=\"187\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"life/2012/02/17/galaxy-note入手体验/index.html","preview":"","title":"Galaxy Note入手体验"},{"content":"\n\u003cblockquote\u003e按：谨以此译文献给仍然挣扎在 CentOS 5/RHEL 5 上的同学们，RHEL 6/CentOS 6 已经包含这个改进了。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e原作者：Goldwyn Rodrigues\u003cbr /\u003e\n原文时间：April 1, 2009\u003cbr /\u003e\n原文链接：\u003ca href=\"http://lwn.net/Articles/326552/\"\u003ehttp://lwn.net/Articles/326552/ \u003c/a\u003e\u003cbr /\u003e\n译者：王旭（ @gnawux, \u003ca href=\"http://wangxu.me/blog/\"\u003ehttp://wangxu.me/blog/\u003c/a\u003e ）\u003cbr /\u003e\n翻译时间：2012年2月7-9日\u003c/p\u003e\n\n\u003cp\u003e在内核的页缓存（page cache）之中，存放着永久存储设备上的文件内容的内存副本。当程序把数据写入到页面之中，但还没写到磁盘上的时候，这些数据就放在缓存之中，这就是“脏页”。脏页的数量可以从 /proc/meminfo 中看到。每30秒，脏页都会被刷入（flush）磁盘。Pdflush 是一组负责将脏页刷入磁盘的内核线程，它或者是由显式的 sync() 调用出发，或者在页面被清出 page cache 时隐式地自动触发，具体情况包括，如果页面在内存中的时间过长，或者 page cache 中有过多的脏页（过多的界定由 /proc/sys/vm/dirty_ratio 确定）。\u003c/p\u003e\n\n\u003cp\u003e在任意给定的时间，系统中会有 2-8 个 pdflush 线程。pdflush 线程的数量由 page chche 的负载确定，如果一秒钟之内，没有空闲的 pdflush线程，但工作队列里还有很多工作要做，就会创建一个新的 pdflush 线程。另一方面，如果最后一个活跃的 pdflush 线程也已经睡了超过1秒了，那就会有一个 pdflush 线程被终止，知道只剩下了两个 pdflush 线程。当前的 pdflush 线程数可以通过 /proc/sys/vm/nr_pdflush_threads 查看。\u003c/p\u003e\n\n\u003cp\u003e很久以来，就有很多 pdflush 相关问题让它饱受诟病。Pdflush 线程是所有块设备共享的，但是，如果它们能专注于每一个磁臂的话，性能可能会更好一些。通过 backing_dev_info 结构的 BDI_pdflush 标志，可以避免 pdflush 线程的竞争，但是，互相影响还是会影响写回的性能。Pdflush的另一个问题是请求的饥饿问题。系统的每个队列中都可以有固定个数的I/O请求。如果超过了限制，所有应用的I/O请求都会被阻塞住，直到有新的空位出现。因为 pdflush 是为多个队列工作的，它不会阻塞在某一个队列上。这样，它会设置 wbc-\u0026gt;nonblocking 写回信息标志。如果其他应用继续在设备上写入数据，pdflush 就无法分配出空位了。如果 pdflush 不断发现一个队列处于拥塞状态，就会导致这个队列的请求被饿死。\u003c/p\u003e\n\n\u003cp\u003eJens Axboe 在\u003ca href=\"http://lwn.net/Articles/324833/\"\u003e一组 patch \u003c/a\u003e中提出了一个新的方案，使用为每个块设备（backing device info, BDI）配置的 flusher 线程作为 pdflush 的替代品。与 pdflush 不同，BDI 专属的 flusher 线程专注于一个磁臂。在 BDI 刷写的情况下，当请求队列出现拥塞的时候，请求的分配会被阻塞住，避免饿死请求，提供了更好的公平性。\u003c/p\u003e\n\n\u003cp\u003e使用 pdflush，脏的 inode list 存储于文件系统的超级块。由于 per-BDI flusher 需要\u003cdel\u003e直到\u003c/del\u003e知道要写入的脏页属于\u003cdel\u003e那\u003c/del\u003e哪个块设备，所以，这个列表现在存储到了 BDI 里。这样，要刷入一个 superblock 上的所有脏 inode，就\u003cdel\u003e回\u003c/del\u003e会导致刷入这个文件系统占用的所有后端设备上的脏 inode 列表。\u003c/p\u003e\n\n\u003cp\u003e与使用 pdflush 时类似，per-BDI 的写回是通过 writeback_control 数据结构控制的，写回程序从中知道写回什么、如何去做。这个结构中的重要字段包括：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003esync_mode: 定义对于 inode 加锁的情况下，进行同步的方式。如果设置为 WB_SYNC_NONE，写回操作会跳过加锁的 inode，而如果设置为 WB_SYNC_ALL，则会等待加锁的 inode 被 unlock，再进行写回。\u003c/li\u003e\n\n\u003cli\u003enr_to_write：要写的页的数量。这个值随着页面被写入而减少。\u003c/li\u003e\n\n\u003cli\u003eolder_than_this：如果不为NULL，所有比这个字段中给出的 jiffies 值老的页面都会被刷入块设备。这个字段会优先于 nr_to_write。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003ebdi_writeback 结构保存了所有用于刷入脏页的信息：\u003c/p\u003e\n\n\u003cpre class=\"brush: c; gutter: true\"\u003estruct bdi_writeback {\n\tstruct backing_dev_info *bdi;\n\tunsigned int nr;\n\tstruct task_struct\t*task;\n\twait_queue_head_t\twait;\n\tstruct list_head\tb_dirty;\n\tstruct list_head\tb_io;\n\tstruct list_head\tb_more_io;\n\n\tunsigned long\t\tnr_pages;\n\tstruct super_block\t*sb;\n};\u003c/pre\u003e\n\n\u003cp\u003ebdi_writeback结构是在设备使用 bdi_register() 进行注册的时候初始化的。结构的各个字段的含义如下：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003ebdi: 和本结构实例相关联的 backing_device_info，\u003c/li\u003e\n\n\u003cli\u003etask: 指向缺省flusher线程的指针，这个线程用于启动进行刷写工作的线程，\u003c/li\u003e\n\n\u003cli\u003ewait: 用于同步flusher线程的等待队列，\u003c/li\u003e\n\n\u003cli\u003eb_dirty: 本 BDI 上面，需要刷入块设备的所有脏 inode 的 list，\u003c/li\u003e\n\n\u003cli\u003eb_io: 要进行 I/O 的 inodes ，\u003c/li\u003e\n\n\u003cli\u003eb_more_io: 更多的要进行 I/O 的 inodes ；所有要刷入的 inode 都先被插入到这个队列中来，之后再移送到 b_io，\u003c/li\u003e\n\n\u003cli\u003enr_pages: 要刷入的页的总数，以及\u003c/li\u003e\n\n\u003cli\u003esb: 指向当前 BDI 上的文件系统的超级块的指针。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003enr_pages 和 sb 是异步传送给 BDI 刷写线程的参数，并且在 bdi_writeback 的生命周期中是可能发生变化的。这是因为有些设备上会有多个文件系统，也就会有多个超级块。当一个设备上有多个超级块的时候，sync 操作可以针对设备上的某一个特定的文件系统。\u003c/p\u003e\n\n\u003cp\u003ebdi_writeback_task 函数会周期性发起 wb_do_writeback(wb) 调用，调用周期为 dirty_writeback_interval，缺省值是5秒。如果5分钟内都没有页面被写入，flusher 线程就回退出（计时精度为 dirty_writeback_interval）。（退出）之后如果又需要工作了，那么就会由缺省写回线程来启动一个新的 flusher 线程。\u003c/p\u003e\n\n\u003cp\u003e写回的flush有两种工作方式：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003epdflush方式：由显式的协会请求触发，比如 sync 一个超级块的所有 inode 页面。这时会以超级块的信息和要刷入的页面数量为参数调用 wb_start_writeback()。这个函数会去获取与此 BDI 相关联的 bdi_writeback 结构。如果获取成功的话，会将 superblock 指针和要刷入的页的数量写入 bdi_writeback 结构，并唤醒 flusher 线程，为该超级块进行实际的写操作。这个操作和 pdflush 的写入操作有所不同：pdflush 会根据写的路径来获取设备，阻塞住其他进城的写操作。\u003c/li\u003e\n\n\u003cli\u003ekupdated 方式：如果没有显式的写回请求，写回线程会周期性地刷入脏数据。当一个 BDI 的一个 inode 的页面第一次变脏的时候，会将 dirtying-time 记入 inode 的地址空间中。当周期性的写回代码检查到这个超级块的 inode 列表的时候，就回写回比某一时间更早变脏的 inode。这一操作的周期是 dirty_writeback_interval，缺省是5秒钟。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e在\u003ca href=\"http://lwn.net/Articles/322920/\"\u003e第一轮\u003c/a\u003e的讨论之后，Jens 根据 Andrew Morton 的建议，添加了每个设备有多个 flusher 线程的支持。Dave Chinner 建议，文件系统可能会希望每个分配组有一个 flusher 线程。在随后的（第二轮）补丁中，Jens 在 superblock 中添加了一个新的接口，来通过一个 inode 获取相关联的 bdi_writeback 结构：\u003c/p\u003e\n\n\u003cpre class=\"brush: c; gutter: true\"\u003estruct bdi_writeback *(*inode_get_wb) (struct inode *);\u003c/pre\u003e\n\n\u003cp\u003e如果 inode_get_wb 为空，就会返回 BDI 缺省的 bdi_writeback 结构，这就意味着这个 BDI 只有一个 bdi_writeback 线程。每个 BDI 可以启动的最大线程数为 32。\u003c/p\u003e\n\n\u003cp\u003eJens 对一块 SATA 硬盘使用 \u003ca href=\"http://sourceforge.net/projects/ffsb/\"\u003eFlexible File System Benchmark (ffsb)\u003c/a\u003e 进行的测试显示，可以获得 8% 的性能提升。通过 vmstat 观察，与未打过补丁的内核相比，文件操作的分布更加平滑 ，缓冲区的写回呈现出均匀分布。而对于一个10块硬盘的 btrfs 文件系统，per-BDI 刷写可以获得 25% 的提速。这组代码位于 Jens 的块设备层 git tree  (git://git.kernel.dk/linux-2.6-block.git)  的 writeback 分支。目前，第二轮讨论还没有新的意见出现，但 per-BDI flusher 线程还不足以进入 2.6.30 内核。\u003c/p\u003e\n\n\u003cp\u003e致谢：感谢 Jens Axboe 审阅本文并对这组补丁的一些内容进行了解释。【译文完】\u003c/p\u003e\n","cover":"","link":"translation/2012/02/09/flushing-out-pdflush/index.html","preview":"","title":"[译文] Flushing out pdflush"},{"content":"\n\u003cp\u003e原文：http://lwn.net/Articles/469805/\u003cbr /\u003e\n原作者：Jonathan Corbet\u003cbr /\u003e\n原文发布时间：November 29, 2011\u003cbr /\u003e\n译者：王旭 （ @gnawux ;  http://wangxu.me/blog/ ）\u003cbr /\u003e\n翻译时间：2012年2月3日\u003c/p\u003e\n\n\u003cp\u003eext4是一个刚刚发布一两年的文件系统。不过，这个坚实稳定的系统是基于一个很古老的设计演化而来的。对于一些被作为“下一代文件系统”开发的 FS，比如 btrfs，本文要提到的一些特性可能都已经具备了。然而，btrfs这样的文件系统还需要相当长的时间，才能在更广泛的用户群中获得足够的信心，同时，日益增长的 ext4 用户对这些特性同样心仪已久。近来提交的一些补丁就让我们看到，虽然 ext4 在很久以前就已经进入一个相对稳定的阶段了，但新特性的开发也并未停止。\u003c/p\u003e\n\n\u003ch2\u003eBigalloc\u003c/h2\u003e\n\n\u003cp\u003e在 Linux 早期，磁盘的大小还是MB级的，文件系统的块大小也只是 1KB 到 4KB。而在本文写作的时候，TB级的硬盘虽然在最近涨了一点价，但无碍一个事实——硬盘已经变大太多了，存储在上面的文件也是如此。但 ext4 文件系统仍然以 4KB 为单位来管理数据。其结果就是要管理的块数太多了，相关联的位图大小必然随之增长，管理这些块的开销也就极具增大。\u003c/p\u003e\n\n\u003cp\u003e在内核中增加文件系统的块大小会对内存管理、page cache 等产生深远影响，因此是件很恐怖的工作。所以大家都不愿意一下子触及这么多地方，但这并不能阻止文件系统被放在越来越大的磁盘上。在 3.2 内核中，ext4 将可以解决这个问题。“bigalloc”补丁给文件系统引入了一个“块簇（block cluster）”的概念，这样，在一个更大的块组中进行分配时，将一次分配一个块簇而不是一个单独的块。在内核中，这些更大的块和原始的4KB块的映射关系由文件系统负责维护。\u003c/p\u003e\n\n\u003cp\u003e簇的大小由管理员在创建文件系统时确定（使用 e2fsprogs 的一个开发版本），不过这个值必须是 2 的整数次幂。在很多情况下，64KB 是个合适的值，对于那些只存放大文件的文件系统，1MB 的簇大小可能是更佳选择。必须指出的是，如果文件系统专用于存放小文件，那么指定一个过大的簇大小回造成很多空间浪费。\u003c/p\u003e\n\n\u003cp\u003e使用簇可以减少块位图和其他管理用数据结构的开销。但是，根据 Ted Ts'o 在 7 月份给出的\u003ca href=\"http://lwn.net/Articles/469821/\"\u003e数据\u003c/a\u003e。因为这个特性可以降低磁盘的碎片化，对文件IO的性能同样有改进。这个特性预计会成为 3.2 内核（以及 e2fsprogs 1.42）对很多用户的一个杀手级特性。\u003c/p\u003e\n\n\u003ch2\u003einline data\u003c/h2\u003e\n\n\u003cp\u003einode 是文件系统中用于描述一个文件的数据结构。对于大多数文件系统而言，有两类 inode：文件系统无关的内核数据结构（struct inode），以及文件系统相关的 on-disk 版本。常规地说，如果内核没有一份 inode 的副本的话，就根本无法操作一个文件。所以，本质上说，inode 是很多 block I/O 的关键入口点。\u003c/p\u003e\n\n\u003cp\u003e在 ext4 文件系统中，磁盘上的 inode 尺寸可以在文件系统创建时指定，缺省是 256 字节。不过，磁盘数据结构(struct ext4_inode) 只需要大概一般的空间。ext4_inode 结构之后剩下的空间通常用于存储扩展属性。比如 SELinux label 就存放在这里。在没大量使用扩展属性的系统中，磁盘 inode 结构的空余空间就直接浪费掉了。\u003c/p\u003e\n\n\u003cp\u003e同时，文件数据的空间分配是以文件系统块为单位的，与 inode 彼此独立。如果一个文件非常小（即使在现在的文件系统中，还是有很多小文件），用于存放这个文件的块就浪费了很多空间。如果文件系统使用了上面提到的块簇，那么浪费的空间还会更多，这里，用户可能就会开始抱怨了。\u003c/p\u003e\n\n\u003cp\u003e马涛（\u003ca href=\"http://www.weibo.com/pagefault\" target=\"_blank\"\u003e@淘伯瑜\u003c/a\u003e）同学的 \u003ca href=\"http://lwn.net/Articles/468678/\"\u003eext4 inline data 补丁\u003c/a\u003e将会改变这一局面。这个想法非常简单：很小的数据可以直接存放在 inode 之间的空余空间里，根本无需单独分配数据块。对于使用 256个字节的 inode 的文件系统，全部空余空间将会被用于存放这些小文件。如果文件系统使用更大的 inode，只有一半的剩余空间会用于存储文件，剩下的空间留给后面可能要添加的扩展属性，否则的话，这些扩展属性就不得不存放在 inode 之外了。\u003c/p\u003e\n\n\u003cp\u003e涛哥提到，在使用了这个补丁的情况下，用于存放内核源码的空间会减少大约 1%，而 /usr 会减少大约 3%。当启用簇之后，节省的空间应该会更多，但这也不能保证对所有情况都能减少。仍然有些细节问题没有完全完成——包括 e2fsck 支持以及扩展属性存放在 inode 之外带来的开销——所以，这个特性最早要在 3.4 kernel 中才会出现。\u003c/p\u003e\n\n\u003ch2\u003e元数据校验和\u003c/h2\u003e\n\n\u003cp\u003e存储设备并不总是像我们期望的那样可靠的，由于硬件原因造成的数据损坏案例屡见不鲜。正因为如此，关心数据安全的人们使用了 RAID 这样的技术，或者像 Btrfs 这样的文件系统可以保存数据和元数据的校验和，以确保内容不被硬件弄丢。不过，ext4 文件系统没有这一能力。\u003c/p\u003e\n\n\u003cp\u003eDarrick Wong 的\u003ca href=\"http://lwn.net/Articles/469717/\"\u003e校验和补丁\u003c/a\u003e并没有解决全部问题。实际上，它似乎进一步印证了那个老笑话——文件系统开发者并不真的关心他们存储数据的正确性，只要文件系统的元数据没错就行了。这组补丁通过给 ext4 文件系统的各个数据结构加上校验和，包括 superblock、bitmap、inode、dir index、extent tree 等，并在读取时检验校验和，以保证元数据的正确性。校验和失败可能导致文件系统失败，如果这发生在一个挂载着的文件系统上，会把它变为只读，并在系统日志中输出一些相关信息。\u003c/p\u003e\n\n\u003cp\u003eDarrick并未提及任何给用户数据添加校验和的计划。给数据添加校验会是一个更宏大的工程——为已有的元数据数据结构添加一个校验字段相对简单，但要存储数据块的校验和就得给文件系统增加全新的数据结构了。而且，全数据校验的性能损失也会更高。所以，尽管未来可能有人会来介入这个问题，但迄今为止还没有这个动向。\u003c/p\u003e\n\n\u003cp\u003e即使只是元数据的校验和，对文件系统的改变仍然是很大的，不过相当一部分工作是属于 e2fsprogs 的。特别的，e2fsck 将具有检查元数据校验和的功能，并在某些校验和出错时进行修复。校验和可以在 mke2fs 时打开，或是通过 tune2fs 开启。总的说，这是个很大的工作，但确实可以帮助用户增加对文件系统结构的信心。根据 Darrick 的介绍，计算和检验校验和的开销在大部分情况下是可以忽略不计的。这个特性目前还没有收到很多反馈，或许已经接近被接纳进内核，但还不清楚什么时候会进来。\u003c/p\u003e\n","cover":"","link":"translation/2012/02/04/ext4/index.html","preview":"","title":"[译文]Ext4新进展：bigalloc, inline data, 和元数据校验和"},{"content":"\n\u003cp\u003e总得在什么地方记录一下自己的一年吧，呵呵，这里似乎蛮清净的。嗯，没什么条理，想到哪写哪。\u003c/p\u003e\n\n\u003cp\u003e2011年对我来说还是有很多重要意义的——3月份儿子三岁上幼儿园了，回来和我们一起住了；5月离职换工作了，人生第一次；6-7月在上海过的，动不动穿梭在京沪之间，还坐了几次京沪高铁；10月份在QConHangzhou 主持了云计算的 Track，结识了不少技术圈的前辈和大牛⋯⋯\u003c/p\u003e\n\n\u003cp\u003e一年的跨度实在是挺大了，我都回忆不起来斯屹刚刚从爷爷奶奶家搬回到爹妈家是什么状态了，但他的幼儿园生活似乎还是挺顺利的，他喜欢幼儿园的生活，也喜欢和父母在一起，长大了不少，虽然还是个不怎么懂事的小屁孩，可也还是我们的心肝宝贝儿。希望他慢点长大，被孩子依赖的感觉，让人觉得活得很真实、很有味道，很舍不得他长大。\u003c/p\u003e\n\n\u003cp\u003e换工作给我的影响太大了，以至于我总觉得这就是这一年的主题，而且对一幕幕记忆犹新。我不想再祥林嫂一样重复换工作前后的那些苦逼或者狗血的对话，只想回顾一些真实的感受。\u003c/p\u003e\n\n\u003cp\u003e盛大不论如何也不算是个“最佳雇主”，而前单位“中国移动”倒确实是很多人心目中的最佳雇主，但是，我必须承认，我的跳槽，当然不是出于什么“社会责任”（某同事的玩笑），待遇之外，还有一点就是我没能力也不喜欢去做一个以领导为中心的工作，我觉得那样对不起自己；我愿意做我喜欢的——技术有关的工作。\u003c/p\u003e\n\n\u003cp\u003e很荣幸，这边的老大是个比较直率的人，而且给了我很多的信任，不仅让我重新回到技术工作之中，更给了我参加QCon等会议的机会，让我和技术圈中的大牛们有更多的接触机会。\u003c/p\u003e\n\n\u003cp\u003e说到遗憾，一方面，我对完全的开发工作其实还是爱很多，但不完全熟练，毕竟读博几年加上前单位的环境让我有些生疏了，我需要更加努力；另一方面，离开做了很长时间的Hadoop也有点不舍。\u003c/p\u003e\n\n\u003cp\u003e虽然目前的工作也时常有不理想的地方，但并没有超出我的预想，我在跳槽的时候也没有期望到一个完全理想的地方，总的来说还是满意的。希望今年的工作做得更有力，做出点东西来，至于更远的下一步，还没有太多考虑。\u003c/p\u003e\n\n\u003cp\u003e如果恶魔城之前给我offer的话，很难说我现在在什么地方，唉，难掩对那个前几天拿到恶魔城 offer 的同学的羡慕嫉妒恨啊。\u003c/p\u003e\n\n\u003cp\u003e2011年带给我的另一个感受是，家中的老人都在真实地衰老，衰老得自然而然却又让人不愿面对，希望2012他们都健康。\u003c/p\u003e\n","cover":"","link":"life/2012/01/03/回忆2011/index.html","preview":"","title":"回忆2011"},{"content":"\n\u003cp\u003e感谢彭涛（bergwolf）、李凯（郁白）、朱延海和 Coly 的到场，这次版聚虽然只有一个主话题，但是由于有这么多到场者的深度参与，变得很有趣、很有收获。特别感谢 bergwolf 熬夜准备片子，还有李凯为每个环节配上小故事。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e按：之前由于各种苦逼原因，版聚一度中断两个月之久，在此危急存亡的时刻，hzmangel 同学挺身而出组织了这次盛会，我很荣幸地帮助预定了盛大创新院（北京）的会议室，bergwolf 贡献了 aio 的 topic，至此本年度12月版聚得以正常举行。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003ch2\u003e到场同学\u003c/h2\u003e\n\n\u003cp\u003e具体到场同学就不一一点名了，大家可以看邮件列表，值得一提的是，这些同学有千丝万缕的联系：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e有四个人是互为同学来的\u003c/li\u003e\n\n\u003cli\u003e有两个人是同一个组的\u003c/li\u003e\n\n\u003cli\u003e有两个人是同事\u003c/li\u003e\n\n\u003cli\u003e有一个人和上面同一个组的人不是同一个组的，和上面两个同事的五个同事或前同事是前同事\u003c/li\u003e\n\n\u003cli\u003e有一个人和上面四个同学中的一个是同学\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e同学们，你们明白了么？\u003c/p\u003e\n\n\u003ch2\u003e序曲：async/sync vs. blocking/non-blocking\u003c/h2\u003e\n\n\u003cp\u003e这个话题被认为上次在 SNDA 会议室已经搞清楚了，可实际情况是——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e当 Coly 出现后，问题再次变得混乱起来，\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e好吧，我们承认，这两对概念的两两组合足以让人抓狂，结论是：大家要记好了，名字叫 non-blocking 的就是 non-blocking，名字叫 async 的就是 async，嗯。\u003c/p\u003e\n\n\u003cp\u003e这个争论的价值是：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eColy: 对于用户程序，不论是否有 NON_BLOCKING 标志，都必须检查 read 的返回值是否达到了请求值，也就是说，即使 read 返回了 \u0026gt;0 的值，也可能会小于请求值，如果没有，需要循环请求，直到全部读完。\u003c/li\u003e\n\n\u003cli\u003eBergwolf: 对于文件系统的实现者，对于 buffered IO，在没有信号中断的情况下，read 请求如果不失败，返回值不应该小于请求值。如果小于请求，应该视为一个 Bug。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e感谢 coly 和 bergwolf 从不同角度对这个问题的阐述。\u003c/p\u003e\n\n\u003ch2\u003e插曲：郁白的DIO故事\u003c/h2\u003e\n\n\u003cp\u003e事实上，本次版聚是由李凯同学来主持的，每一段他都有一个小故事。对于这里，郁白同学介绍——\u003c/p\u003e\n\n\u003cp\u003e他曾经使用 DIO 模拟 append，这时，如果超出 512B 的块大小，需要补齐再 truncate 回来，有时会发生 EIO，求解答\u003c/p\u003e\n\n\u003cp\u003e经过 coly、bergwolf、朱延海等同学的合议，认为这个问题有可能是 journal 的 bug，因为郁白同学仗着自己使用了很好的 raid 卡，对 journal 区域进行了疯狂的操作，在一次 append 中，最差情况可能有 5 次 io，而且由于他经常 sync，还丧失了合并日志操作的机会，在这种极端情况下，可能会触发 journal 的某个深藏的 bug。\u003c/p\u003e\n\n\u003ch2\u003e正文上半场：POSIX AIO\u003c/h2\u003e\n\n\u003cp\u003e简单地说，POSIX AIO （ aio(7) ）是由 glibc 使用 pthread 在用户空间实现的，由于实现的比较粗糙，没有线程池等机制，这一实现的性能比较低劣——说到这里，有几位同学灰心地苦笑了一下。\u003c/p\u003e\n\n\u003cp\u003e本日出镜最高的郁白同学介绍——Linux 中的 POSIX AIO 实现没有线程池，而且有可能有锁冲突，还可能有其他bug，所以导致性能低下，大约为 pread/pwrite 的 1/3；如果自己妥善地实现一个用户空间 AIO 的话，性能和同步 IO 的性能应该是基本一致的，当然，上下文切换可能是不可避免的。\u003c/p\u003e\n\n\u003cp\u003e朱延海这里有一个想法，是否可以用非阻塞读写和 select/epoll 来做一个更好的 AIO，殷宇辉同学表示 libeio 可能已经这么做了。\u003c/p\u003e\n\n\u003ch2\u003e正文下半场：Native AIO\u003c/h2\u003e\n\n\u003cp\u003ekernel 态的 Native AIO 性能上没有什么问题，但是，它有一些限制——\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e只支持 AIO-DIO\u003c/li\u003e\n\n\u003cli\u003e不支持 fsync/fdatasync\u003c/li\u003e\n\n\u003cli\u003e不支持 socket/pipe\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e并且，bergwolf 表示，据他前一晚上写片子时看代码，ext4 的 aio 似乎没有用上，coly 和朱延海对此不太相信，大家表示后面会再继续研究一下。\u003c/p\u003e\n\n\u003cp\u003e郁白同学此时又有提问：有时 get events 的时候 get 不到，这时内存中用于 io 的 buffer 是否可以安全释放？经过一段讨论，结论大致是这样的：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e首先，IO 用的 page 是 lock 住的，实际不会被释放掉；\u003c/li\u003e\n\n\u003cli\u003e其次，libc 中，free 并不一定会还给内核，而可能会重复给其他进程用；\u003c/li\u003e\n\n\u003cli\u003e这时，如果内存我们还给 libc，libc 又分给其他 malloc 用，在 IO 完成时可能回冲掉这块内存，从而造成了后一个 malloc 不安全\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e所以，这时的内存释放和管理需要谨慎。\u003c/p\u003e\n\n\u003ch2\u003e总结 by 郁白\u003c/h2\u003e\n\n\u003cp\u003e作为每个环节都有话说的李凯同学，这时给了一个总结：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e他比较喜欢用户态的实现，如果有个靠谱的用户空间库，他不太喜欢使用 native 的实现。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e版聚笔记到此为止，linuxfb 2012 见。\u003c/p\u003e\n","cover":"","link":"linux/2011/12/12/2011年最后一次版聚小记/index.html","preview":"","title":"2011年最后一次版聚小记"},{"content":"\n\u003cp\u003e越是无聊乏味的日子，越能学到点东西\u003c/p\u003e\n","cover":"","link":"读后感/2011/11/19/阅读笔记/index.html","preview":"","title":"阅读笔记"},{"content":"\n\u003cp\u003e话说最近有两件事很郁闷，一是云计算这个概念从总体上讲继续不靠谱，而且没有变靠谱的趋势，这件事不是最郁闷的，最郁闷的是第二件——我得跟别人说，我是做云计算的。只希望云计算赶快退热，让那些浮云被风吹走吧。\u003c/p\u003e\n\n\u003cp\u003e先声明啊，我不是在攻击同行啊，不指责同行是我的一个个人准则，更不是说自己的公司不靠谱，不靠谱还做什么呢。\u003c/p\u003e\n\n\u003cp\u003e前不久在 QCon杭州主持了云计算的 Track，那时候看到的是——BigData 与云计算的概念逐步分离，云计算成功实践已然浮现，技术圈对云计算的看法趋于冷静、理智，找到了适于和不适于云计算的场景，对于追捧、炒作、质疑都或泰然处之、或辨清曲直、或接受面对。似乎“大家”都可以好好做事、为用户服务了。\u003c/p\u003e\n\n\u003cp\u003e然而，我忽视了一个事实——那个小小的技术圈还算不上“大家”，技术人员对社会的影响力是很小而且不直接的。\u003c/p\u003e\n\n\u003cp\u003e这两天在高交会看展台，满眼政务云、医疗云、安全云、物流云⋯⋯依然是不知所云、人云亦云。各路政府、机构、厂商，有的本来就对概念一知半解，有的为了自己的利益故意混淆是非，让本来已经逐渐清晰化的概念又在模糊起来了。更残酷的事实是，正是这些宣传在影响着更多的人，而不是我们技术小圈子的共识，现在，那些花50块钱进来看展览的叔叔阿姨们也知道了有这么多朵云了，知道所有东西都可以是云了⋯⋯对我来说，痛心疾首啊，我只想，让云赶快退烧，我们换一个技术名词吧。\u003c/p\u003e\n\n\u003cp\u003e好了，说了这么多，我来给云下王氏定义了：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e不计自称为云的 SaaS 模式（此模式由来已久、变化不大、仅是在名词上划为了云，我们不评论它，这里的讨论也不涉及它，我更没有能力和兴趣来界定它），过去几年谈的云已经划分为了两个主流的概念：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003cstrong\u003e用大规模系统、服务大规模用户，这样的服务还叫云\u003c/strong\u003e，其外在的特征表现为快速弹性（快速扩展与收缩服务能力）、用量计费（按照精确的消耗时长、空间、和流量）、按需自助服务（通过页面或API自助服务），而其内在特征则是细粒度、高效率、高可靠、自动化的资源池；【此定义参考了米国国家标准学会的定义，搞了很久无厘头的云计算标准化，这方面还是有点积累的，呵呵】\u003c/li\u003e\n\n\u003cli\u003e\u003cstrong\u003e用大规模系统、处理大规模数据，这样的应用现在叫BigData\u003c/strong\u003e，其核心竞争力在于利用PC级硬件集群，存储海量数据，在适当建模的基础上，进行大规模分布式处理，高效的任务分解与调度，提供较以往的数据库或数据仓库类产品更高的容量和更强大的处理能力。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e当然，你完全不必接受我的定义，这是我在自己的博客上的闲言碎语，也不打算在这里争概念，有不同见解的，请另找地方发表高见，我不支持你在本文后面的评论里写你的见解，唯一的原因就是——我觉得闹心。\u003c/p\u003e\n\n\u003cp\u003e我的愿望很简单，剩下的这部分最好也别叫云了，咱要么叫原来的名字，Utility Computing，好不好？至于那些在云或“类云系统”（请允许我这么称呼那些功能不全、规模不大的小型平台）上工作的服务，咱们也别叫XX云了吧。\u003c/p\u003e\n\n\u003cp\u003e嗯，就这样，我的简单的愿望不知道哪天才能实现啊⋯⋯\u003c/p\u003e\n","cover":"","link":"cloud/2011/11/18/看展台的烦心事/index.html","preview":"","title":"看展台的烦心事"},{"content":"\n\u003cpre\u003e作者：Goldwyn Rodrigues\n原文发布日期：January 22, 2011\n来源：http://lwn.net/Articles/424004/\n译者：王旭( http://wangxu.me , @gnawux )\n翻译时间：2011年11月17日\u003c/pre\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cem\u003e按：上次翻译 LWN 的文章似乎还是\u003ca title=\"[译文] 空指针的乐趣（2）\" href=\"http://wangxu.me/blog/p/46\" target=\"_blank\"\u003e 两年前翻译空指针的乐趣\u003c/a\u003e的事呢，时间好快，这次来深圳高交会看展台，晚上无聊，就翻译了这个。作为这个故事的结局，LIO已经在 2.6.38 进入 kernel 了。\u003c/em\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003cem\u003e\u003c/em\u003e2010年底，\u003ca href=\"http://lwn.net/Articles/420691\" target=\"_blank\"\u003eLIO 项目获选成为新的内核态的 SCSI target\u003c/a\u003e，取代原有的用户态的 STGT 项目。当时有两个主要的竞争项目（LIO和SCST），都在努力将代码并入主线内核。本文将比较着两个项目，并尽力描述他们都提供了什么东西。\u003c/p\u003e\n\n\u003ch2\u003e什么是 SCSI Target？\u003c/h2\u003e\n\n\u003cp\u003eSCSI 子系统使用了一种客户机-服务器（C/S）模型。通常，一台计算机是这个模型中的客户机，称为 initiator（发起者），想 target （目标）发起块操作请求，这个 target 通常是一个存储设备。SCSI Target 子系统可以让一台计算机作为一台 SCSI 存储设备来工作，响应其他 SCSI initiator 节点的存储请求。这样就可以定制 SCSI 存储设备，并让存储设备工作得更加“智能”了。\u003c/p\u003e\n\n\u003cp\u003e一个智能 SCSI Target 的例子是\u003ca href=\"http://www.datadomain.com/products/appliances.html\" target=\"_blank\"\u003eData Domain的在线备份设备\u003c/a\u003e，它具有数据排重的功能，可以节约空间。这个设备从功能上说是个 SCSI target，但它实际是一台智能的计算机，它只存储那些还没有的数据块，对于已经存在的数据，只是增加引用计数，这样只写入那些上次备份之后有变动的块。而在 SCSI 连接的另一边，initiator 看到的设备就是一个普通的、共享的 SCSI 存储设备，只要使用任意的备份软件，将备份写向这个 target就行了。\u003c/p\u003e\n\n\u003cp\u003e最常见的 SCSI target 子系统的实现是 iSCSI 服务器，它使用标准的 TCP/IP 来封装 SCSI 指令，通过网络来提供一个 SCSI 设备。大多数 SCSI target 项目在最初都会先支持 iSCSI 协议。这事因为 iSCSI initiator 和 iSCSI target 之间只需要一个网络连接，差不多所有计算机都可以使用，对它的支持不需要任何特殊硬件。不过，大部分的 SCSI target 还能支持已有的 initiator 卡，所以，如果你又一个光纤通道、SAS 或并行 SCSI 卡，可能某个 SCSI target 项目可以支持这些特定设备的 SCSI 总线。\u003c/p\u003e\n\n\u003ch2\u003e当前状态\u003c/h2\u003e\n\n\u003cp\u003e当前 Linux 内核的 SCSI 子系统使用 STGT 来实现 SCSI target 功能；STGT 是在 2006 年末，由 Fujita Tomonori 引入的。它在内核中有一个库，来配合内核中的 target 驱动工作。而所有的 target 处理都在用户空间完成，这可能回带来一些性能瓶颈。\u003c/p\u003e\n\n\u003cp\u003e有两个还没有并入内核的 SCSI target 实现尅考虑用来替换 STGT：\u003ca href=\"http://www.linux-iscsi.org/\" target=\"_blank\"\u003eLIO\u003c/a\u003e 和\u003ca href=\"http://scst.sourceforge.net/\" target=\"_blank\"\u003e SCST\u003c/a\u003e。SCST 至少在2008年就\u003ca href=\"http://thread.gmane.org/gmane.linux.kernel/628313/focus=640460\" target=\"_blank\"\u003e试图推入 Linux 内核\u003c/a\u003e。当时认为 STGT 项目海可以为内核服务稍长一段时间。但随着时间的推移，STGT 的设计局限被发现，并且有了一个可用的替换方案。替换 SCSI target 子系统的主要条件是由 James Bottomley 确定的，他是 SCSI 的维护者，条件如下：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e它将更换掉已有的 STGT，因为只能有一个 SCSI target 基础设施。\u003c/li\u003e\n\n\u003cli\u003e要使用现代的、基于 sysfs 的控制与配置方式。\u003c/li\u003e\n\n\u003cli\u003e代码要被仔细审查，确定足够干净、可以进入内核。\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e第一个条件被证实太过于严苛了，会不可避免地破坏整个 ABI。所以，当前的目标变成了寻找一种方法，来让 STGT 用户平滑地过渡到新接口上来。\u003c/p\u003e\n\n\u003cp\u003eLIO 替代 STGT 的项目开始于 2010 年的\u003ca href=\"http://lwn.net/Articles/400589/\" target=\"_blank\"\u003e Linux 存储与文件系统峰会（LSF 2010）\u003c/a\u003e。Cristoph Hellwig 志愿来审阅并清理代码，他尽力将代码缩减到一万行以内，使之可以被并入内核。\u003c/p\u003e\n\n\u003ch2\u003e对比\u003c/h2\u003e\n\n\u003cp\u003e两个项目都在他们的官方网站（LIO 和 SCST）上提供了他们的特性对比图表。不过，在探讨它们的不同之前，先来看一下相似性吧。两个项目都实现了一个内核态的 SCSI target 核心。他们都提供了类似 loop device 的本地 SCSI target，这让使用他们的 target 创建虚拟设备变得很方便。两个项目都支持 iSCSI，这是他们的项目的最初的也是最主要的动机。\u003c/p\u003e\n\n\u003cp\u003e两个项目的后端存储管理都可以在内核空间或是用户控件进行。后端存储管理器让 target 的管理员可以控制设备如何输出服务给 initiator。比如，pass-through 后端允许将一个 SCSI 硬件直接提供给用户，而不屏蔽掉这个设备的任何细节；而 virtual-disk 后端则允许将一个文件作为虚拟磁盘来输出给 initiator。\u003c/p\u003e\n\n\u003cp\u003e两个项目都支持永久性预留（Persistent Reservation, PR）；这是一个用于高可用集群中的存储设备的 I/O 隔离与存储设备故障切换、接管的特性。通过使用 PR 命令，initiator 可以在一个 target 上建立、抢占、查询、重置预留策略。在故障接管过程中，新的虚拟资源可以重置老的虚拟资源的预留策略，从而让故障切换更快、更容易地进行。\u003c/p\u003e\n\n\u003ch3\u003eSCST\u003c/h3\u003e\n\n\u003cp\u003eSCSI target 子系统的主要用户是提供存储解决方案的存储公司。大部分这些存储解决方案都提供了即插即用的设备，可以只进行很少的配置，甚至是无需配置，就被加入到一个存储网络。SCST 拥有更广泛的用户群，这可能是因为它们支持更多的传输方式。\u003c/p\u003e\n\n\u003cp\u003eSCST 支持 Qlogic 和 Emulex 的光纤通道卡，而 LIO 目前只支持 Qlogic 的 target 驱动，并且这个驱动也还在 beta 测试截断。SCST 支持 SCSI RDMA 协议（SRP），并宣称对于以太网传输的光纤通道协议（FCoE）、LSI 的并行 SCSI 光纤通道以及串行 SCSI（SAS）等协议的的开发也处于领先地位。目前，它已经对 IBM pSeries 的虚拟 SCSI 提供了支持。目前，Scalable Informatics、Storewize、Open-e 等公司都基于 SCST target 开发了它们的即插即用设备。\u003c/p\u003e\n\n\u003cp\u003eSCST 可以使用异步事件通知（AEN）来通告会话状态的变更。AEN 是一个 SCSI target 用来向 initiator 进行 target 端的事件告知的协议特性，即使在没有服务请求的时候也可以进行。于是 initiator 就可以在 target 端发生事件时，如设备插入、移除、调整尺寸或更换介质时，可以得到通知。这让 initiator 可以以即插即用的方式看到 target 的变化。\u003c/p\u003e\n\n\u003cp\u003eSCST 的开发者声称，它们的设计在健壮性和安全性方面更加符合 SCSI 标准。SCSI 协议要求，如果一个 initiator 要清除另一个 initiator 的预留资源时，预留者必须要得到清除通知，否则，多个 initiator 都可能来改变预留数据，就可能会破坏数据。SCST 可以实现安全的预留、释放操作，避免类似事情发生。\u003c/p\u003e\n\n\u003cp\u003e依照 SCSI 协议，initiator 和 target 可以协商决定传输尺寸。一个 initiator 端错误的传输尺寸通信可能会导致 target 设备端的锁死或是崩溃。SCST 的安全保障机制可以在传输尺寸或方向出错时避免这个问题。他们的代码中具有良好的内存管理策略来避免内存耗尽的情况。还可以限制介入 target 的 initiator 的数量，避免过多连接占用资源。SCST 还支持每个 portal 的可见性管理，也就是说，可以让一个 target 只对一组 initiator 可见。\u003c/p\u003e\n\n\u003ch3\u003eLIO\u003c/h3\u003e\n\n\u003cp\u003eLIO 项目最初是以 iSCSI 作为核心目标的，创建了一个支持 iSCSI 的通用 SCSI target 子系统。简单性是项目的一个重要设计目标，因此，LIO 也更容易理解。除此之外，LIO 的开发者表现得更乐于和内核开发者合作，正如 James 对 SCST 的维护者 Vladislav Bolkhovitin 所\u003ca href=\"http://www.spinics.net/lists/linux-scsi/msg49038.html\" target=\"_blank\"\u003e指出\u003c/a\u003e的：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e来，让我们把事情说得简单一点：在这个社区里，不是让你直接把菜上到桌上就行了，你需要加入到这个社区当中来，称为 linux 内核社区的一部分。更广泛的社区焦炉是开源项目成功的必要条件。你曾经有过这样的机会了：我们在其他地方已经使用了 sysfs，但在 STGT 这里，你就说了一句——这事我们的接口，用它好了。而 LIO 则问了他们所需要的东西，并设法来使用 sysfs 接口。事已至此，你为什么还会对 STGT 的人更倾向于 LIO 而表示大惊小怪呢？\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eLIO 项目还提供了一些 SCST 没有或刚刚开始开发的特性。比如，LIO 支持非对称逻辑卷分配（ALUA）。ALUA 允许 target 管理员来管理 target 的访问状态和路径属性。这让多路径路由机制可以选择最好的路径，从而根据 target 的访问状态，优化带宽的使用。换句话说，在多路径环境下，target 管理员可以通过改变访问状态来调整 initiator 的路径。\u003c/p\u003e\n\n\u003cp\u003eLIO 海支持管理信息数据库（MIB），会让管理 SCSI 设备更简单。SCSI target 设备可以按照 RFC4455 SCSI MIB 的描述方式来输出管理信息，这些信息会被 SNMP agent 收集起来。这个特性扩展了 iSCSI 设备，在管理有很多 SCSI 的存储网络时好处会更加明显。\u003c/p\u003e\n\n\u003cp\u003eiSCSI 连接的错误可能会发生在三个层面上：会话、校验或是连接层。错误恢复工作也可以在这三个层面开始进行，这样就可以在当前的层面开始进行恢复，不会让错误到达下一个层面。错误恢复首先是检查断开的连接。在这种情况下，iSCSI initiator 驱动会主动建立新的到 target 的 TCP 连接它会告诉 target，SCSI 指令路径已经变到新的连接上了。这样 target 就可以在新的连接上处理 SCSI 命令了。这时，上层的 SCSI 驱动对新的连接已经建立、控制信息已经通过新连接传输的事还是毫无知觉的。iSCSI 会话在这期间会保持正常，不会重新变换状态。LIO 支持的最大错误恢复级别（ERL）为2，这就是说，它可以在会话、校验或连接层进行错误恢复。而SCST 支持的 ERL 为 0，也就是说，它智能恢复会话级别的错误，所有连接层面的错误都会转到 SCSI 驱动层面来处理。\u003c/p\u003e\n\n\u003cp\u003eLIO 还支持“会话多连接”（MC/S）。MC/S 让 initiator 可以和 target 在一条或多条物理路径上建立多条连接。这样，在一条路径发生错误的时候，已经建立好的会话可以不中断会话，直接使用其他的路径。MC/S 还可以用来进行所有连接之间的负载均衡。这种情况下，会在所有通信路径上保持会话命令的顺序性。\u003c/p\u003e\n\n\u003cp\u003eLIO 还宣称，他们的代码被用于了\u003ca href=\"http://www.linux-iscsi.org/wiki/Ecosystem\" target=\"_blank\"\u003e很多设备\u003c/a\u003e之中，虽然他们的用户看起来和 SCST 的差不多。\u003c/p\u003e\n\n\u003cp\u003e没有性能对比的对比不是个完整的对比。SCST 的开发者经常会\u003ca href=\"http://article.gmane.org/gmane.linux.scsi/38108\" target=\"_blank\"\u003e放出\u003c/a\u003e他们的性能数据。但是，所有数据都是和 STGT 进行的对比。SCST 的对比页面说，他们的性能好于 LIO，但是是根据代码研究而非真实世界测试的结果。SCST 指责 LIO 没有发布数据，（在我的印象里）确实没有性能数据来在两者之间进行直接对比。\u003c/p\u003e\n\n\u003cp\u003e不过最后，决定已经做出了，虽然有一点反对的声音。现在的任务就是把所有 LIO 没有但有用的特性从 SCST 移植到 LIO 来。尽管这个决定有些争议，但这俨然又是一次试图把不能和内核社区合作的代码并入内核的失败尝试。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"translation/2011/11/18/scsi-targets/index.html","preview":"","title":"[译文] SCSI Target 之双城记"},{"content":"\n\u003cp\u003e嗯，首先声明，这是不客观评价，不同的人、不同的应用会有不同的结论，我的结论就是我的感觉与我的选择，读者可以参考也可以不同意，没必要来跟我争什么，当然，有什么我不知道的也请告知我。\u003c/p\u003e\n\n\u003ch2\u003e公平与不公平\u003c/h2\u003e\n\n\u003cp\u003e作为之前四年都在中国移动工作的同学，如果我心里没有偏向某一方的话，那简直是不可能的，这个我不仅承认，而且可以认为是我开始评价的一个前提。很多人都认为中国移动比中国联通靠谱，其实我也是这么认为的，而且对此更加深信，但是我也不得不承认，某些环节上，中国移动也很不靠谱。\u003c/p\u003e\n\n\u003cp\u003e对比 EDGE 和 WCDMA 本身可能就是不公平的，200K 和 5M之间似乎没什么可比性，但是，对于大量持有一款水货 WCDMA 手机的用户而言，移动或联通，也就是 EDGE 和 WCDMA 的一个对比，用行货 TD 智能手机的，如果不是换的手机，应该就是送的手机，花钱给买个 TD 智能手机，自己成天手机上网的用户，我是觉得比较另类啊。\u003c/p\u003e\n\n\u003cp\u003e嗯，顺便说，即使是 TD 和 WCDMA 的对比也是不公平的，单一的1.6MHz频段对一对5MHz频段，是6倍的关系啊。\u003c/p\u003e\n\n\u003ch2\u003e结论放在前面\u003c/h2\u003e\n\n\u003cp\u003e准备这样：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e联通网络的地面覆盖还是不错的，地下就别提了，总体评价，大部分情况下是比移动的EDGE有优势的。\u003c/li\u003e\n\n\u003cli\u003e联通的电话套餐吸引力不足，过这个月后消掉联通的这张电话卡，维持原有的移动号码。\u003c/li\u003e\n\n\u003cli\u003e联通的上网卡套餐其实不错，准备后面买一张专门的上网的资费卡，配个mifi玩了\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch2\u003e业务的对比和一些揣测\u003c/h2\u003e\n\n\u003cp\u003e首先说说购买和入网，这方面联通做得很不错，网上商城可以直接选号、送到家，与移动相比的一个最大的优势是可以在开通当月就使用套餐。移动的 BOSS 系统提供这个很难么？必须逼着用户在月底才能入网么？简直不能接受啊。当然，网上的免费的联通的3G 号码没什么好号，估计没有不带4的。另外，不知道是联通的渠道策略问题还是经销商管理问题，很多淘宝商家都能买到不同价格的资费卡，对于用户的口袋可能有好处，但背后的混乱也有一点隐忧，而且担心可能会影响到出问题之后的处理。\u003c/p\u003e\n\n\u003cp\u003e卡到手之后说说覆盖，我有几天差不多是在外面跑的，感觉上联通在市区干道上的覆盖挺不错的，不仅一路上都有 3G/HSPA 覆盖，而且连接上 L2TP VPN 之后也基本不会断，这是相当不错的质量了。作为手机用户，我对速度没有明显的快的感觉，但应该不算慢，比较满意。不过在地铁里的覆盖就不敢恭维了，全程没看到过 H 和 3G 的字样，当然，也不能说一直都是 G，确实有的时候连 G 都没有。不过就冲地面的覆盖的质量，还是值得弄一张来上网的。\u003c/p\u003e\n\n\u003cp\u003e再来说说套餐和资费。联通的手机套餐分为A B C 计划，其中A计划是针对上网用户的，流量相对较高，但是流量实际也不算高，66块钱的套餐配有 300MB 流量，问题是之后价格的提升和流量的增长是不成比例的，将近两倍价格的 126 块钱的套餐也只有 400MB 流量，和常理中的“越高流量越便宜”明显相悖。并且，不像移动一样，提供附加的流量套餐。这里，我只能理解为联通对自己的网络容量没有信心，担心用户流量过高了。不过，上网卡支持到半年3G或1年6G的套餐还是不错的，而且可以买到便宜的，这方面不太容易理解啊。\u003c/p\u003e\n\n\u003cp\u003e最后说说渠道。首先说网上营业厅，移动联通真实不分伯仲的差啊，在网站的 UED 方面都非常渣，不说啥了。呼叫中心方面，我感到联通 10010 的 mm 说话比 10086 冷很多，虽然我还是给她打了“满意”，但说实话感觉她们不太专业，用户问到没有的东西的时候，完全不加解释，直接说“没有”，也不会为用户推荐任何可能的替代方案，她说了“没有”之后，我都不知道说啥好了⋯⋯\u003c/p\u003e\n\n\u003cp\u003e就对比这么多吧，嗯。\u003c/p\u003e\n\n\u003ch2\u003e花絮\u003c/h2\u003e\n\n\u003cp\u003e唯一的花絮是——我的手机拒绝显示“中国联通”字样，所有插入中国移动卡时显示“中国移动”字样的地方，换上联通的卡之后，都是空白，没有任何内容。我的手机是Moto Milestone （WCDMA），非定制机，CM7 的 ROM，Android 2.3.5 ，跟 OPhone 没有什么瓜葛。\u003c/p\u003e\n","cover":"","link":"life/2011/09/16/不客观地对比一下移动edge和联通wcdma的业务/index.html","preview":"","title":"不客观地对比一下移动Edge和联通WCDMA的业务"},{"content":"\n\u003cp\u003e这两天和儿子玩以及和老婆吵架想到的，不是想说谁对谁错啊，就是说点感受。\u003c/p\u003e\n\n\u003cp\u003e昨天和3岁半的儿子玩球，发现捡球这事情是这样的：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e对于没接到的球，说服儿子是他没做好，让他捡球是困难的；\u003c/li\u003e\n\n\u003cli\u003e但是，接受儿子的结论，然后问他能不能帮忙捡一下，是可以被欣然接受的，即使球比较远也可以，只要再说声谢谢\u003c/li\u003e\n\n\u003cli\u003e而且，如果跟儿子商量石头剪刀布，赢了的捡球，那么他会抢着赢，甚至有些在我脚边的球，他都要求石头剪刀布\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这就是说：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e如果让人有被请求的感觉，对方是可以接受一些本不乐意的事情的\u003c/li\u003e\n\n\u003cli\u003e如果让人有胜利的骄傲，对方甚至会很愉快地做这样的事情\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e捡球这事骗骗孩子还行，大人就没戏了，但大人的世界有时也很类似，简单的一句话说，就是——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e争辩赢得了道理，但不一定能赢得到最后的结果。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这事情在家庭这种感情因素比重很大的地方尤其适用，对付 bug 啥的我还有点招数，对付老婆方面，我实在是束手无策。最常发生争吵的事情就是：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e自认为有理的时候，老婆坚决拒绝低头，针锋相对，然后⋯⋯\u003c/li\u003e\n\n\u003cli\u003e自认为委屈的时候，老婆坚决不予同情，赶尽杀绝，然后⋯⋯\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，最后结果当然都是我惨败啊。不知道两种情况是不是互逆的啊，呵呵，完美的换位思考这事，真的不是人类能做到的啊。\u003c/p\u003e\n","cover":"","link":"life/2011/09/15/有道理的有时是行不通的/index.html","preview":"","title":"有道理的有时是行不通的"},{"content":"\n\u003cp\u003e抓紧时间记一下，迟了就忘了⋯⋯\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2011/08/IMG_0015.jpg\"\u003e\u003cimg class=\"aligncenter size-medium wp-image-556\" title=\"IMG_0015\" src=\"/assets/IMG_0015-225x300.jpg\" alt=\"\" width=\"225\" height=\"300\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e这里分成山水篇、住行篇和往返篇，分别介绍这次玩的主要景区、武夷山的衣食住行、以及往返的路程，每部分最后都总结了一下一点心得，供参考。\u003c/p\u003e\n\n\u003ch2\u003e山水篇\u003c/h2\u003e\n\n\u003cp\u003e这次在武夷山玩了四天，这里按顺序分别记述每天的行程。\u003c/p\u003e\n\n\u003ch3\u003e保护区：青龙瀑布和龙川大峡谷\u003c/h3\u003e\n\n\u003cp\u003e8月14日当天早上不到7点，到达了武夷山，到住处吃早饭时，刚好遇到一对上海来的夫妇，他们租了车要去生态保护区玩，于是我们就和他们拼车前往了。保护区无法乘坐公交车或旅游车去，租车是唯一的手段，租车的事后面单聊，这里讲讲保护区。\u003c/p\u003e\n\n\u003cp\u003e我们选择了比较轻松的玩法，只去了青龙大瀑布和龙川大峡谷，每个景点每人60块钱。后面回忆，这是最好玩的一天。青龙大瀑布略远，山更陡峭一些，坐车上山，自己爬下来，龙川大峡谷则相反，自己向上爬，累了坐车下来。这两个景点都是顺着水走，所到之处有山有水，绿树成荫，非常舒服。\u003c/p\u003e\n\n\u003cp\u003e[caption id=\"attachment_563\" align=\"alignnone\" width=\"300\" caption=\"青龙瀑布与龙川峡谷\"]\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2011/08/20110818-2142301.jpg\"\u003e\u003cimg class=\"size-medium wp-image-563\" title=\"20110818-214230\" src=\"/assets/20110818-2142301-300x187.jpg\" alt=\"\" width=\"300\" height=\"187\" /\u003e\u003c/a\u003e[/caption]\u003c/p\u003e\n\n\u003cp\u003e后来斯屹累了，坐在我肩膀上走了很长一段路，登山杖有效降低了对膝关节的冲击，只是第二天有些腿疼而已，关节没有问题。\u003c/p\u003e\n\n\u003ch3\u003e天游峰和九曲溪竹筏漂流\u003c/h3\u003e\n\n\u003cp\u003e天游峰和九曲溪都是武夷山的必去科目，我们也不能免俗。第二天，我们上午去爬天游峰，下午九曲溪漂流，这两个都可以坐星村专线到达。我们比较休闲，没有一大早出来，据说早上可以看到云海，不过我们上山的时候都日上三竿了，就不要想这个了。\u003c/p\u003e\n\n\u003cp\u003e天游峰的景致主要在于俯瞰周围的山水，某同学评价是和百花山差不多，只是多了水⋯⋯对此我不发表任何看法了。斯屹在上山时的陡峭部分主要都是自己上去的，或者是妈妈拉着，下山就有一半是在爸爸肩膀上了，等到出了天游峰景区，已经累的睡着了。\u003c/p\u003e\n\n\u003cp\u003e九曲溪则比较轻松，只是开头一段很晒。在九曲溪上，可以路过周围一系列山头，比较著名的可能就是玉女峰了。竹筏需要给10块钱的小费，据说是香港人培养出来的，呵呵。事后我倒更想不给小费，好不要讲解，毕竟也没说出啥来。下面还是照片：\u003c/p\u003e\n\n\u003cp\u003e[caption id=\"attachment_567\" align=\"alignnone\" width=\"300\" caption=\"天游峰与九曲溪\"]\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2011/08/20110818-21423011.jpg\"\u003e\u003cimg class=\"size-medium wp-image-567\" title=\"20110818-2142301\" src=\"/assets/20110818-21423011-300x187.jpg\" alt=\"\" width=\"300\" height=\"187\" /\u003e\u003c/a\u003e[/caption]\u003c/p\u003e\n\n\u003cp\u003e整个武夷山的导游讲解都有些偏色情，什么“一楼泡茶、二楼泡妞”之类的言语总能重复听到，不知是在迎合谁的需要，反正我不喜欢这样的讲解。\u003c/p\u003e\n\n\u003ch3\u003e虎啸岩和一线天\u003c/h3\u003e\n\n\u003cp\u003e连续第三天的爬山，我们的目的地是虎啸岩和一线天，同样乘坐星村专线前往。我们乘车到达虎啸岩，爬山后，从后山徒步走到一线天，然后出一线天，乘车回到住处。\u003c/p\u003e\n\n\u003cp\u003e虎啸岩是一块大石头，据说是因为风吹过会发出虎啸一样的声音而得名，石头山有两条路，好汉坡陡峭，另一条路平坦，但无法到达峰顶。我们成功挑战了好汉坡，斯屹表现很好，其中最陡峭的部分都是自己走上去的，一直到半入云。下面中间那张照片就是在半入云的石门拍的，酷吧。\u003c/p\u003e\n\n\u003cp\u003e从虎啸岩下山一直到一线天，斯屹已经非常累了，我全程一直驮着他，大概数了2500步，才到一线天，还好路不算难走，只是当时水都喝完了，还是很辛苦的，仍然要感谢登山杖，才能平安到达。\u003c/p\u003e\n\n\u003cp\u003e一线天非常坑爹，狭窄是意料中的，意料之外的是里面非常臭，斯屹一直喊“我不想闻这个味”，直到出来，才算是长出一口气，如果再给我一次机会的话，我一定不去一线天。\u003c/p\u003e\n\n\u003cp\u003e[caption id=\"attachment_569\" align=\"alignnone\" width=\"300\" caption=\"虎啸岩和一线天\"]\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2011/08/20110818-2142302.jpg\"\u003e\u003cimg class=\"size-medium wp-image-569\" title=\"20110818-2142302\" src=\"/assets/20110818-2142302-300x187.jpg\" alt=\"\" width=\"300\" height=\"187\" /\u003e\u003c/a\u003e[/caption]\u003c/p\u003e\n\n\u003ch3\u003e《印象大红袍》\u003c/h3\u003e\n\n\u003cp\u003e第三天晚上我们去看了《印象大红袍》表演，话说张艺谋很会圈钱啊，里面差不多还是大型运动会团体操的那个路子，360度转动的观众席用来切换不同的幕算是个新意，作为背景的大王峰是亮点。强烈的光影色彩冲击感觉用力过猛，老婆当时说喜欢，回来回味的时候也觉得不如让人自己感受，而我一直就不喜欢这种风格。\u003c/p\u003e\n\n\u003ch3\u003e武夷宫\u003c/h3\u003e\n\n\u003cp\u003e前三天累坏了，最后一天上午我们去了武夷宫，这里可以去爬大王峰，不过我们没去爬，只在武夷古代名人馆转了一圈，又在宋街看了看有没有什么可买的。宋街实际就在第二天九曲溪漂流下船的码头那里，只是当天出门没来转一圈而已。这里实际没用多长时间，就留这么一张照片吧\u003c/p\u003e\n\n\u003cp\u003e[caption id=\"attachment_571\" align=\"alignnone\" width=\"300\" caption=\"武夷宫、大王峰\"]\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2011/08/IMG_20110817_094403.jpg\"\u003e\u003cimg class=\"size-medium wp-image-571\" title=\"IMG_20110817_094403\" src=\"/assets/IMG_20110817_094403-300x224.jpg\" alt=\"\" width=\"300\" height=\"224\" /\u003e\u003c/a\u003e[/caption]\u003c/p\u003e\n\n\u003ch3\u003eTips：\u003c/h3\u003e\n\n\u003cblockquote\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e如果能不带上孩子就别带了，挺累的；\u003c/li\u003e\n\n\u003cli\u003e如果一定要带上孩子就带着登山杖吧，挺管用的；\u003c/li\u003e\n\n\u003cli\u003e天游峰比较累，九曲溪竹筏漂流平日的票比较好买，虎啸岩一般累，一线天很坑爹，保护区比较好玩。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/blockquote\u003e\n\n\u003ch2\u003e住行篇\u003c/h2\u003e\n\n\u003cp\u003e这次的住行都是老婆安排的，我坐享其成，简要介绍下。\u003c/p\u003e\n\n\u003ch3\u003e候鸟家驴友驿站\u003c/h3\u003e\n\n\u003cp\u003e我们住的候鸟家驴友驿站离景区入口很近，大约不到一公里，早上出屋门就可以看到烟雾缭绕的大王峰。这里的吃住都还不错，老板阿明还可以帮忙买票、联系租车什么的，而且出门走一点点就可以在兰汤站坐星村专线。\u003c/p\u003e\n\n\u003cp\u003e不过我们没用上之前说过的洗衣机，幸好衣服带的多，要么每天一件还真有点困难。\u003c/p\u003e\n\n\u003ch3\u003e星村专线、旅游车、租车，以及黄包车\u003c/h3\u003e\n\n\u003cp\u003e武夷山旅游最经济的手段就是星村专线了，可以到景区大红袍、水帘洞以外差不多所有的景区，包括天游峰、大王峰、九曲溪竹筏码头、虎啸岩、一线天等，根据距离，1-3块钱不等。如果坐旅游车的话，三天票是95块每位，差距太大了。\u003c/p\u003e\n\n\u003cp\u003e如果去保护区玩，必须要自己租车，旅游车也不到。\u003c/p\u003e\n\n\u003cp\u003e我们去看印象大红袍的时候，还坐了一次三轮车，因为太近，没租到车。去的时候，师傅要价6块钱，我们看着辛苦——我承认，是我太重，给了10块，师傅很高兴地10块钱又拉我们回来，一直到住处路口。\u003c/p\u003e\n\n\u003cp\u003e感觉当地人，各种司机乃至蹬黄包车的大叔，都很支持旅游事业，发自内心地向我们推介武夷山的各种好处，呵呵，没有什么抱怨。\u003c/p\u003e\n\n\u003ch3\u003eTips:\u003c/h3\u003e\n\n\u003cblockquote\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e大部分情况下，出门坐星村专线就行了，旅游车完全就是坑爹的；\u003c/li\u003e\n\n\u003cli\u003e候鸟家还不错，可以考虑。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/blockquote\u003e\n\n\u003ch2\u003e往返篇\u003c/h2\u003e\n\n\u003cp\u003e老婆被之前单程 30多个小时的巴西之行飞怕了，这次一定要坐火车。Z59/60的买票有一点波折，不过总的讲一切顺利。\u003c/p\u003e\n\n\u003ch3\u003eZ59/60、京九线\u003c/h3\u003e\n\n\u003cp\u003eZ 字头的车全是 25T 的车底，也算是比较好的车了，软卧还算舒服，只是两个人带着孩子还是有点挤。来回在餐车上吃了几顿，感觉也还算不错。回来的路上，同一隔间是另外一家三口，父母带着一个小萝莉，从武夷山来北京出差+旅游的，还挺热闹的。\u003c/p\u003e\n\n\u003cp\u003e关于回来买票，我们观察了好几天，发现只有发车当天下午会有票，据店家讲，这里的票会被旅行社先全拿走，当天如果有剩下，再退回来，于是就只有当天有机会了。软卧的有票的时间窗口其实还蛮长的，每天都回超过 2个小时，而且经常到发车还有剩下，不过买票当天还是感觉挺紧张的，买到票感觉挺兴奋的。\u003c/p\u003e\n\n\u003ch3\u003eTips:\u003c/h3\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eZ60回京的车票不好买，跟踪几天看规律吧，我们这几天的规律是下午三点半左右开始放出当天晚上的票，软卧还是比较有保障的；\u003c/li\u003e\n\n\u003cli\u003eZ59的票，在北京买，售票点和电话订票95105105都还算靠谱，不用太发愁；\u003c/li\u003e\n\n\u003cli\u003e飞机的话，如果有合适的特价票也不错。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch2\u003e后记\u003c/h2\u003e\n\n\u003cp\u003e其实没什么可记的，就这么几句吧：作为联合国评出来的遗产，武夷山保护的还挺不错的；每年政府都会给老百姓一点小钱，虽然老百姓知道这点只是毛毛雨，但看起来还挺知足，而且自觉维护的，连小贩都会多给我们一个垃圾袋；山顶上的价格也不是非常离谱，整体的物价水平都还比较容易接受。\u003c/p\u003e\n\n\u003cp\u003e总的讲，这次旅游还算挺满意的，就是有点累，后记完成。\u003c/p\u003e\n","cover":"","link":"life/2011/08/22/武夷山游记/index.html","preview":"","title":"武夷山游记"},{"content":"\n\u003cp\u003e其实近期也没打算开始译书，这是时间和精力的原因。但这两天看到china-pub 的一些书评，心里不怎么舒服，在自己的汉语水平得到有效提高之前，我还是暂时不要接这类工作了。\u003c/p\u003e\n\n\u003cp\u003e我可以自我安慰地说某些网友可能就是来踢场子的，毕竟调戏译者也是件挺好玩的事；同时也见到有人在夸我或者安慰我。但译书这件工作本身，是有责任的。我眼里这个责任，不是说我尽力了就可以了，而是确实做好了才行，这是能力问题，而非纯粹的态度问题。就我的个人能力而言，只要认真看，技术文章还是能看懂的，但中文作文的能力自己也没什么信心，我自己能保证所有内容我自己看得懂，却无法让它达到读者所期望的流利水平。\u003c/p\u003e\n\n\u003cp\u003e再者，计算机领域，尤其是快速发展的互联网相关的技术领域，知识的新陈代谢速度非常之快，本书的翻译时间是三个月，前面是原书的出版周期和版权谈判等时间，后面是出版社的整理出版周期。这样，原书是针对0.6 正式版和0.7 Beta 版的，等到中文版上架的时候，0.8 都已经发布了，所幸，主要是增加了几个新特性，而非去掉本书介绍的东西。\u003c/p\u003e\n\n\u003cp\u003e那么我这三个月是怎么干的呢？我是业余翻译，支撑我的是兴趣和责任，在翻译期间，用掉了几乎所有的业余时间，甚至在医院一边排队等号，一边用iPad 翻译，为此还特意买了个蓝牙键盘。所有内容都是过了两遍的：第一遍初译，纯直译方式；第二遍整理，按照我的语言习惯来理顺语言，统一表达等。时间紧迫的情况下，有可能影响整理的精细程度，所以，如果有人说部分内容译得像机器的话，我想应该不是来无理取闹的。\u003c/p\u003e\n\n\u003cp\u003e或许我可以说，快餐的质量无需和大餐去比较，不过我也看过李松峰等优秀译者翻译的文章和一些不错的译著，我必须承认，我在翻译方面的水平仅限于自我娱乐，一两天或三五天翻译一篇自己喜欢的文章还不错，但长篇翻译一本书还是欠火候，我还没有能力在短时间内遣词造句，兼顾表达愿意和语句流畅两个方面。出版业是一个严肃的行业，没能力的同学应该自觉靠边或是回家学习去。\u003c/p\u003e\n\n\u003cp\u003e嗯，当然，在不污染视听的角落里，我还是会悄悄地在我的blog 里，在不违反原作者意愿的情况下，翻译一些我喜欢的文章的，对于读者，可以任其选择读与不读。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"translation/2011/08/01/暂时放弃译书工作了/index.html","preview":"","title":"暂时放弃译书工作了"},{"content":"\n\u003cp\u003e\u003cem\u003e按：王旭（http://wangxu.me/blog, @gnawux）于2011年6月6日译自 ZooKeeper程序员指南 （\u003ca href=\"http://zookeeper.apache.org/doc/r3.3.3/zookeeperProgrammers.html\"\u003ehttp://zookeeper.apache.org/doc/r3.3.3/zookeeperProgrammers.html\u003c/a\u003e）的同名章节。似乎很少有文档提这个啊，我其实在看这个之前一直不明白这东东是怎么用的。\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cspan style=\"font-family: Verdana, Helvetica, sans-serif; font-size: 13px; line-height: 15px; background-color: #ffffff;\"\u003e所有的Zookeeper读操作，包括getData()、getChildren()和exists()，都有一个开关，可以在操作的同时再设置一个watch。在ZooKeeper中，Watch是一个一次性触发器，会在被设置watch的数据发生变化的时候，发送给设置watch的客户端。watch的定义中有三个关键点：\u003c/span\u003e\u003cspan style=\"font-family: Verdana, Helvetica, sans-serif; font-size: 13px; background-color: #ffffff;\"\u003e\u0026nbsp;\u003c/span\u003e\u003c/p\u003e\n\n\u003cdiv class=\"section\"\u003e\n\n\u003cul style=\"padding-top: 0px; padding-right: 25px; padding-bottom: 0px; padding-left: 25px; margin: 0px;\"\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e\u003cstrong\u003e一次性触发器\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e一个watch事件将会在数据发生变更时发送给客户端。例如，如果客户端执行操作getData(\"/znode1\", true)，而后\u0026nbsp;/znode1 发生变更或是删除了，客户端都会得到一个\u0026nbsp;\u0026nbsp;/znode1 的watch事件。如果\u0026nbsp;\u0026nbsp;/znode1 再次发生变更，则在客户端没有设置新的watch的情况下，是不会再给这个客户端发送watch事件的。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e\u003cstrong\u003e发送给客户端\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e这就是说，一个事件会发送向客户端，但可能在在操作成功的返回值到达发起变动的客户端之前，这个事件还没有送达watch的客户端。Watch是异步发送的。但ZooKeeper保证了一个顺序：一个客户端在收到watch事件之前，一定不会看到它设置过watch的值的变动。网络时延和其他因素可能会导致不同的客户端看到watch和更新返回值的时间不同。但关键点是，每个客户端所看到的每件事都是有顺序的。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e\u003cstrong\u003e被设置了watch的数据\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e这是指节点发生变动的不同方式。你可以认为ZooKeeper维护了两个watch列表：data watch和child watch。getData()和exists()设置data watch，而getChildren()设置child watch。或者，可以认为watch是根据返回值设置的。getData()和exists()返回节点本身的信息，而getChildren()返回子节点的列表。因此，setData()会触发znode上设置的data watch（如果set成功的话）。一个成功的\u0026nbsp;create() 操作会触发被创建的znode上的数据watch，以及其父节点上的child watch。而一个成功的\u0026nbsp;delete()操作将会同时触发一个znode的data watch和child watch（因为这样就没有子节点了），同时也会触发其父节点的child watch。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/div\u003e\n\n\u003cp\u003e\u003cspan style=\"font-family: Verdana, Helvetica, sans-serif; font-size: 13px; line-height: 15px; background-color: #ffffff;\"\u003eWatch由client连接上的ZooKeeper服务器在本地维护。这样可以减小设置、维护和分发watch的开销。当一个客户端连接到一个新的服务器上时，watch将会被以任意会话事件触发。当与一个服务器失去连接的时候，是无法接收到watch的。而当client重新连接时，如果需要的话，所有先前注册过的watch，都会被重新注册。通常这是完全透明的。只有在一个特殊情况下，watch可能会丢失：对于一个未创建的znode的exist watch，如果在客户端断开连接期间被创建了，并且随后在客户端连接上之前又删除了，这种情况下，这个watch事件可能会被丢失。\u003c/span\u003e\u003cspan style=\"font-family: Verdana, Helvetica, sans-serif; font-size: 13px; background-color: #ffffff;\"\u003e\u0026nbsp;\u003c/span\u003e\u003c/p\u003e\n\n\u003cdiv class=\"section\"\u003e\u003ca name=\"N10239\"\u003e\u003c/a\u003e\u003ca name=\"sc_WatchGuarantees\"\u003e\u003c/a\u003e\u003cbr /\u003e\n\n\u003ch3 class=\"h4\" style=\"font-family: 'Trebuchet MS', verdana, arial, helvetica, sans-serif; font-weight: bold; margin-top: 18px; margin-bottom: 0px; font-size: 17px; margin-right: 0px; margin-left: 0px; padding: 0px;\"\u003eZooKeeper对Watch提供了什么保障\u003c/h3\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; margin-top: 0.5em; margin-bottom: 1em;\"\u003e对于watch，ZooKeeper提供了这些保障：\u003c/p\u003e\n\n\u003cul style=\"padding-top: 0px; padding-right: 25px; padding-bottom: 0px; padding-left: 25px; margin: 0px;\"\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003eWatch与其他事件、其他watch以及异步回复都是有序的。\u0026nbsp;ZooKeeper客户端库保证所有事件都会按顺序分发。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cul style=\"padding-top: 0px; padding-right: 25px; padding-bottom: 0px; padding-left: 25px; margin: 0px;\"\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e客户端会保障它在看到相应的znode的新数据之前接收到watch事件。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cul style=\"padding-top: 0px; padding-right: 25px; padding-bottom: 0px; padding-left: 25px; margin: 0px;\"\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e从ZooKeeper接收到的watch事件顺序一定和ZooKeeper服务所看到的事件顺序是一致的。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca name=\"N1025E\"\u003e\u003c/a\u003e\u003ca name=\"sc_WatchRememberThese\"\u003e\u003c/a\u003e\u003cbr /\u003e\n\n\u003ch3 class=\"h4\" style=\"font-family: 'Trebuchet MS', verdana, arial, helvetica, sans-serif; font-weight: bold; margin-top: 18px; margin-bottom: 0px; font-size: 17px; margin-right: 0px; margin-left: 0px; padding: 0px;\"\u003e关于Watch的一些值得注意的事情\u003c/h3\u003e\n\n\u003cul style=\"padding-top: 0px; padding-right: 25px; padding-bottom: 0px; padding-left: 25px; margin: 0px;\"\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003eWatch是一次性触发器，如果你得到了一个watch事件，而你希望在以后发生变更时继续得到通知，你应该再设置一个watch。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cul style=\"padding-top: 0px; padding-right: 25px; padding-bottom: 0px; padding-left: 25px; margin: 0px;\"\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e因为watch是一次性触发器，而获得事件再发送一个新的设置watch的请求这一过程会有延时，所以你无法确保你看到了所有发生在ZooKeeper上的一个节点上的事件。所以请处理好在这个时间窗口中可能会发生多次znode变更的这种情况。（你可以不处理，但至少请认识到这一点）。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cul style=\"padding-top: 0px; padding-right: 25px; padding-bottom: 0px; padding-left: 25px; margin: 0px;\"\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e一个watch对象或一个函数/上下文对，为一个事件只会被通知一次。比如，如果同一个watch对象在同一个文件上分别通过exists和getData注册了两次，而这个文件之后被删除了，这时这个watch对象将只会收到一次该文件的deletion通知。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cul style=\"padding-top: 0px; padding-right: 25px; padding-bottom: 0px; padding-left: 25px; margin: 0px;\"\u003e\n\n\u003cli style=\"margin-top: 0.5em; margin-bottom: 0.5em; padding-top: 0px; padding-right: 5px; padding-bottom: 0px; padding-left: 5px;\"\u003e\n\n\u003cp style=\"line-height: 15px; text-align: left; padding: 0px; margin: 0px;\"\u003e当你从一个服务器上断开时（比如服务器出故障了），在再次连接上之前，你将无法获得任何watch。请使用这些会话事件来进入安全模式：在disconnected状态下你将不会收到事件，所以你的程序在此期间应该谨慎行事。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"translation/2011/06/06/zookeeper-watches/index.html","preview":"","title":"ZooKeeper Watches"},{"content":"\n\u003cdiv\u003e\n\n\u003cp id=\"internal-source-marker_0.6600217127706856\"\u003e我刚刚做了一个艰难的决定——离开中国移动研究院，加入盛大创新院。对很多人来说这不算什么；对一些人来说，这无法理解。是的，钱是问题，不过，也不是所有问题，我希望在离开之前，把自己的一些想法说清，不求理解，但求备忘。\u003c/p\u003e\n\n\u003ch2\u003e总免不了，最初的一阵痛\u003c/h2\u003e\n\n\u003cp\u003e2007年，刚刚毕业的我，进入了中国移动通信研究院，在这里度过了四个生日、四个新年，不敢说兢兢业业，也没什么斐然的成绩，到这个月，终于接近了一个终点。在一个商业社会，换工作并不是什么难以想象的事，对于一个打工者，四年也算个不短的时间了，可是我作为一个从未跳槽过的人，总免不了最初的一阵痛。\u003c/p\u003e\n\n\u003cp\u003e难忘一起入职、一起奋斗的同事徐萌和郭磊涛，我们一起来报到，一起度过四年时光，特别是小郭，很多次Team building、工会活动，我们都分在一个房间。\u003c/p\u003e\n\n\u003cp\u003e难忘带我第一次出差的蓝总，虽然那次我们损失了一件冲锋衣，还有一起调研呼叫中心的唐总，咱们几个在一起干活、聊天也是从07年开始的。\u003c/p\u003e\n\n\u003cp\u003e难忘安宁，很投缘的人，很多交流，很遗憾在你不在单位的时候选择离职。\u003c/p\u003e\n\n\u003cp\u003e难忘周华，总是一本正经的分析问题，我不会再说你是奥特曼了。\u003c/p\u003e\n\n\u003cp\u003e难忘赵立芬，以后不会互相搭车回家了。\u003c/p\u003e\n\n\u003cp\u003e难忘吕锐新，对不起，我不再陪你一起得C了，14个对我来说是个终点了。\u003c/p\u003e\n\n\u003cp\u003e难忘程宇，有个人分享软件和新闻、一起玩iPad真的很好。\u003c/p\u003e\n\n\u003cp\u003e我不是在点名，所以，就不继续提起更多的兄弟姐妹的名字、不再徒添伤感了。天下没有不散的筵席，我们就此举杯别过吧。\u003c/p\u003e\n\n\u003ch2\u003e是的，可能是个错误\u003c/h2\u003e\n\n\u003cp\u003e这次跳槽可能是个错误，我不回避这个问题。\u003c/p\u003e\n\n\u003cp\u003e不谦虚的自我评价一下，我是个有很强思考能力聪明人，但却不是一个善于决断的人，一言以蔽之，多谋但不善断。\u003c/p\u003e\n\n\u003cp\u003e在我还不长的这半辈子里，让我事后觉得懊恼的决定不胜枚举，从小学的选择直到读博，选错的可能不比选对的少。\u003c/p\u003e\n\n\u003cp\u003e但是，对于整体局势的判断，我还是相当有信心的，我相信，对于我个人而言，离开的时机和去向都有可能有差错，但离开的选择本身不会有错。\u003c/p\u003e\n\n\u003ch2\u003e离开，不是因为恨\u003c/h2\u003e\n\n\u003cp\u003e来到移动研究院之后，我对移动有了越来越多的认识，我知道，这不止是靠国家垄断资源盈利的一家公司，它的管理层和企业文化中，也有值得尊重的一面。在来到移动之后，我就再也不曾从内心里鄙视这家公司，当然，这里面毫无疑问的有屁股决定脑袋的成分。\u003c/p\u003e\n\n\u003cp\u003e我不是一个在离开时就一定说恭维话的人，这里还有很多不规范、不成熟和其他让人不满意的地方，我对自己在这里的工作确实有些不满，但这不是我最终决定离开的原因。\u003c/p\u003e\n\n\u003cp\u003e正如两个很好的人不一定能组成一个幸福的家庭一样，好的职位只是对合适的人而言的，而非对所有优秀的人而言。我有一个不错的职位，但我感到这不合适：\u003c/p\u003e\n\n\u003cp\u003e这不是我的职业发展路线\u003c/p\u003e\n\n\u003cp\u003e——这就是我离开的原因。\u003c/p\u003e\n\n\u003ch2\u003e为什么选择盛大\u003c/h2\u003e\n\n\u003cp\u003e为什么选择盛大，这的确是个问题，钱确实是问题的一个很大的部分，但也有很多其他部分，当然，不包括和张靓颖成为同事这条。\u003c/p\u003e\n\n\u003cp\u003e在最近一段，我曾经接触过几家别的公司，但毫无疑问，我都没有让他门感到我有足够的性价比，或者说我的面试准备可能谈不上出色，也可能是中国移动研究院的待遇确实还不错。\u003c/p\u003e\n\n\u003cp\u003e我曾经不愿意选择盛大，因为我从思想上还没准备好“进军娱乐业”，不过，通过面试和后来电话的交流，我体会到了：\u003c/p\u003e\n\n\u003cp\u003e自己在交流中被尊重了，这可能是不理智的一面，但我确实因此跨越了“进军娱乐业”的心理障碍；\u003c/p\u003e\n\n\u003cp\u003e盛大在认真的做一件事情，而我也想认真的做一件事情，刚好，它们可以是同一件事情。\u003c/p\u003e\n\n\u003cp\u003e所以，我相信，这个选择有可能不是最优的，但也是一个不错的选择。\u003c/p\u003e\n\n\u003ch2\u003e或许……\u003c/h2\u003e\n\n\u003cp\u003e是的，对职业生涯而言，我还只是一只小小鸟，直到飞上青天才会发现自己真的无依无靠。\u003c/p\u003e\n\n\u003cp\u003e或许我不该对职业路线有过高的期待，或许我现在还没有真的找到自己想要的，或许我丢弃了一些最值得珍惜的……\u003c/p\u003e\n\n\u003cp\u003e但是，这就是生活，可以懊恼，却不会回头。\u003cbr /\u003e\n这就是我在2011年4月留给自己的记忆，感谢你们，每一个看到的人。\u003c/p\u003e\n\n\u003c/div\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"life/2011/05/10/一个艰难的决定/index.html","preview":"","title":"一个艰难的决定"},{"content":"\n\u003cp\u003e发到这里了：\u003ca href=\"http://wangsiyi.net/siyi/p/51\"\u003ehttp://wangsiyi.net/siyi/p/51\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e视频用SONY的DV拍的，然后用ffmpeg转码，然后用openshot编辑的，期间crash了好几次，WTF，然后又ffmpeg出了一个比较低质量、小体积的，上传了，就是这个：\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u003cembed src=\"http://player.youku.com/player.php/sid/XMjY0NTI3NTMy/v.swf\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"sameDomain\" type=\"application/x-shockwave-flash\"\u003e\u003c/embed\u003e\u003c/p\u003e\n","cover":"","link":"life/2011/05/06/斯屹的家庭作业/index.html","preview":"","title":"斯屹的家庭作业"},{"content":"\n\u003cp\u003e\n\n\u003cdiv style=\"color: #000000; font-family: 'Lucida Grande', Verdana, Arial, Helvetica, sans-serif; font-size: 13px; margin-top: 8px; margin-right: 12px; margin-bottom: 8px; margin-left: 12px; background-image: url(http://assets.tumblr.com/images/input_bg.gif); background-attachment: initial; background-origin: initial; background-clip: initial; background-color: #ffffff; line-height: 1.4; font-weight: normal; background-position: 50% 0%; background-repeat: repeat no-repeat; padding: 0px;\"\u003e\n\n\u003cp\u003e这个可以把原有DV的输出压缩到原来的一半以下，质量上，我自己看不出区别\u003c/p\u003e\n\n\u003cblockquote style=\"border-left-style: solid; border-left-width: 4px; border-left-color: #e4e4e4; margin-left: 30px; padding-left: 15px;\"\u003e\u003cp\u003effmpeg -i $f -vcodec libx264 -vpre veryfast -crf 20 -threads 0 -acodec flac ${f%MPG}mkv\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e主要参考了\u003c/p\u003e\n\n\u003cp\u003e\u003ca style=\"color: #007bff;\" href=\"http://rob.opendot.cl/index.php/useful-stuff/ffmpeg-x264-encoding-guide/\"\u003ehttp://rob.opendot.cl/index.php/useful-stuff/ffmpeg-x264-encoding-guide/\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e和\u003c/p\u003e\n\n\u003cp\u003e\u003ca style=\"color: #007bff;\" href=\"http://www.twm-kd.com/linux/encoding-videos-with-ffmpeg-and-h-264/\"\u003ehttp://www.twm-kd.com/linux/encoding-videos-with-ffmpeg-and-h-264/\u003c/a\u003e\u003c/p\u003e\n\n\u003cdiv\u003e\u003c/div\u003e\n\n\u003c/div\u003e\n","cover":"","link":"scripts/2011/05/05/研究了一宿，找到了个合适的ffmpeg参数/index.html","preview":"","title":"研究了一宿，找到了个合适的ffmpeg参数"},{"content":"\n\u003cp\u003e历时三个月，我于今天凌晨2点完成了\u003ca href=\"http://twitter.com/#!/ebenhewitt\"\u003eEben Hewitt\u003c/a\u003e著，O‘Reilly出版的\u003ca href=\"http://oreilly.com/catalog/0636920010852\"\u003eCassandra: The Definitive Guide\u003c/a\u003e（中文名《Cassandra权威指南》）的全部文稿的翻译工作，本书将由图灵图书在国内出版。本人的更多有关Cassandra和其他主题的译文可以在本人blog的\u003ca href=\"http://wangxu.me/blog/tag/translation\"\u003e译文标签\u003c/a\u003e下找到。由于个人原因，在未来几个月内恐怕不会再翻译书了，呵呵，不过本书的翻译过程很愉快，也很让人兴奋，感谢图灵的\u003ca href=\"http://twitter.com/#!/turingbook\"\u003e刘江老师\u003c/a\u003e和编辑们。\u003c/p\u003e\n\n\u003cp\u003e后面编辑们会进行一系列辛苦工作，而我基本可以等着看新书上市了 :)\u003c/p\u003e\n\n\u003cp\u003e下面是译者序，再次向在翻译过程中给予我支持和帮助的人致谢，还有我的家人：\u003c/p\u003e\n\n\u003cp\u003e对于一位分布式存储系统的开发者，Cassandra无疑是非常引人注目的，它的无中心架构、高可用性、无缝扩展，等继承自亚马逊Dynamo的特质，使之相对于其他主从架构的NoSQL系统更加简洁，也更具有美感。\u003c/p\u003e\n\n\u003cp\u003e我从2010年初开始关注这个系统，并曾翻译了几篇Cassandra相关的文章，还引起一些相关的讨论。2010年底，当刘江老师寻找本书的译者时，我按耐不住毛遂自荐了一下，并在随后在2011年1月中下旬，开始了本书的翻译工作。用了三个月的业余时间，终于在4月完成了译稿。因为Cassandra仍在快速开发中，翻译时我也尽力能更快一些，以便能让本书中文版出版时不至于落伍。\u003c/p\u003e\n\n\u003cp\u003e本书对Cassandra的概念、架构、配置、使用进行了全面的介绍，作者在介绍时非常详尽，而且给出了很多参考信息。对于希望了解Cassandra，评估Cassandra是否适合自己的应用，以及开始着手在Cassandra上进行应用开发的人都是不错的读物。当然，如果想参与Cassandra的开发或做更深入的工作，还需要直接通过源代码来获取更详尽的信息。\u003c/p\u003e\n\n\u003cp\u003e在翻译中，我尽力使用已有的、被广泛接受的中文名词，对于一些没有广泛接受的中文名词的术语，在没有歧义的时候，我会选择一个自以为恰当的词，并不时给出英文，以避免读者在接触代码时和本书给出的名词无法对应。还有很多名词没有贴切的中文对应、中文名词容易产生歧义或是国内开发者也习惯使用英文，对于这样的术语，我在翻译中也保留了英文原文。这些选择都以帮助理解、避免歧义为第一考虑。\u003c/p\u003e\n\n\u003cp\u003e在本书的翻译过程中，得到了很多朋友和网友的关注，希望没有让他们久等。我的同事郭磊涛，作为数据库和HBase 的专家、Cassandra用户，在本书的翻译过程中给出了很多有益的帮助。感谢图灵和CSDN的刘江老师，给我这个机会把Cassandra介绍给大家。当然，还要感谢图灵的编辑杨海玲、傅志红，还有李松峰在本书翻译的过程中进行的细心工作。\u003c/p\u003e\n\n\u003cp\u003e希望本书的翻译工作能对读者进入NoSQL的世界、开始自己的Cassandra应用有些许的帮助。\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"works/2011/04/25/cassandra-definitive-guide/index.html","preview":"","title":"《Cassandra权威指南》翻译完成"},{"content":"\n\u003cp\u003e大概用了三天弄出来的，当前trunk的FSDataset的结构\u0026amp;调用关系图，肯定有疏漏的地方。这个文件现在是HDFS里，仅次于FSNamesystem的最长的文件了。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg style=\"vertical-align: middle; border: 1px solid black;\" src=\"/assets/FSDataset.png\" alt=\"Illustration of FSDataset\" width=\"500\" height=\"500\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"cloud/2011/04/07/fsdataset结构图/index.html","preview":"","title":"FSDataset结构图"},{"content":"\n\u003cp\u003e主页网志就是小朋友的名字：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003ehttp://wangsiyi.net/siyi/\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e目前初步有了些内容，欢迎访问。作为该域名的监护人，我的邮箱是 father (at) wangsiyi.net \u003c/p\u003e\n","cover":"","link":"life/2011/04/01/欢迎访问王斯屹小朋友的主页/index.html","preview":"","title":"欢迎访问王斯屹小朋友的主页"},{"content":"\n\u003cp\u003e昨天晚上给儿子的幼儿园做的，照片都是从 ourmetro 上搜集的，感谢啊\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cdiv id=\"__ss_7434890\" style=\"width: 425px;\"\u003e\u003cstrong style=\"display: block; margin: 12px 0 4px;\"\u003e\u003ca title=\"Metro Beijing\" href=\"http://www.slideshare.net/gnawux/metro-beijing\"\u003eMetro Beijing\u003c/a\u003e\u003c/strong\u003e\u003cobject id=\"__sse7434890\" width=\"425\" height=\"355\"\u003e\u003cparam name=\"movie\" value=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=metro-110329130747-phpapp02\u0026amp;stripped_title=metro-beijing\u0026amp;userName=gnawux\" /\u003e\u003cparam name=\"allowFullScreen\" value=\"true\" /\u003e\u003cparam name=\"allowScriptAccess\" value=\"always\" /\u003e\u003cembed type=\"application/x-shockwave-flash\" width=\"425\" height=\"355\" src=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=metro-110329130747-phpapp02\u0026amp;stripped_title=metro-beijing\u0026amp;userName=gnawux\" name=\"__sse7434890\" allowscriptaccess=\"always\" allowfullscreen=\"true\"\u003e\u003c/embed\u003e\u003c/object\u003e\u003c/p\u003e\n\n\u003cdiv style=\"padding: 5px 0 12px;\"\u003eView more \u003ca href=\"http://www.slideshare.net/\"\u003epresentations\u003c/a\u003e from \u003ca href=\"http://www.slideshare.net/gnawux\"\u003egnawux\u003c/a\u003e.\u003c/div\u003e\n\n\u003c/div\u003e\n","cover":"","link":"life/2011/03/30/地铁与地铁列车（北京）/index.html","preview":"","title":"地铁与地铁列车（北京）"},{"content":"\n\u003cp\u003e场景是这样的，两台机器A和B，通过缺省路由互相可达；希望A通过B的连接出去；A的地址为动态分配，且A可能的interface不缺定，因此，上来先给点先决条件：\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e#!/bin/bash\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003edefault_dev=\"wlan0\"\u003c/p\u003e\n\n\u003cp\u003edefault_gw=\"192.168.12.1\"\u003c/p\u003e\n\n\u003cp\u003eflag_nogw=\"false\"\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003elocal_ip=192.168.12.111\u003c/p\u003e\n\n\u003cp\u003ethost_ip=192.168.32.214\u003c/p\u003e\n\n\u003cp\u003etnet_cidr=\"192.168.32.0/21\"\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003elocal_tun_addr=\"172.16.1.1\"\u003c/p\u003e\n\n\u003cp\u003eremote_tun_addr=\"172.16.1.254\"\u003c/p\u003e\n\n\u003cp\u003etun_dev=\"tun9\"\u003c/p\u003e\n\n\u003cp\u003etun_cidr=\"172.16.0.0/16\"\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e然后，想办法获取缺省路由的接口和网关地址，当然，不一定所有的缺省路由都有网关地址\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e# get default gw and local ip address\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003eroute -n | while read dst gw msk flag metric ref use iface\u003c/p\u003e\n\n\u003cp\u003edo\u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; if [ \"$dst\" = \"0.0.0.0\" -a \"$msk\" = \"0.0.0.0\" ]\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; then \u0026nbsp; \u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; default_dev=$iface\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; if [ \"$flag\" = \"UG\" ]\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; then \u0026nbsp; \u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; default_gw=$gw\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; else \u0026nbsp; \u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; flag_nogw=\"true\"\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; fi \u0026nbsp; \u0026nbsp; \u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; fi \u0026nbsp; \u0026nbsp; \u0026nbsp;\u003c/p\u003e\n\n\u003cp\u003edone\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cdiv\u003e之后判断一下连在缺省接口上的IP地址\u003c/div\u003e\n\n\u003cdiv\u003e\n\n\u003cblockquote\u003e\n\n\u003cdiv\u003elocal_ip=$(ifconfig $default_dev | grep \"inet addr\"|sed -ne 's/.*inet addr:\\([.0-9]\\+\\).*/\\1/p')\u003c/div\u003e\n\n\u003c/blockquote\u003e\n\n\u003c/div\u003e\n\n\u003cdiv\u003e然后在远程主机上启动隧道、配置路由，并设置NAT：\u003c/div\u003e\n\n\u003cdiv\u003e\n\n\u003cblockquote\u003e\n\n\u003cdiv\u003essh ${thost_ip} iptunnel add ${tun_dev} mode ipip remote $local_ip local ${thost_ip}\u003c/div\u003e\n\n\u003cdiv\u003essh ${thost_ip} ifconfig ${tun_dev} ${remote_tun_addr}\u003c/div\u003e\n\n\u003cdiv\u003essh ${thost_ip} route add -net ${tun_cidr} dev ${tun_dev}\u003c/div\u003e\n\n\u003cdiv\u003essh ${thost_ip} iptables -t nat -A POSTROUTING -s ${local_tun_addr} -j MASQUERADE\u003c/div\u003e\n\n\u003c/blockquote\u003e\n\n\u003c/div\u003e\n\n\u003cdiv\u003e接下来设置本机上的隧道和路由：\u003c/div\u003e\n\n\u003cdiv\u003e\n\n\u003cblockquote\u003e\n\n\u003cdiv\u003e#setup tunnel on local machine\u003c/div\u003e\n\n\u003cdiv\u003eiptunnel add ${tun_dev} mode ipip remote ${thost_ip} local ${local_ip}\u003c/div\u003e\n\n\u003cdiv\u003eifconfig ${tun_dev} ${local_tun_addr}\u003c/div\u003e\n\n\u003cdiv\u003eroute add -net ${tun_cidr} dev ${tun_dev}\u003c/div\u003e\n\n\u003c/blockquote\u003e\n\n\u003c/div\u003e\n\n\u003cdiv\u003e最后，改缺省路由\u003c/div\u003e\n\n\u003cdiv\u003e\n\n\u003cblockquote\u003e\n\n\u003cdiv\u003e#setup default route rule\u003c/div\u003e\n\n\u003cdiv\u003eif [ \"${flag_nogw}\" = \"false\" ]\u003c/div\u003e\n\n\u003cdiv\u003ethen\u003c/div\u003e\n\n\u003cdiv\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; route add -net ${tnet_cidr} gw ${default_gw}\u003c/div\u003e\n\n\u003cdiv\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; route del default gw ${default_gw}\u003c/div\u003e\n\n\u003cdiv\u003eelse\u003c/div\u003e\n\n\u003cdiv\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; route add -net ${tnet_cidr} dev ${default_dev}\u003c/div\u003e\n\n\u003cdiv\u003e\u0026nbsp; \u0026nbsp; \u0026nbsp; \u0026nbsp; route del default dev ${default_dev}\u003c/div\u003e\n\n\u003cdiv\u003efi\u003c/div\u003e\n\n\u003cdiv\u003eroute add default gw ${remote_tun_addr}\u003c/div\u003e\n\n\u003c/blockquote\u003e\n\n\u003c/div\u003e\n\n\u003cdiv\u003e完毕。\u003c/div\u003e\n","cover":"","link":"scripts/2011/03/28/一个自动搭建ipip隧道的脚本/index.html","preview":"","title":"一个自动搭建ipip隧道的脚本"},{"content":"\n\u003cp\u003e这两天用svm同步hadoop上游的svn仓库的时候遇到个小问题，刚刚fix了，特此贴出来：\u003c/p\u003e\n\n\u003ch2\u003e同步仓库\u003c/h2\u003e\n\n\u003cp\u003e如果是RHEL/CentOS 5的话，安装 perl-SVN-Mirror 包，其他 distro 未尝试，应该类似，然后用 svnadmin 创建一个仓库，这个应该不用教，呵呵\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003emkdir –p /state/partion1/repo/\u003c/p\u003e\n\n\u003cp\u003esvnadmin create mirror\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这个仓库mirror就是我们准备用于做镜像的仓库了，然后初始化仓库，需要先设置环境变量\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eexport SVMREPOS=”/state/partion1/repo/mirror”\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e然后初始化\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003esvm init hadoop-common \u003ca href=\"http://svn.apache.org/repos/asf/hadoop/common\"\u003ehttp://svn.apache.org/repos/asf/hadoop/common\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这里的hadoop-common是在新仓库里的路径，现在，就可以来同步仓库了\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003esvm sync hadoop-common\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e如果一切顺利的话，经过相当长一段时间的同步，镜像仓库就可以顺利使用了，新仓库的路径是：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003ca href=\"file:///state/partion1/repo/mirror/hadoop-common\"\u003efile:///state/partion1/repo/mirror/hadoop-common\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e至于如果需要HTTP访问或是其他什么特殊的定制的话，可以自行配置了。可以重复执行上面的同步命令来追加同步上游仓库里的更新\u003c/p\u003e\n\n\u003ch2\u003e仓库锁定的问题及修复\u003c/h2\u003e\n\n\u003cp\u003e昨天遇到的一个问题是仓库同步的时候，被我用C-c中断了，于是出现了一个无法解锁的问题，重复打印错误：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eWaiting for sync lock on /hadoop-common: wang.xu:9660.\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e经过大约2小时的源码和命令研究，大致明白了问题，首先分解上面的这句话：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003esync是加锁的命令，svm sync\u003c/li\u003e\n\n\u003cli\u003e/hadoop-common是同步的路径\u003c/li\u003e\n\n\u003cli\u003ewang.xu是出错的主机的hostname\u003c/li\u003e\n\n\u003cli\u003e9660是加锁的进程的PID\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e试图直接利用svm自己来解锁失败后，改为研究它是怎么加锁的，最终证明：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e所谓的锁是一个加在 revision 0 上的 revision property\u003c/li\u003e\n\n\u003cli\u003e锁的名字由加锁命令和路径构成，形式如 svm:lock:sync:_hadoop-common ，路径里的 _ 会被替换为 __，而/则会替换为_\u003c/li\u003e\n\n\u003cli\u003e锁的内容由主机和PID构成，形式如wang.xu:9660\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e可以这样看到：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e$ svnlook pg –revprop –r0 mirror/ svm:lock:sync:_hadoop-common      \u003cbr /\u003ewang.xu:9660\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e上面的mirror/是仓库的文件系统路径。自然地，应该这么去掉这个属性就可以解锁了：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003esvn pd svm:lock:sync:_hadoop-common –revprop –r 0 \u003ca href=\"file:///state/partion1/repo/mirror/\"\u003efile:///state/partion1/repo/mirror/\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e不过，大部分svn仓库缺省不允许revision property随便写的，所以，这个命令无法成功，需要编辑这个hook文件\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e/state/partion1/repo/mirror/hook/pre-revprop-change\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e让这个文件对于我们的编辑返回0，甚至临时改成就一行 exit 0 也行，以后记得改过来就好。然后，务必给这个文件加执行权限，并且，上述svn命令的执行者需要可以访问这个目录且有执行权限。\u003c/p\u003e\n\n\u003cp\u003e这样，执行上述svn pd命令即可。现在，锁被消灭了，可以正常更新了。\u003c/p\u003e\n","cover":"","link":"linux/2011/01/19/用svm同步svn仓库及解决锁问题/index.html","preview":"","title":"用SVM同步SVN仓库及解决锁问题"},{"content":"\n\u003ch2\u003e巴克球是每个人的\u003c/h2\u003e\n\n\u003cp\u003e嗯，免费广告一则，斯屹也很喜欢，抢走我的巴克球，玩了一晚上\u003c/p\u003e\n\n\u003cp\u003e\u003cembed src=\"http://player.youku.com/player.php/sid/XMjMyNjA0MjE2/v.swf\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"sameDomain\" type=\"application/x-shockwave-flash\"\u003e\u003c/embed\u003e\u003c/p\u003e\n\n\u003ch2\u003e让单车飞\u003c/h2\u003e\n\n\u003cp\u003e斯屹小伙子长大了，可以自己骑车去超市了，正式宣告我儿子可以打酱油了，哈\u003c/p\u003e\n\n\u003cp\u003e\u003cembed src=\"http://player.youku.com/player.php/sid/XMjMyNjA1MTMy/v.swf\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"sameDomain\" type=\"application/x-shockwave-flash\"\u003e\u003c/embed\u003e\u003c/p\u003e\n","cover":"","link":"life/2010/12/27/斯屹生活视频两则/index.html","preview":"","title":"斯屹生活视频两则"},{"content":"\n\u003cp\u003e从05年到10年，LinuxFB版聚在不知不觉中已经开到第六年了，六年中的，很多人都参与到了讨论中，也有很多人贡献了自己的Presentation，作为最初的组织者之一，在岁末，希望感谢所有这些参与者，当然，更要感谢两位积极的组织者\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003ca href=\"http://twitter.com/hzmangel\"\u003e@hzmangel\u003c/a\u003e (\u003ca href=\"http://www.hzmangel.info/blog/\"\u003eblog\u003c/a\u003e)：虽然说 \u003ca href=\"http://twitter.com/colyli\"\u003e@colyli\u003c/a\u003e 是我们的精神领袖，但胡子同学做了大量事务性和创造性的工作，包括我们的网站代码：\u003ca href=\"http://linuxfb.net\"\u003ehttp://linuxfb.net\u003c/a\u003e , 收集管理幻灯片 (\u003ca href=\"http://www.slideshare.net/hzmangel\"\u003eslideshare\u003c/a\u003e) ，还包括会议室准备、会议餐饮支持等，是当之无愧的第一位要感谢的同学\u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://twitter.com/colyli\"\u003e@colyli\u003c/a\u003e（\u003ca href=\"http://blog.coly.li/\"\u003eblog\u003c/a\u003e）：很委屈 Coly，放在了第二位，他是LinuxFB的精神领袖，也是最积极的推动者，不仅常年资助就餐活动、邀请重量级嘉宾、提供各种新奇纪念品，还把活动的影响力推向了国外。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e相比于他们，我好像什么都没做过啊。不过我想我还是一个合格的见证者，这次继续见证版聚。\u003c/p\u003e\n\n\u003cp\u003e本次版聚的第一个话题是我的偶像——bergwolf (\u003ca href=\"http://twitter.com/oatgnep\"\u003e@oatgnep\u003c/a\u003e) 讲的 pNFS，和以往一样，每次听bergwolf 讲东西都会有新收获。这次他介绍了 pNFS 和 EMC 私有的 MPFS，pNFS 和 NFS 4.1 的关系，介绍了 pNFS 的现状、进入kernel的进程和 pNFS 中的技术概念。\u003c/p\u003e\n\n\u003cp\u003e通观整个Topic，感觉 pNFS 仍然处于一种厂商主导、消费者观望的状态，由于\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e开源的 pNFS Server可能在短时间内都无法和存储厂商的产品相抗衡\u003c/li\u003e\n\n\u003cli\u003e不同厂商的 pNFS 服务之间仍然不能完美互通（pNFS server和数据服务之间的接口是内部接口）\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e个人认为，这一规范的应用的普及可能会比较慢。\u003c/p\u003e\n\n\u003cp\u003e第二个话题是Leaf John介绍的ofono——Meego的Telephony软件，管理不同接口的 Modem，通过这个Topic，我才知道，原来不同的手机/Modem的接口种类很多，不一定都是接收 AT Command 的各种串口，也知道用 D-Bus 非常方便。原来对 D-Bus 只是远距离听说，现在看真的挺不错的，支持 D-Bus 一统江湖。\u003c/p\u003e\n\n\u003cp\u003e在两个话题之间，请 hzmangel 即兴表演了上次巴克球，我用手机拍了视频，上传到优酷了：\u003c/p\u003e\n\n\u003cp\u003e\u003cembed src=\"http://player.youku.com/player.php/sid/XMjMxMjE1MzI4/v.swf\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"sameDomain\" type=\"application/x-shockwave-flash\"\u003e\u003c/embed\u003e\u003c/p\u003e\n\n\u003cp\u003e我和epico以及其他好几个人都非常羡慕这个玩具，嗯，考虑组团团购一个来玩。\u003c/p\u003e\n\n\u003cp\u003e版聚之后，我和 hzmangel、epico、bergwolf （及其可能还没过门的老婆）等人一起去日昌吃晚饭，饭桌上确定了明年年后，由本版万能的 hzmangel 来讲一下 scala，并希望到时候 wks 能来给 hzm 以足够的压力，并通过挑错给大家继续普及知识。\u003c/p\u003e\n\n\u003cp\u003e尽管这次版聚 colyli 没有参加，但仍有诸多到场人员，呵呵，我们的版聚越来越红火了。\u003c/p\u003e\n","cover":"","link":"linux/2010/12/21/2010年最后一次linux版聚/index.html","preview":"","title":"2010年最后一次Linux版聚"},{"content":"\n\u003cp\u003e前不久我们的一批使用 Broadcom NetXtreme II BCM5709 千兆网卡的 CentOS 5.4 机器的网卡在大负载下频频挂掉，无法ping通任何其他机器，但可以ping通自己，只要重启网卡即可恢复，实在让人费解。\u003c/p\u003e\n\n\u003cp\u003eGoogle了一下，发现此版本的 bnx2 驱动缺省使用了 MSI-X，但在处理中断时可能会出现问题，具体影响的版本如下：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e# uname -r\u003cbr /\u003e\n2.6.18-164.6.1.el5\u003cbr /\u003e\n# modinfo bnx2 |grep \"^version\"\u003cbr /\u003e\nversion:        1.9.3\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eRed Hat的KB/Bugzilla里是这么记录的\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003ein certain circumstances, under heavy load, certain network interface cards using the bnx2 driver and configured to use MSI-X, could stop processing interrupts and then network connectivity would cease. (BZ#587799)\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e嗯，解决方法，很简单，在/etc/modprobe.d/目录中添加一个文件，比如叫bnx2，设置一下模块参数：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e# cat /etc/modprobe.d/bnx2\u003cbr /\u003e\n# This is believed could solve the network freezing problem\u003cbr /\u003e\n# RHKB: in certain circumstances, under heavy load, certain\u003cbr /\u003e\n# network interface cards using the bnx2 driver and configured\u003cbr /\u003e\n# to use MSI-X, could stop processing interrupts and then\u003cbr /\u003e\n# network connectivity would cease. (BZ#587799)\u003c/p\u003e\n\n\u003cp\u003eoptions bnx2 disable_msi=1\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e如果不重启机器的话，就重启一下模块\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e# modprobe –r bnx2\u003cbr /\u003e\n# modprobe bnx2\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e然后就OK了。\u003c/p\u003e\n","cover":"","link":"linux/2010/12/13/centos-rhel-5.4-bcm5709网卡问题/index.html","preview":"","title":"CentOS/RHEL 5.4 BCM5709网卡问题"},{"content":"\n\u003cp\u003e按：\u003ca title=\"DataNode Volume Refreshment in HDFS-1362\" href=\"http://gnawux.info/hadoop/2010/12/datanode-volume-refreshment-in-hdfs-1362/\"\u003e英文版在这里\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e前不久发到JIRA的HDFS-1362是一个关于DataNode的磁盘管理的小Feature，简单的说，就是根据配置文件，重新刷新服务，让新加入的硬盘提供服务，这一切不需要重启计算机或重启DN服务。\u003c/p\u003e\n\n\u003ch2\u003e动机\u003c/h2\u003e\n\n\u003cp\u003e和其他的PC集群一样，研究院大云团队的Hadoop集群也常常遇到磁盘故障，更换磁盘会导致节点暂时退服，进而造成不必要的块迁移，因此在线更换硬盘是一个有用的功能。当前的DataNode，实际是FSDataset已经可以在线去掉无法提供服务的磁盘了，不过不能在线激活新的硬盘。要知道，大部分现代的服务器和SATA硬盘都是支持热插拔的，所以，为啥不动手提供这个功能呢？\u003c/p\u003e\n\n\u003cp\u003e一开始我们提供了一个简单的接口，可以通过命令行列出、加入、删除卷。不过在11月和Tom White和Todd Lipcon讨论之后，我们决定转而利用HADOOP-7001提供的在线更新配置的机制，提供一个单一的刷新接口，这样也不用担心配置文件和运行的服务不一致这个问题了。\u003c/p\u003e\n\n\u003ch2\u003eDataNode的卷管理\u003c/h2\u003e\n\n\u003cp\u003eDataNode实际使用了双重的卷管理。在启动时，DataStorage加载配置的目录，检查这些目录是否存在、是否可用、结构是否正确、版本是否有问题等，并针对目录的情况、依据启动的参数进行升级、回滚、格式化等必要操作。这些卷被存储为一个列表，并提供一个Iterator\u0026lt;StorageDirectory\u0026gt;，用于外部访问。\u003c/p\u003e\n\n\u003cp\u003e装载这些目录之后，DN会构造FSDataset来管理卷和卷中的块。FSDataset之中的FSVolumeSet有一个卷的数组，存放着可用的卷，FSDataset中还有一个map，以BlockID为索引，存放着所有的块信息。这个map并没有按照卷的索引，所以，如果要删掉一个卷，需要遍历整个map，才能删掉所有的块，事实上现在的那个删除卷的操作也就是这么干的。\u003c/p\u003e\n\n\u003cp\u003e注意上面说的，块加载的时间依赖于卷里面有多少个块，如果卷很满的话，就要花很长时间。\u003c/p\u003e\n\n\u003ch2\u003e基本思路\u003c/h2\u003e\n\n\u003cp\u003eHDFS-1362里，大概分四步来进行卷刷新工作：\u003c/p\u003e\n\n\u003cp\u003e• 首先读取配置文件，加入到一个新目录的List里面；\u003c/p\u003e\n\n\u003cp\u003e• 遍历DataStorage中的StorageDirectory：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e• 如果这个sd没在FSDataset的FSVolumeSet的数组中的话，说明它已经因故障被删掉了，所以，从DataStorage里删掉它；\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cblockquote\u003e\u003cp\u003e• 如果这个sd包含在上面的新目录列表里的话，从新目录列表里删掉它，因为它已经在提供服务了，不用添加；\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cblockquote\u003e\u003cp\u003e• 相反，如果这个sd不包含在新目录列表里的话，也就是说一个在服务中的目录居然没在新的配置列表里，是要删除一个卷么？目前的版本，我们只是留一条warning，不会让卷退服。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e• 把剩下的真的新目录添加到DataStorage里面去.\u003c/p\u003e\n\n\u003cp\u003e• 把这些卷添加到FSDataset里面去.\u003c/p\u003e\n\n\u003ch2\u003e加载卷\u003c/h2\u003e\n\n\u003cp\u003e加载卷操作是基于 DataStorage.revoverTransitionRead来做的，我只是基于它修改了一个revoverTransitionAdditionalRead来加载卷，两者有这么几个区别：\u003c/p\u003e\n\n\u003cp\u003e• 不需要初始化 StorageID 和 StorageDirectory 列表;\u003c/p\u003e\n\n\u003cp\u003e• 不对所有的SD进行 doTransition ，只针对新加入的;\u003c/p\u003e\n\n\u003cp\u003e• 不使用writeAll, 只对新加入的SD执行write;\u003c/p\u003e\n\n\u003cp\u003e• 返回一个新加入SD的Collection, 用于FSDataset的重新加载\u003c/p\u003e\n\n\u003cp\u003e这里没有用一个函数完成这两个功能的原因其实就是关于writeAll和transition操作，我担心这两者的操作方式差别可能比较大。\u003c/p\u003e\n\n\u003ch2\u003e让FSDataset加载新卷上的块\u003c/h2\u003e\n\n\u003cp\u003e这个操作不外乎就是给FSVolumeSet的数组添加卷、载入块的map。不过这里将来可能可以有块加载的优化。\u003c/p\u003e\n\n\u003ch2\u003e异步服务\u003c/h2\u003e\n\n\u003cp\u003eFSDataset 使用了 FSDatasetAsyncDiskService 来进行某些在每个卷上执行的异步任务，这个类是基于HashMap管理每个卷上的操作的，所以，只要把构造函数里的添加卷操作剥离出来成为一个单独的函数，让我们的刷新操作也能使用这个函数就可以了。\u003c/p\u003e\n\n\u003ch2\u003e下一步工作\u003c/h2\u003e\n\n\u003cp\u003e目前我们对于去掉卷的需求就是给了一个WARNING，将来可以继续讨论，是否可以通过这个接口让卷退服。\u003c/p\u003e\n","cover":"","link":"misc/2010/12/08/datanode-hdfs-1362/index.html","preview":"","title":"DataNode的磁盘管理以及HDFS-1362"},{"content":"\n\u003cp\u003e前两天回学校，和师弟师妹简单聊了一下云计算，嗯，造孽啊，幻灯片送上：\u003c/p\u003e\n\n\u003cdiv style=\"width:425px\" id=\"__ss_5898976\"\u003e\u003cstrong style=\"display:block;margin:12px 0 4px\"\u003e\u003ca href=\"http://www.slideshare.net/gnawux/cloud-computing-seminar-with-bupt-wti\" title=\"Cloud Computing Seminar with BUPT WTI\"\u003eCloud Computing Seminar with BUPT WTI\u003c/a\u003e\u003c/strong\u003e\u003cobject id=\"__sse5898976\" width=\"425\" height=\"355\"\u003e\u003cparam name=\"movie\" value=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=cloud-bupt-101124233256-phpapp02\u0026stripped_title=cloud-computing-seminar-with-bupt-wti\u0026userName=gnawux\" /\u003e\u003cparam name=\"allowFullScreen\" value=\"true\" /\u003e\u003cparam name=\"allowScriptAccess\" value=\"always\" /\u003e\u003cembed name=\"__sse5898976\" src=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=cloud-bupt-101124233256-phpapp02\u0026stripped_title=cloud-computing-seminar-with-bupt-wti\u0026userName=gnawux\" type=\"application/x-shockwave-flash\" allowscriptaccess=\"always\" allowfullscreen=\"true\" width=\"425\" height=\"355\"\u003e\u003c/embed\u003e\u003c/object\u003e\n\n\u003cdiv style=\"padding:5px 0 12px\"\u003eView more \u003ca href=\"http://www.slideshare.net/\"\u003epresentations\u003c/a\u003e from \u003ca href=\"http://www.slideshare.net/gnawux\"\u003egnawux\u003c/a\u003e.\u003c/div\u003e\n\n\u003c/div\u003e\n","cover":"","link":"cloud/2010/12/06/前两天回学校喷了.../index.html","preview":"","title":"前两天回学校喷了..."},{"content":"\n\u003cp\u003e按：这个系列是在米国回来的飞机上用iPad写好的，嗯，特意花$9.9买的Pages来写这个，不过耽误了两个星期PO出来……今天一批全发出来【飞机上比较累，2是最后一个了，其他的稍后照片送上】\u003c/p\u003e\n\n\u003cp\u003e从旧金山到圣何塞，有好几种轨道交通工具，这次往返、周末出游和购物都体验了一下，这里一一介绍一下。\u003c/p\u003e\n\n\u003cp\u003e1 湾区轨道交通BART\u003c/p\u003e\n\n\u003cp\u003e一共有四五条线路，纵贯旧金山市区，在市区内的线路基本是共线的，连接了湾区的旧金山\u003c/p\u003e\n\n\u003cp\u003e和奥克兰两大城市，费用较高，分段计费，动不动就四五刀，先看看车\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image0024.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image002[4]\" border=\"0\" hspace=\"12\" alt=\"clip_image002[4]\" vspace=\"12\" src=\"/assets/clip_image0024_thumb.jpg\" width=\"244\" height=\"183\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e基本所有我见到的BART都一样，但实际有8节和9节两种编组，每节车有两个车门，内藏门。\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image004.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image004\" border=\"0\" hspace=\"12\" alt=\"clip_image004\" vspace=\"12\" src=\"/assets/clip_image004_thumb.jpg\" width=\"242\" height=\"182\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image0064.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image006[4]\" border=\"0\" hspace=\"12\" alt=\"clip_image006[4]\" vspace=\"12\" src=\"/assets/clip_image0064_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image007.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image007\" border=\"0\" hspace=\"12\" alt=\"clip_image007\" vspace=\"12\" src=\"/assets/clip_image007_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image009.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image009\" border=\"0\" hspace=\"12\" alt=\"clip_image009\" vspace=\"12\" src=\"/assets/clip_image009_thumb.jpg\" width=\"244\" height=\"183\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image011.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image011\" border=\"0\" hspace=\"12\" alt=\"clip_image011\" vspace=\"12\" src=\"/assets/clip_image011_thumb.jpg\" width=\"244\" height=\"183\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image013.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image013\" border=\"0\" hspace=\"12\" alt=\"clip_image013\" vspace=\"12\" src=\"/assets/clip_image013_thumb.jpg\" width=\"244\" height=\"183\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image015.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image015\" border=\"0\" hspace=\"12\" alt=\"clip_image015\" vspace=\"12\" src=\"/assets/clip_image015_thumb.jpg\" width=\"244\" height=\"183\" /\u003e\u003c/a\u003e车内很宽敞，至少是A车，可以上自行车的。\u003c/p\u003e\n\n\u003cp\u003eBART的闸机倒是感觉很亲切，和北京的比较像。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image017.jpg\"\u003e\u003cimg style=\"border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px\" title=\"clip_image017\" border=\"0\" hspace=\"12\" alt=\"clip_image017\" vspace=\"12\" src=\"/assets/clip_image017_thumb.jpg\" width=\"163\" height=\"123\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e2 城际铁路Caltrain\u003c/p\u003e\n\n\u003cp\u003eCaltrain是连接旧金山和湾区另一座城市圣何塞的城际铁路线，它经过的路线里，写着这样一些名字: intel, HP, Cisco, EMC, Broadcom, Google, Yahoo, Facebook, SUN(已经挂掉了),\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image019.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image019\" border=\"0\" hspace=\"12\" alt=\"clip_image019\" vspace=\"12\" src=\"/assets/clip_image019_thumb.jpg\" width=\"74\" height=\"98\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image021.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image021\" border=\"0\" hspace=\"12\" alt=\"clip_image021\" vspace=\"12\" src=\"/assets/clip_image021_thumb.jpg\" width=\"130\" height=\"98\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image023.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image023\" border=\"0\" hspace=\"12\" alt=\"clip_image023\" vspace=\"12\" src=\"/assets/clip_image023_thumb.jpg\" width=\"130\" height=\"98\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image025.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image025\" border=\"0\" hspace=\"12\" alt=\"clip_image025\" vspace=\"12\" src=\"/assets/clip_image025_thumb.jpg\" width=\"129\" height=\"98\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eApple, Citrix, Avaya, Adobe, Rockheed Marting.....嗯，随便贴几家公司的图片哈\u003c/p\u003e\n\n\u003cp\u003e嗯，太多的都没拍了。Caltrain很大很彪悍，似乎不是动车组吧，不懂\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image027.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image027\" border=\"0\" hspace=\"12\" alt=\"clip_image027\" vspace=\"12\" src=\"/assets/clip_image027_thumb.jpg\" width=\"193\" height=\"145\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image029.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image029\" border=\"0\" hspace=\"12\" alt=\"clip_image029\" vspace=\"12\" src=\"/assets/clip_image029_thumb.jpg\" width=\"194\" height=\"146\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image031.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image031\" border=\"0\" hspace=\"12\" alt=\"clip_image031\" vspace=\"12\" src=\"/assets/clip_image031_thumb.jpg\" width=\"136\" height=\"180\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image033.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image033\" border=\"0\" hspace=\"12\" alt=\"clip_image033\" vspace=\"12\" src=\"/assets/clip_image033_thumb.jpg\" width=\"244\" height=\"183\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eCaltrain的每一节车厢的配置都不完全相同，有残疾人设施的，有挂自行车的，也有给我这样的带行李的人放行李的\u003c/p\u003e\n\n\u003cp\u003e嗯，Caltrain也是分段收费的，不过，从Millbrae到圣何塞也只要6刀，还是很便宜的。\u003c/p\u003e\n\n\u003cp\u003e3 硅谷公交的轻轨LRT\u003c/p\u003e\n\n\u003cp\u003e硅谷公交VTA的公交全是2刀单程，6刀全天，出去买东西的时候常坐LRT，实际就是半专属路权的低地板有轨电车，有时一组，有时两组联挂，编组比较灵活。这个车是站台自助购票上车，没有闸机啥的，也没见过查票的，估计万一抓住会罚的比较狠。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image043.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image043\" border=\"0\" hspace=\"12\" alt=\"clip_image043\" vspace=\"12\" src=\"/assets/clip_image043_thumb.jpg\" width=\"176\" height=\"133\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image045.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image045\" border=\"0\" hspace=\"12\" alt=\"clip_image045\" vspace=\"12\" src=\"/assets/clip_image045_thumb.jpg\" width=\"176\" height=\"133\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image041.jpg\"\u003e\u003cimg style=\"background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px\" title=\"clip_image041\" border=\"0\" hspace=\"12\" alt=\"clip_image041\" vspace=\"12\" src=\"/assets/clip_image041_thumb.jpg\" width=\"176\" height=\"133\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e4 旧金山F线有轨电车\u003c/p\u003e\n\n\u003cp\u003e有轨电车，通往渔人码头的，超老的车，但是还挺能装入的，仍然是通勤线路，不光是观\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image035.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image035\" border=\"0\" hspace=\"12\" alt=\"clip_image035\" vspace=\"12\" src=\"/assets/clip_image035_thumb.jpg\" width=\"177\" height=\"133\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image037.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image037\" border=\"0\" hspace=\"12\" alt=\"clip_image037\" vspace=\"12\" src=\"/assets/clip_image037_thumb.jpg\" width=\"101\" height=\"133\" /\u003e\u003c/a\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image039.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image039\" border=\"0\" hspace=\"12\" alt=\"clip_image039\" vspace=\"12\" src=\"/assets/clip_image039_thumb.jpg\" width=\"177\" height=\"133\" /\u003e\u003c/a\u003e光。\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e嗯，就这些吧，其他线路没坐过。\u003c/p\u003e\n","cover":"","link":"life/2010/12/05/第一次米国之行（2）：轨道交通/index.html","preview":"","title":"第一次米国之行（2）：轨道交通"},{"content":"\n\u003cp\u003e按：这个系列是在米国回来的飞机上用iPad写好的，嗯，特意花$9.9买的Pages来写这个，不过耽误了两个星期PO出来……今天一批全发出来\u003c/p\u003e\n\n\u003cp\u003e虽然出发之前十分狼狈，但当经过了十一个小时的长途飞行，来到旧金山的时候，还是非常兴奋的。取了行李后，开始向第一个会议的会场，San Jose出发。\u003c/p\u003e\n\n\u003cp\u003e插一句，San Jose是一个西班牙语地名，圣荷西是它的正确音译，读作圣肘子就错了，我不是到的第一天发现这个的，是第五天才有同事告知的，嗯，应该还有人不知道呢吧，我就贴在这里了哈。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image002.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; margin: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image002\" border=\"0\" hspace=\"12\" alt=\"clip_image002\" vspace=\"12\" src=\"/assets/clip_image002_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e从旧金山机场出发，首先是坐湾区地铁BART到Millbrae，上了BART之后就发现座位上有一部iPhone\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image004.gif\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image004\" border=\"0\" hspace=\"12\" alt=\"clip_image004\" vspace=\"12\" src=\"/assets/clip_image004_thumb.gif\" width=\"240\" height=\"181\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e这个…不是在钓鱼吧，我实在不敢动，后面我专门介绍BART吧，这里继续行程，在Millbrae我拽着行李去换乘Caltrain，然后乘坐Caltrain大约一小时到圣荷西火车站。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/12/clip_image006.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"clip_image006\" border=\"0\" hspace=\"12\" alt=\"clip_image006\" vspace=\"12\" src=\"/assets/clip_image006_thumb.jpg\" width=\"244\" height=\"183\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e虽然已到墙外，但数据漫游还是，不敢用手机上推，还好有推特记事本，记下了一路上的小tweets:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e• Caltrain路过Palo Alto，好多人下车，似乎有什么比赛。传说中的PARC，还有Facebook，让人神往的地方啊。 14:20 6/11/2010\u003c/p\u003e\n\n\u003cp\u003e• Mountain View了，确实能看到山，Google的老家啊，不过在Caltrain上看不出哪里是Google。 14:31 6/11/2010\u003c/p\u003e\n\n\u003cp\u003e• 看到天上一个飞艇 14:33 6/11/2010\u003c/p\u003e\n\n\u003cp\u003e• Sunnyvale，似乎比Mountain View大，原来Yahoo！家离Google家这么近啊。 14:35 6/11/2010\u003c/p\u003e\n\n\u003cp\u003e终于，在当天下午到达了酒店，安顿下来然后去会场踩点。关于会议暂且不表，下面打乱时间顺序聊点旅途中的事情。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n","cover":"","link":"misc/2010/12/05/第一次米国之行（1）：到达san-jose/index.html","preview":"","title":"第一次米国之行（1）：到达San Jose"},{"content":"\n\u003cp\u003e按：这个系列是在米国回来的飞机上用iPad写好的，嗯，特意花$9.9买的Pages来写这个，不过耽误了两个星期PO出来……今天一批全发出来\u003c/p\u003e\n\n\u003cp\u003e一个月没写blog了，这次出国补上吧，很多同事都不相信这次是我第二次出国出差，也不相信我没来过美国，不过，这都是血淋淋的事实啊...\u003c/p\u003e\n\n\u003cp\u003e历史上，我来公司以后，一共办过四次出国手续，第一次没去成，办下来一个公务护照，第二次去了加拿大，第三次也没去成，不过留下一个美国签证，便宜了这次来硅谷了。\u003c/p\u003e\n\n\u003cp\u003e也许你觉得公务护照挺牛的，去签证都拿着外交部的文件，可实际对我们只有麻烦，没有任何好处，该拒签还拒签，该check还check，唯一的影响就是你必须按照批准的时间和行程走，万一临时有变改签都麻烦，更别想多滞留玩一个礼拜了，纯粹是国际玩笑。\u003c/p\u003e\n\n\u003cp\u003e这次因为我和其他多方面原因，直到最后一刻才搞定全部手续，换汇完成的时候银行都已经关门了:\u003c/p\u003e\n\n\u003cp\u003e出发前一天下午，因为需要找几个人，4点才到集团取护照，外事处的马良和徐雁两人忙前忙后帮我找了护照、批件等很多东西。然后我奔到楼下ICBC去换汇，弄到一半居然发现没拿支票@##!#?\\~。#4?:~(\\@。‘;。，￥:?@!…!…!…?’\u003c/p\u003e\n\n\u003cp\u003e银行的mm也茫然了，当时已经4:40了，银行5店下班，我只好请银行mm多等我几分钟，我以迅雷不及掩耳盗铃之势飞回研究院拿支票，又麻烦了财务的两大美女，拿到后奔回银行，挤进门去，在银行已经关门的情况下高的换汇，又把会计凭证送回单位…真是太惊险了。\u003c/p\u003e\n\n\u003cp\u003e说到这里，虽然以前一直很不喜欢工行的服务，但这次绝对让人心服口服，因为我第二天就出发，而且第二天是周末，对公业务不办公，所以她们特别为我延长工作时间，而且全无不耐烦的地方，非常感谢他们。\u003c/p\u003e\n","cover":"","link":"life/2010/12/05/第一次米国之行（0）：前传/index.html","preview":"","title":"第一次米国之行（0）：前传"},{"content":"\n\u003cp\u003e10月7号晚上，打开了久违的计算机，似乎我已经有一个星期没动过计算机了，也就是一周没工作了，呵呵，后面几天要加油干活了。不过，远离了计算机却没有远离世界，手机让我继续和外界沟通，除此之外就是享受家庭生活了，本来想写家庭、劳动、读书三篇周记blog的，不过还是一篇全都写下来吧，呵呵，表多占篇幅了。\u003c/p\u003e\n\n\u003ch2\u003e家庭篇\u003c/h2\u003e\n\n\u003cp\u003e和中秋三天一样，这七天差不多一直和老婆孩子在一起，似乎很久没享受过这样的家庭生活了，全心投入在家庭之中让人忘掉工作里的诸多不如意的事情，真的感受到超出工作之外的生活。三号下午，我们从父母那里把小孩接到自己家，让父母休息一下，也更专注地和斯屹相处。\u003c/p\u003e\n\n\u003cp\u003e四号的天气很好，接近中午，我们带着斯屹到旁边的西土城公园里晒太阳、野餐，斯屹跑疯了，呵呵，根本抓拍不到正脸\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/10/073.jpg\"\u003e\u003cimg style=\"background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px\" title=\"073\" border=\"0\" alt=\"073\" src=\"/assets/073_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e之后（5号），我们临时和表姐一起约着去了龙脉温泉，斯屹第一次去温泉，在水里很兴奋，不过似乎累坏了，当天后来的活动都没什么精神，很容易哭。在怀柔住了一宿之后（也就是昨天，6号），因为斯屹状态不好，我们放弃了继续去山里玩的计划，直接回家休息了。\u003c/p\u003e\n\n\u003cp\u003e昨天晚上斯屹似乎尿炕着了点凉，有点小鼻涕，今天接近中午的时候送斯屹回了爷爷奶奶家，还真有点舍不得，呵呵，临走发现斯屹脑袋后面出现两个大包，十分担心，想去医院，不过斯屹困了，就让他睡觉了，我们先回来，过一两天如果不好再去医院吧，唉，今天真有点揪心。\u003c/p\u003e\n\n\u003ch2\u003e劳动篇\u003c/h2\u003e\n\n\u003cp\u003e最近添置了冲击钻和电锤这样的“重型”电动工具，DIY热情已经从计算机扩展到装修和水电了，十一期间更是玩起了铝塑管来。3号下午我们从明光家居买了一些淋浴龙头之类的东西，希望换掉之前的简陋的喷头。\u003c/p\u003e\n\n\u003cp\u003e当晚，我就把这组淋浴龙头拼接了起来，第二天固定到了墙上，下面左图就是固定后的情景，原来简陋的花洒和水管还在，昨天又去金五星买了铝塑管和接头，接上了水管、拆除了旧的水管（下面右图）。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/10/060.jpg\"\u003e\u003cimg style=\"background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px\" title=\"060\" border=\"0\" alt=\"060\" src=\"/assets/060_thumb.jpg\" width=\"138\" height=\"244\" /\u003e\u003c/a\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/10/085.jpg\"\u003e\u003cimg style=\"background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px\" title=\"085\" border=\"0\" alt=\"085\" src=\"/assets/085_thumb.jpg\" width=\"110\" height=\"244\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e今天送回斯屹之后，又在墙上标记了很久终于固定了上了一系列宜家买来的东东，下面的照片里的放线的槽和下面的挂钩就是其中的主要部分。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/10/093.jpg\"\u003e\u003cimg style=\"background-image: none; border-right-width: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px\" title=\"093\" border=\"0\" alt=\"093\" src=\"/assets/093_thumb.jpg\" width=\"244\" height=\"83\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e这几天一共在墙上打了8mm和6mm的洞大约40个，晚上又拆掉了洗手的角盆，等着明天早上来装新的洗手池和浴室柜。呵呵，劳动真快乐啊，老婆说，我真不应该搞软件，哈哈。\u003c/p\u003e\n\n\u003ch2\u003e读书篇\u003c/h2\u003e\n\n\u003cp\u003e这几天不开机，读书就成了闲暇时间的占据者，一般是在儿子睡着之后看书，这几天看完了两本之前开始看但还没看完的书——\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://book.douban.com/subject/4909629/\"\u003e\u003cimg style=\"padding-bottom: 20px; border-right-width: 0px; padding-left: 0px; padding-right: 20px; float: left; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px\" src=\"/assets/s4414698.jpg\" /\u003e\u003c/a\u003e \u003ca href=\"http://book.douban.com/subject/3652388/\"\u003e\u003cimg style=\"padding-bottom: 20px; border-right-width: 0px; padding-left: 0px; padding-right: 20px; float: left; border-top-width: 0px; border-bottom-width: 0px; border-left-width: 0px; padding-top: 0px\" src=\"/assets/s3724604.jpg\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e此外，还差不多扫完了手机上看的SICP的电子版，嗯，后面的部分没怎么看明白也没怎么细看，不过还是学到了不少东西。\u003c/p\u003e\n\n\u003ch2\u003e小结\u003c/h2\u003e\n\n\u003cp\u003e呵呵，一周过得真快啊，打开计算机的时候也就是休假结束的时候，呵呵，真的很享受这种生活的时间，让工作暂时远离自己真的很幸福，乐不思蜀啊。\u003c/p\u003e\n","cover":"","link":"misc/2010/10/08/十一周记/index.html","preview":"","title":"十一周记"},{"content":"\n\u003cp\u003e话说两周前丢了信用卡之后，对四家银行（工商、中行、中信、民生）做了\u003ca href=\"http://wangxu.me/blog/?p=442\"\u003e一个评测\u003c/a\u003e，两周过去了，人也冷静了，钱也花去了，卡也差不多补办了（嗯，还没钱包，有人希望捐赠可以联系我），现在，可以对于补卡相关的内容做些评测吧。\u003c/p\u003e\n\n\u003cp\u003e首先是补卡支出，按从少到多排序：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e民生银行：没收钱，嗯，没损失。\u003c/li\u003e\n\n\u003cli\u003e工商银行：20，嗯，损失有限。\u003c/li\u003e\n\n\u003cli\u003e中国银行：挂失+补卡供55元\u003c/li\u003e\n\n\u003cli\u003e中信银行：60元\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e第二项是补卡速度，按从快到慢排序：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e民生银行：周日挂失，周三送到，共三天；\u003c/li\u003e\n\n\u003cli\u003e中信银行：周日冻结，周一挂失，第二个周一送到；\u003c/li\u003e\n\n\u003cli\u003e中国银行：周日挂失，第二个周一送到，是和中信银行一起送到的；\u003c/li\u003e\n\n\u003cli\u003e工商银行：周日挂失的，今天（第二个周五）送到的，整两个星期，10个工作日。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，给个结论——民生的白金卡的挂失补卡服务比较好，免费广告一下，呵呵。\u003c/p\u003e\n","cover":"","link":"life/2010/09/10/信用卡评测之二——补卡相关/index.html","preview":"","title":"信用卡评测之二——补卡相关"},{"content":"\n\u003cp\u003e前两天在twitter上，因为 HIC2010 的缘故，注意到 TUP 搞了这个 Hadoop 沙龙（\u003ca title=\"http://tup.csdn.net\" href=\"http://tup.csdn.net\"\u003ehttp://tup.csdn.net\u003c/a\u003e），通过和刘江老师（@turingbook）陶瓷，混到了入场机会，今天就兴奋而来了，这里记个流水账。\u003c/p\u003e\n\n\u003cp\u003e因为路途遥远，下班后不敢耽搁，直接出发，一路公交+地铁，六点半赶到五道口，饥饿难耐，在 KFC 解决了一下自己的肚子问题，然后匆匆赶往清华科技园的 Yahoo 北京研发中心。\u003c/p\u003e\n\n\u003cp\u003e走到电梯间，发现了周六见过的印裔老哥，估计这就是今天的主讲人Milind Bhandarkar了，于是上前搭讪，说明自己是中国移动的搞 hadoop 的同学，特地慕名前来参加 hadoop 的活动的，简单寒暄了几句，大意是说周六的活动很盛大，问问他停留多久，还去了啥地方啥的，别的不说了，总之，印度口音让我对今晚的活动有点怯意。\u003c/p\u003e\n\n\u003cp\u003e到门口的时候看到了刘江老师，可能是上周电话确认的时候我没接到电话，所以签到表里并没有我的名字，厚着脸皮签了个名就进去了，这时就差不多七点了。进到会场，发现已经来了不少人了，差不多坐满了，不过后来还有不少陆陆续续赶到的同学，我还不算是晚的，呵呵。\u003c/p\u003e\n\n\u003cp\u003e在刘江老师和Yahoo的东道主们致辞之后，介绍就正式开始了。Milind 今天的主要话题是 Hadoop 调优，面向 MapReduce 应用，实际上从08年底09年初的某项目之后一年半多的时间里，我的重点都不在调优上，所以今天的话题不是很在行，基本就是来学习一下，不准备吭声了，话题里，有这么几个点还是值得一说的，时间顺序：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eMilind 的工作是做 Job 无关的调优，或者说 Job 的实现是个黑箱，主要根据系统运行参数进行调优，通过配置，使应用相对于基线效率有较大提升；\u003c/li\u003e\n\n\u003cli\u003e首先是 Map/Reduce 的数量和性能优化的关系，Map 任务越多，并行度就越高，但调度开销也越高，这是需要 trade-off 的；而 Reduce 则要有所保留，不要占满所有能力，为重复执行留出一部分能力空余来；\u003c/li\u003e\n\n\u003cli\u003e然后是内存分配方面，通过设置buffer，（Map 端的 io.sort.mb 和 Reduce 端的几个参数）尽量降低本地磁盘读写；\u003c/li\u003e\n\n\u003cli\u003e还有使用 combiner ，通过 map 端的提前聚合，降低 map 与 reduce 任务间的通信量；\u003c/li\u003e\n\n\u003cli\u003e当然还有使用压缩，减少通信，节约磁盘开销。\u003c/li\u003e\n\n\u003cli\u003e此外，还在最后总结时提到了 DistributedCache 的使用。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e讲座中，还介绍了一个 hadoop 诊断工具 vaidya。\u003c/p\u003e\n\n\u003cp\u003e这里是一张照片，嗯，是内容的最后一页，总结一些经验的\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/09/csdntup.jpg\"\u003e\u003cimg style=\"background-image: none; border-bottom: 0px; border-left: 0px; padding-left: 0px; padding-right: 0px; display: inline; border-top: 0px; border-right: 0px; padding-top: 0px\" title=\"csdntup\" border=\"0\" alt=\"csdntup\" src=\"/assets/csdntup_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e这是我今天拍的唯一一张能看得到字的，不是因为我坐的太远，是因为……我的手机相机一直工作在微距的状态……FML，调回自动状态，并擦了擦镜头后，终于拍到一张能看到字的……\u003c/p\u003e\n\n\u003cp\u003e在完成之后的提问环节，比较引起我关注的是关于 scheduler 的问题，毕竟同事小郭也做了这方面的工作，Yahoo 在使用的是 Capacity Scheduler，用于给不同的用户分配处理能力，这方面我们可能有参考或经验，不过要回去请教小郭才知道。\u003c/p\u003e\n\n\u003cp\u003e此外，又有人提到 NameNode 的 SPoF 问题了，这次 Milind 十分慷慨地介绍说中国移动也有哥们搞这个，我就接过话题说了一下我们当前的状态和下一步考虑一起共建 trunk 中的 HA 的考虑。这个问题上，我想我低估需求了，虽然技术上实际上问题的严重性并不高，但人们的心魔难祛，这个功能实际的需求（包括心理需求）是很强烈的，我应该在上面再花点精力努力一下。\u003c/p\u003e\n\n\u003cp\u003e也正因为这下曝光了我的垄断国企雇员身份，引来无数目光，嗯，我干的确实还不够好，有点对不起大家的话费了。\u003c/p\u003e\n\n\u003cp\u003e往外走的时候，刘江老师建议我们写写我们的Hadoop方面的工作，呵呵，真是有些惭愧，担心拿不出手啊。在门口还和优酷、Yahoo中国的朋友交流了半天，快10点才出门，觉得今天不仅收获到了些知识，还增加了很多动力。\u003c/p\u003e\n\n\u003cp\u003e回想一下这几天参见的 HIC2010 和 TUP，我先后向 Facebook、Yahoo 和国内同行朋友们介绍了我们在 NameNode HA 和 DataNode 卷管理方面的工作，但这些工作在受到一定瞩目的同时还有很多不成熟的地方，我得抓紧时间、集中精力，作出更大贡献才对得起自己、对得起大家。希望我们的工作更多地出现在官方的代码仓库里。\u003c/p\u003e\n","cover":"","link":"cloud/2010/09/06/csdn-tup-之-hadoop-沙龙流水账/index.html","preview":"","title":"CSDN TUP 之 Hadoop 沙龙流水账"},{"content":"\n\u003cp\u003e下面是我在 HIC2010 大会的幻灯片，相关内容欢迎进一步交流。\u003c/p\u003e\n\n\u003cdiv style=\"width: 425px\" id=\"__ss_5133060\"\u003e\u003cstrong style=\"margin: 12px 0px 4px; display: block\"\u003e\u003ca title=\"Hadoop development in China Mobile Research Institute\" href=\"http://www.slideshare.net/gnawux/hadoop-development-incmri\"\u003eHadoop development in China Mobile Research Institute\u003c/a\u003e\u003c/strong\u003e\u003cobject id=\"__sse5133060\" width=\"425\" height=\"355\"\u003e\u003cparam name=\"movie\" value=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=hadoopdevelopmentincmri-100905092957-phpapp02\u0026amp;stripped_title=hadoop-development-incmri\" /\u003e\u003cparam name=\"allowFullScreen\" value=\"true\" /\u003e\u003cparam name=\"allowScriptAccess\" value=\"always\" /\u003e\u003cembed name=\"__sse5133060\" src=\"http://static.slidesharecdn.com/swf/ssplayer2.swf?doc=hadoopdevelopmentincmri-100905092957-phpapp02\u0026amp;stripped_title=hadoop-development-incmri\" type=\"application/x-shockwave-flash\" allowscriptaccess=\"always\" allowfullscreen=\"true\" width=\"425\" height=\"355\"\u003e\u003c/embed\u003e\u003c/object\u003e\n\n\u003cdiv style=\"padding-bottom: 12px; padding-left: 0px; padding-right: 0px; padding-top: 5px\"\u003eView more \u003ca href=\"http://www.slideshare.net/\"\u003epresentations\u003c/a\u003e from \u003ca href=\"http://www.slideshare.net/gnawux\"\u003egnawux\u003c/a\u003e.\u003c/div\u003e\n\n\u003c/p\u003e\u003c/div\u003e\n","cover":"","link":"cloud/2010/09/05/cmri-hadoop/index.html","preview":"","title":"中国移动研究院的Hadoop开发工作"},{"content":"\n\u003cp\u003e刚刚在最后的Panel开始之前提前撤出了 HIC2010 的会场，来篇新闻稿吧谢罪吧。\u003c/p\u003e\n\n\u003ch2\u003e关于大会组织\u003c/h2\u003e\n\n\u003cp\u003e这次 HIC2010 的会场选在了文津国际酒店，地理位置比去年的计算所更便利，组织者也花费了很大心思在布展上，但分会场的位置都不是很好找，标识也不够醒目，导致我、@acumon 和几个其他的讲演者在找自己的会场的时候都有点困难，呵呵。\u003c/p\u003e\n\n\u003cp\u003e这次来的公司里，多了EMC、VMWare这样的厂商，没有听VMWare的发言，也不知道他们到底是来做什么的，既然交了赞助费，应该不是来踢场子的。Hadoop主要参与者Yahoo和Facebook都来了很多人，Yahoo来了他们的VP，Facebook的华人团队更是差不多全来了，不过没看见上次见过的海荣有点遗憾。比较意外的是，Cloudera这次完全缺席，不知是主办方的问题还是Cloudera自己的问题，上次他们不仅有大佬来，还有培训。\u003c/p\u003e\n\n\u003cp\u003e对于演讲的topic，没什么可挑剔的，大家都很务实，介绍了自己的工作，不过每个topic的时间限制太短了，大部分讲演者都不自觉地超时了，我的讲演拖了大概十分钟，@acumon 同学的也差不多这个情况，差不多每个分会场都是如此，我觉得每个topic安排40分钟可能更合理一些。\u003c/p\u003e\n\n\u003ch2\u003e关于交流\u003c/h2\u003e\n\n\u003cp\u003e交流时此次来的主要目的，有些人是久仰大名的，比如 @turingbook 老师，有些是来之前知道也会前来的同行，比如 @acumon，有些是原来工作中有过交流但素未谋面的，比如Facebook的邵征和Intel的Jason Dai，这次都见到真身而且搭上讪了，非常兴奋。\u003c/p\u003e\n\n\u003cp\u003e因为时间关系，没有听到 Facebook 的Scott Chen的讲演，本来非常遗憾，不过快出门时看到Facebook一干大神正在门口聊天，赶快上来搭讪，和Scott Chen就HDFS进行了一些交流。同时还和另外几位百度的同学相谈甚欢，收货不少。\u003c/p\u003e\n\n\u003cp\u003e今天最大的收获差不多是向很多人，包括facebook的邵征和Scott Chen推出了我的最近的工作：DataNode 在线磁盘更换功能，他们也非常有兴趣，我得抓紧时间把这个patch附到JIRA上去了。\u003c/p\u003e\n\n\u003cp\u003e此外，今天着重还听了一下IBM CRL的邱杰的工作，因为和我的一些工作有很强的相关性，不过因为他下课后没直接出来，没有搭上讪算是唯一的遗憾了吧，争取以后有机会联系一下。\u003c/p\u003e\n\n\u003ch2\u003e后记\u003c/h2\u003e\n\n\u003cp\u003e最后，感觉还是北京有相当几个真做Hadoop的同学的，至少我们、百度、IBM都有，阿里巴巴、腾讯似乎也有，今天没见到，应该搞些小规模的真正的开发者的民间聚会了，就像linuxfb一样。开源技术交流非常有趣，非公司之间、非竞争性、非盈利性，纯粹的个体间技术交流，互相促进、共同繁荣。\u003c/p\u003e\n\n\u003cp\u003e嗯，先这些吧。\u003c/p\u003e\n","cover":"","link":"cloud/2010/09/04/hadoop-in-china-2010大会归来/index.html","preview":"","title":"Hadoop in China 2010大会归来"},{"content":"\n\u003cp\u003e【更新：关于工行的IVR菜单，我土了，1个人客户，2企业客户，后面是3紧急挂失，4信用卡，进信用卡之后还有挂失，虽然也挺麻烦，但不会像我当时一样，这基本不影响我的评分，因为当时的操作可能是每个人的正常选择，但是也请各位用户知道个更简单的办法】\u003c/p\u003e\n\n\u003cp\u003e周末，钱包丢了，没pp没真相，可是我真的没办法找来钱包拍遗照了 ~~\u0026gt;_\u0026lt;~~\u003c/p\u003e\n\n\u003ch2\u003e哭诉部分\u003c/h2\u003e\n\n\u003cp\u003e最大的可能性是在饭馆的时候，我带儿子去洗手，老婆专心点餐的时候被人摸了，另有可能 a) 路上被人摸了；b) 儿子大逆不道地拉开我的包的拉锁，把钱包放走了。当然，这些可能性都很小。中午记录如下：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003ca href=\"chrome-extension://encaiiljifbdbjlphpgpiimidegddhic/popup.html#\"\u003egnawux\u003c/a\u003e 中午吃饭把钱包丢了，刚挂失了四张信用卡，一张借记卡，损失三百元，包括挂失补卡费用一百多，现金一百元，钱包自身不足百元 \u003ca href=\"chrome-extension://encaiiljifbdbjlphpgpiimidegddhic/\"\u003e#FML\u003c/a\u003e\u0026#160;\u003ca href=\"chrome-extension://encaiiljifbdbjlphpgpiimidegddhic/popup.html#\"\u003eabout 1 day ago\u003c/a\u003e from \u003ca href=\"chrome-extension://encaiiljifbdbjlphpgpiimidegddhic/popup.html#\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e十分郁闷，而且中午饭没吃好。不幸中的万幸是听从了兰总的建议，证件和钱包分开，所以身份证和驾照都还在。\u003c/p\u003e\n\n\u003ch2\u003e四家银行挂失业务比较\u003c/h2\u003e\n\n\u003cp\u003e参评银行（按拨打热线电话顺序）：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e中国银行：信用卡一张\u003c/li\u003e\n\n\u003cli\u003e民生银行：信用卡一张（白金卡）\u003c/li\u003e\n\n\u003cli\u003e工商银行：信用卡一张、借记卡一张\u003c/li\u003e\n\n\u003cli\u003e中信银行：信用卡一张\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e挂失服务客户满意度评比顺序（以挂失人当时的心情排序）：中信银行\u0026gt;中国银行\u0026gt;民生银行\u0026gt;\u0026gt;\u0026gt;\u0026gt;工商银行。以下是具体评测项目：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e速度：挂失就是比速度，速度是影响客户心情的最主要方面。在这方面，中信银行微弱优势胜出，工商银行十分恶劣。\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e中信银行（5分）：菜单第一项就是挂失，直接接入专员，而且根据手机可以知道用户身份，无需多说，荣膺最高分。\u003c/li\u003e\n\n\u003cli\u003e中国银行（4.9分）：菜单第二项是挂失，仅仅这么小的差距，第一项是开卡。\u003c/li\u003e\n\n\u003cli\u003e民生银行（3.5分）：进入菜单前先要求输入电话密码了，不过之后就可以接入专员挂失了。\u003c/li\u003e\n\n\u003cli\u003e工商银行（1分）：似乎没有专门的信用卡电话，95588时，没有听到直接挂失的 IVR 菜单，要求输入卡号和密码进入，然后……\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003cfont color=\"#ff0000\"\u003e人工是菜单第9项，我听了半天才找到这个选项，并且人工要等待半天\u003c/font\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cfont color=\"#ff0000\"\u003e坐席居然让心急如焚的我选择是先挂失借记卡还是信用卡，在我表示无所谓、要快的时候，还是执意要我选择\u003c/font\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cfont color=\"#ff0000\"\u003e在我要选择信用卡时才知道居然要再转接一次，只好先挂失借记卡，在当时的心境下，坐席人员的话只能让人感到罗嗦\u003c/font\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cfont color=\"#ff0000\"\u003e信用卡客服居然也要我背一遍卡号……他们没有我的信息么？！有几个像我一样能背下来的？\u003c/font\u003e\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/ul\u003e\n\n\u003cli\u003e功能：挂失方面，如果有临时冻结功能，会对很多心存侥幸的丢卡人有很好的心理安慰\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e中信银行（5分）：提供冻结24小时功能。\u003c/li\u003e\n\n\u003cli\u003e其他（4分）：不提供或没主动告诉我。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cli\u003e服务与信息：即使、准确而不拖沓的信息是你最需要的，而不是复杂的解释性信息：\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e中国银行、民生银行、中信银行（4.5分）：都不错，挂失费用说明、影响说明和最近消费记录，都是用户关心的内容，充分、扼要，满足用户需求。\u003c/li\u003e\n\n\u003cli\u003e工商银行（3分）：说了很多无关信息，但关键的最近消费之类的信息却不主动告诉我，当然，我承认，我在给工行打电话的时候十分焦躁，那是因为他们在耽误我的时间，我当时还没打中信的电话呢，万一他们罗嗦的时候被人盗刷，我岂不是郁闷死了。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cli\u003e费用：挂失和补卡的费用也是一个比较因素，除了影响心情外，还影响你的最终损失，当然，当时急着挂失，可能没记清楚\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e民生银行（5分）：白金卡补卡似乎不收费？\u003c/li\u003e\n\n\u003cli\u003e工商银行（4分）：收费，但多少忘了，似乎不太多\u003c/li\u003e\n\n\u003cli\u003e中国银行（3分）：挂失和补卡各一份费用，多少忘了，共五六十吧\u003c/li\u003e\n\n\u003cli\u003e中信银行（3分）：大约60\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e结论：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e如果你像我一样工资卡是工行的，有张工行的信用卡是方便一些，但是，放在家里网银购物用就行了，没事别带着出去溜。\u003c/li\u003e\n\n\u003cli\u003e如果能有一张民生白金卡的话，挂失补卡似乎是免费的，这个够有吸引力的吧。\u003c/li\u003e\n\n\u003cli\u003e中国银行和中信银行的挂失服务差不多，中信略胜一筹，可以让你更放心。\u003c/li\u003e\n\n\u003cli\u003e最后，钱包里别放身份证，这点确实很重要，当然，尽管如此，还是请大家多小心，注意人身和财产安全。\u003c/li\u003e\n\n\u003c/ul\u003e\n","cover":"","link":"life/2010/08/30/周末，钱包丢了暨四家银行的挂失服务比较【update20100831】/index.html","preview":"","title":"周末，钱包丢了暨四家银行的挂失服务比较【Update20100831】"},{"content":"\n\u003cp\u003e首先说，我并不是全程参与的，中午丢了钱包（这个有空介绍下挂失经验）所以去晚了，第一个话题已经开始了，后来因为承诺儿子五点钟回去，所以没有看完共创软件的大哥的问题征集，也得抱歉一下，不过，总的来说，今天的聚会还是挺充实的。\u003c/p\u003e\n\n\u003ch2\u003e人物上的亮点\u003c/h2\u003e\n\n\u003cp\u003e今天人物上的一号亮点无疑是wks，这包括他是今天的主角、我对他在haskell/scala方面的无限崇拜等等各种因素，不过，我还是要说一下他的不足之处：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e讲座的主线和范围不够清晰和集中——跑火车这个在我们这里不算是错事，不过，wks还是让我在整个讲座过程中都无法知道他到底要讲多少东西，以至于结束的时候感觉戛然而止，以为还应该有很多呢；\u003c/li\u003e\n\n\u003cli\u003e不能很好地抓住听众的问题——实际上 bergwolf 的问题和 wks 的回答几乎一直都没对上，wks 似乎一直没有抓住 bergwolf 到底在问什么，知道最后大家一拥而上的时候，bergwolf 的问题才被明确回答。事实上，作为shanghai LSF 的受邀嘉宾，bergwolf 对文件系统的领悟在 linuxfb 范围内已经达到了一人之下、其他之上的地步，wks 如果仔细听一下应该可以知道他问的是什么的。\u003c/li\u003e\n\n\u003cli\u003e有一点紧张——不像之前几次版聚的时候那么闲庭信步了，呵呵。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e不过，总的讲，还是很不错的，以至于成了差不多唯一的主角，呃……另一位主讲是谁来着？下次一定要上台讲啊，光做人肉翻页器可不行啊，也得上来被大家虐啊——不过，他回答bergwolf的问题的时候倒是蛮一针见血的，更加简单直接。\u003c/p\u003e\n\n\u003cp\u003e人物上的其他亮点都集中在Coly不知从何而来的幻灯片上，对了，bergwolf真的结婚了么？那我们以后调侃的话题不就少了么？\u003c/p\u003e\n\n\u003ch2\u003e内容：Btrfs\u003c/h2\u003e\n\n\u003cp\u003e说到内容，btrfs是我此行的唯一目标，通过wks的讲解，我理解了这么几个问题：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003ebtr原来是B-Tree\u003c/li\u003e\n\n\u003cli\u003ebtrfs实现了多个物理磁盘弄在一起的功能，但我觉得这个功能有点过了，尽管有coly的支持，我仍然觉得这个支持有点过于铺张了一些\u003c/li\u003e\n\n\u003cli\u003ebtrfs创建文件系统很快——这个上次我在测试SSD的时候实际亲手见识过了，不过忘了\u003c/li\u003e\n\n\u003cli\u003e根据我的理解，btrfs的subvolume就是为了支持snapshot而提供的功能，至于能提供多个tree做不同的挂载点这一点，我觉得75%-80%的意义上说是副产品\u003c/li\u003e\n\n\u003cli\u003ebtrfs的snapshot很好很强大\u003c/li\u003e\n\n\u003cli\u003e一口气在目录下可以建立一万个文件，嗯，wks手很快，那个命令行似乎是 touch {1..10000}，中间几个点没看清，反正我没用过\u003c/li\u003e\n\n\u003cli\u003ebtrfs的用户态工具命令行功能很强大\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，差不多了，最后是\u003c/p\u003e\n\n\u003ch2\u003e致谢\u003c/h2\u003e\n\n\u003cp\u003e感谢wks和他的师父coly。\u003c/p\u003e\n","cover":"","link":"linux/2010/08/29/linuxfb-gnome北京用户组联合聚会记录/index.html","preview":"","title":"LinuxFB/Gnome北京用户组联合聚会记录"},{"content":"\n\u003ch2\u003eHadoop 0.21 发布\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"http://hadoop.apache.org/common/docs/r0.21.0/releasenotes.html\"\u003ehttp://hadoop.apache.org/common/docs/r0.21.0/releasenotes.html\u003c/a\u003e     \u003cbr /\u003e8 月23日，Hadoop 0.21发布，距离上一个版本0.20的发布已经过去了16个月，而之前两个版本，从0.18到0.20也仅仅用了一半的时间，8个月。这个千呼万唤始出来的版本是Hadoop发展历史上的一个重要里程碑，但是，很可能将成为一个过渡版本，而不会被广泛使用。 \u003c/p\u003e\n\n\u003cp\u003eHadoop 0.21有一个代码结构上的大调整，HDFS和MapReduce分离成了两个独立的子项目，而公共部分，如 RPC 和一些辅助工具则由 Common 子项目来完成，这一拆分是造成发布姗姗来迟的主要原因之一。这一版本在功能上的新特征包括：支持Backup Node来改善NameNode的单点问题，扩大了新MapReduce API的支持范围，提供了新的 FileContext API等，同时对测试框架进行了改进，引入了新的自动测试框架Herriot。 \u003c/p\u003e\n\n\u003cp\u003e尽管从结构上和开发框架上有了很多调整，但从功能看，Hadoop 0.21.0 实际上只是 0.20.2+，在接口上保持了和 0.20.2 的兼容性，新增加的功能或者比较有限，或者还在完善中，很重要的安全方面的功能 Kerberos 的支持也要到 0.22 才会提供，因此，包括 Yahoo 在内的很多重要用户都表示很可能会跳过 0.21 而在 0.22 成熟时直接演进到 0.22，0.21 的前途尚不明朗，它很可能只是 0.22 前进路上的一个重要的铺路石。    \u003c/p\u003e\n\n\u003ch2\u003eCassandra 0.7.0-beta1和0.6.5发布\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"https://svn.apache.org/repos/asf/cassandra/tags/cassandra-0.7.0-beta1/NEWS.txt\"\u003ehttps://svn.apache.org/repos/asf/cassandra/tags/cassandra-0.7.0-beta1/NEWS.txt\u003c/a\u003e     \u003cbr /\u003e开源分布式非关系型数据库NoSQL一直在我们的视野之中，自从成为Apache项目以来，发展十分迅速，当然也经历了一些波折，面对着一些质疑，此次 0.7.0 beta的发布，使他再次出现在我们的视野之中，0.7中，行的尺寸从2GB提升到了20亿列，同时增加了输出到Hadoop的输出格式，便于两者的互动，此外，还在功能和性能上进行了很多其他改进。     \u003c/p\u003e\n\n\u003ch2\u003eOpenStack 社区迅速成长\u003c/h2\u003e\n\n\u003cp\u003e\u003ca href=\"http://openstack.org/blog/2010/08/openstack-community-update/\"\u003ehttp://openstack.org/blog/2010/08/openstack-community-update/\u003c/a\u003e     \u003cbr /\u003e如果说上半年的明星项目是Cassandra的话，迄今为止，下半年的明星项目当属RackSpace和NASA在7月联合发布的OpenStack，一个多月来，这个项目一直留在我们的视野当中，并于8月25日举行了一次聚会。目前，OpenStack的计算部分（Nova）支持了KVM、Xen和 VirtualBox三种虚拟机，而存储部分则开始进行对象存储系统swift的开发。这些具体的工作让 OpenStack 开始逐步走向现实。\u003c/p\u003e\n","cover":"","link":"cloud/2010/08/28/8月云计算相关开源新闻/index.html","preview":"","title":"8月云计算相关开源新闻"},{"content":"\n\u003cp\u003e拿到一个小组准备买书的列表，大家把书的卓越的url都放进去了，我决定帮负责订书的同事mm一个忙，不要一个一个点啦，咱们这样，把书的url保存成一个csv文件，比如Book1.csv，然后这么干：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eurl=http://www.amazon.cn/gp/item-dispatch?submit.addToCart=addToCart; inc=1; sed -ne 's/.*\\(B0[0-9A-Z]\\{8\\}\\).*/\\1/p' Book1.csv | while read bookid; do url=`echo ${url}\\\u0026amp;asin.${inc}\\=${bookid}`; inc=$(($inc+1));echo $inc: $url; done;\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这样，每行会打出一个url，这个url里的结尾部分就是 \u0026amp;asin.1=B0xxxxxxxx\u0026amp;asin.2=B0xxxxxxxx\u0026amp;asin.3….以此类推，不管有多少本，都可以放到一个URL里，实际测试到75本，没有问题，可以一次性加入。\u003c/p\u003e\n\n\u003cp\u003e登录卓越后，打开这个URL就可以一次性添加了。\u003c/p\u003e\n\n\u003cp\u003e呵呵，自娱自乐。\u003c/p\u003e\n","cover":"","link":"scripts/2010/08/17/卓越购书单生成命令行/index.html","preview":"","title":"卓越购书单生成命令行"},{"content":"\n\u003cp\u003e昨天晚上跟风PS的，嗯，凡客的广告影响很大啊，呵呵\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/love_big_cloud.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"love_big_cloud\" border=\"0\" alt=\"love_big_cloud\" src=\"/assets/love_big_cloud_thumb.jpg\" width=\"644\" height=\"404\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e呵呵，参考凡客的那个韩寒的广告，灵感是受到\u003ca href=\"http://coolshell.cn/?p=2806\"\u003e酷壳的启发\u003c/a\u003e，这个BIGCLOUD的针织马甲还不错吧，哈哈。\u003c/p\u003e\n","cover":"","link":"cloud/2010/08/13/中国移动大云非官方广告桌面/index.html","preview":"","title":"中国移动大云非官方广告桌面"},{"content":"\n\u003cp\u003e首先感谢国家，感谢CCSA，让我在上海度过一个生日，而且是30大整的生日，嗯，说到这要感谢各位朋友的祝福，回到主线，聊聊这两天在上海的出差之外的生活吧。\u003c/p\u003e\n\n\u003cp\u003e上海故事其实是个品牌，上次来上海，似乎是05或06年的事，当时给女朋友买了一条丝巾，就是上海故事的，如今，外滩依旧，伊人……伊人也依旧，只是成了孩儿他妈了，呵呵，待遇上也没有丝巾了，当然，原因是我确实也没找到这家店……\u003c/p\u003e\n\n\u003ch2\u003e地铁\u003c/h2\u003e\n\n\u003cp\u003e作为业余地铁爱好者，来上海是不能不感受一下地铁的，所以，尽管本来可以报销机场到酒店的出租车费，到虹桥机场之后，还是径直去了2号线的入口，首先是买票：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/035.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"035\" border=\"0\" alt=\"035\" src=\"/assets/035_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/041.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"041\" border=\"0\" alt=\"041\" src=\"/assets/041_thumb.jpg\" width=\"324\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e很漂亮的IC车票，用法和北京的类似，不过通过闸机的方式有点差别，还真有点不适应。八编的长车和长展台真让人羡慕啊：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/036.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"036\" border=\"0\" alt=\"036\" src=\"/assets/036_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"038\" border=\"0\" alt=\"038\" src=\"/assets/038_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e不想打车了，准备体验一下上海地铁 \u003ca href=\"http://twitter.com/gnawux/status/20786312170\"\u003e7:09 PM Aug 10th\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e上海地铁感觉不错，8编A车羡慕死北京人了，2号线似乎分两节，这车就到我坐的这组刚好到我要去的广兰路 \u003ca href=\"http://twitter.com/search?q=%23ourmetro\"\u003e#ourmetro\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20787077182\"\u003e7:24 PM Aug 10th\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e感觉制动有点太硬了，都闻到闸瓦灰味儿了，北新泾\u003ca href=\"http://twitter.com/search?q=%23ourmetro\"\u003e#ourmetro\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20787580377\"\u003e7:34 PM Aug 10th\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e上海地铁的青鱼的鸣笛太雄壮了，呵呵 \u003ca href=\"http://twitter.com/search?q=%23ourmetro\"\u003e#ourmetro\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20787676879\"\u003e7:36 PM Aug 10th\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e不过，下了车找酒店就没这么顺利了，酒店可以从车站看到，但是，中间隔着工地，无法到达，必须在晚上拖着箱子绕过整个街区，很茫然，很不知所措，但觉得打车有点亏，于是还是靠着Google Map、GPS以及电话找到了\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003eI'm at 广兰路站 地铁二号线 (翠柳路, 广兰路, 上海市).\u003ca href=\"http://4sq.com/bKpa4L\"\u003ehttp://4sq.com/bKpa4L\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20790427010\"\u003e8:25 PM Aug 10th\u003c/a\u003e via \u003ca href=\"http://foursquare.com/\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=31.21074605,121.61993980\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e出站之后很荒，很乱，很多摩的，很难找 \u003ca href=\"http://twitter.com/gnawux/status/20791199687\"\u003e8:38 PM Aug 10th\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e看到张江有轨电车，很好玩 \u003ca href=\"http://twitter.com/gnawux/status/20791282115\"\u003e8:39 PM Aug 10th\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e终于找到了 (@ Howard Johnson Hotel Zhangjiang Shanghai) \u003ca href=\"http://4sq.com/9niP2X\"\u003ehttp://4sq.com/9niP2X\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20792325767\"\u003eTue Aug 10 2010 20:56:49 (China Standard Time)\u003c/a\u003e via \u003ca href=\"http://foursquare.com/\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=31.210452,121.626205\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e酒店不错，适合两口子，可惜啊，我还不知道和我拼房的哥们是谁呢 \u003ca href=\"http://twitter.com/gnawux/status/20793854100\"\u003eTue Aug 10 2010 21:20:10 (China Standard Time)\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e从下车到入住，用了差不多45分钟，苦啊……\u003c/p\u003e\n\n\u003cp\u003e今天晚上再次出发，想去市中心看看有啥纪念品，再次去地铁站\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e出发，去城里看看 \u003ca href=\"http://twitter.com/gnawux/status/20878251869\"\u003eabout 5 hours ago\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e@\u003ca href=\"http://twitter.com/DavidFeng\"\u003eDavidFeng\u003c/a\u003e 呃，我正从广兰路往那边坐呢 \u003ca href=\"http://twitter.com/gnawux/status/20879799880\"\u003eabout 4 hours ago\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e \u003ca href=\"http://twitter.com/DavidFeng/status/20879605385\"\u003ein reply to DavidFeng\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003eI'm at 2号线南京东路站 (九江路, 上海市).\u003ca href=\"http://4sq.com/bzyRh1\"\u003ehttp://4sq.com/bzyRh1\u003c/a\u003e\u003ca href=\"http://twitter.com/gnawux/status/20881974374\"\u003eabout 4 hours ago\u003c/a\u003e via \u003ca href=\"http://foursquare.com/\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=31.23852432,121.48072243\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e然后回来\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e收队，回荒郊野外的饭店 (@ People's Square Metro Station 人民广场地铁站) \u003ca href=\"http://4sq.com/cGMUsC\"\u003ehttp://4sq.com/cGMUsC\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20888006202\"\u003eabout 2 hours ago\u003c/a\u003e via \u003ca href=\"http://foursquare.com/\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=31.23467408,121.47145271\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e售票机前混乱不堪 \u003ca href=\"http://twitter.com/gnawux/status/20888180887\"\u003eabout 2 hours ago\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e车站果断停止售票，放行拥挤乘客，让出站补票，赞一个\u003ca href=\"http://twitter.com/gnawux/status/20888608610\"\u003eabout 2 hours ago\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e感觉上海地铁的设施和管理都很不错，这种人多时的处理显然是预先准备好的预案，控制得井井有条。而且，这次我掌握了穿越工地的要领\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e掌握了穿越工地的路线，酒店到地铁站的路程从半小时骤然减少到5分钟 (@ Howard Johnson Hotel Zhangjiang Shanghai)\u003ca href=\"http://4sq.com/9niP2X\"\u003ehttp://4sq.com/9niP2X\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20892017056\"\u003eabout 1 hour ago\u003c/a\u003e via \u003ca href=\"http://foursquare.com/\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=31.210452,121.626205\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e嗯，地铁到此为止，说说外滩和南京路吧。\u003c/p\u003e\n\n\u003ch2\u003e外滩和南京路\u003c/h2\u003e\n\n\u003cp\u003e时隔四五年再来上海，居然又来一次外滩，我也够无聊的\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e无聊到要来这里看看了，和平饭店 (@ Peace Hotel)\u003ca href=\"http://4sq.com/cOdjtv\"\u003ehttp://4sq.com/cOdjtv\u003c/a\u003e\u003ca href=\"http://twitter.com/gnawux/status/20882701624\"\u003eabout 4 hours ago\u003c/a\u003e via \u003ca href=\"http://foursquare.com/\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=31.2409087,121.4839455\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/044.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"044\" border=\"0\" alt=\"044\" src=\"/assets/044_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e然后，看到外滩人山人海\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e外滩真牛，都挤不到江边，更别说跳下去了，我现在至少同时在两个人的镜头里，而且是靠中间的位置，赶快跑吧 \u003ca href=\"http://twitter.com/gnawux/status/20883520311\"\u003eabout 3 hours ago\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/046.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"046\" border=\"0\" alt=\"046\" src=\"/assets/046_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/054.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"054\" border=\"0\" alt=\"054\" src=\"/assets/054_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e当然，南京路上也是\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e无聊的人啊 (@ 南京路步行街) \u003ca href=\"http://4sq.com/9A3e4e\"\u003ehttp://4sq.com/9A3e4e\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20884800859\"\u003eabout 3 hours ago\u003c/a\u003e via \u003ca href=\"http://foursquare.com/\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=31.277209,121.505305\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/062.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"062\" border=\"0\" alt=\"062\" src=\"/assets/062_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e真的想买点东西给媳妇，不过筷子似乎有点贵\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e要么带双筷子回去? (@ 韵泓筷子店) \u003ca href=\"http://4sq.com/c1orlv\"\u003ehttp://4sq.com/c1orlv\u003c/a\u003e\u0026#160;\u003ca href=\"http://twitter.com/gnawux/status/20885365149\"\u003eabout 3 hours ago\u003c/a\u003e via \u003ca href=\"http://foursquare.com/\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=31.232855,121.475311\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e开眼了，筷子也能卖上千块钱 \u003ca href=\"http://twitter.com/gnawux/status/20885541550\"\u003eabout 3 hours ago\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e不过，后来时间过得太快了，只好简单买点小食品了\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cstrong\u003e\u003ca href=\"http://twitter.com/gnawux\"\u003egnawux\u003c/a\u003e\u0026#160;\u003c/strong\u003e呃，南京路都要打烊了，赶紧买点小点心了事 \u003ca href=\"http://twitter.com/gnawux/status/20887271155\"\u003eabout 3 hours ago\u003c/a\u003e via \u003ca href=\"http://twicca.r246.jp/\"\u003etwicca\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e不论如何，30岁的生日就这样过去了，满30了，明天还要讲技术报告呢，赶快休息了。\u003c/p\u003e\n","cover":"","link":"life/2010/08/12/上海故事/index.html","preview":"","title":"上海故事"},{"content":"\n\u003cp\u003e记一点本周末南戴河行的流水账。\u003c/p\u003e\n\n\u003cp\u003e斯屹一直对海边念念不忘，差不多每两三顿饭就会提一次去海边，忘不了他的小螃蟹、忘不了他的小贝壳。禁不起念叨，我和媳妇开始计划今年夏天的第二次海边之行，上次去天津有诸多不爽之处，这次我们选择了媳妇朝思暮想的南戴河。周五，我们休假一天，计划从周五到周日，从容地在海边玩两天。\u003c/p\u003e\n\n\u003cp\u003e周五一早，我们掺乎着早高峰就出发了，一路上斯屹还算乖，哄着在安全座椅上坐了一路三个小时，虽然脚都快翘到天上了，但有去海边的信念撑着，他做到了。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/201.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"201\" border=\"0\" alt=\"201\" src=\"/assets/201_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e当天中午，在停了一次服务区之后，我们到达了南戴河，住进了媳妇提前约好的家庭旅店\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e快一半了，休息一下 (@ G1·京哈高速·新安镇服务区)\u003ca href=\"http://4sq.com/bzhBHX\"\u003ehttp://4sq.com/bzhBHX\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e家庭旅馆的环境不错 (@ 富强里小区) \u003ca href=\"http://4sq.com/cGx4co\"\u003ehttp://4sq.com/cGx4co\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e随后，儿子睡了一大觉，下午五点多，我们来到了海边\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eI'm at 天马海滨浴场 (南戴河, 秦皇岛市). \u003ca href=\"http://4sq.com/b42q7M\"\u003ehttp://4sq.com/b42q7M\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这里全是人啊，你们能找到我家王斯屹在哪么？\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/230.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"230\" border=\"0\" alt=\"230\" src=\"/assets/230_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e当天，王斯屹光脚在沙滩上玩了好久，兴奋过度，这可能为晚上埋下了伏笔\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/249.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"249\" border=\"0\" alt=\"249\" src=\"/assets/249_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/258.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"258\" border=\"0\" alt=\"258\" src=\"/assets/258_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e之后，晚上在外面吃了点东西，买了些物资，超市的东西还不贵\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e买点明天吃的 (@ 艾欣超市) \u003ca href=\"http://4sq.com/bZXVhM\"\u003ehttp://4sq.com/bZXVhM\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e不过，到了晚上，我们发现儿子的脑袋发烫，估计是白天太兴奋了，着凉了\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e儿子兴奋过度，现在体温有点高，正在给他物理降温\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e经过一夜物理降温，斯屹早上的海边热情依旧，但精神没有头一天足，为了安全起见，我们退了房，带儿子又去海边转了一圈，然后启程返京。来的路上是我们两个人换班开车的，回来的时候，考虑到媳妇后半夜没怎么睡，我一路开回北京，途中屡次超速，嗯。\u003c/p\u003e\n\n\u003cp\u003ePS： 途中发现对面事故导致差不多停了10公里，同情对面的出游的朋友。\u003c/p\u003e\n\n\u003cp\u003e周六中午到家之后，斯屹下午又发烧了一下，用了点药降温，之后体温一直没再提高，周日上午，我们看他没什么大碍，又带他去龙德转了一圈，下午又带他去公园玩了，完全没什么问题了。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eI'm at 丽家宝贝 (龙德广场, 北京市). \u003ca href=\"http://4sq.com/coOvGr\"\u003ehttp://4sq.com/coOvGr\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eI just became the mayor of 丽家宝贝 on @\u003ca href=\"http://twitter.com/foursquare\"\u003efoursquare\u003c/a\u003e!\u003ca href=\"http://4sq.com/coOvGr\"\u003ehttp://4sq.com/coOvGr\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eI'm at 金种子乐园 (立汤路186号龙德广场四层, 北京市).\u003ca href=\"http://4sq.com/9ST7cA\"\u003ehttp://4sq.com/9ST7cA\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eI'm at 天通艺园 (天通东苑, 北京市). \u003ca href=\"http://4sq.com/a4dlWw\"\u003ehttp://4sq.com/a4dlWw\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/267.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"267\" border=\"0\" alt=\"267\" src=\"/assets/267_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e更多内容都是视频形式的，有功夫处理一下上传吧，没功夫就只能无限期拖延了……\u003c/p\u003e\n","cover":"","link":"life/2010/08/09/不太爽的海边之行/index.html","preview":"","title":"不太爽的海边之行"},{"content":"\n\u003cp\u003e张教授的背景\u003cstrike\u003e我就不多介绍了，有兴趣的自己去搜吧\u003c/strike\u003e可以\u003ca href=\"http://www.cse.ohio-state.edu/~zhang/\"\u003e参考此链接\u003c/a\u003e，总之是让人很兴奋的一次交流。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/199.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"199\" border=\"0\" alt=\"199\" src=\"/assets/199_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e这次交流之前，我大致准备了三个问题，不过基本都没有得到提问的机会，张教授就已经把这些问题都提到了：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cul\u003e\n\n\u003cli\u003eHybrid SSD/HDD的意义?\u003c/li\u003e\n\n\u003cli\u003eFirmware or Software? Open vs. Optimistic\u003c/li\u003e\n\n\u003cli\u003eChallenge to fs and block drivers\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e下面我基本按照张教授介绍的顺序把这些我们关心的问题提到。\u003c/p\u003e\n\n\u003cp\u003e张教授和 Intel lab、NSF 都进行了合作，致力于改善 SSD 的应用，释放 SSD 的最大潜能，进而推进 SSD 的应用。下面是正文：\u003c/p\u003e\n\n\u003cp\u003e张教授介绍的第一项工作是使用一个用户态程序来通过读写特征匹配来判断 SSD 的内部结构，主要是SSD读写的并发程度，从而确定对 SSD 可以进行何种优化。这方面，主要是对 SSD 内部的读写并发程度的判定，从而最大限度的利用SSD的能力。在这方面，张教授还回答了我关于开放一部分 firmware 的功能给软件来完成的可能性，张教授的判断是，这方面如果可以开放给操作系统应该是最好的方案，这个工具也就没必要了，但是各个厂商出于利益考虑，短时间内不会公开这一架构。\u003c/p\u003e\n\n\u003cp\u003e张教授介绍的第二项工作是同时使用 SSD 和 HDD，提供最佳应用组合，项目名叫 Hystor，在 block layer入手，将 HDD/SSD 以统一界面呈现给上层，调度热/小数据存放在 SSD，将大数据存放于 HDD，利用其大块连续数据读写的优势。对于某厂商的 Hybrid 方式，张教授表示不看好其单纯将 SSD 应用为 HDD 的 Cache 的方式。对于张教授的使用方式，其中会存在根据应用情况，将数据在不同容器间进行迁移的可能性，感觉上这方面是仍然不太成熟的方面，似乎还在改进中。\u003c/p\u003e\n\n\u003cp\u003e张教授介绍的第三项工作大致是根据第一项工作，对SSD的使用进行优化，包括一些预取机制，可以在 iosched 层面进行并行化的优化，充分利用SSD内部的读写并行化特征，对很多典型应用的性能有数倍的提升，可见目前的SSD应用的性能潜力还是蛮大的。\u003c/p\u003e\n\n\u003cp\u003e来一些花絮：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cul\u003e\n\n\u003cli\u003e张教授在我某同事一进门的时候就认出他来，他04年到访中科大时，我们这位同事还在中科大念书呢，张教授不仅记得他有拉丁舞绝技，甚至还记得他的名字，叫我们这些记不住人的晚辈情何以堪啊\u003c/li\u003e\n\n\u003cli\u003e张教授使用的SSD是Intel X-25E，不太常见的高端设备，不过刚好我手里也有几块，呵呵，可以借鉴很多参数啊；\u003c/li\u003e\n\n\u003cli\u003e张教授是我在工大的校友，呵呵，工大的牛人还是挺多的，并不罕见，不过主要集中在80年代初期，呵呵；\u003c/li\u003e\n\n\u003cli\u003e后来的交流中，张教授多次提到了吴峰光、Colyli等大牛，呵呵，和国内的开发者还是有很多交流的。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e此外，有点遗憾的是当天晚上有好几个活要干，我没坚持到最后，六点多溜了，呵呵。\u003c/p\u003e\n\n\u003cp\u003eUpdate：感谢张教授授权介绍讲座内容，并指出一些被我遗漏的花絮。\u003c/p\u003e\n","cover":"","link":"misc/2010/08/09/张晓东教授来访研究院，交流ssd应用/index.html","preview":"","title":"张晓东教授来访研究院，交流SSD应用"},{"content":"\n\u003cp\u003e08年底买入我的HTC Touch Diamond (P3700)，至今年五月，供使用大约1年半，之后，随着购入milestone，Diamond也就宣告退休了（以下图片视频全是用milestone拍摄的，有点兔死狐悲的味道啊，呵呵），作为备机2个月后，正式准备挂牌出售，这里提供一些图片视频信息，以便潜在买家了解手机的成色。\u003c/p\u003e\n\n\u003cp\u003e手机属于自用机，算不上爱惜，也算不上祸害，所以，一年半，使用率比较高，成色也算不上很新了，不知该说几成。\u003c/p\u003e\n\n\u003ch2\u003e主要磨损\u003c/h2\u003e\n\n\u003col\u003e\n\n\u003cli\u003e屏幕的膜有点翘起，建议买家换一个吧，一直有膜，所以屏幕应该没什么问题\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/047.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"047\" border=\"0\" alt=\"047\" src=\"/assets/047_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/048.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"048\" border=\"0\" alt=\"048\" src=\"/assets/048_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e2. 背面的“钻石切割”有磨损，这个是Diamond的通病，有两三个月就这样了\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/050.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"050\" border=\"0\" alt=\"050\" src=\"/assets/050_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e3. 后盖因为摔到地上有个缺角（如图红圈所示），这个是儿子干的好事，呵呵\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/053.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"053\" border=\"0\" alt=\"053\" src=\"/assets/053_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003ch2\u003e系统状况\u003c/h2\u003e\n\n\u003cp\u003e除了上面这些磨损以外，系统运行正常，标准的 Windows Mobile 6.1 + HTC TouchFlo 3D，下面是一个视频，内容就是开机、动两下manila，然后关掉，用于简单演示系统运行状态：\u003c/p\u003e\n\n\u003cp\u003e \u003cembed src=\"http://player.youku.com/player.php/sid/XMTk0NjQ3MTYw/v.swf\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"sameDomain\" type=\"application/x-shockwave-flash\"\u003e\u003c/embed\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003ch2\u003e附件情况\u003c/h2\u003e\n\n\u003cp\u003e两块电池：原电+羽博一块，有适配器+数据线\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/055.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"055\" border=\"0\" alt=\"055\" src=\"/assets/055_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/08/057.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"057\" border=\"0\" alt=\"057\" src=\"/assets/057_thumb.jpg\" width=\"244\" height=\"139\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e原装耳机接触不良，不好用了，有一个后加的，似乎后来也不是很好用了，真要用的话建议再另购一个。\u003c/p\u003e\n\n\u003ch2\u003e其他（报价？）\u003c/h2\u003e\n\n\u003cp\u003e没什么其他的了，有需要、想玩Windows Mobile的可以和我联系，出价，嗯800块钱吧，原价的零头，呵呵。\u003c/p\u003e\n\n\u003cp\u003e哦，还有交易地点，最好就是北京吧，越近越好，越直接越好。\u003c/p\u003e\n","cover":"","link":"misc/2010/08/02/准备出我的diamond/index.html","preview":"","title":"准备出我的Diamond"},{"content":"\n\u003cp\u003e还有五天，就是7月8日，我们的结婚三周年纪念日了，在这个周末，我收集了两个人在一起的点点滴滴的往事，做了一个小视频，来纪念这一个日子，把祝福送给我的爱妻。\u003c/p\u003e\n\n\u003cp\u003e照例，视频密码还是 internet \u003c/p\u003e\n\n\u003cp\u003e \u003cembed src=\"http://player.youku.com/player.php/sid/XMTg2NjI1MzI4/v.swf\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"sameDomain\" type=\"application/x-shockwave-flash\"\u003e\u003c/embed\u003e\n\n\u003cp\u003e注1：无搞笑内容，寻娱乐者不必打开了，直接祝福就好了，嘿嘿\u003c/p\u003e\n\n\u003cp\u003e注2：配乐为伍佰的《与你到永久》\u003c/p\u003e\n\n\u003cp\u003e致谢：感谢王冀彬等人参与拍摄的部分照片\u003c/p\u003e\n","cover":"","link":"life/2010/07/03/爱你到永久/index.html","preview":"","title":"爱你到永久"},{"content":"\n\u003cp\u003e本月的最主要新闻来自Hadoop社区，世界杯正在南非举行，而Hadoop世界的最大的聚会则是每年6月在硅谷举办的Hadoop Summit，今年的 Hadoop Summit 会在 6月29日在圣克拉拉举办，继续了去年的盛况。此外IaaS相关开源社区也很活跃。\u003c/p\u003e\n\n\u003cp\u003e1. Hadoop Summit 2010将于6月29日举行    \u003cbr /\u003e\u003ca href=\"http://developer.yahoo.com/events/hadoopsummit2010/\"\u003ehttp://developer.yahoo.com/events/hadoopsummit2010/\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eMapReduce模式大规模并行处理的事实标准 Hadoop 项目拥有庞大的用户社区，在世界各地会召开不同规模的社区聚会或会议，一年一度的在硅谷召开的Hadoop Summit是其中最为重要的会议，会议由Hadoop的发起者Yahoo公司举办，全球的 Hadoop 开发者、研究者和用户会参加会议的开发、研究和应用三个主题的研讨，包括Yahoo、Amazon、Cloudera、Facebook在内的云计算领先者都会进行主题发言。\u003c/p\u003e\n\n\u003cp\u003e目前，Hadoop的线下活动已经有Hadoop Summit, Hadoop World这样的全球峰会、HUG Meetup这样的小规模技术讨论，以及中国、印度等地的区域性大会，线下活动的丰富是社区成熟的产物，同时也帮助社区更进一步的健康发展。\u003c/p\u003e\n\n\u003cp\u003e2. CloudEra与Quest合作开发Hadoop Oracle Connector\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://news.cnet.com/8301-13846_3-20008242-62.html\"\u003ehttp://news.cnet.com/8301-13846_3-20008242-62.html\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e仍然是一条Hadoop相关新闻，CloudEra宣布，要和Quest Software合作为Hadoop开发一个Oracle Connector，以便进行 Hadoop 和 Oracle 的双向数据通信。\u003c/p\u003e\n\n\u003cp\u003eCloudera 之前已经开发了一个数据库导入工具 squoop，而这次的 Oracle 导入/导出工具更进一步针对了 Oracle 广泛应用的企业IT系统。\u003c/p\u003e\n\n\u003cp\u003e3. C12G 发布 OpenNebula 1.4 指南（PDF版） \u003c/p\u003e\n\n\u003cp\u003ehttp://www.c12g.com/blog:2010-06-21-c12g_releases_opennebula_1.4_pdf_guides_-_june_21_2010\u003c/p\u003e\n\n\u003cp\u003eOpenNebula 是当前的一个比较著名的开源 IaaS 系统（另一个是Eucalyptus），今年3月，项目的创立者们成立了一家名为C12G的公司，开始商业化地运营。在OpenNebula上个月推出 1.4 企业版和简化版后，这个月C12G发布了1.4版的手册，这个公司正在逐渐开始运转，推动OpenNebula更加成熟。\u003c/p\u003e\n\n\u003cp\u003e商业化和开源从来都不矛盾，获得良好商业模式的支持会使得开源软件和社区更具有生命力，MySQL就是个不错的例子，不过，开源软件的生命力在于健康的社区，如果不能营造一个健康开放的社区，开源项目和商业公司可能面临双输的结局，这样的例子也比比皆是。现在对C12G进行判断还为时尚早，期待C12G和OpenNebula共同繁荣。\u003c/p\u003e\n\n\u003cp\u003e4. Eucalyptus发布伙伴计划，推进云计算产业链丰富与完善\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.crn.com/software/225701187\"\u003e\u003c/a\u003e\u003ca href=\"http://www.crn.com/software/225701187;jsessionid=PDVDQFSBBPVG5QE1GHOSKH4ATMY32JVN\"\u003ehttp://www.crn.com/software/225701187;jsessionid=PDVDQFSBBPVG5QE1GHOSKH4ATMY32JVN\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.crn.com/software/225701187\"\u003e\u003c/a\u003e另一家开源IaaS厂商Eucalyptus也不甘寂寞，他们开始了一个合作伙伴计划，向系统集成商、零售商、服务提供商以及平台厂商推广云计算。这项计划的核心是一个“Eucalyptus合作伙伴云”，让伙伴们可以在这里开发、测试他们的解决方案。Eucalyptus期望可以通过这种方式可以构建一个以自己为中心的、繁荣的云计算生态环境。\u003c/p\u003e\n","cover":"","link":"cloud/2010/06/27/6月云计算相关开源新闻/index.html","preview":"","title":"6月云计算相关开源新闻"},{"content":"\n\u003cp\u003e一个星期以来都想为一天天长大的斯屹写一篇日志，尤其是最近用新手机拍了很多视频以后，不过这两天太忙了，总没时间整理视频们，一拖再拖。不过，不能总欠着儿子的，给不了他一篇完美的日志，也不能完全不给啊，呵呵。\u003c/p\u003e\n\n\u003cp\u003e斯屹最近生了几回病，吊瓶都用上了，全家心疼坏了，生病之余还在5月30号参加了研究院的亲子大赛，和爸爸一起拿了一个项目的第三名，表现优异，赢了个令人羡慕的大奖，稍后再补上同事帮忙拍的照片吧。\u003c/p\u003e\n\n\u003cp\u003e斯屹在运动方面也有很大加强，这次让人震惊的飞过小桥太刺激了（视频第20秒）\u003c/p\u003e\n\n\u003cp\u003e \u003cembed src=\"http://player.youku.com/player.php/sid/XMTc5NDgzMDcy/v.swf\" quality=\"high\" width=\"480\" height=\"400\" align=\"middle\" allowscriptaccess=\"sameDomain\" type=\"application/x-shockwave-flash\"\u003e\u003c/embed\u003e \u003c/p\u003e\n\n\u003cp\u003e视频的密码是internet\u003c/p\u003e\n\n\u003cp\u003e最近斯屹的经典行为——有一天晚上他突然拍了爷爷大腿外侧两下，说“斯屹最喜欢爷爷了”——原因是他妈妈跟他说，去，拍拍爷爷马屁，说“斯屹最喜欢爷爷了”，然后他就果然去拍了……全家笑翻。\u003c/p\u003e\n\n\u003cp\u003e  更多视频和端午假期去天津海边的情况，回头再发吧，这里先给儿子一个交代，呵呵，别都忘了。\u003c/p\u003e\n","cover":"","link":"life/2010/06/23/欠斯屹一篇日志/index.html","preview":"","title":"欠斯屹一篇日志"},{"content":"\n\u003cp\u003e原文: \u003ca href=\"http://www.rackspacecloud.com/blog/2010/05/12/cassandra-by-example/#\"\u003ehttp://www.rackspacecloud.com/blog/2010/05/12/cassandra-by-example/#\u003c/a\u003e     \u003cbr /\u003e原作者：Eric Evan\u0026#160; \u003cbr /\u003e原文发布日期：May 12, 2010     \u003cbr /\u003e译者：王旭（\u003ca href=\"http://wangxu.me/blog/\"\u003ehttp://wangxu.me/blog/\u003c/a\u003e , @gnawux）     \u003cbr /\u003e翻译时间：2010年5月15,25,26日\u003c/p\u003e\n\n\u003cp\u003e近来 \u003ca href=\"http://cassandra.apache.org/\"\u003eCassandra\u003c/a\u003e 备受瞩目，很多人正在评估是否可以应用 Cassandra。由于这些人更多的追求速度，相应的，我们的文档就过于粗浅了。这些文章中，最差的是为有关系数据库基础的人解释Cassandra数据模型的那些。\u003c/p\u003e\n\n\u003cp\u003eCassandra 数据模型实际和传统的数据库差异非常大，足够让人眩晕，而且很多误解都需要修正。\u003c/p\u003e\n\n\u003cp\u003e有些人把这个数据模型描述成存放map的map，或对于super column的场景，是存放map的map的map。这些解释经常用类似 JSON 标记的视觉辅助展示方法来进行佐证。其他人则把列族看做是系数表，还有人把列族看作是存放列对象的集合容器。甚至有人有时把列看走势三元组。我觉得所有这些解释都不够好。\u003c/p\u003e\n\n\u003cp\u003e问题在于很难去用类比的方法来确切解释一个新的东西，而且如果比较的不准确的话常常把人搞糊涂。我仍然期望有人能解释清楚这个数据模型，但同时我觉得确切的例子可能更容易说明白一些。\u003c/p\u003e\n\n\u003ch3\u003eTwitter\u003c/h3\u003e\n\n\u003cp\u003e尽管 \u003ca href=\"http://twitter.com/\" target=\"_blank\"\u003eTwitter\u003c/a\u003e 本身就是 Cassandra 的一个\u003ca href=\"http://nosql.mypopescu.com/post/407159447/cassandra-twitter-an-interview-with-ryan-king\" target=\"_blank\"\u003e实际的应用场景\u003c/a\u003e，它仍然是一个不错的教学实例，因为它众所周知而且易于抽象。在例子中，和很多站点一样，每个用户都有一份用户数据（显示名称、密码、email等），这些信息链接到朋友（译注：用户follow的人）和 follower（译注：follow用户的人）。此外，如果没有那些短 tweets 的话也就不是 twitter 了，tweet每条140个字符，它们都关联着诸如时间戳和惟一的id这样的元数据，这个id我们可以从URL里看到。\u003c/p\u003e\n\n\u003cp\u003e现在我们在一个关系数据库里来直接进行建模，我们首先需要一个表来存放用户。\u003c/p\u003e\n\n\u003cpre\u003eCREATE TABLE user (\n    id INTEGER PRIMARY KEY,\n    username VARCHAR(64),\n    password VARCHAR(64)\n);\u003c/pre\u003e\n\n\u003cp\u003e我们还需要两张表来存储一对多的follow关系。\u003c/p\u003e\n\n\u003cp\u003eCREATE TABLE followers (\u003cbr /\u003e\n  \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; user INTEGER REFERENCES user(id), \u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u0026#160;\u0026#160; follower INTEGER REFERENCES user(id) \u003c/p\u003e\n\n\u003cp\u003e); \u003c/p\u003e\n\n\u003cp\u003e\u0026#160; \u003cbr /\u003eCREATE TABLE following ( \u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u0026#160;\u0026#160; user INTEGER REFERENCES user(id), \u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u0026#160;\u0026#160; followed INTEGER REFERENCES user(id) \u003c/p\u003e\n\n\u003cp\u003e);\u003c/p\u003e\n\n\u003cp\u003e显然，我们还需要表来存储tweets。\u003c/p\u003e\n\n\u003cpre\u003eCREATE TABLE tweets (\n    id INTEGER,\n    user INTEGER REFERENCES user(id),\n    body VARCHAR(140),\n    timestamp TIMESTAMP\n);\u003c/pre\u003e\n\n\u003cp\u003e由于仅仅是个例子，我已经极大简化了情况，但仅仅是这个极度简化的模型，也还有很多需要做的工作。例如，要以可行的方法达到达到数据归一化就需要一个外部键值约束，而因为我们需要从多张表join信息，我们需要对任意值建索引，以保证高效。\u003c/p\u003e\n\n\u003cp\u003e但是让一个分布式系统正常工作相当有挑战性，几乎不可能不做任何折衷。对Cassandra来说也是如此，而且这也是为什么上述数据模型对我们来说是无法工作的的原因。对于入门者，没有可供参考的完整性，缺乏次索引使得join很难进行，所以，你必须反归一化。另一方面，你被迫思考你要进行的查询的方式和期望结果，因为这差不多就是数据模型看起来的样子。\u003c/p\u003e\n\n\u003ch3\u003eTwissandra\u003c/h3\u003e\n\n\u003cp\u003e那么如何把上述模型翻译到Cassandra中呢？十分幸运，我们只需要看看 \u003ca href=\"http://github.com/ericflo/twissandra\"\u003eTwissandra\u003c/a\u003e，这是 \u003ca href=\"http://www.eflorenzano.com/\"\u003eEric Florenzano\u003c/a\u003e 写的一个 Twitter 的简化版克隆，用作例子。那么让我们来使用 Twitter 和 Twissandra 作为例子来看看 Cassandra 的数据模型是如何的。\u003c/p\u003e\n\n\u003ch4\u003eSchema\u003c/h4\u003e\n\n\u003cp\u003eCassandra 是一种无 schema 的数据存储方式，但为你的应用做一些特定的配置还是必要的。Twissandra 给出了一个可以工作的 Cassandra 配置，不过研究一下关于数据模型方面的配置还是物有所值的。\u003c/p\u003e\n\n\u003ch5\u003eKeyspaces\u003c/h5\u003e\n\n\u003cp\u003eKeyspaces 是 Cassandra 中最顶层的命名空间。在未来版本的 Cassandra 中，将可以动态创建 keyspace，正如在 RDBMS 中创建数据库一样，但是对于 0.6 和以前的版本，这些都在主配置文件中定义，如：\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;Keyspaces\u0026gt;\n  \u0026lt;Keyspace Name=\u0026quot;Twissandra\u0026quot;\u0026gt;\n  ...\n  \u0026lt;/Keyspace\u0026gt;\n\u0026lt;/Keyspaces\u0026gt;\u003c/pre\u003e\n\n\u003ch5\u003eColumn Families\u003c/h5\u003e\n\n\u003cp\u003e对于每个 keyspace，都可以有一个或多个列族。列族是用于关联类型相近的记录的命名空间。Cassandra 在写操作时，在一个列族内部允许有记录级的原子性，对它们进行查询非常高效。这些特性十分重要，在进行你的数据建模前必须记牢，它们会在下面讨论到。\u003c/p\u003e\n\n\u003cp\u003e和keyspace类似，列族也在主配置文件中定义，虽然在将来的版本中你将可以在运行时创建列族，正像在RDBMS中创建表一样。\u003c/p\u003e\n\n\u003cpre\u003e\u0026lt;Keyspaces\u0026gt;\n  \u0026lt;Keyspace Name=\u0026quot;Twissandra\u0026quot;\u0026gt;\n    \u0026lt;ColumnFamily CompareWith=\u0026quot;UTF8Type\u0026quot;  Name=\u0026quot;User\u0026quot;/\u0026gt;\n    \u0026lt;ColumnFamily CompareWith=\u0026quot;BytesType\u0026quot; Name=\u0026quot;Username\u0026quot;/\u0026gt;\n    \u0026lt;ColumnFamily CompareWith=\u0026quot;BytesType\u0026quot; Name=\u0026quot;Friends\u0026quot;/\u0026gt;\n    \u0026lt;ColumnFamily CompareWith=\u0026quot;BytesType\u0026quot; Name=\u0026quot;Followers\u0026quot;/\u0026gt;\n    \u0026lt;ColumnFamily CompareWith=\u0026quot;UTF8Type\u0026quot;  Name=\u0026quot;Tweet\u0026quot;/\u0026gt;\n    \u0026lt;ColumnFamily CompareWith=\u0026quot;LongType\u0026quot;  Name=\u0026quot;Userline\u0026quot;/\u0026gt;\n    \u0026lt;ColumnFamily CompareWith=\u0026quot;LongType\u0026quot;  Name=\u0026quot;Timeline\u0026quot;/\u0026gt;\n  \u0026lt;/Keyspace\u0026gt;\n\u0026lt;/Keyspaces\u0026gt;\u003c/pre\u003e\n\n\u003cp\u003e需要指出的是，上面的配置片段中，指定名字的时候同时指定了一个比较者类型。这凸显了 Cassandra 和传统数据库的又一个重大不同，记录按照设计的顺序存储，在之后不能轻易改变。\u003c/p\u003e\n\n\u003ch5\u003e这些列族都是什么?\u003c/h5\u003e\n\n\u003cp\u003e一下子看所有的七个Twissandra列族是干什么的可能不那么直观，所以，我们来逐个仔细看一下：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eUser\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003eUser用于存储用户信息，大致相当于上面描述的用户表。列族中的每条记录以UUID为键值，并包含用户名和密码列。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eUsername\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e在User列族中查询一个用户需要知道用户的键值，但从用户名怎么找到这个UUID键值呢？在上面描述的SQL关系数据库里的话，我们就在User表里来一个匹配用户名的SELECT语句（WHERE username = ‘jericevans’）就行了。但这对于Cassandra来说却不可能。\u003c/p\u003e\n\n\u003cp\u003e首先，关系数据库可以顺序地扫描全表来进行这样一个 SELECT，但由于记录是基于键值分布在 Cassandra 集群中的，这个匹配将可能会在多个节点上进行，可能是很多节点。而且，即使是数据就在一个节点上，仍然有一个原因会让这一操作远没有关系数据库效率高，因为关系数据库可以对username列有索引。前面提到过，Cassandra是不支持第二索引的。\u003c/p\u003e\n\n\u003cp\u003e解决方案就是，建立一个我们自己的反向索引，进行用户名到UUID键值的映射，这就是Username列族的用途。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eFriends\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eFollowers\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003eFriends 和 Follower 列族可以回答这些问题：用户X follow了哪些人？谁follow了用户X？这两个列族的键值都是这个唯一的用户ID，其中包含了哪些有follow关系的用户以及它们创建的时间。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eTweet\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003eTweet 列族用于存放所有的tweets。这个列族以每个 tweet 的 UUID为键值，还包含了用户id，tweet内容以及tweet时间这些列。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eUserline\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这是属于每个用户的时间线。记录的键值是用户的ID，其他的列中，包含有一个数字时间戳到Tweet列族中的tweet ID的映射。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eTimeline\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e最后，Timeline列族类似于Userline，只是这里存储着每个用户的朋友的tweet的时间线视图。\u003c/p\u003e\n\n\u003cp\u003e有了上面这些列祖，现在我们可以看一些常用的操作都是如何发生的。\u003c/p\u003e\n\n\u003ch4\u003e把这些列族放在一起来试一下\u003c/h4\u003e\n\n\u003ch5\u003e添加一个新用户\u003c/h5\u003e\n\n\u003cp\u003e首先，新用户需要一个方法来注册一个账户，当他们注册的时候，组要将他们添加到Cassandra数据库中去。对于Twissandra，我们来看看里面的内容：\u003c/p\u003e\n\n\u003cpre\u003eusername = 'jericevans'\npassword = '**********'\nuseruuid = str(uuid())\u0026#160;\u0026#160; \u003c/pre\u003e\n\n\u003cpre\u003ecolumns = {'id': useruuid, 'username': username, 'password': password}\u0026#160;\u0026#160; \u003c/pre\u003e\n\n\u003cpre\u003eUSER.insert(useruuid, columns)\nUSERNAME.insert(username, {'id': useruuid})\u003c/pre\u003e\n\n\u003cp\u003eTwissandra是用Python写成的，使用 \u003ca href=\"http://github.com/vomjom/pycassa\"\u003ePycassa\u003c/a\u003e 作为访问 Cassandra的客户端，上述大写的 USER 和 USERNAME 是 pycassa.ColumnFamily 的实例，它们需要在使用之前的某个位置被分别初始化。\u003c/p\u003e\n\n\u003cp\u003e这里说明一下，这不是从 Twissandra 里原样摘出来的。我让他们更加简单而且是自包含的。比如，在上面的例子中，如果没有对用户名和密码的赋值的话，可能不那么好理解，不过一个 web 应用只能从用户注册表单里得到这些内容。\u003c/p\u003e\n\n\u003cp\u003e从这个例子中回来，有两个不同的 Cassandra 写操作（insert()），第一个创建了一个用户列族，另一个更新了用户名到用户 UUID 键值的反向映射表。在两个例子中，参数都是用于查找记录的键值，以及包含列名和值的map。\u003c/p\u003e\n\n\u003ch5\u003eFollowing 一个朋友\u003c/h5\u003e\n\n\u003cpre\u003efrienduuid = 'a4a70900-24e1-11df-8924-001ff3591711'\u0026#160;\u0026#160; \u003c/pre\u003e\n\n\u003cpre\u003eFRIENDS.insert(useruuid, {frienduuid: time.time()})\nFOLLOWERS.insert(frienduuid, {useruuid: time.time()})\u003c/pre\u003e\n\n\u003cp\u003e这里我们再来两个不同的\u003ccode\u003einsert()\u003c/code\u003e操作，这次是加入一个用户到我们的朋友列表，并加入反向关系：给被 follow 用户添加一个 follower。\u003c/p\u003e\n\n\u003ch5\u003e发出Tweet\u003c/h5\u003e\n\n\u003cpre\u003etweetuuid = str(uuid())\nbody = '@ericflo thanks for Twissandra, it helps!'\ntimestamp = long(time.time() * 1e6)\u0026#160;\u0026#160; \u003c/pre\u003e\n\n\u003cpre\u003ecolumns = {'id': tweetuuid, 'user_id': useruuid, 'body': body, '_ts': timestamp}\nTWEET.insert(tweetuuid, columns)\u0026#160;\u0026#160; \u003c/pre\u003e\n\n\u003cpre\u003ecolumns = {struct.pack('\u0026amp;gt;d', timestamp: tweetuuid}\nUSERLINE.insert(useruuid, columns)\u0026#160;\u0026#160; \u003c/pre\u003e\n\n\u003cpre\u003eTIMELINE.insert(useruuid, columns)\nfor otheruuid in FOLLOWERS.get(useruuid, 5000):\n    TIMELINE.insert(otheruuid, columns)\u003c/pre\u003e\n\n\u003cp\u003e要存储一条新的tweet，我们需要使用一个新的UUID作为键值，在 Tweet列族创建一个记录，其中的列包含作者的用户ID，创建的时间，当然还有tweet的文本内容本身。\u003c/p\u003e\n\n\u003cp\u003e此外，用户的 Userline 中也要加入tweet的时间和它的id。如果这是用户的第一条tweet的话，这个\u003ccode\u003einsert()\u003c/code\u003e会产生一条新的纪录，后面的只是为这条记录添加新列。\u003c/p\u003e\n\n\u003cp\u003e最后要给发出tweet的用户和其他follower的 timeline 列族添加这条tweet的ID和时间。\u003c/p\u003e\n\n\u003cp\u003e值得注意的一件事是，这里，时间戳使用的是64位长整型变量，而当它成为一个列的名字的时候，它会被打包为网络字节序的二进制值。这是因为Userline和Timeline列族使用了一个LongType Comparator，允许我们使用数值区间指定查找指定范围，所以它们被按照数值来存放起来。\u003c/p\u003e\n\n\u003ch5\u003e接收一个用户的 tweets\u003c/h5\u003e\n\n\u003cpre\u003etimeline = USERLINE.get(useruuid, column_reversed=True)\ntweets = TWEET.multiget(timeline.values())\u003c/pre\u003e\n\n\u003cp\u003e接收一个用户的tweet，首先从Userline获取tweet ID的一个列表，然后从Tweet列族通过\u003ccode\u003emultiget()\u003c/code\u003e方法莱读取这些tweet。得到的结果将是通过着数值表示的时间戳逆序排列的，因为Userline使用了LongTyper comparator，并且reversed设置为了True。\u003c/p\u003e\n\n\u003ch5\u003e获取一个用户的时间线\u003c/h5\u003e\n\n\u003cpre\u003estart = request.GET.get('start')\nlimit = NUM_PER_PAGE\u0026#160;\u0026#160; \u003c/pre\u003e\n\n\u003cpre\u003etimeline = TIMELINE.get(useruuid, column_start=start, \ncolumn_count=limit, column_reversed=True)\ntweets = TWEET.multiget(timeline.values())\u003c/pre\u003e\n\n\u003cp\u003e和上一个例子类似，这次是从 Timeline 读取 tweet ID，不过这次我们还使用了 start 和 limit 来控制读取列的范围。这样有助于输出结果的分页。\u003c/p\u003e\n\n\u003ch3\u003e那么，下一步呢?\u003c/h3\u003e\n\n\u003cp\u003e希望这足够提供给你一个大致的概念。重复一下，我从代码中提取了一些例子，为了简明起见，略去了一些操作，所以现在可能是 check out 出 \u003ca href=\"http://github.com/ericflo/twissandra\"\u003eTwissandra\u003c/a\u003e 的源代码并进行下一步深入研究的好时候了。有很多功能，诸如 retweet 和 lists，都还空着没有实现，可以作为一个练习的起点。如果你已经熟悉 Python 和 Django 的话，那你可以考虑实现一下这些方法。\u003c/p\u003e\n\n\u003cp\u003eCassandra 的 \u003ca href=\"http://wiki.apache.org/cassandra\"\u003ewiki\u003c/a\u003e 包含了大量的信息，而且还在不断增多，还包括一个实时更新的其他人贡献的\u003ca href=\"http://wiki.apache.org/cassandra/ArticlesAndPresentations\"\u003e文章与幻灯片\u003c/a\u003e的列表。\u003c/p\u003e\n\n\u003cp\u003e如果你喜欢IRC的话，你可以加入 irc.freenode.net 的 #cassandra 频道，来和那里的人聊天，他们总是热衷于提供帮助和回答问题。如果你更青睐 email 的话，\u003ca href=\"mailto:user-subscribe@cassandra.apache.org\"\u003ecassandra-user\u003c/a\u003e 邮件列表上也有很多可以提供帮助的人。\u003c/p\u003e\n","cover":"","link":"translation/2010/05/27/cassandra-examples/index.html","preview":"","title":"[译文]Cassandra实例"},{"content":"\n\u003cp\u003e忙碌的一周，来点流水账，开始的一日FML和最后的一日出差是亮点：\u003c/p\u003e\n\n\u003cp\u003e上周六，头天晚上喝酒了，第二天一早还没醒酒起床地铁到天通苑来看儿子，中午吃晚饭，下午去单位加班，本来想干到晚上然后回蓟门里休息的，结果到九点多，老婆来电话说儿子发烧了。虽然老婆说不用我回去，我还是想回去帮帮忙，至少让老婆能多睡一会，于是——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e儿子发烧了，我还在加班，很不心安 \u003ca href=\"http://twitter.com/gnawux/status/13606866032\"\u003e9:01 PM May 8th\u003c/a\u003e via \u003ca href=\"http://echofon.com/\"\u003eEchofon\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e儿子发烧了，赶快赶回天通苑 (@ 西便门桥) \u003ca href=\"http://4sq.com/cqyEzK\"\u003ehttp://4sq.com/cqyEzK\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13609771401\"\u003e10:05 PM May 8th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=39.89989290,116.35774612\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e应该还有70分钟能到老婆和儿子身边 (@ Changchunjie Subway Station 地铁长椿街站) \u003ca href=\"http://4sq.com/cbZ3Dy\"\u003ehttp://4sq.com/cbZ3Dy\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13610199013\"\u003e10:14 PM May 8th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=39.89923444,116.36332512\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e老婆说不用我，我还是想回去让她能稍微歇一下 (@ Chongwenmen Subway Station 地铁崇文门站) \u003ca href=\"http://4sq.com/bgtk9k\"\u003ehttp://4sq.com/bgtk9k\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13610699653\"\u003e10:24 PM May 8th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=39.90097936,116.41731262\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e可是屋漏偏逢连天雨，再次因为没听天气预报而遭到报应……\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e好像下雨了，TP417 北苑路北进站前ATP故障，紧急停车一次 \u003ca href=\"http://twitter.com/search?q=%23ourmetro\"\u003e#ourmetro\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13612505039\"\u003e10:59 PM May 8th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e刚才打了个雷，md，我又要被雨淋了，咋这么背呢 \u003ca href=\"http://twitter.com/gnawux/status/13612606778\"\u003e11:01 PM May 8th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e天通苑南进站前再次ATP故障，是下雨造成的吧 \u003ca href=\"http://twitter.com/search?q=%23ourmetro\"\u003e#ourmetro\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13612893077\"\u003e11:06 PM May 8th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e儿子啊，你爸爸\u003cfont color=\"#ff0000\"\u003e让雷劈着就回来啦\u003c/font\u003e (@ 地铁天通苑南站) \u003ca href=\"http://4sq.com/dz7eYZ\"\u003ehttp://4sq.com/dz7eYZ\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13612981300\"\u003e11:08 PM May 8th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=40.06628177,116.41289234\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e雨太大，出不了站 \u003ca href=\"http://twitter.com/search?q=%23FML\"\u003e#FML\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13613132734\"\u003e11:11 PM May 8th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这时和家打了个电话，老婆怕我人品太差被雷劈了，让我关上手机，在我买了一把伞之后，赶到家的时候，已然空无一人，斯屹烧到39.4，老婆抓狂地带着他去医院了，刚好这时我手机听话的关机了，所以就没带我。他们要我在家待命，随时送东西去医院——时逢我家的车去修了，在这样的一天说FML应该不为过吧。四点钟儿子才回来，打了吊瓶，烧退了，休息两三天之后，斯屹基本恢复了，这孩子的抵抗力还是不错的，今天我回家，他和爸爸非常亲，呵呵，有儿子真开心。\u003c/p\u003e\n\n\u003cp\u003e------------------8\u0026lt;-------------------FML的分隔线---------------------8\u0026lt;--------------------------------\u003c/p\u003e\n\n\u003cp\u003e周三下午，正和同事一起在外面开会，忽然接到通知，去武汉开会，是的，下午就走，于是——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u0026#160; \u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e出发，赶飞机 (@ Xitucheng subway station地铁西土城站) \u003ca href=\"http://4sq.com/d1zdD6\"\u003ehttp://4sq.com/d1zdD6\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13838620957\"\u003e\u003cfont color=\"#ff0000\"\u003e3:54 PM May 12th\u003c/font\u003e\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=39.97613351,116.35379791\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e换机场线，间隔太不美好了，能赶上飞机么 (@ Sanyuanqiao Subway Station 地铁三元桥站) \u003ca href=\"http://4sq.com/9oHfO1\"\u003ehttp://4sq.com/9oHfO1\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13839484293\"\u003e4:22 PM May 12th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=39.96054351,116.45700931\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003emd，机场快轨也太慢了，要误我值机了 (@ 首都机场二号航站楼) \u003ca href=\"http://4sq.com/cS5J5S\"\u003ehttp://4sq.com/cS5J5S\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13840637652\"\u003e5:01 PM May 12th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=40.079545,116.588671\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e唉，登机口又是在航站楼的尽头，每次都这样，好像近处登机门从来不开一样 \u003ca href=\"http://twitter.com/gnawux/status/13841205017\"\u003e5:19 PM May 12th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e \u003c/li\u003e\n\n\u003cli\u003e到了不用坐，直接开始登机，头一次啊，时间真悬，东航的，也是头一回坐，会不会头一次准点啊 \u003ca href=\"http://twitter.com/gnawux/status/13841335387\"\u003e5:23 PM May 12th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e \u003c/li\u003e\n\n\u003cli\u003e难道我瘦了？B737-800啥时候这么宽敞了？还以为是空客的呢 \u003ca href=\"http://twitter.com/gnawux/status/13841536358\"\u003e5:30 PM May 12th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e预料之中的郁闷，交通管制，等15分钟 \u003ca href=\"http://twitter.com/gnawux/status/13842331946\"\u003e5:55 PM May 12th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e实际是晚了一个小时…..到武汉后\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e晚点一小时，安全着陆武汉，似乎下雨了 (@ 武汉天河机场) \u003ca href=\"http://4sq.com/9rk4WG\"\u003ehttp://4sq.com/9rk4WG\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13848488539\"\u003e8:34 PM May 12th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=30.77240823,114.2052577\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e这个出租车在哭雨中开高速，一直保持100以上，没停着地在打电话，我很怕的说 \u003ca href=\"http://twitter.com/gnawux/status/13849920955\"\u003e9:05 PM May 12th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e出租车里这个电台太烦了，非常吵，而且不清楚 \u003ca href=\"http://twitter.com/gnawux/status/13850586753\"\u003e9:19 PM May 12th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e到了，CCSA的会务大婶十分居委会啊 (@ 亚洲大酒店) \u003ca href=\"http://4sq.com/d1CiUY\"\u003ehttp://4sq.com/d1CiUY\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13852229091\"\u003e9:53 PM May 12th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=30.577256,114.261024\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e路上总共用时6个小时，和同事了解了会议情况之后，睡觉之前翻译了一篇文章\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e每次来武汉出差都会半夜翻译篇文章啊，这次是 Ran Tavory 的Understanding \u003ca href=\"http://twitter.com/search?q=%23Cassandra\"\u003e#Cassandra\u003c/a\u003e Code Base，译文在这里: \u003ca href=\"http://wangxu.me/blog/?p=381\"\u003ehttp://wangxu.me/blog/?p=381\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13862430754\"\u003e1:26 AM May 13th\u003c/a\u003e via \u003ca href=\"http://echofon.com/\"\u003eEchofon\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e翻译了一篇文章，算是私活，第二天早起吃饭之后去开会，开了不到两个小时——对，就是不到两个小时，然后……然后就吃中午饭，就准备回北京了——我来的时候路上就六个小时啊，开会居然只有不到俩小时，虽然是正事吧，可性价比也太低了吧……\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003echeck-out 准备回北京，唉，跑这么远来，就开了不到俩小时的会 \u003ca href=\"http://twitter.com/gnawux/status/13894015457\"\u003e12:24 PM May 13th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e@\u003ca href=\"http://twitter.com/hzmangel\"\u003ehzmangel\u003c/a\u003e 热干面没吃到，鸭脖子买了点，晚上来找我吃啊 \u003ca href=\"http://twitter.com/gnawux/status/13895259740\"\u003e12:53 PM May 13th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e \u003ca href=\"http://twitter.com/hzmangel/status/13894629367\"\u003ein reply to hzmangel\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cfont color=\"#ff0000\"\u003e来机场路上，司机一直在瞌睡，我使出浑身解数在和司机搭讪，同车两个不明真相的同事都觉得我真tmd贫，\u003c/font\u003e果然是个侃爷... \u003ca href=\"http://twitter.com/gnawux/status/13896842139\"\u003e1:33 PM May 13th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e平安到机场了，传说中的大雨还没出现，希望尽早飞回北京 (@ 武汉天河机场) \u003ca href=\"http://4sq.com/9rk4WG\"\u003ehttp://4sq.com/9rk4WG\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13896921669\"\u003e1:35 PM May 13th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=30.77240823,114.2052577\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e躲过司机的瞌睡一劫之后，我们开始等待预计3点的飞机……\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003egood，我和同事之间没人，心情愉快，PS:旁边的国航飞机还没动，他们已经晚了快半小时了，我们如果正点应该3点飞 \u003ca href=\"http://twitter.com/gnawux/status/13899392361\"\u003e2:47 PM May 13th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003emd，交通管制，我们也飞不了呢 \u003ca href=\"http://twitter.com/gnawux/status/13899732280\"\u003e2:58 PM May 13th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003ca\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e实际上晚点大约一小时，度过了相当无聊的飞机上的时间之后——\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e到北京了，还是去坐机场快轨吧 (@ 首都机场二号航站楼) \u003ca href=\"http://4sq.com/cS5J5S\"\u003ehttp://4sq.com/cS5J5S\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13905244744\"\u003e5:56 PM May 13th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=40.079545,116.588671\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e机场出口有免费取用的打火机，不知是不是在安检口处人们丢下的 \u003ca href=\"http://twitter.com/gnawux/status/13905400294\"\u003e6:00 PM May 13th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e回家时坐机场线运气好多了，刚好一组车进T2站，不像来时等了14分钟 \u003ca href=\"http://twitter.com/gnawux/status/13905560828\"\u003e6:05 PM May 13th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e机场快轨回程很快啊，不到一刻钟就从T2到三元桥了 (@ Sanyuanqiao Subway Station 地铁三元桥站) \u003ca href=\"http://4sq.com/9oHfO1\"\u003ehttp://4sq.com/9oHfO1\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13906059684\"\u003e6:20 PM May 13th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=39.96054351,116.45700931\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e10号线也这么拥挤，没上去... \u003ca href=\"http://twitter.com/search?q=%23ourmetro\"\u003e#ourmetro\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13906206404\"\u003e6:24 PM May 13th\u003c/a\u003e via \u003ca href=\"http://dabr.co.uk\"\u003edabr\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e对没什么行李的乘客，机场快轨还是个不错的选择，很快就到家了 (@ Xitucheng subway station地铁西土城站) \u003ca href=\"http://4sq.com/d1zdD6\"\u003ehttp://4sq.com/d1zdD6\u003c/a\u003e \u003ca href=\"http://twitter.com/gnawux/status/13906904505\"\u003e6:45 PM May 13th\u003c/a\u003e via \u003ca href=\"http://foursquare.com\"\u003efoursquare\u003c/a\u003e from \u003ca href=\"http://maps.google.com/maps?q=39.97613351,116.35379791\"\u003ehere\u0026#160; \u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e回程用时总计也是六个多小时，这次出差，路上花费了十二个半小时，开会两个小时，创下性价比新低，唉……特此记之。\u003c/p\u003e\n","cover":"","link":"misc/2010/05/14/一周：加班、小孩生病以及出差/index.html","preview":"","title":"一周：加班、小孩生病以及出差"},{"content":"\n\u003cp\u003e原文: \u003ca href=\"http://prettyprint.me/2010/05/02/understanding-cassandra-code-base/\"\u003ehttp://prettyprint.me/2010/05/02/understanding-cassandra-code-base/\u003c/a\u003e     \u003cbr /\u003e原作者：Ran Tavory\u0026#160; \u003cbr /\u003e原文发布日期：May 2nd, 2010     \u003cbr /\u003e译者：王旭（\u003ca href=\"http://wangxu.me/blog/\"\u003ehttp://wangxu.me/blog/\u003c/a\u003e , @gnawux）     \u003cbr /\u003e翻译时间：2010年5月12日\u003c/p\u003e\n\n\u003cp\u003e最近我为 \u003ca href=\"http://cassandra.apache.org/\"\u003ecassandra\u003c/a\u003e 添加了一些小特性，于是我花了些时间来更仔细地考察了这个系统的内部设计。诸如 \u003ca href=\"http://prettyprint.me/2010/02/14/running-cassandra-as-an-embedded-service/\"\u003eembedded service\u003c/a\u003e 这样的特性实际上并不需要对源代码和设计的深入理解，但其他特性，比如 \u003ca href=\"https://issues.apache.org/jira/browse/CASSANDRA-531\"\u003etruncate\u003c/a\u003e 就需要对系统中使用的不同算法有深入的了解，如写操作时如何进行的，读操作时如何进行的，值时如何删除的（提示：他们没有……）等等。\u003c/p\u003e\n\n\u003cp\u003e源代码虽然不是非常长，有大约91136行，但非常密级，而且有很多算法，所以直接读这些代码对我来说并不是非常简单。我是用如下的外科手段来进行行数计数的（\u003ccode\u003e$ cassandra/trunk $ find * -name *.java -type f -exec cat {} \\;|wc -l \u003c/code\u003e）\u003c/p\u003e\n\n\u003cp\u003e我写这篇文章希望可以帮助其他人能更快地阅读这些代码。我不会介绍那些基础信息，比如“什么是Cassandra”，如何部署，如何检出代码，如何编译，如何下载thrift等。我也不想介绍算法最复杂的部分，比如ae-service使用的merkle-tree如何 ，Cassandra 中不同部分都是用的 bloom filter 是什么、如何工作，以及 gossip 是如何使用的。我不认为我适于解释所有这些问题，而且在cassandra的\u003ca href=\"http://wiki.apache.org/cassandra/ArchitectureInternals\" target=\"_blank\"\u003e开发者wiki\u003c/a\u003e上也已经介绍这些了。我要写的就是我学习cassandra的途径，以及我在这个过程中学到了什么。我没有在其他地方发现过类似文档（当我完全完成的时候，可能我会把这些写入wiki），所以我觉得这对我下次再深入新的源代码会非常有用。\u003c/p\u003e\n\n\u003cp\u003e最后是一个免责声明：这里仅仅是我对系统如何工作的个人理解，它们是不完整、不确切的，特此警告。注意我也只是在学习，或多或少也是Cassandra菜鸟。也请注意，Cassandra 是一个运动目标，它一直在快速开发者，任何一个代码的快照或早或晚都会发生些变化。在本文写作的时候，官方版本是 0.6.1，不过我工作在 trunk 上，这个分支将来会成为 0.7.0。\u003c/p\u003e\n\n\u003cp\u003e这里是我所采取的几个步骤以及我学到的东西的一个描述。\u003c/p\u003e\n\n\u003ch5\u003e下载，配置，运行…\u003c/h5\u003e\n\n\u003cp\u003e首先你需要下载代码并运行单元测试。如果你使用 eclipes，IDEA，netbeans，vi，emacs等等这些的话，可能还需要配置一下。这非常简单，\u003ca href=\"http://wiki.apache.org/cassandra/HowToContribute\" target=\"_blank\"\u003e这里\u003c/a\u003e有更多介绍。\u003c/p\u003e\n\n\u003ch5\u003e阅读\u003c/h5\u003e\n\n\u003cp\u003e接下来你需要读一些背景材料，这依赖于你想搞哪个部分。我希望理解读操作、写操作以及值如何删除，所以我把下面每个文档都看了差不多五遍。没错，每个五遍。它们包含了大量的信息，我发现每次读我都能被更多的一些细节所吸引。我先读过这些文档，然后读源代码，确定我理解了算法如何在类和方法中实现，然后再读文档，然后再读源代码，读单元测试（并用debugger运行它们）等等。这是这些文档：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wiki.apache.org/cassandra/ArchitectureInternals\"\u003ehttp://wiki.apache.org/cassandra/ArchitectureInternals\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.eecs.harvard.edu/~mdw/papers/seda-sosp01.pdf\"\u003eSEDA paper\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wiki.apache.org/cassandra/HintedHandoff\"\u003ehttp://wiki.apache.org/cassandra/HintedHandoff\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wiki.apache.org/cassandra/ArchitectureAntiEntropy\"\u003ehttp://wiki.apache.org/cassandra/ArchitectureAntiEntropy\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wiki.apache.org/cassandra/ArchitectureSSTable\"\u003ehttp://wiki.apache.org/cassandra/ArchitectureSSTable\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wiki.apache.org/cassandra/ArchitectureCommitLog\"\u003ehttp://wiki.apache.org/cassandra/ArchitectureCommitLog\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wiki.apache.org/cassandra/DistributedDeletes\"\u003ehttp://wiki.apache.org/cassandra/DistributedDeletes\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e我还看了 Google \u003ca href=\"http://labs.google.com/papers/bigtable.html\" target=\"_blank\"\u003eBigTable 的论文\u003c/a\u003e和让人着迷的亚马逊的 \u003ca href=\"http://www.allthingsdistributed.com/2007/10/amazons_dynamo.html\" target=\"_blank\"\u003eDynamo 的论文\u003c/a\u003e，不过这都是很久以前的事情了。它们是很好的背景材料，不过对于理解实际代码并不是必须的。\u003c/p\u003e\n\n\u003cp\u003e好了，读完所有这些文档，我开始知道能做什么、如何做了，但我感觉我还没有到达能写新特性的阶段。在读代码几次之后，我发现我有点晕了，还是不了解诸如“值到底是不是真的被删除了”，那个累负责哪个功能，有几个Stage，Stage之间的数据流是什么样的，还有“如何标记整个列族为删除”，这是我在truncate操作中真正想做的。\u003c/p\u003e\n\n\u003ch5\u003eStages\u003c/h5\u003e\n\n\u003cp\u003eCassandra 的操作使用的并发模型在 SEDA 论文中有介绍。这个并发模型大致是这样的，和很多其他兵法系统不同，一个操作，比如一个写操作，并不是在同一个线程中开始和结束的。相反，一个操作在一个线程中开始，之后把操作（异步）交给了另一个线程，然后再传递到下一个进程，直至完成。事实上，操作并不是在线程间流转，而是在stage间流转。操作从一个stage转向另一个。每个stage都和一个线程池相关联，这个线程池在方便的时候来执行这个操作。一些操作是 IO bound 的（译注：这里应该是CPU吧，猜的），另一些则受限于磁盘或网络，所谓“方便”取决于资源的可用性。SEDA 论文把这个过程解释得非常好（很好的文章，值得一读），简单地说你从中得到的是更高级别的并发性和更好的资源管理，资源包含 CPU、磁盘、网络等。\u003c/p\u003e\n\n\u003cp\u003e所以，要理解 Cassandra 的数据流，你首先需要理解 SEDA。然后你需要了解 Cassandra 中有哪些 Stage，以及这些 stage 之间数据时如何流动的。\u003c/p\u003e\n\n\u003cp\u003e十分幸运，作为一个起点，\u003ca href=\"https://svn.apache.org/repos/asf/cassandra/trunk/src/java/org/apache/cassandra/concurrent/StageManager.java\"\u003eStageManager\u003c/a\u003e 类中包含了一个不完整 stage 列表：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cpre\u003epublic final static String READ_STAGE = \u0026quot;ROW-READ-STAGE\u0026quot;;\npublic final static String MUTATION_STAGE = \u0026quot;ROW-MUTATION-STAGE\u0026quot;;\npublic final static String STREAM_STAGE = \u0026quot;STREAM-STAGE\u0026quot;;\npublic final static String GOSSIP_STAGE = \u0026quot;GS\u0026quot;;\npublic static final String RESPONSE_STAGE = \u0026quot;RESPONSE-STAGE\u0026quot;;\npublic final static String AE_SERVICE_STAGE = \u0026quot;AE-SERVICE-STAGE\u0026quot;;\nprivate static final String LOADBALANCE_STAGE = \u0026quot;LOAD-BALANCER-STAGE\u0026quot;;\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e我就不具体介绍每个 stage 都负责什么了（因为我也不知道……）但我可以说大致说，ROW-READ-STAGE 在读操作中，ROW-MUTATION-STAGE 参与了写和删除操作，而 AE-SERVICE-STAGE 负责 anti-entropy （译注：整理？不知道怎么确切用中文表达了）。这不是一个完整的 stage 列表，根据你感兴趣的代码路径，用这个方法，你可以找到更多。比如，查看文件\u003ca href=\"https://svn.apache.org/repos/asf/cassandra/trunk/src/java/org/apache/cassandra/db/ColumnFamilyStore.java\"\u003eColumnFamilyStore\u003c/a\u003e你可以找到更多的stage，如FLUSH-SORTER-POOL, FLUSH-WRITER-POOL 和 MEMTABLE-POST-FLUSHER。在 Cassandra 中，stage 由 ExecutorService 的实例来唯一标识，这差不多是一个线程池，他们有全大写的名字，如 MEMTABLE-POST-FLUSHER。\u003c/p\u003e\n\n\u003cp\u003e我画了一张混有类和stage的图来便于理解。这不是合法的UML，但我觉得这对于了解数据在系统中如何流动是个很好的方法。这不是全部类和stage的完整的图示，仅仅是我感兴趣的一部分。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/05/cassandra1.png\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"cassandra-1\" border=\"0\" alt=\"cassandra-1\" src=\"/assets/cassandra1_thumb.png\" width=\"518\" height=\"480\" /\u003e\u003c/a\u003e\u0026#160; \u003cbr /\u003e\u003ca href=\"http://yuml.me/diagram/plain;dir:LR;/class/edit/[note:Classes and STAGES], [ColumnFamilyStore| flushSorter_:FLUSH-SORTER-POOL; flushWriter_:FLUSH-WRITER-POOL; commitLogUpdater_:MEMTABLE-POST-FLUSHER], [ColumnFamilyStore]-\u0026gt;[SSTableTracker], [ColumnFamilyStore]-\u0026gt;[Memtable (memtable_)], [CommitLog|CommitLogExecutor], [DeletionService|FILEUTILS-DELETE-POOL], [StorageLoadBalancer| lb_:LB-OPERATIONS; lbOperations_:LB-TARGET], [StorageService| consistencyManager_:CONSISTENCY-MANAGER], [StageManager| READ_STAGE; MUTATION_STAGE; STREAM_STAGE; GOSSIP_STAGE; RESPONSE_STAGE; AE_SERVICE_STAGE; LOADBALANCE_STAGE; MIGRATION_STAGE]\"\u003e[SSTableTracker], [ColumnFamilyStore]-\u0026gt;[Memtable (memtable_)], [CommitLog|CommitLogExecutor], [DeletionService|FILEUTILS-DELETE-POOL], [StorageLoadBalancer| lb_:LB-OPERATIONS; lbOperations_:LB-TARGET], [StorageService| consistencyManager_:CONSISTENCY-MANAGER], [StageManager| READ_STAGE; MUTATION_STAGE; STREAM_STAGE; GOSSIP_STAGE; RESPONSE_STAGE; AE_SERVICE_STAGE; LOADBALANCE_STAGE; MIGRATION_STAGE]\u0026quot;\u0026gt;yUML source\u003c/a\u003e\u003c/p\u003e\n\n\u003ch5\u003eDebugging\u003c/h5\u003e\n\n\u003cp\u003e可以使用一个 debugger 来读代码，运行一个单元测试是了解事情如何工作的非常棒的方法。我不是一个\u003ca href=\"http://stackoverflow.com/questions/602138/is-a-debugger-the-mother-of-all-evil\" target=\"_blank\"\u003edebugger的铁杆粉丝\u003c/a\u003e，但是他们有一个可取之处就是通过单步执行单元测试来学习新代码。所以我所做的证实单步执行代码中的单步执行。这非常酷。我还运行了 Hector 的单元测试，它使用 thrift 接口并运行一个嵌入的 cassandra 服务器，这个方法一针见血、界面友好而且还能学到更多东西。\u003c/p\u003e\n\n\u003ch5\u003e类图\u003c/h5\u003e\n\n\u003cp\u003e接下来我所做的是使用一个工具来从已有代码中提取类图。这不是非常有用。\u003c/p\u003e\n\n\u003cp\u003e好，我使用的工具不是很棒，但这不是最关键的问题，问题是 cassandra 的代码书写方法使得类图对于理解代码作用很有限。UML 类图对于面向对象设计非常有效。类图的必要性在于列出类、成员以及它们的关系。比如类 A 是类 B 的一个列表，这样通过 UML 类图可以看出 A 是 B 的聚合，而且仅仅通过类图就可以学到很多。比如一架飞机有很多乘客。\u003c/p\u003e\n\n\u003cp\u003eCassandra 是一个拥有坚实算法后台和优秀性能的系统，但是，老实说，依我之见，从好的面向对象实践的视角来看，它可不是一个很好的研究案例……它的类包含很多静态方法和成员，而且在很多地方，你可以看到一个类调用另一个类的静态方法。纯粹的C风格，所以我发现类图尽管从类的可视化以及类之间的关系方面有些帮助，但并不是非常有用。\u003c/p\u003e\n\n\u003cp\u003e我放弃了类图，继续进入下一种兔——序列图。\u003c/p\u003e\n\n\u003ch5\u003e序列图\u003c/h5\u003e\n\n\u003cp\u003e序列图非常适于实体之间的交互的抽象和可视化。这里，一个实例可能是一个类，一个 STAGE 或一个 thrift 客户端。很幸运，使用序列图，你不必太专注于序列图里实体的类型，你只需要把他们都表示为 actor 就行了（至少我觉得这么做就够了，希望UML大神们原谅）。\u003c/p\u003e\n\n\u003cp\u003e下面的图通过运行 \u003ca href=\"http://prettyprint.me/2010/02/23/hector-a-java-cassandra-client/\"\u003eHector\u003c/a\u003e 的单元测试并使用一个（单节点）嵌入式 Cassandra 服务器得到。这个序列图并不很通用，它仅仅描述了一种可能的执行路径，而实际上可能有很多种，但我尼克让它们更简单一些，尽管有点不太精确。\u003c/p\u003e\n\n\u003cp\u003e我使用了一个简单的在线序列图编辑器（\u003ca href=\"http://www.websequencediagrams.com\"\u003ehttp://www.websequencediagrams.com\u003c/a\u003e）来生成他们。\u003c/p\u003e\n\n\u003cp\u003e读操作：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/05/cassandra2.png\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"cassandra-2\" border=\"0\" alt=\"cassandra-2\" src=\"/assets/cassandra2_thumb.png\" width=\"644\" height=\"259\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e写操作：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/05/cassandra3.png\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"cassandra-3\" border=\"0\" alt=\"cassandra-3\" src=\"/assets/cassandra3_thumb.png\" width=\"644\" height=\"332\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003ch5\u003eTable is a Keyspace\u003c/h5\u003e\n\n\u003cp\u003e最后提示：作为 Cassandra 的用户我应该使用 Keyspace, ColumnFamily, Column 这些名词。不过，代码中使用了 Table 这个名词。啥是 Table 呢？……原来，\u003ca href=\"https://svn.apache.org/repos/asf/cassandra/trunk/src/java/org/apache/cassandra/db/Table.java\"\u003eTable\u003c/a\u003e实际上就是 Keyspace…… 就是一个提示，仅此而已。\u003c/p\u003e\n\n\u003cp\u003e研究代码是一项艰巨而有成就感的工作，我希望这篇文章帮助你也有个好的起点，快点跑起来。\u003c/p\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cfont color=\"#4d4d4d\"\u003e\u003c/font\u003e\u003c/p\u003e\n","cover":"","link":"translation/2010/05/13/[译文]理解cassandra源代码/index.html","preview":"","title":"[译文]理解Cassandra源代码"},{"content":"\n\u003cp\u003e2010年4月25日，linuxfb（北邮真情流露Linux版）在老据点之一——北邮教三某实验室的会议室举行了一月一次的版聚。由于聪明的同学们都看了天气预报没来，追星的同学都因为Coly同学缺席没来，版聚史无前例的只有11人出席，不过，还是一如既往的深入、一如既往的愉快。在此感谢李东阳、彭涛和Casparant同学的分享。参加的同学在Google Wave里有记录，搜索“linuxfb with:public”就能找到了，这里不再赘述，仅仅提一下几位突出贡献同学：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003ebergwolf，也就是彭涛同学，每次在自我介绍时都会一如既往地将戒指从无名指挪到中指，这次贡献了一个很时髦的话题，一会再介绍，希望下次再聚会的时候不再需要这么挪戒指了——呃，我不是说要他提前挪好哈，大家明白吧。\u003c/li\u003e\n\n\u003cli\u003elidongyang，李东阳每次来都给我留下深刻印象，尤其这次，带来了第一个精彩话题，当然，一会还是会介绍到的。\u003c/li\u003e\n\n\u003cli\u003e上面两位同学各带来一位围观者，不同的是，含蓄的东阳不想让在他组实习的mm来，而bergwolf则邀请来一位师妹，不知道这两位可爱的mm是不是以后还会来参加啊，呵呵\u003c/li\u003e\n\n\u003cli\u003ejerry/文捷，还有saka，都是来参加版聚新同学，热烈欢迎他们，saka让我们想起了久违的LeoVirgo，啥时候能再聚聚啊\u003c/li\u003e\n\n\u003cli\u003ebunbun是版聚的老面孔了，搞技术的女孩，呵呵，redsand后继有人啊，话说如果redsand下次带宝宝来的话，我也带我家儿子来，哈哈。\u003c/li\u003e\n\n\u003cli\u003egmoto，linuxfb五年版聚史中的第一偶像派的帅哥，这次也来了，可惜没有topic和众多的男女fans\u003c/li\u003e\n\n\u003cli\u003ehzmalgel，版聚的元老，这次也一如既往的拒绝承认有女朋友，一样的活跃，而且参与了中间的caspar的VPN环节，试用了cooler提供的VPN账号，当然，没成功\u003c/li\u003e\n\n\u003cli\u003ecasparant，本次版聚的多面手，测试了投影仪，担任了摄影师，还在第二个话题中介绍了多种翻墙技巧。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e李东阳这次介绍了一个ocfs2的一个bug，大概是这样的，fsstress的truncate会出错，内存中和磁盘上的元数据不一致，东阳同学在VFS的direct write位置定位了这个问题。背景是这样的：OCFS2的Direct Write不允许改变元数据，以获得更好的并发性能。但如果发现有O_DIRECT而不能directio，就送回VFS去做buffered io，可是，VFS的aio还是会检查 o_direct，回到 ocfs2_direct....，最后，该函数只查看 offset，不判断是否超出inode的范围，于是就出现了问题。最终的修改比较直接，就是要确定不要回到direct，只要确定进aio，就一定进aio，这样就不会出问题了。曲折的debug故事一直是我们比较喜欢的话题，非常有趣。\u003c/p\u003e\n\n\u003cp\u003e最后，bergwolf介绍了ATA的新指令TRIM，用于宣称某个块已经没有用了，可以被删除了，希望来帮助SSD更主动地垃圾回收，从而提升性能。2.6.33的内核已经支持了TRIM，btrfs和ext4也会使用TRIM。但是TRIM指令的设计师非常匪夷所思的，不能进入queue，类似barrier，这样，需要等前面的指令执行完才能执行TRIM，而TRIM完成之后才能有新的指令进入queue，一次的时延有上百毫秒，如果大量使用这个命令的话，反而会影响性能。结论是——这个命令暂时没啥好处……\u003c/p\u003e\n\n\u003cp\u003e总之，感谢讲话题的三位同学：lidongyang，bergwolf，casparant，也感谢永远的组织者，colyli和hzmangel，当然，我也会一如既往的记下去。\u003c/p\u003e\n","cover":"","link":"linux/2010/04/28/linuxfb版聚总结/index.html","preview":"","title":"LinuxFB版聚总结"},{"content":"\n\u003cp\u003e\u003ccode\u003e\u003cbr /\u003e\ngrep -n -R '//\\*CR\\*' * |sed -ne 's/\\([^:]*\\)\\/\\([^.:]\\+\\.java\\):\\([0-9]\\+\\):\\(.*\\)\\/\\/\\*CR\\*\\(.*\\)$/@line \\3 of \\2 \\n\\tin Path: \\.\\/\\1\\n\\t--\u0026gt; \\4\\n\\t\\\"Issue: \\5/p'\u003cbr /\u003e\n\n\u003c/code\u003e\u003c/p\u003e\n","cover":"","link":"misc/2010/04/08/codereview统计脚本/index.html","preview":"","title":"CodeReview统计脚本"},{"content":"\n\u003cp\u003e原文: \u003ca title=\"http://ria101.wordpress.com/2010/02/24/hbase-vs-cassandra-why-we-moved/\" href=\"http://ria101.wordpress.com/2010/02/24/hbase-vs-cassandra-why-we-moved/\"\u003ehttp://ria101.wordpress.com/2010/02/24/hbase-vs-cassandra-why-we-moved/\u003c/a\u003e     \u003cbr /\u003e原作者：Dominic Williams     \u003cbr /\u003e原文发布日期：February 24, 2010 at 7:27 pm     \u003cbr /\u003e译者：王旭（\u003ca href=\"http://wangxu.me/blog/\"\u003ehttp://wangxu.me/blog/\u003c/a\u003e , @gnawux）     \u003cbr /\u003e翻译时间：2010年3月21-25日\u003c/p\u003e\n\n\u003cp\u003e我的团队近来正在忙于一个全新的产品——即将发布的网络游戏 \u003ca href=\"http://translate.googleusercontent.com/translate_c?hl=en\u0026amp;ie=UTF-8\u0026amp;sl=en\u0026amp;tl=zh-CN\u0026amp;u=http://www.fightmymonster.com/\u0026amp;prev=_t\u0026amp;rurl=translate.google.com\u0026amp;twu=1\u0026amp;usg=ALkJrhh_x7GYSmfh1ly73ymLlymT_aahvQ\"\u003ewww.FightMyMonster.com\u003c/a\u003e。这让我们得以奢侈地去构建一个全新的 NOSQL 数据库，也就是说，我们可以把恐怖的 MySQL sharding 和昂贵的可伸缩性抛在脑后了。最近有很多人一直在问，为什么我们要把注意力从 HBase 上转移到 Cassandra 上去。我确认，确实有这样的变化，实际上我们基本上已经把代码移植到了 Cassandra 上了，这里我将给出解释。\u003c/p\u003e\n\n\u003cp\u003e为了那些不熟悉 NOSQL 的读者，后面的其他文章中，我会介绍为什么我们将会在未来几年中看到地震式的从 SQL 到 NOSQL 的迁移，这正和向云计算的迁移一样重要。后面的文章还会尝试解释为什么我认为 NOSQL 可能会是贵公司的正确选择。不过本文我只是解释我们选择 Cassandra 作为我们的 NOSQL 解决方案的选择。\u003c/p\u003e\n\n\u003cp\u003e免责声明——如果你正在寻找一个捷径来决定你的系统选择，你必须要明白，这可不是一个详尽而严格的比较，它只是概述了另一个初创团队在有限时间和资源的情况下的逻辑。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eCassandra 的血统是否预言了它的未来\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e我最喜欢的一个工程师们用来找 bug 的谒语是“广度优先而非深度优先”。这可以可能对那些解决技术细节的人来说很恼人，因为它暗示着如果他们只是看看的话，解决方法就会简单很多（忠告：只对那些能够原谅你的同事说这个）。我造出这个谒语的原因在于，我发现，软件问题中，如果我们强迫我们自己在进入某行代码的细节层面之前，先去看看那些高层次的考虑的话，可以节省大量时间。\u003c/p\u003e\n\n\u003cp\u003e所以，在谈论技术之前，我在做 HBase 和 Cassandra 之间的选择问题上先应用一下我的箴言。我们选择切换的技术结论可能已经可以预测了：Hbase和Cassandra有着迥异的血统和基因，而我认为这会影响到他们对我们的业务的适用性。\u003c/p\u003e\n\n\u003cp\u003e严格的说，Hbase 和它的支持系统源于著名的 Google BigTable 和 Google 文件系统设计（GFS 的论文发于 2003 年，BigTable 的论文发于 2006 年）。而 Cassandra 则是最近 Facebook 的数据库系统的开源分支，她在实现了 BigTable 的数据模型的同时，使用了基于 Amazon 的 Dynamo 的系统架构来存储数据（实际上，Cassandra 的最初开发工作就是由两位从 Amazon 跳槽到 Facebook 的 Dynamo 工程师完成的）。\u003c/p\u003e\n\n\u003cp\u003e在我看来，这些不同的历史也导致Hbase更加适合于数据仓库、大型数据的处理和分析（如进行Web页面的索引等），而 Cassandra 则更适合于实时事务处理和提供交互型数据。要进行系统研究来证明这个观点超出了本文的范畴，但我相信你在考虑数据库的时候总能发现这个差异的存在。\u003c/p\u003e\n\n\u003cp\u003e注意：如果你在寻找一个简单的证明，你可以通过主要 committer 的关注点来进行验证：大部分 HBase 的 committer 都为 Bing 工作（M$ 去年收购了他们的搜索公司，并允许他们在数月之后继续提交开源代码）。与之对应，Cassandra 的主要 committer 来自 Rackspace，用来可以自由获得的支持先进的通用的 NOSQL 的解决方案，用来和 Google, Yahoo, Amazon EC2 等提供的那些锁定在专有的 NOSQL 系统的方案相抗衡。\u003c/p\u003e\n\n\u003cp\u003eMalcolm Gladwell 会说只是根据这些背景的不同就可以简单地选择了 Cassandra。不过这是小马过河的问题。但当然，闭着眼睛就进行一个商业选择是相当困难的……\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e哪个 NOSQL数据库风头更劲?\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e另一个说服我们转向 Cassandra 的原因是我们社区中的大风向。如你所知，软件平台行业里，大者恒大——那些被普遍看好的平台，会有更多人聚集在这个平台周围，于是，从长远看，你可以得到更好的生态系统的支持（也就是说，大部分支持的软件可以从社区中获得，也有更多的开发者可以雇佣）。\u003c/p\u003e\n\n\u003cp\u003e如果从 HBase 开始时，我的印象就是它后面有巨大的社区力量，但我现在相信，Cassandra 更加强大。最初的印象部分来源于 StumpleUpon 和 Streamy 的两位 CTO 的两个非常有说服力的出色的讲演，他们是 Web 行业中两个在 Cassandra 成为一个可选系统之前的 HBase 的两个重要的贡献者，同时也部分来源于快速阅读了一篇名为“HBase vs Cassandra： NoSQL 战役！”的文章（大部分内容都被广泛证实了）。\u003c/p\u003e\n\n\u003cp\u003e势头是很难确证的，你不得不自己进行研究，不过我可以找到的一个重要的标志是 IRC 上的开发者动向。如果你在 freenode.org 上比较 #hbase 和 #cassandra 的开发这频道，你会发现 Cassandra 差不多在任何时候都有两倍的开发者在线。\u003c/p\u003e\n\n\u003cp\u003e如果你用考虑 HBase 一般的时间来考察 Cassandra，你就能发现 Cassandra 的背后确实有非常明显的加速势头。你可能还会发现那些逐渐出现的鼎鼎大名，如 Twitter，他们也计划广泛使用 Cassandra（\u003ca href=\"http://translate.googleusercontent.com/translate_c?hl=en\u0026amp;ie=UTF-8\u0026amp;sl=en\u0026amp;tl=zh-CN\u0026amp;u=http://nosql.mypopescu.com/post/407159447/cassandra-twitter-an-interview-with-ryan-king\u0026amp;prev=_t\u0026amp;rurl=translate.google.com\u0026amp;twu=1\u0026amp;usg=ALkJrhhAV1dF6U42J_vUIBl8TrGtPX8EmQ\" target=\"_blank\"\u003e这里\u003c/a\u003e）。\u003c/p\u003e\n\n\u003cp\u003e注：Cassandra 的网站看起来比 HBase 的好看多了，但认真的说，这可能不仅是市场的趋势。继续吧。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e深入到技术部分: CAP 和 CA 与 AP 的神话\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e对于分布式系统，有个非常重要的理论（这里我们在讨论分布式数据库，我相信你注意到了）。这个理论被称为 CAP 理论，由 Inktomi 的 联合创始人兼首席科学家 Eric Brewer 博士提出。\u003c/p\u003e\n\n\u003cp\u003e这个理论说明，分布式（或共享数据）系统的设计中，至多只能够提供三个重要特性中的两个——一致性、可用性和容忍网络分区。简单的说，一致性指如果一个人向数据库写了一个值，那么其他用户能够立刻读取这个值，可用性意味着如果一些节点失效了，集群中的分布式系统仍然能继续工作，而容忍分区意味着，如果节点被分割成两组无法互相通信的节点，系统仍然能够继续工作。\u003c/p\u003e\n\n\u003cp\u003eBrewer教授是一个杰出的人物，许多开发者，包括 HBase 社区的很多人，都把此理论牢记在心，并用于他们的设计当中。事实上，如果你搜索线上的关于 HBase 和 Cassandra 比较的文章，你通常会发现，HBase 社区解释他们选择了 CP，而 Cassandra 选择了 AP ——毫无疑问，大多数开发者需要某种程度的一致性 （C）。\u003c/p\u003e\n\n\u003cp\u003e不过，我需要请你注意，事实上这些生命基于一个不完全的推论。CAP 理论仅仅适用于一个分布式算法（我希望 Brewer 教授可以统一）。但没有说明你不能设计一个系统，在其中的各种操作的底层算法选择上进行这种。所以，在一个系统中，确实一个操作职能提供这些特性中的两个，但被忽视的问题是在系统设计中，实际是可以允许调用者来选择他们的某个操作时需要哪些特性的。不仅如此，现实世界并不简单的划分为黑白两色，所有这些特性都可以以某种程度来提供。这就是 Cassandra。\u003c/p\u003e\n\n\u003cp\u003e这点非常重要，我重申：Cassandra 的优点在于你可以根据具体情况来选择一个最佳的折衷，来满足特定操作的需求。Cassandra 证明，你可以超越通常的 CAP 理论的解读，而世界仍然在转动。\u003c/p\u003e\n\n\u003cp\u003e我们来看看两种不同的极端。比如我必须从数据库中读取一个要求具有很高一致性的值，也就是说，我必须 100%保证能够读取到先前写入的最新的内容。在这种情况下，我可以通过指定一致性水平为“ALL”来从 Cassandra 读取数据，这时要求所有节点都有数据的一致的副本。这里我们不具有对任何节点失效和网络分裂的容错性。在另一个极端的方面，如果我不特别关心一致性，或仅仅就是希望最佳性能，我可以使用一致性级别“ONE”来访问数据。在这种情况下，从任意一个保存有这个副本的节点获取数据都可以——即使数据有三个副本，也并不在意其他两个有副本的节点是否失效或是否有不同，当然，这种情况下我们读到的数据可能不是最新的。\u003c/p\u003e\n\n\u003cp\u003e不仅如此，你不必被迫生活在黑白世界中。比如，在我们的一个特定的应用中，重要的读写操作通常使用“QUORUM”一致性级别，这意味着大部分存有此数据的节点上的副本是一致的——我这里是个简要描述，具体写你的 Cassandra 程序之前最好还是仔细研究一下。从我们的视角看，这这提供了一个合理的节点失效与网络分裂的耐受性，同时也提供了很高的一致性。而在一般情况下，我们使用前面提到的“ONE”一致性级别，者可以提供最高的性能。就是这样。\u003c/p\u003e\n\n\u003cp\u003e对我们来说，这是 Cassandra 的一个巨大的加分项目。我们不仅能轻易地调整我们的系统，也可以设计它。比如，当一定数量的节点失效或出现网络连接故障时，我们的大部分服务仍然可以继续工作，只有那些需要数据一致性的服务会失效。HBase并没有这么灵活，它单纯地追求系统的一个方面（CP），这让我再次看到了 SQL 开发者和查询优化人员们之间的那道隔阂——有些事情最好能够超越它，HBase！\u003c/p\u003e\n\n\u003cp\u003eIn our project then, Cassandra has proven by far the most flexible system, although you may find your brain at first loses consistency when considering your QUORUMs.在我们的项目之后，卡桑德拉已被证明是迄今为止最灵活的系统，虽然你可能发现一致性第一失去你的大脑在考虑您的法定人数。\u003c/p\u003e\n\n\u003cp\u003e在我们的项目中，Cassandra 已经证明了它是有史以来最灵活的系统，虽然你可能在对这个问题进行投票（QUORUM）的时候发现的大脑失去了一致性。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e什么时候单体会比模块化强？\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eCassandra 和 HBase 的一个重要区别是， Cassandra 在每个节点是是一个单 Java 进程，而完整的 HBase 解决方案却由不同部分组成：有数据库进程本身，它可能会运行在多个模式；一个配置好的 hadoop HDFS 分布式文件系统，以及一个 Zookeeper 系统来协调不同的 HBase 进程。那么，这是否意味着 HBase 有更好的模块化结构呢？\u003c/p\u003e\n\n\u003cp\u003e虽然 HBase 的这种架构可能确实可以平衡不同开发团队的利益，在系统管理方面，模块化的 HBase 却无法视为一个加分项目。事实上，特别是对于一些小的初创公司，模块化倒是一个很大的负面因素。\u003c/p\u003e\n\n\u003cp\u003eHBase的下层相当复杂，任何对此有疑惑的人应该读读 Google 的 GFS 和 BigTable 的论文。即使是在一个单一节点的伪分布式模式下来架设 HBase 也很困难——事实上，我曾经费力写过一篇快速入门的教程（如果你要试试HBase的话\u003ca href=\"http://ria101.wordpress.com/2010/01/28/setup-hbase-in-pseudo-distributed-mode-and-connect-java-client/\" target=\"_blank\"\u003e看看这里\u003c/a\u003e）。在这个指南里你可以看到，设置好 HBase 并启动它实际包含了两个不同系统的手工设置：首先是 hadoop HDFS，然后才是 HBase 本身。\u003c/p\u003e\n\n\u003cp\u003e然后，HBase 的配置文件本身就是个怪兽，而你的设置可能和缺省的网络配置有极大的不同（在文章里我写了两个不同的Ubuntu的缺省网络设置，以及 EC2 里易变的 Elastic IP 和内部分配的域名）。当系统工作不正常的时候，你需要查看大量的日志。所有的需要修复的东西的信息都在日志里，而如果你是一个经验丰富的管理员的话，就能发现并处理问题。\u003c/p\u003e\n\n\u003cp\u003e但是，如果是在生产过程中出现问题，而你又没有时间耐心查找问题呢？如果你和我们一样，只有一个小的开发团队却有远大的目标，没有经历去 7*24 的进行系统监控管理会怎么样呢？\u003c/p\u003e\n\n\u003cp\u003e严肃地说，如果你是一个希望学习 NoSQL 系统的高级 DB 管理员的话，那么选择 HBase。这个系统超级复杂，有灵巧双手的管理员肯定能拿到高薪。\u003c/p\u003e\n\n\u003cp\u003e但是如果你们是一个向我们一样尽力去发现隧道尽头的小团队的话，还是等着听听别的闲话吧\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e胜在 Gossip\u003c/strong\u003e\u003cstrong\u003e！\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eCassandra 是一个完全对称的系统。也就是说，没有主节点或像 HBase 里的 region server 这样的东西——每个节点的角色是完全一样的。不会有任何特定的节点或其他实体来充当协调者的角色，集群中的节点使用称为 “Cossip” 的纯 P2P 通信协议来协调他们的行为。\u003c/p\u003e\n\n\u003cp\u003e对 Gossip 的详细描述和使用 Gossip 的模型超过了本文的内容，但 Cassandra 所采用的 P2P 通信模型都是论证过的，比如发现节点失效的消息传播到整个系统的时间，或是一个客户应用的请求被路由到保存数据的节点的时间，所有这些过程所消耗的时间都毫无疑问的非常的短。我个人相信，Cassandra 代表了当今最振奋的一种 P2P 技术，当然，这和你的 NOSQL 数据库的选择无关。\u003c/p\u003e\n\n\u003cp\u003e那么，这个基于 Gossip 的架构究竟给 Cassandra 用户带来什么显示的好处呢。首先，继续我们的系统管理主体，系统管理变得简单多了。比如，增加一个新节点到系统中就是启动一个 Cassandra 进程并告诉它一个种子节点（一个已知的在集群中的节点）这么简单。试想当你的分布式集群可能运行在上百个节点的规模上的时候，如此轻易地增加新节点简直是难以置信。更进一步，当有什么出错的时候，你不需要考虑是哪种节点出了问题——所有节点都是一样的，这让调试成为了一个更加易于进行且可重复的过程。\u003c/p\u003e\n\n\u003cp\u003e第二，我可以得出结论，Cassandra 的 P2P 架构给了它更好的性能和可用性。这样的系统中，负载可以被均衡地三步倒各个节点上，来最大化潜在的并行性，这个能力让系统面临网络分裂和节点失效的时候都能更加的无缝，并且节点的对称性防止了 HBase 中发现的那种在节点加入和删除时的暂时性的性能都懂（Cassandra 启动非常迅速，并且性能可以随着节点的加入而平滑扩展）。\u003c/p\u003e\n\n\u003cp\u003e如果你想寻找更多更多的证据，你会对一个原来一直关注 hadoop 的小组（应该对 HBase 更加偏爱）的报告很感兴趣……\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e一份报告胜过千言万语。\u003c/strong\u003e\u003cstrong\u003e我是指图表\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eYahoo！进行的第一个 NOSQL 系统的完整评测。研究似乎证实了 Cassandra 所享有的性能优势，从图表上看，非常倾向于 Cassandra。\u003c/p\u003e\n\n\u003cp\u003e目前这些论文还是草稿，你可以从这里找到这些论文：   \u003cbr /\u003e\u003ca href=\"http://www.brianfrankcooper.net/pubs/ycsb-v4.pdf\"\u003ehttp://www.brianfrankcooper.net/pubs/ycsb-v4.pdf\u003c/a\u003e     \u003cbr /\u003e\u003ca href=\"http://www.brianfrankcooper.net/pubs/ycsb.pdf\"\u003ehttp://www.brianfrankcooper.net/pubs/ycsb.pdf\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e注意：这份报告中 HBase 仅在对一个范围的记录进行扫描这一项上优于 Cassandra。虽然 Cassandra 团队相信他们可以很快达到 HBase 的时间，但还是值得指出，在通常的 Cassandra 配置中，区间扫描几乎是不可能的。我建议你可以无视这一点，因为实际上你应该在 Cassandra 上面来实现你自己的索引，而非使用区间扫描。如果你对区间扫描和在 Cassandra 中存储索引相关问题有兴趣，可以看我的\u003ca href=\"http://ria101.wordpress.com/2010/02/22/cassandra-randompartitioner-vs-orderpreservingpartitioner/\"\u003e这篇文章\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e最后一点： 这篇文章背后的 Yahoo！研究团队正尝试让它们的评测应用通过法律部门的评估，并将它发布给社区。如果他们成功的话，我当然希望他们成功，我们将能够看到一个持续的竞争场面，不论 HBase 还是 Cassandra 无疑都会进一步提高他们的性能。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e锁和有用的模块性\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e毫无疑问，你会从 HBase 阵营听到这样的声音：HBase 的复杂结构让它可以提供 Cassandra 的 P2P 架构无法提供的东西。其中一个例子可能就是 Hbase 提供给开发者行锁机制，而 Cassandra 则没有（在 HBase 中，因为数据副本发生在 hadoop 底层，行锁可以由 region server 控制，而在 Cassandra 的 P2P 架构中，所有节点都是平等的，所以也就没有节点可以像一个网管囊样负责锁定有副本的数据）。\u003c/p\u003e\n\n\u003cp\u003e不够，我还是把这个问题返回到关于模块化的争论中，这实际是对 Cassandra 有理的。Cassandra 通过在对称节点上分布式存储数据来实现了 BigTable 的数据模型。它完整地实现了这些功能，而且是以最灵活和高性能的方式实现的。但如果你需要锁、事务和其它功能的话，这些可以以模块的方式添加到你的系统之中——比如，我们发现我们可以使用 Zookeeper 和相关的工具来很简单地为我们的应用提供可扩展的锁功能（对于这个功能，Hazelcast 等系统可能也可以实现这个功能，虽然我们没有进行研究）。\u003c/p\u003e\n\n\u003cp\u003e通过为一个窄领域目的来最小化它的功能，对我来说，Cassandra 的设计达到了它的目的——比如前面指出可配置的 CAP 的折衷。这种模块性意味着你可以依据你的需求来构建一个系统——需要锁，那么拿来 Zookeeper，需要存储全文索引，拿来 \u003ca href=\"http://go2.wordpress.com/?id=725X1342\u0026amp;site=ria101.wordpress.com\u0026amp;url=http%3A%2F%2Fblog.sematext.com%2F2010%2F02%2F09%2Flucandra-a-cassandra-based-lucene-backend%2F\"\u003eLucandra\u003c/a\u003e ，等等。对于我们这样的开发者来说，这意味着我们不必部署复杂度超出我们实际需要的系统，给我们提供了更加灵活的构建我们需要的应用的终极道路。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003eMapReduce，别提 MapReduce！\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003eCassandra 做的还不够好的一件事情就是 MapReduce！对于不精通此项技术同学简单的解释一句，这是一个用于并行处理大量数据的系统，比如从上百万从网络上抓取的页面提取统计信息。MapReduce 和相关系统，比如 Pig 和 Hive 可以和 HBase 一起良好协作，因为它使用 HDFS 来存储数据，这些系统也是设计用来使用 HDFS 的。如果你需要进行这样的数据处理和分析的话，HBase 可能是你目前的最佳选择。\u003c/p\u003e\n\n\u003cp\u003e记住，这就像小马过河！\u003c/p\u003e\n\n\u003cp\u003e因此，我停止了对 Cassandra\u0026#160; 的优点的赞美，实际上，HBase 和 Cassandra 并不一定是一对完全的竞争对手。虽然它们常常可以用于同样的用途，和 MySQL 和 PostgreSQL 类似，我相信在将来它们将会成为不同应用的首选解决方案。比如，据我所知 StumbleUpon 使用了 HBase 和 hadoop MapReduce 技术，来处理其业务的大量数据。Twitter 现在使用 Cassandra 来存储实时交互的社区发言，可能你已经在某种程度上使用它了。\u003c/p\u003e\n\n\u003cp\u003e作为一个有争议的临别赠言，下面我们进入下一个话题。\u003c/p\u003e\n\n\u003cp\u003e注意：在继续下一个小节之前，我要指出，Cassandra 在 0.6 版本会有 hadoop 支持，所以 MapReduce 整合能获得更好的支持。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e兄弟，我不能失去数据...\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e作为先前 CAP 理论争议的一个可能结果，可能有这样的印象，HBase 的数据似乎比 Cassandra 中的数据更安全。这是我希望揭露的最后一个关于 Cassandra 的秘密，当你写入新数据的时候，它实际上立刻将它写入一个将要存储副本的仲裁节点的 commit log 当中了，也被复制到了节点们的内存中。这意味着如果你完全让你的集群掉电，只可能会损失极少数据。更进一步，在系统中，通过使用 Merkle tree 来组织数据的过分不一致（数据熵），更加增加了数据的安全性\u003cimg alt=\"：）\" src=\"/assets/icon_smile.gif\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e事实上，我对 HBase 的情况并不是非常确切——如果能有更细节的情况，我回尽快更新这里的内容的——但现在我的理解是，因为 hadoop 还不支持 append，HBase 不能有效地将修改的块信息刷入 HDFS （新的对数据变化会被复制为多个副本并永久化保存）。这意味着会有一个更大的缺口，你最新的更改是不可见的（如果我错了，可能是这样，请告诉我，我回修正本文）。\u003c/p\u003e\n\n\u003cp\u003e所以，尽管希腊神话中的 Cassandra 非常不幸（译注：Cassandra 是希腊神话里，特洛伊的那个可怜的女先知的名字，如果你不知道详情的话，可以参考wiki），但你的 Cassandra 中的数据不会有危险。\u003c/p\u003e\n\n\u003cp\u003e注意：Wade Amold 指出， hadoop .21 很快就会发布，其中将会解决 HBase 的这个问题。\u003c/p\u003e\n","cover":"","link":"translation/2010/03/25/hbase-vs-cassandra:-我们迁移系统的原因/index.html","preview":"","title":"HBase vs Cassandra: 我们迁移系统的原因"},{"content":"\n\u003cp\u003e一岁和两岁的对比，留此存照，希望斯屹大了也能看到这些照片，相似角度的：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/100_4793.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"100_4793\" border=\"0\" alt=\"100_4793\" src=\"/assets/100_4793_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0205.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0205\" border=\"0\" alt=\"IMG_0205\" src=\"/assets/IMG_0205_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e餐椅还是那张餐椅，虽然折旧明显了些。下面再来一些生日当天的照片:\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0191.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0191\" border=\"0\" alt=\"IMG_0191\" src=\"/assets/IMG_0191_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0206.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0206\" border=\"0\" alt=\"IMG_0206\" src=\"/assets/IMG_0206_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0208.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0208\" border=\"0\" alt=\"IMG_0208\" src=\"/assets/IMG_0208_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0214.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0214\" border=\"0\" alt=\"IMG_0214\" src=\"/assets/IMG_0214_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0224.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0224\" border=\"0\" alt=\"IMG_0224\" src=\"/assets/IMG_0224_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0217.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0217\" border=\"0\" alt=\"IMG_0217\" src=\"/assets/IMG_0217_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0221.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0221\" border=\"0\" alt=\"IMG_0221\" src=\"/assets/IMG_0221_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0233.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0233\" border=\"0\" alt=\"IMG_0233\" src=\"/assets/IMG_0233_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n","cover":"","link":"misc/2010/03/22/斯屹两岁照片集（多图杀猫）/index.html","preview":"","title":"斯屹两岁照片集（多图杀猫）"},{"content":"\n\u003cp\u003e今天，3月20日，是你的生日，爸爸祝你生日快乐！\u003c/p\u003e\n\n\u003cp\u003e很久不写儿子的博客了，两周前被这小子破相的时候就想写的，可是挺忙，一直没动笔，直到今天，通宵干活之后没什么睡意，想起到了斯屹的生日，还是写几句吧，没什么条理，想到哪写到哪，微博体，哈。\u003c/p\u003e\n\n\u003cp\u003e如今斯屹长大了好多，我和媳妇都有点想不通，那么点一个小家伙，怎么这么快就这么大了啊，呵呵，今天我和老婆差不多同时让各自的同事惊讶，都有个这么大的娃了。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0144.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0144\" border=\"0\" alt=\"IMG_0144\" src=\"/assets/IMG_0144_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0145.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0145\" border=\"0\" alt=\"IMG_0145\" src=\"/assets/IMG_0145_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2010/03/IMG_0146.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMG_0146\" border=\"0\" alt=\"IMG_0146\" src=\"/assets/IMG_0146_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e郑渊洁说的好啊，从儿子降生那天，我有了个新角色——父亲，没有儿子就没有老爸，所以，我应该感谢他，是斯屹让我的人生从此不同，也祝福他在以后的日子里能健康幸福。希望我们家庭的努力能让孩子幸福，希望我们这代人的努力，能让下一代人不必经历我们的很多痛苦，比如那个墙啥的……嗯，是啊，指着爸爸再挣钱给你买房娶媳妇是戏不大了，哈哈。\u003c/p\u003e\n\n\u003cp\u003e……真的语无伦次啊，刚才那阵外面风呼呼的，嗯，看来我其实是困了，儿子，早上起来再祝你生日快乐，爸爸先睡了。\u003c/p\u003e\n","cover":"","link":"misc/2010/03/20/生日快乐，斯屹！/index.html","preview":"","title":"生日快乐，斯屹！"},{"content":"\n\u003cp\u003e第三周了，手机的新鲜劲差不多过去了，主要写两方面——痛心疾首的最最让我痛苦的问题和一些软件的试用情况，还是那句话，不好用的地方也可能是我不会用，还请会用的同学帮忙指出。\u003c/p\u003e\n\n\u003cp\u003e先说问题：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e似乎触屏的定位精度和反应灵敏度随着使用会有下降，不知道和装的东西有没有关系，想点清楚一些东西似乎更费劲了，重新校准了一下，似乎有所好转，但似乎仍然没有刚拿到机器的水平，这个比较主观，不一定是真的这样，但作为体验感受也记下来吧。\u003c/li\u003e\n\n\u003cli\u003eO1e基本是不能装输入法的，这个输入法中缺少光标移动键，这样，在编辑表单输入的时候，尤其是 retweet 想加评语的时候，怎么也没办法把光标挪到开头去，真是痛不欲生啊。\u003c/li\u003e\n\n\u003cli\u003e自动横屏，浏览器的自动横屏功能很灵敏，但是，能不能方便地强制使用竖屏方式呢，躺着看的时候其实很希望它虽然横着，但竖屏显示啊。\u003c/li\u003e\n\n\u003cli\u003e短信息，似乎不能方便地在不保存入通讯录的情况下复制发信人地址，这样，我就很难用 10086999 举报垃圾短信了\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e就这些，欢迎有解决方案的同学回复解决方案。下面介绍下这两天试用的几个软件\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e闹钟 alarms，MM上的高价软件，15块钱。问题1：重启后需要运行alarms；问题2：需要定周日到周四，才能在周一到周五响（@!#@$!$@…..就是这样，我也不知道为啥），详见\u003ca href=\"http://wangxu.me/blog/?p=340\"\u003e我的blog\u003c/a\u003e。\u003c/li\u003e\n\n\u003cli\u003e闹钟klaxon （wakeme），功能还挺好用的，但经常弹出报错窗口，嗯，但似乎不影响使用。\u003c/li\u003e\n\n\u003cli\u003eaFile，文件共享工具，可以安装并打开，但我没用过。\u003c/li\u003e\n\n\u003cli\u003eshopsavvy，条码扫描软件，很好玩，不过我扫的条码它都搜不到……可以理解哈，老外的数据库里少有我们这些国产食品，呵呵。\u003c/li\u003e\n\n\u003cli\u003e名片全能王，嗯，照了照片可以用它ocr，识别率不错，但直接拍名片似乎没法读，可能是不会用的说。\u003c/li\u003e\n\n\u003cli\u003erootexplorer，文件浏览器，还不错\u003c/li\u003e\n\n\u003cli\u003erootbooter，软重启工具，功能还不错，界面丑了点，嗯\u003c/li\u003e\n\n\u003cli\u003eGPS status，搜星工具，能用，嗯\u003c/li\u003e\n\n\u003cli\u003etunewiki播放器，能用，不过我没耳机，没播放过啥东西\u003c/li\u003e\n\n\u003cli\u003e凯立德，打开地图就退出了，不知道是不是内存不足啥的，没见报错和日志输出\u003c/li\u003e\n\n\u003cli\u003esteel 浏览器，无法安装\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e差不多就这么多吧，这个星期再用用，回头下个星期就准备交给下一位同学试用了，这两天再找找看，有没有什么其他有趣的软件可以来尝试一下，没有找到好用的GTD工具和Terminal一直比较遗憾，当然，估计用这个输入法，就算有term，用起来也比较行为艺术。后面的同学还嗷嗷待哺，如果下次再有机会拿OPhone玩的话，考虑自己写个任务管理工具（抄个idea或直接port些源码）。\u003c/p\u003e\n","cover":"","link":"misc/2010/02/04/ophone体验第三周/index.html","preview":"","title":"OPhone体验第三周"},{"content":"\n\u003cp\u003e上周夸了一下MM上要价15块钱的昂贵的alarms（当然了，这个钱数其实不多，不过和MM上其他软件比比就知道，这个已经是天价了），然后它就罢工了一天，重启之后不干活了，当然，重启之后要重新运行也不是什么离谱的事，不过下面这个就离谱了——\u003c/p\u003e\n\n\u003cp\u003e要想让它周一到周五叫早，那就要设定它周日到周四工作；如果设置周一到周五工作，那么它就周二到周六叫。对，我是周六发现这个问题的，太匪夷所思了。以一位有超过10年linux使用经验的同学的思路进行判断，我认为，这一定是UTC的问题，我设的闹钟是7:30，嗯，格林威治时间看，还没到第二天呢……\u003c/p\u003e\n\n\u003cp\u003e嗯，各位路过打酱油的同学们，你们觉得呢？\u003c/p\u003e\n","cover":"","link":"misc/2010/02/02/ophone上好玩的闹钟alarms/index.html","preview":"","title":"OPhone上好玩的闹钟Alarms"},{"content":"\n\u003cp\u003eOPhone用到第二个星期了，呵呵，逐渐习惯了很多东西，也有很多问题逐渐被发现。总的说，我是一个比较习惯适应的人，不太爱挑刺，呵呵，这里也没有找麻烦的意思，想直接骂OPhone的同学，烦劳移步，不要在我这里留言了，呵呵，就算是不好，也说出个确切的问题来，这样才有利于改进嘛。\u003c/p\u003e\n\n\u003cp\u003e说说我适用的MM上和其他地方弄来的软件：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eroot file explore: 还挺好用的文件管理器\u003c/li\u003e\n\n\u003cli\u003ealarms: 从功能讲，我比较喜欢的闹钟，可以设置多个闹钟，自定义铃音、音量和振动，即使系统处于飞行模式或静音状态也能工作。就是太贵了，居然15块钱，是我在mm里看到的最贵的软件了。\u003c/li\u003e\n\n\u003cli\u003e摇甩切换程序：貌似挺好玩的，不过我觉得不太适合我，嗯\u003c/li\u003e\n\n\u003cli\u003e温度计：对于O1e来说，这个，不准\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，其他的系统自带的程序里，有些我明确地不满意，寻求替代品，还有些功能，希望找到软件，请听到的达人回话：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e邮件（上周说过），不能批量操作、不能筛选未读邮件，确实不方便\u003c/li\u003e\n\n\u003cli\u003e浏览器，上周说了些不足，下了个steel for android，不能安装……\u003c/li\u003e\n\n\u003cli\u003eterminal，十分期望有一个terminal，linux的东东都没有个terminal太不爽了\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e还有些系统使用问题\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e输入法：英文应该能选择大小写，另外，没有方向键导致很难将光标放在文本编辑框的最前端和最后端\u003c/li\u003e\n\n\u003cli\u003e短信：很难在不加为联系人的情况下选择复制发件人的号码，这样，向10086999投诉垃圾短信不容易啊\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，先这些吧，呵呵。\u003c/p\u003e\n","cover":"","link":"misc/2010/01/27/ophone第二周体验/index.html","preview":"","title":"OPhone第二周体验"},{"content":"\n\u003cp\u003e﻿accu=0;sed -ne 's/.*bytesIn=\\\"\\([0-9]*\\)\\\"\\/\u0026gt;/\\1/p' stage_3.xml |while read num;do cur=$(($num-$accu));accu=$num; echo $(($cur/20/1024/1024));done\u003c/p\u003e\n\n\u003cp\u003e记在这里了，先不解释了。\u003c/p\u003e\n","cover":"","link":"scripts/2010/01/20/一行的日志统计计算脚本/index.html","preview":"","title":"一行的日志统计计算脚本"},{"content":"\n\u003cp\u003e首先声明，我之前没用过Android手机，无法做出科学对比，无法准确比较二者，仅仅给出一些主观感受。\u003c/p\u003e\n\n\u003cp\u003e周二的时候，考完驾照回到单位，小郭将OPhone流转到我这里，我来继续做友好用户体验，作为新设备体验的爱好者和手机爱好者，我准备让它在我这多留些天，后面的同学对不起啦。\u003c/p\u003e\n\n\u003cp\u003e我之前用的手机是HTC Diamond （Windows Mobile），玩了两年多了，去年又给老婆买了个 Diamond 2 玩，呵呵，主要是已有的几款 Android 屏幕分辨率都比较低，呵呵，当时没选，不过这次看到手的 O1e，屏幕分辨率也没有 Diamond 高，不过也还看起来挺清晰的，呵呵，反思一下当时是不是应该买个 Android 手机来玩啊。\u003c/p\u003e\n\n\u003cp\u003e总的讲，我还挺喜欢这款手机的，有人反映不好用啥的，我倒也不觉得问题太大，唯一的比较大的问题估计也就是有时会漏接电话了，友情提醒——请开通来电提醒服务，这样，漏接电话之后可以得到短信提示。\u003c/p\u003e\n\n\u003cp\u003e和我的WM手机Diamond相比，对这款 OPhone 比较满意的包括\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e触摸屏反映不错（有人说屏硬，我没觉得啊），触摸屏反馈正常，虽然是电阻屏，但定位也挺精确，可能和没贴膜有关系\u003c/li\u003e\n\n\u003cli\u003e彩信效果不错，不论接受还是查看都不错，不存在收不下来的问题\u003c/li\u003e\n\n\u003cli\u003e相机效果不错，有LED补光，晚上拍了两张儿子的照片，色彩不错，应该是比Diamond好\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，说完满意的，说些细节方面具体的不满意的地方，也可能是我不会用，我是友好用户，没恶意，如果啥地方我说的不对的请指出，乐意学习：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e漏接电话问题\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e不知道是GPRS联网时还是连接PC时，或者其他某个条件下，这款手机会漏接电话，漏接时信号条件不差。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cli\u003e浏览器问题，总的来说还挺好的，有些细节上有不便的感觉，我不是这方面的专家，嗯，可能是我不会用，欢迎指出\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e浏览器地址栏编辑不便，不知道怎么编辑地址栏已有的地址\u003c/li\u003e\n\n\u003cli\u003e打开书签很不方便，需要四五次触屏才能展开书签，打开链接\u003c/li\u003e\n\n\u003cli\u003e切换多个标签窗口不方便，需要三次触屏才能切换\u003c/li\u003e\n\n\u003cli\u003e多行文本框显示成一个很小的文本框，不知道为啥\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cli\u003e输入法问题，个人觉得输入法其实还挺好用的，但是还是有个小问题\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e试试一下输入“不能”这两个字\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cli\u003e邮件程序问题，这个也可能是我不会用哈，当年mutt我也是用了很久才会用“t”的\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e不能批量选择操作，这个很不方便啊\u003c/li\u003e\n\n\u003cli\u003e不能全部标记或筛选啥的\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cli\u003e其他需求/问题\u003c/li\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e和outlook不能直接ActiveSync同步，这个其实还是很有用的\u003c/li\u003e\n\n\u003cli\u003e很多应用似乎过度追求“傻瓜化”了，反而不怎么方便，比如上面提到的那个邮件程序\u003c/li\u003e\n\n\u003cli\u003e不知道有没有可用、好用的GTD程序啊，缺省那个“待办事项”，标记任务为“完成”似乎还要打开编辑，显得很麻烦\u003c/li\u003e\n\n\u003cli\u003e有没有addinTimer一样好用的程序啊\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，活跃的开发和用户社区是一个平台生存的根本，众多的好的优秀软件和开发者，以及了与传播这些软件的活跃用户才会让社区更加繁荣，很多平台的不足实际是缺少或没用上好的第三方应用造成的，如果上面哪个问题是实际应该使用更好软件，请留言告诉我哈，我是新手，请多指教。\u003c/p\u003e\n","cover":"","link":"misc/2010/01/17/ophone使用一周体验/index.html","preview":"","title":"OPhone使用一周体验"},{"content":"\n\u003cp\u003e周六上午去驾校取回了驾照，嗯，持证了，于是，这个周末就开始上路吓人了，周六下午开车从天通苑到了知春路沃尔玛地库，之后老婆看不下去了，从沃尔玛回家没用我，之后她决定不再看我开车了，今天我独自一人开车去单位加班了。回来时候本来想尾随徐萌同学的，不过一不小心超过她了，后来不知道啥时候她又超过去不见了，一个人开车回家了……嗯，一路上估计吓了不少人，对不住大家了。\u003c/p\u003e\n\n\u003cp\u003e昨天披露了自己上路的新闻后，twitter上，不少人表达了关注\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003ecolyli @gnawux 你太猛了！！！！！！！！\u003c/p\u003e\n\n\u003cp\u003eypwong @gnawux 陪练还好，不是的话，你也太猛了\u003c/p\u003e\n\n\u003cp\u003emwei_ @gnawux 好远额.....果然厉害\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e嗯，还是同事说的直接\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e告诉我，你走哪条路，我绕着走\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e嗯……无论如何，新一代的马路杀手上路已经是不争的事实了，哈哈。\u003c/p\u003e\n","cover":"","link":"misc/2010/01/17/上路吓人啦/index.html","preview":"","title":"上路吓人啦"},{"content":"\n\u003cp\u003e前两天德国的一位专家宣布破解了GSM的加密算法，一时间引起了大家的广泛关注，我顺口说了一下\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e没那么严重，现网都没开加密功能，由于蜂窝网络的结构的原因，即使不开加密也很难随意监听某个特定号码的通话 RT @\u003ca href=\"http://twitter.com/turingbook\"\u003eturingbook\u003c/a\u003e: 熬夜搞了一条综述新闻：德安全专家破解GSM加密算法 几十亿手机受威胁 \u003ca href=\"http://tinyurl.com/yfxdedz\"\u003ehttp://tinyurl.com/yfxdedz\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e——\u003ca title=\"http://twitter.com/gnawux/status/7181314644\" href=\"http://twitter.com/gnawux/status/7181314644\"\u003ehttp://twitter.com/gnawux/status/7181314644\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e于是\u003ca href=\"http://twitter.com/turingbook\"\u003e刘江老师\u003c/a\u003e建议我写短文介绍一下，虽然曾经是学通信专业的，又在中国移动工作，但当时钻研得不深，如今的工作也和移动网络部分关系不算太密切，实在不太好意思提笔，这里就简单的说说我的理解，比我专业的同学很多，还请多指正吧。\u003c/p\u003e\n\n\u003cp\u003e所谓“蜂窝网络”，就是将地面划分成很小的小区（公里级别吧，依据需求调整），在每个小区里使用一个发送接收装置（也就是基站）和该小区的用户通信。这是现代移动通信网络的基础拓扑，因为它有这么两个基本的好处：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e频率资源的利用：无线信号传播的资源主要用这么几类——频段、时间、空间、功率。其中功率只有在各种CDMA中才有利用，为简单起见先不介绍，对于任意地点，同一时间、统一频点上的信息只能为同一组通信服务，但是通信基本是实时的，时间上不好做大文章，频率带宽上比较有限，只能分给少数用户。为了让更多的用户通信，如果在不同的地方重复使用相同的频率，那么，无线网络就可以容纳更多用户了。这也就是为什么小区越密，支持用户就越多的原因。\u003c/li\u003e\n\n\u003cli\u003e发射功率降低：因为每个小区覆盖范围小，所以，不论是基站还是和基站通信的手机，都不需要很高的发射功率，这对于基站周围的居民是一个福音，更重要的是，终端因此可以更小、辐射更低、更省电\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e正是这种结构上的特点，使得要监听一个用户的通信所需的一个基本条件——接收到他的信号变得有些困难，即，除非监听者和被监听者的位置很接近，否则很难接收到对方的信号，也就很难接收到对方的信息。\u003c/p\u003e\n\n\u003cp\u003e其次，一般移动网络中的终端并不经常地在网络上传递手机号码，事实上 GSM/WCDMA/TD-SCDMA 终端在移动网络中使用的标识是一个称为 IMSI 的(U)SIM卡的标识，而非手机号码，甚至这个 IMSI 也仅在手机开机的时候才会在空中传输，之后会使用一个称为 TMSI 的临时标识与网络沟通。并且，这个 TMSI 的使用频率也不高，只有在该用户发起通信的时候、用户移动了很大的幅度（位置区是很多个小区的覆盖范围，不是一个）、以及很长时间用户没有通信的时候，才会进行通信。而且，在用户不进行通信时，即使是网络都不很确定终端在哪个具体的小区之中，只能知道位置区。在这样的情况下，其实很难确定终端的位置、哪个是要找的终端。\u003c/p\u003e\n\n\u003cp\u003e对于GSM终端的鉴权和加密体系，是直接由网络中的鉴权中心和手机双方完成的，GSM 使用一个三元组（随机数、期望结果、密钥），WCDMA/TD-SCDMA 是五元组。随机数发送给终端，终端用 SIM卡中的 K3 算法算出来返回给网络，网络方与期望结果进行比对，如果一致，则终端合法，鉴权成功，用户可以接入终端，所谓克隆SIM卡，就是要把这个K3算法使用的存在SIM卡里的一个密钥搞出来。同时，网络送来的密钥，结合SIM卡里的密钥和卡中的K5算法，会生成一个用于加密通信的密钥，这个也就是上面新闻中说的被破解的加密算法。\u003c/p\u003e\n\n\u003cp\u003e事实上，对于大部分普通人来说，上面的那些困难已经让监听变得很困难了，除非监听者在很近的地方并且有效地获知用户的标识信息，才能展开破解，这实际已经有些困难了，进行有效监听的成本还是很高的。在这种背景下，很多移动网络根本就没有对通信进行加密，毕竟真的有权力的监听者实际上可以利用网络设备监听，根本不屑这种很麻烦又不很有效的监听方式的，各位担心的背着老婆和小三通话之类的信息，只要保存好自己的手机、处理好话费账单，还是不那么容易被老婆监听的。\u003c/p\u003e\n\n\u003cp\u003e当然，作为一种民用通信系统，不论是GSM还是CDMA 2000/ WCDMA/ TDSCDMA，被监听的可能性都是存在的，机密信息是无论如何不应该直接使用民用网络明文传输的。\u003c/p\u003e\n\n\u003cp\u003e嗯，简单的说，这个破解对人民群众生活影响不大，各个运营商情绪基本稳定。\u003c/p\u003e\n","cover":"","link":"misc/2010/01/07/写点关于移动网络和gsm安全的科普/index.html","preview":"","title":"写点关于移动网络和GSM安全的科普"},{"content":"\n\u003cp\u003e过节的短信勾起了我的重名之痛……谨以这些糗事恭祝大家新年快乐。\u003c/p\u003e\n\n\u003cp\u003e我叫王旭，嗯，各位谁不认识几个叫王旭的出门是不是都不好意思跟人打招呼啊，我就认识挺多——小时候去买酱菜，桂馨斋酱园子里有个女售货员叫王旭，初中的时候，值周，抓到个迟到的小孩叫王旭，高中似乎也有一个，大学学院团委书记叫王旭，等到工作了，单位有个网管叫王旭，所以很多人找我修机器，山东公司有个同事叫王旭，经常收到山东的呼叫中心相关邮件，集团财务部还有个叫王旭的，但chinamobile.com的邮送域的wangxu这个id是我的，所以，前连天他给我电话，让我删除一封机密邮件……\u003c/p\u003e\n\n\u003cp\u003e俗名的同学都有这个苦衷啊，但俗名的同学也会遇到俗名的同学，这次元旦，发过节短信，发给了我一个同事，但实际收到的是一个师弟——因为他们都叫刘阳，其实我还有另一个小学同学叫刘阳，以及一个本科同学叫刘扬……想必他们都和我差不多郁闷吧\u003c/p\u003e\n\n\u003cp\u003e回想起我儿子出生的时候，我发短信，结果一个同班同学回复说“恭喜师兄”我十分ft的同情他，认错人了，告诉他我是他一个班的，结果她（对，就是要换成女字旁的）非常肯定的确认，她是我隔壁组的师妹……是啊，是我搞错了……FML\u003c/p\u003e\n","cover":"","link":"misc/2010/01/01/重名啊……fml/index.html","preview":"","title":"重名啊……FML"},{"content":"\n\u003cp\u003e2009年就要不声不响的过去了，这实际上是乏善可陈的一年，对这一年最大的不舍莫过于希望能弥补一下这一年中的不足。但即使是这平庸的一年，仍有许多事情发生在了我身上和身边，而由于网络的发达，甚至是很多本来遥远的事情，也让我们感同身受，更让人增添了一些迷茫。\u003c/p\u003e\n\n\u003cp\u003e2010年，不知道是不是哪天就要忽然回到局域网中，可能再也无从访问互联网，理性与温和不是不作为也不是盲动，我尽力把控，首先控制自己的生活，再考虑更远的事情。很多事情并非我们可以左右，我们也只能作为一个参与者，发出一些声音或是做出一些微不足道的动作。\u003c/p\u003e\n\n\u003cp\u003e关于工作，在2009年底，实际上我已经开始了改进自己的工作方式，我希望2010年的努力能让我的职业生涯的道路变得更加清晰一些，希望到了明年的这个时候，我能有另一种对生活的留恋。\u003c/p\u003e\n\n\u003cp\u003e嗯，心情有点乱，不过还是记下这一刻的这些纠结吧，人生的第30个年头，我就要来了。为了我自己的快乐和梦想、为了孩子和家庭，我需要认真对待，不要浪费生命。\u003c/p\u003e\n","cover":"","link":"misc/2009/12/31/再见，2009/index.html","preview":"","title":"再见，2009"},{"content":"\n\u003cp\u003e在买车后的七个月，我终于走上科目二的考场啦，早上一到就被地上一个坎绊了一下，不过，凭借我不怎么好的协调能力还是站住了，哈哈，没摔，吉兆啊——逢凶化吉。\u003c/p\u003e\n\n\u003cp\u003e前面是自动挡爱丽舍，我是第一个C1桑塔纳，嗯，前面那个倒霉孩子在最后倒库就要成功的一刹那间，在库里把车开出了一边，结果折了，嗯，让我不免有点紧张。话说考的库似乎是比练的宽一点的，不知是不是这个原因，让我也在倒库环节出现了幻觉，看错了一根杆，差点回错了库，呃……挺吓人的啊……\u003c/p\u003e\n\n\u003cp\u003e然后是场内路，今天我赶上的坡起+定点停车是那个弯道上的上坡，出弯立刻上坡，在坡上停车，上坡的时候，松离合有点不够，差一点熄火，咬着牙轻抬离合，总算上来了，停得还算靠谱，至少考官没啥表示（呃……!$#@\u0026amp;^$%#@!，他要表示一下我就废了），结果，惊魂未定时，坡起又有停住不动的趋势，硬着头皮给了点油，终于过去了，呃，似乎这是我学车以来坡起+定点停车都很罕见的一次意外啊，还好当时不是太慌张，然后的侧方停车没什么意外，就这样，停进去之后下车了。\u003c/p\u003e\n\n\u003cp\u003e明年就要考科目三啦，然后就可以持证跟老婆抢车开啦，哈哈。\u003c/p\u003e\n","cover":"","link":"misc/2009/12/28/科目二考试通过啦/index.html","preview":"","title":"科目二考试通过啦"},{"content":"\n\u003cp\u003e感谢 @heavenmade1201 同学提供消息\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eRT @heavenmade1201 图书馆惊见Debian标准教程\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e呵呵，很高兴啊，图书馆都有这个了，说明又卖出去几本，哈哈。而且，@heavenmade1201 还在我的请求下，帮忙在公物上涂鸦，写上了书中示例代码的地址\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003ca title=\"https://code.google.com/p/unleashed-debian/\" href=\"https://code.google.com/p/unleashed-debian/\"\u003ehttps://code.google.com/p/unleashed-debian/\u003c/a\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e多谢学校里的同学们啦 :)\u003c/p\u003e\n","cover":"","link":"misc/2009/12/26/北邮图书馆惊现《debian标准教程》/index.html","preview":"","title":"北邮图书馆惊现《Debian标准教程》"},{"content":"\n\u003cp\u003e本文正在使用Live Writer写作，昨天从Twitter上发现Spaces访问不了了\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eRT \u003ca href=\"http://twitter.com/gfwrev\"\u003e@gfwrev\u003c/a\u003e: 从15:45起GFW开始部署对MSN Space 65.54.233.0/24段某些IP的路由封锁，目前范围还在扩大。 \u003ca href=\"https://twitter.com/search?q=%23GFW\"\u003e\u003cstrong\u003e#GFW\u003c/strong\u003e\u003c/a\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eSpaces对我来说，只是狡兔三窟之一，可是，moon mm正在用Spaces记录她腹中宝宝的成长过程，她还能继续么，她还能回忆么？小蔡同学正在用Spaces记录他追求梦想的征程，他是不是只有出国的时候才能再更新了呢？还有很多善良的朋友，也在失去他们自己的空间……我能袖手旁观，不帮助他们访问这些其实还存在的页面么？\u003c/p\u003e\n\n\u003cp\u003e当然，和菜头已经被封了，独立博客们的冬天可能也不会太远了，谁知道哪天我会失去自己的blog呢，谁知道哪天，我们就彻底进入一个噤声的局域网中呢？难道只有在我自己家的局域网里写blog才能留住这些足迹么？\u003c/p\u003e\n\n\u003cp\u003e你越是不留意它，忽视它，希望能与它井水不犯河水，它越是会侵犯我们的生活，就像这几天的敏感词，我们需要温和、理性，同样不能少了对话，沉默只会让我们的空间更加局促，更喘不过气来，在还有能力发声的时候，我们必须说出来——FuckGFW！\u003c/p\u003e\n","cover":"","link":"misc/2009/12/26/oh!-spaces/index.html","preview":"","title":"Oh! Spaces"},{"content":"\n\u003cp\u003e原文: \u003ca title=\"http://www.cloudera.com/blog/2009/12/15/observers-making-zookeeper-scale-even-further/\" href=\"http://www.cloudera.com/blog/2009/12/15/observers-making-zookeeper-scale-even-further/\"\u003ehttp://www.cloudera.com/blog/2009/12/15/observers-making-zookeeper-scale-even-further/\u003c/a\u003e     \u003cbr /\u003e\u003csmall\u003eTuesday, December 15th, 2009 at 10:30 am by Henry Robinson\u003c/small\u003e     \u003cbr /\u003e译文: 王旭（\u003ca href=\"http://wangxu.me\"\u003ehttp://wangxu.me\u003c/a\u003e, \u003ca href=\"http://twitter.com/gnawux\"\u003e@gnawux\u003c/a\u003e）2009年12月16,21日\u003c/p\u003e\n\n\u003cp\u003e看过我们\u003ca href=\"http://www.cloudera.com/blog/2009/05/28/building-a-distributed-concurrent-queue-with-apache-zookeeper/\"\u003e之前相关文章\u003c/a\u003e的读者都知道，\u003ca href=\"http://hadoop.apache.org/zookeeper/\"\u003eZooKeeper\u003c/a\u003e是一个分布式协作服务，用于实现锁和并发事务排队等协作原语。ZooKeeper 的一个优势是可伸缩性（Scalability）。五台或七台机器集群可以满足很多大型应用的需求。\u003c/p\u003e\n\n\u003cp\u003e最近我们给ZooKeeper增加了一个新的特性，进一步增强了它可伸缩性——一种新的称为 Observers 的服务器。在这篇文章中，我想要介绍一下添加这个特征的动机，并解释这个服务器如何帮助我们的系统更具有可伸缩性。可伸缩性对不同的人意味着不同的事情，而在这里是说，如果我们的工作负载可以通过给系统分配更多的资源来分担，那么这个系统就是可伸缩的；一个不可伸缩的系统却无法通过增加资源来提升性能，甚至会在工作负载增加时，性能急剧下降。\u003c/p\u003e\n\n\u003cp\u003e要了解 Observers 为何能影响 ZooKeeper 的可伸缩性，我们需要首先了解一下这个服务时如何工作的。宽泛地说，ZooKeeper 集群上的任何操作不是读操作就是写操作。ZooKeeper 确保所有读和写操作在所有客户端看来，都具有完全相同的顺序，这样他们就不会为操作的顺序而疑惑了。\u003c/p\u003e\n\n\u003cp\u003e在提供强一致性保障的同时，ZooKeeper同时给出高可用性承诺，这可以被简单地解释为它可以在多台服务器失效的情况下仍然为客户端提供服务。ZooKeeper使用一个传统的手段来达到可用性——通过将数据读写分布到几台机器上来实现，这样如果一台失效了，其它的可以接管它的服务，而无需让客户端更聪明。\u003c/p\u003e\n\n\u003cp\u003e然而，一致性和可用性这两个属性是很难同时达到的，目前，ZooKeeper 必须确保集群中的每个副本都对读写操作是顺序性的。它通过一个一致性协议来达到这一目标。简单地说，这个协议由一个选定的领导者将新操作高速其他服务器，所有节点投票支持并反馈给领导。一旦领导节点收集到过半数的投票，它就认为投票已经获得了通过，并将进一步消息传送给服务器们，以使他们可以继续工作，将操作提交到内存中。\u003c/p\u003e\n\n\u003cp\u003e这个从始至终的数据流如下图所示。客户进程将一个值提交给它连接的服务器。服务器将消息转送给领导节点，它发起这个一致性协议，一旦最初的服务器从领导节点得到结果，它就可以返回给用户了。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg title=\"Simplified flow of a ZooKeeper write request\" alt=\"Simplified flow of a ZooKeeper write request\" src=\"/assets/zk-flow.png\" width=\"560\" height=\"755\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e图1：简化的写请求工作流\u003c/p\u003e\n\n\u003cp\u003eObservers 的需求源于 ZooKeeper 服务器在上述协议中实际扮演了两个角色。它们从客户端接受连接与操作请求，之后对操作结果进行投票。这两个职能在 ZooKeeper集群扩展的时候彼此制约。如果我们希望增加 ZooKeeper 集群服务的客户数量（我们经常考虑到有上万个客户端的情况），那么我们必须增加服务器的数量，来支持这么多的客户端。然而，从一致性协议的描述可以看到，增加服务器的数量增加了对协议的投票部分的压力。领导节点必须等待集群中过半数的服务器响应投票。于是，节点的增加使得部分计算机运行较慢，从而拖慢整个投票过程的可能性也随之提高，投票操作的会随之下降。这正是我们在实际操作中看到的问题——随着 ZooKeeper 集群变大，投票操作的吞吐量会下降。\u003c/p\u003e\n\n\u003cp\u003e所以，这让我们不得不在增加客户节点数量的期望和我们希望保持较好吞吐性能的期望间进行权衡。要打破这一耦合关系，我们引入了不参与投票的服务器，称为 Observers。 Observers 可以接受客户端的连接，将写请求转发给领导节点。但是，领导节点不会要求 Observers 参加投票。相反，Observers 不参与投票过程，仅仅在上述第3歩那样，和其他服务节点一起得到投票结果。\u003c/p\u003e\n\n\u003cp\u003e这个简单的扩展给 ZooKeeper 的可伸缩性带来了全新的镜像。我们现在可以加入很多 Observers 节点，而无须担心严重影响写吞吐量。规模伸缩并非无懈可击——协议中的一歩（通知阶段）仍然与服务器的数量呈线性关系。但是，这里的穿行开销非常低。我们可以认为在通知服务器阶段的开销无法成为主要瓶颈。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg title=\"Observers Write Throughput Benchmark\" alt=\"Observers Write Throughput Benchmark\" src=\"/assets/observers-sync-benchmark.png\" width=\"414\" height=\"278\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e图2: Observers 写吞吐量 Benchmark\u003c/p\u003e\n\n\u003cp\u003e图2 显示了一个简单评测的结果。纵轴是我能够从一个单一的客户端发出的每秒钟同步写操作的数量（一个调优的 ZooKeeper 可以得到更好的每秒钟操作数——这里我们更感兴趣的是相对值）。横轴是 ZooKeeper 集群的尺寸。蓝色的是每个服务器都是 voting 服务器的情况，而绿色的则只有三个是 voting 服务器，其它都是 Observers。图中显示，我们扩充 Observers，写性能几乎可以保持不便，但如果同时扩展 voting 节点的数量的话，性能会明显下降。显然 Observers 是有效的。\u003c/p\u003e\n\n\u003ch4\u003eObservers 同样提升读性能的可伸缩性\u003c/h4\u003e\n\n\u003cp\u003e增加客户端的数量是 Observers 的一个重要用例，但是实际上它们还给集群带来很多其它的好处。\u003c/p\u003e\n\n\u003cp\u003e作为一个优化，ZooKeeper 服务器可以直接读取它们的本地数据存储，而无需经过投票过程，这面临一定的“时光旅行”风险，可能在读到新值之后又读到老值，但这只在服务器故障时才会发生。事实上，在这种情况下客户端可以请求一个 ‘sync’ 操作来保证下一个值是最新的。\u003c/p\u003e\n\n\u003cp\u003e因此，在大量读操作的工作负载下，Observers 是个巨大的性能提升。写操作直接进入标准的投票路径，这样，与客户端可扩展性类似，提高投票服务器数量来承担读操作会影响写性能。Observers 允许我们将读性能和写性能分开。这适用于 ZooKeeper 的很多应用场景，大部分客户端很少写，但经常读。\u003c/p\u003e\n\n\u003ch4\u003eObservers 提供了广域网能力\u003c/h4\u003e\n\n\u003cp\u003eObservers 还能做更多。Observers 对于跨广域网连接的客户端来说是很好的候选方案。这有三个原因。为了获得很好的读性能，有必要让客户端离服务器尽量近，这样往返时延不会太高。然而，将 ZooKeeper 集群分散到两个集群是非常不可取的设计，因为良好配置的 ZooKeeper 应该让投票服务器间用低时延连接互联——否则我们将会遇到上面提到的低反映速度的问题。\u003c/p\u003e\n\n\u003cp\u003e而 Observers 可以被部署在需要访问 ZooKeeper 的任意数据中心中。这样，投票协议不会受到数据中心间链路的高时延的影响，性能得到提升。投票过程中 Observers 和领导节点间的消息远少于投票服务器和领导节点间的消息。这有助于在远程数据中心高写负载的情况下降低带宽需求。\u003c/p\u003e\n\n\u003cp\u003e最后，由于Observers即使失效也不会影响到投票集群，这样如果数据中心间链路发生故障，不会影响到服务本身的可用性。这种故障的发生概率要远高于一个数据中心中机架间的连接的故障概率，所以不依赖于这种链路是个优点。\u003c/p\u003e\n\n\u003ch4\u003e如何开始使用 Observers\u003c/h4\u003e\n\n\u003cp\u003eObservers 还没有成为某个 ZooKeeper release 的一部分，所以要使用它，你需要从 \u003ca href=\"http://hadoop.apache.org/zookeeper/version_control.html\"\u003eSubversion trunk\u003c/a\u003e 获取源代码。\u003c/p\u003e\n\n\u003cp\u003e下面的内容提取自 Observers 用户手册，可以在源代码的 \u003ccode\u003edocs/zooKeeperObservers.html\u003c/code\u003e 文件中看到。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003ch5\u003e如何使用 Observers\u003c/h5\u003e\n\n\u003cp\u003e注意，在ZOOKEEPER-578 解决之前，你必须在每个服务器的配置文件中设置 electionAlg=0 。否则当你启动服务的时候会抛出一个异常。\u003c/p\u003e\n\n\u003cp\u003e原因：因为 Observers 并不参与领导节点的选举，它们依赖于投票 Followers 来获知领导的变动。目前，只有基本选举算法启动一个线程来响应 Observers 确定当前领导的请求。其他 JIRA 上的工作将会让其他所有的领导选举协议都支持这一功能。\u003c/p\u003e\n\n\u003cp\u003e设置 ZooKeeper 使用 Observers 非常简单，只需要在配置文件中有两处改动。首先是每个 Observer 的配置文件中都要有这么一行：\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003epeerType=observer\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e这行让服务器作为一个 Observer 来工作。之后，在每个服务器配置文件中，你必须在服务器定义行给每个 Observer 加入 :observer\u0026#160; 。比如：\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003eserver.1:localhost:2181:3181:observer\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e这让每个其他服务器知道 server.1 是一个 Observer，就不会期望它进行投票了。这就是要加入一个 Observer 的时候，所有你需要做的配置。现在可以将它作为一个正常的 Follower 来看待了。可以这么试试：\u003c/p\u003e\n\n\u003cp\u003e\u003ccode\u003ebin/zkCli.sh -server localhost:2181\u003c/code\u003e\u003c/p\u003e\n\n\u003cp\u003e这里 localhost:2181 是 Observer 在每个配置文件中指定的主机名和端口号。你应该看到命令行提示了，这时就可以查询 Zookeeper 服务了。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003ch4\u003e下一步工作\u003c/h4\u003e\n\n\u003cp\u003eObservers 特性还有很多工作要做。短期内，我们将致力于让 Observers 与 ZooKeeper 中的所有领导选举算法完全兼容 —— 我们希望这个可以在未来几天内完成。长期看，我们希望能研究一下进行性能优化，比如基于 Observers 的集群的批量和离线读取，来更好的利用 Observers 不像一般 ZooKeeper 服务器一样严格要求时延的好处。\u003c/p\u003e\n\n\u003cp\u003e我们希望 Observers 能进入明年年初的 ZooKeeper 3.3.0。我们会很高兴能听到你的反馈，不管是在\u003ca href=\"http://hadoop.apache.org/zookeeper/mailing_lists.html\"\u003e邮件列表\u003c/a\u003e里还是\u003ca href=\"mailto:henry@cloudera.com\"\u003e直接发送email\u003c/a\u003e。ZooKeeper 长期招募贡献者，我们有足够多的有趣的问题来解决，所以，如果你想加入的话请联系我，我回很高兴能帮你开始的。\u003c/p\u003e\u003c/p\u003e\n\n\u003cp\u003e \u003cfont color=\"#4d4d4d\"\u003e\u003c/font\u003e\u003c/p\u003e\n","cover":"","link":"translation/2009/12/22/zookeeper-observers/index.html","preview":"","title":"[译文] Observers: 让ZooKeeper更具可伸缩性"},{"content":"\n\u003cp\u003e今年4月，我在刚刚知道于mm怀孕的时候就发了\u003ca href=\"http://wangxu.me/blog/?p=10\" target=\"_blank\"\u003e一篇文章\u003c/a\u003e来恭喜\u003ca href=\"http://www.fishnini.com/\" target=\"_blank\"\u003e胡铮和于静潇夫妇\u003c/a\u003e，今天，胡宇昕小朋友终于在大家的期望中平安出生了，祝他健康成长 :)\u003c/p\u003e\n","cover":"","link":"misc/2009/12/21/胡宇昕小朋友出生啦/index.html","preview":"","title":"胡宇昕小朋友出生啦"},{"content":"\n\u003cp\u003e早有此意，但今天做发放这个动作主要是源于内疚，由于我自己对出版过程关注不够，有很多示例的排版有严重问题，给阅读带来极大不便，因此，这里给出示例全部代码，并且，今后会进一步给出更多的信息。\u003c/p\u003e\n\n\u003cp\u003e代码放在Google Code\u003c/p\u003e\n\n\u003cp\u003e\u003ca title=\"https://code.google.com/p/unleashed-debian/\" href=\"https://code.google.com/p/unleashed-debian/\"\u003ehttps://code.google.com/p/unleashed-debian/\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e在此向大家致歉。\u003c/p\u003e\n","cover":"","link":"works/2009/12/21/发放《debian标准教程》示例源代码/index.html","preview":"","title":"发放《Debian标准教程》示例源代码"},{"content":"\n\u003cp\u003e上一篇blog刚刚同时贴到了 \u003ca href=\"http://wangxu.me/blog/?p=309\" target=\"_blank\"\u003ewangxu.me\u003c/a\u003e 和 \u003ca href=\"http://labs.chinamobile.com/mblog/225_35050\" target=\"_blank\"\u003elabs\u003c/a\u003e，不过眼见着 labs blog 访问量已经上 10 万了，虽然自己的独立博客看起来更漂亮一些吧，还是立此存照吧，呵呵\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/12/over_100k.png\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"over_100k\" border=\"0\" alt=\"over_100k\" src=\"/assets/over_100k_thumb.png\" width=\"161\" height=\"244\" /\u003e\u003c/a\u003e\u003c/p\u003e\n","cover":"","link":"misc/2009/12/20/似乎还是labs博客访问量高啊/index.html","preview":"","title":"似乎还是labs博客访问量高啊"},{"content":"\n\u003cp\u003e原文: \u003ca title=\"http://natishalom.typepad.com/nati_shaloms_blog/2009/12/the-common-principles-behind-the-nosql-alternatives.html\" href=\"http://natishalom.typepad.com/nati_shaloms_blog/2009/12/the-common-principles-behind-the-nosql-alternatives.html\"\u003ehttp://natishalom.typepad.com/nati_shaloms_blog/2009/12/the-common-principles-behind-the-nosql-alternatives.html\u003c/a\u003e     \u003cbr /\u003ePosted by Nati Shalom at 12:01 PM Dec 15, 2009     \u003cbr /\u003e译文: 王旭（\u003ca href=\"http://wangxu.me\"\u003ehttp://wangxu.me\u003c/a\u003e , \u003ca href=\"http://twitter.com/gnawux\" target=\"_blank\"\u003e@gnawux\u003c/a\u003e）2009年12月16/19日\u003c/p\u003e\n\n\u003cp\u003e几个星期之前，我写了一篇文章描述了常被称作 NOSQL 的一类新型数据库的背后驱动。几个星期之前，我在Qcon上发表了一个演讲，其中，我介绍了一个可伸缩（scalable）的 twitter 应用的构建模式，在我们的讨论中，一个显而易见的问题就是数据库的可扩展性问题。要解答这个问题，我试图寻找隐藏在各种 NOSQL 之后的共有模式，并展示他们是如何解决数据库可扩展性问题的。在本文中，我将尽力勾勒出这些共有的原则。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://notonlysql.com\" target=\"_blank\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"nosql\" border=\"0\" alt=\"nosql\" src=\"/assets/nosql.png\" width=\"238\" height=\"165\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003ch4\u003e实现们的共有原则\u003c/h4\u003e\n\n\u003ch5\u003e假设失效是必然发生的 \u003c/h5\u003e\n\n\u003cp\u003e与我们先前通过昂贵硬件之类的手段尽力去避免失效的手段不同，NOSQL实现都建立在硬盘、机器和网络都会失效这些假设之上。我们需要认定，我们不能彻底阻止这些时效，相反，我们需要让我们的系统能够在即使非常极端的条件下也能应付这些失效。Amazon S3 就是这种设计的一个好例子。你可以在我最近的文章 \u003ca href=\"http://natishalom.typepad.com/nati_shaloms_blog/2009/11/why-existing-databases-rac-are-so-breakable.html\"\u003eWhy Existing Databases (RAC) are So Breakable!\u003c/a\u003e 中找到进一步描述。哪里，我介绍了一些来自 \u003ca href=\"http://qconsf.com/sf2009/speaker/Jason+McHugh\"\u003eJason McHugh\u003c/a\u003e 的讲演的面向失效的架构设计的内容（Jason 是在 Amazon 做 S3 相关工作的高级工程师）。\u003c/p\u003e\n\n\u003ch5\u003e对数据进行分区 \u003c/h5\u003e\n\n\u003cp\u003e通过对数据进行分区，我们最小化了失效带来的影响，也将读写操作的负载分布到了不同的机器上。如果一个节点失效了，只有该节点上存储的数据受到影响，而不是全部数据。\u003c/p\u003e\n\n\u003ch5\u003e保存同一数据的多个副本\u003c/h5\u003e\n\n\u003cp\u003e大部分 NOSQL 实现都基于数据副本的热备份来保证连续的高可用性。一些实现提供了 API，可以控制副本的复制，也就是说，当你存储一个对象的时候，你可以在对象级指定你希望保存的副本数。在 GigaSpaces，我们还可以立即复制一个新的副本到其他节点，甚至在必要时启动一台新机器。这让我们不比在每个节点上保存太多的数据副本，从而降低总存储量以节约成本。\u003c/p\u003e\n\n\u003cp\u003e你还可以控制副本复制是同步还是异步的，或者两者兼有。这决定了你的集群的一致性、可用性与性能三者。对于同步复制，可以牺牲性能保障一致性和可用性（写操作之后的任意读操作都可以保证得到相同版本的数据，即使是发生失效也会如此）。而最为常见的 GigaSpaces 的配置是同步副本到被分界点，异步存储到后端存储。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e动态伸缩\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e要掌控不断增长的数据，大部分 NOSQL 实现提供了不停机或完全重新分区的扩展集群的方法。一个已知的处理这个问题的算法称为一致哈希。有很多种不同算法可以实现一致哈希。\u003c/p\u003e\n\n\u003cp\u003e一个算法会在节点加入或失效时通知某一分区的邻居。仅有这些节点受到这一变化的影响，而不是整个集群。有一个协议用于掌控需要在原有集群和新节点之间重新分布的数据的变换区间。\u003c/p\u003e\n\n\u003cp\u003e另一个（简单很多）的算法使用逻辑分区。在逻辑分区中，分区的数量是固定的，但分区在机器上的分布式动态的。于是，例如有两台机器和1000个逻辑分区，那么每500个逻辑分区会放在一台机器上。当我们加入了第三台机器的时候，就成了每 333 个分区放在一台机器上了。因为逻辑分区是轻量级的（基于内存中的哈希表），分布这些逻辑分区非常容易。\u003c/p\u003e\n\n\u003cp\u003e第二种方法的优势在于它是可预测并且一致的，而使用一致哈希方法，分区之间的重新分布可能并不平稳，当一个新节点加入网络时可能会消耗更长时间。一个用户在这时寻找正在转移的数据会得到一个异常。逻辑分区方法的缺点是可伸缩性受限于逻辑分区的数量。\u003c/p\u003e\n\n\u003cp\u003e更进一步的关于这一问题的讨论，建议阅读 \u003ca href=\"http://www.blogger.com/profile/03793674536997651667\"\u003eRicky Ho\u003c/a\u003e 的文章 \u003ca href=\"http://horicky.blogspot.com/2009/11/nosql-patterns.html%20\"\u003eNOSQL Patterns\u003c/a\u003e 。\u003c/p\u003e\n\n\u003ch5\u003e查询支持\u003c/h5\u003e\n\n\u003cp\u003e在这个方面，不同的实现有相当本质的区别。不同实现的一个共性在于哈希表中的 key/value 匹配。一些市县提供了更高级的查询支持，比如面向文档的方法，其中数据以 blob 的方式存储，关联一个键值对属性列表。这种模型是一种无预定义结构的（schema-less）存储，给一个文档增加或删除属性非常容易，无需考虑文档结构的演进。而 GigaSpaces 支持很多 SQL 操作。如果 SQL查询没有指出特定的简直，那么这个查询就会被并行地 map 到所有的节点去，由客户端完成结果的汇聚。所有这些都是发生在幕后的，用户代码无需关注这些。\u003c/p\u003e\n\n\u003ch5\u003e使用 Map/Reduce 处理汇聚\u003c/h5\u003e\n\n\u003cp\u003eMap/Reduce 是一个经常被用来进行复杂分析的模型，经常会和 Hadoop 联系在一起。 map/reduce 常常被看作是并行汇聚查询的一个模式。大部分 NOSQL 实现并不提供 map/reduce 的内建支持，需要一个外部的框架来处理这些查询。对于 GigaSpaces 来说，我们在 SQL 查询中隐含了对 map/reduce 的支持，同时也显式地提供了一个称为 executors 的 API 来支持 map/reduce。在质疑模型中，你可以将代码发送到数据所在地地方，并在该节点上直接运行复杂的查询。\u003c/p\u003e\n\n\u003cp\u003e这方面的更多细节，建议阅读 \u003ca href=\"http://www.blogger.com/profile/03793674536997651667\"\u003eRicky Ho\u003c/a\u003e 的文章 \u003ca href=\"http://horicky.blogspot.com/2009/11/query-processing-for-nosql-db.html\"\u003eQuery Processing for NOSQL DB\u003c/a\u003e 。\u003c/p\u003e\n\n\u003ch4\u003e基于磁盘的和内存中的实现 \u003c/h4\u003e\n\n\u003cp\u003eNOSQL 实现分为基于文件的方法和内存中的方法。有些实现提供了混合模型，将内存和磁盘结合使用。两类方法的最主要区别在于每 GB 成本和读写性能。\u003c/p\u003e\n\n\u003cp\u003e最近，斯坦福的一项称为“The Case for RAMCloud”的调查，对磁盘和内存两种方法给出了一些性能和成本方面的有趣的比较。总体上说，成本也是性能的一个函数。对于较低性能的实现，磁盘方案的成本远低于基于内存的方法，而对于高性能需求的场合，内存方案则更加廉价。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cem\u003e内存云的显而易见的缺点就是单位容量的高成本和高能耗。对于这些指标，内存云会比纯粹的磁盘系统差50到100倍，比使用闪存的系统差5-10倍（典型配置情况和指标参见参考文献[1]）。内存云同时还比基于磁盘和闪存的系统需要更多的机房面积。这样，如果一个应用需要存储大量的廉价数据，不需要高速访问，那么，内存云将不是最佳选择。        \u003cbr /\u003e\u003c/em\u003e然而，对于高吞吐量需求的应用，内存云将更有竞争力。\u003cstrong\u003e当使用每次操作的成本和能量作为衡量因素的时候，内存云的效率是传统硬盘系统的 100 到 1000 倍，是闪存系统的 5-10 倍。因此，对于高吞吐量需求的系统来说，内存云不仅提供了高性能，也提供了高能源效率。同时，如果使用 DRAM 芯片提供的低功耗模式，也可以降低内存云的功耗，特别是在系统空闲的时候。\u003c/strong\u003e此外，内存云还有一些缺点，一些内存云无法支持需要将数据在多个数据中心之间进行数据复制。对于这些环境，更新的时延将主要取决于数据中心间数据传输的时间消耗，这就丧失了内存云的时延方面的优势。此外，跨数据中心的数据复制会让内存云数据一致性更能难保证。不过，内存云仍然可以在夸数据中心的情况下提供低时延的读访问。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003ch5\u003e仅仅是炒作?\u003c/h5\u003e\n\n\u003cp\u003e近来我见到的最多的问题就是 “NOSQL 是不是就是炒作？” 或 “NOSQL 会不会取代现在的数据库？”\u003c/p\u003e\n\n\u003cp\u003e我的回答是——NOSQL 并非始于今日。很多 NOSQL 实现都已经存在了十多年了，有很多成功案例。我相信有很多原因让它们在如今比以往更受欢迎了。首先是由于社会化网络和云计算的发展，一些原先只有很高端的组织才会面临的问题，如今已经成为普遍问题了。其次，已有的方法已经被发现无法跟随需求一起扩展了。并且，成本的压力让很多组织需要去寻找更高性价比的方案，并且研究证实基于普通廉价硬件的分布式存储解决方案甚至比现在的高端数据库更加可靠。（\u003ca href=\"http://natishalom.typepad.com/nati_shaloms_blog/2009/11/why-existing-databases-rac-are-so-breakable.html\" target=\"_blank\"\u003e进一步阅读\u003c/a\u003e）所有这些导致了对这类“可伸缩性优先数据库”的需求。这里，我引用 AWS团队的接触工程师、VP， \u003ca href=\"http://mvdirona.com/jrh/work/\"\u003eJames Hamilton\u003c/a\u003e 在他的文章 \u003ca href=\"http://perspectives.mvdirona.com/2009/11/03/OneSizeDoesNotFitAll.aspx\"\u003eOne Size Does Not Fit Al\u003c/a\u003el 中的一段话：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e“伸缩性优先应用是那些必须具备无限可伸缩性的应用，能够不受限制的扩展比更丰富的功能更加重要。这些应用包括很多需要高可伸缩性的网站，如 Facebook, MySpace, Gmail, Yahoo 以及 Amazon.com。有些站点实际上使用了关系型数据库，而大部分实际上并未使用。这些服务的共性在于可扩展性比功能公众要，他们无法泡在一个单一的 RDBMS 上。”\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e总结一下——我认为，现有的 SQL 数据库可能不会很快淡出历史舞台，但同时它们也不能解决世上的所有问题。NOSQL 这个名词现在也变成了 Not Only SQL，这个变化表达了我的观点。\u003c/p\u003e\n\n\u003ch4\u003e参考：\u003c/h4\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003ca href=\"http://natishalom.typepad.com/nati_shaloms_blog/2009/07/no-to-sql-anti-database-movement-gains-steam-my-take.html\"\u003eNo to SQL? Anti-database movement gains steam – My Take\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://natishalom.typepad.com/nati_shaloms_blog/2009/11/why-existing-databases-rac-are-so-breakable.html\"\u003eWhy Existing Databases (RAC) are So Breakable!\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://www.rackspacecloud.com/blog/2009/11/09/nosql-ecosystem/\"\u003eNoSQL Ecosystem\u003c/a\u003e By \u003ca href=\"http://twitter.com/spyced\"\u003eJonathan Ellis\u003c/a\u003e, \u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://www.linux-mag.com/cache/7579/1.html\"\u003eNoSQL: Distributed and Scalable Non-Relational Database Systems\u003c/a\u003e by \u003ca href=\"http://www.linkedin.com/in/jzawodn\"\u003eJeremy Zawodny\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://horicky.blogspot.com/2009/11/nosql-patterns.html\"\u003eNOSQL Patterns\u003c/a\u003e by \u003ca href=\"http://www.blogger.com/profile/03793674536997651667\"\u003eRicky Ho\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://horicky.blogspot.com/2009/11/query-processing-for-nosql-db.html\"\u003eQuery Processing for NOSQL DB\u003c/a\u003e by \u003ca href=\"http://www.blogger.com/profile/03793674536997651667\"\u003eRicky Ho\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://perspectives.mvdirona.com/2009/11/03/OneSizeDoesNotFitAll.aspx\"\u003eOne Size Does Not Fit Al\u003c/a\u003el\u0026#160; by \u003ca href=\"http://mvdirona.com/jrh/work/\"\u003eJames Hamilton\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://blog.oskarsson.nu/2009/06/nosql-debrief.html\"\u003eNOSQL debrief\u003c/a\u003e by \u003ca href=\"http://www.linkedin.com/in/johanoskarsson\"\u003eJohan Oskarsson\u003c/a\u003e, \u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://www.stanford.edu/%7Eouster/cgi-bin/papers/ramcloud.pdf\"\u003eThe Case for RAMClouds: Scalable High-Performance Storage Entirely in DRAM\u003c/a\u003e by Department of Computer Science Stanford University \u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://www.gigaspaces.com/wiki/display/XAP7/Task+Execution+over+the+Space\"\u003eGigaSpaces Map/Reduce API\u003c/a\u003e\u003c/li\u003e\n\n\u003c/ul\u003e\n","cover":"","link":"translation/2009/12/20/[译文]-nosql们背后的共有原则/index.html","preview":"","title":"[译文] NOSQL们背后的共有原则"},{"content":"\n\u003cp\u003e大概是从给公盟捐款开始注意到\u003ca href=\"http://www.geekcook.net/\"\u003eGeekCook\u003c/a\u003e的，那时他们似乎有一个捐款满50给优惠的活动，不过那个活动我没有参加，因为觉得捐款和优惠没什么关系，不过也因为这件事记住了这个网站/商店。\u003c/p\u003e\n\n\u003cp\u003e这次在twitter上看到这个《\u003ca href=\"http://www.geekcook.net/?page_id=1083\"\u003e我的杯具仅10元\u003c/a\u003e》这个活动，终于还是心动了，还是写几行字，换个杯具吧，摆在办公室桌上应该还挺招摇的吧，呵呵。社会化网络/社会化媒体/Web 2.0这些说不清是不是一样的东西的特点就在于个性化和长尾，类似GeekCook这样的个性化的商品配上个性化的营销手段真的是一个绝配。\u003c/p\u003e\n\n\u003cp\u003e今天，@youthfilm 的 twitbook/twitcafe 也上架了，价格比 GeekCook 的高很多，但也更精美，有点担心 GeekCook 的盈利问题，不知道他们仅通过社会化营销是否有足够大的市场来维持运作，或者，仅仅就是一个爱好呢。不过不论如何，twitter 上的脸熟的卖家们先给自己挣了一份人气和口碑，也算是社会化营销的一点好处吧。\u003c/p\u003e\n","cover":"","link":"misc/2009/12/14/从geekcook订一个自己的杯具/index.html","preview":"","title":"从GeekCook订一个自己的杯具"},{"content":"\n\u003cp\u003e何谓新媒体，这个不好说，不过，我这里实际上就是指的 twitter。昨天，twitter 上有这么一条 tweets：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eRT @acetone RT @jiahuajie: 11月9日，河南南阳发生了大规模的断网事件，断网事件导致南阳市区的中国移动用户手机信号中断将近两个小时，给当地市民造成了一定程度上的恐慌。在网络恢复后，中国移动南阳分公司未向用户发表任何声明以及公开致歉。 \u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这条信息对于中国移动而言，本身就是个负面新闻，在 twitter 上被广泛传播，又一次唤起了大家对我们这个电信垄断企业的愤怒之情。大家的情绪当然是可以理解的，我个人坐地铁的时候，调试 CBTC 的一段时间，2号线经常紧急制动，没有解释，大家就很不满；而五号线在偶尔 ATP 故障导致紧急制动的时候，司机就会广播致歉，同样的事情，我就觉得舒服很多。网络信号这么重要的的联络手段中断后，如果没有什么道歉，我们的用户理所当然当然很不满。\u003c/p\u003e\n\n\u003cp\u003e对于 twitter 这样的信息快速散播的媒体，一个局部的负面新闻很快就能成为全国乃至世界性的消息，作为 One China Mobile 的一部分的我们，理所当然的也受到影响，在这种背景下，中国移动实际应该建立起一个对新媒体的响应能力，及时发布信息，也及时与用户互动。\u003c/p\u003e\n\n\u003cp\u003e在 twitter 上搜索了一下，我发现了 \u003ca href=\"http://twitter.com/tiyan100\"\u003e@tiyan100\u003c/a\u003e (该链接在国内无法直接打开) 这个账号，不断的发布着广东移动的体验活动信息，不知道是网友弄的还是广东移动自己的官方或半官方账号，但是，对于中国移动来说这个账号做得还很不够——一方面它 follow 和被 follow 的覆盖面太少，另一方面，它只是通过 \u003ca href=\"http://twitterfeed.com\"\u003etwitterfeed\u003c/a\u003e 来发布一些信息，而没有互动和与用户的响应，这种没有互动的方式完全无法发挥 twitter 的媒体特性。我们完全可以更好地利用 twitter：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e网络部和省地市公司可以通过 twitter 对网友的故障信息进行响应、利用网友的网络覆盖问题投诉辅助优化网络，收集到更多信息的同时也可以减少呼叫中心和营业厅的负担。\u003c/li\u003e\n\n\u003cli\u003e市场部门可以利用 twitter 发布促销等信息。\u003c/li\u003e\n\n\u003cli\u003e综合部、发展战略部等部门可以利用 twitter 收集各种意见、发布各种公关、社会责任等信息，与用户互动。\u003c/li\u003e\n\n\u003cli\u003e研究院可以利用 twitter 发布研究工作信息，与众多研究者和学生互动\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e通过发布信息和及时的互动，可以更好的改善服务和形象，这方面，twitter 的广泛传播能力绝对远胜于聊天室和 IM 工具。\u003c/p\u003e\n\n\u003cp\u003e只有与活跃的人们进行真正的交流，展现出自己渴望沟通和进步的心态，才能让移动逐步走出负面印象。\u003c/p\u003e\n","cover":"","link":"misc/2009/11/12/移动应该更好地利用新媒体/index.html","preview":"","title":"移动应该更好地利用新媒体"},{"content":"\n\u003cp\u003e上上个周末，老婆不小心把我们家的 EeePC 1000HE 的屏幕按破了，打听了一下，客服那里修的话要 1k 大洋，实在是太心疼了，好在有淘宝，在上面搜“10寸液晶屏”就能找到很多，EeePC 1000H 系列都是瀚视的这款 HSD100IWF1，不到300块钱，于是，牺牲质保，自己换屏。\u003c/p\u003e\n\n\u003cp\u003e看到屏幕拆下来的样子，老婆一下来了精神，拿着她的 Diamond 2 左拍右拍\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/11/IMAG0103.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAG0103\" border=\"0\" alt=\"IMAG0103\" src=\"/assets/IMAG0103_thumb.jpg\" width=\"244\" height=\"148\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/11/IMAG0104.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAG0104\" border=\"0\" alt=\"IMAG0104\" src=\"/assets/IMAG0104_thumb.jpg\" width=\"244\" height=\"148\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/11/IMAG0105.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAG0105\" border=\"0\" alt=\"IMAG0105\" src=\"/assets/IMAG0105_thumb.jpg\" width=\"244\" height=\"148\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/11/IMAG0106.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAG0106\" border=\"0\" alt=\"IMAG0106\" src=\"/assets/IMAG0106_thumb.jpg\" width=\"244\" height=\"148\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e作为专业的 EMC 工程师，她说，这些都是因为 EMI 过不了才弄上的……嗯，我反正不是太懂，虽然也曾经搞过硬件吧……\u003c/p\u003e\n\n\u003cp\u003e经历一番努力之后，新屏幕上上了，咱们试试\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/11/IMAGE_840.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_840\" border=\"0\" alt=\"IMAGE_840\" src=\"/assets/IMAGE_840_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/11/IMAGE_841.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_841\" border=\"0\" alt=\"IMAGE_841\" src=\"/assets/IMAGE_841_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e后面老婆不管了，咱自己来拍，换回小钻的相机吧，上面这是装上屏幕，没装 B 壳的时候的场面，点亮了，没啥问题，然后是 B 壳也上上，最终版的照片\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/11/IMAGE_843.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_843\" border=\"0\" alt=\"IMAGE_843\" src=\"/assets/IMAGE_843_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e大功告成，呵呵。总共开销：290屏+20快递费。\u003c/p\u003e\n\n\u003cp\u003ePS: 顺丰的快递员都是用的 139 的手机号，送到的时候我还以为是同事找我呢，呵呵。\u003c/p\u003e\n","cover":"","link":"misc/2009/11/12/eeepc换屏记/index.html","preview":"","title":"EeePC换屏记"},{"content":"\n\u003cp\u003e呃……似乎很多人都吵过了，前两天没顾上，其实还是想说两句的。\u003c/p\u003e\n\n\u003cp\u003eGoogle在国内又一次引起轩然大波，很多作家都指责Google侵权，说实话，一开始我也是这么以为的，不过后来的结果似乎挺清楚，Google似乎并没有什么不当之举，在得到授权之前，Google也并没有开放全书的阅读。\u003c/p\u003e\n\n\u003cp\u003e嗯，我也出了一本书，从我个人的角度讲，我倒是不在乎Google开放我的书的阅读，即使是没经过我授权，毕竟，在中国，版权保护本身就是一个奢求，当然，盗版确实不对，但我写的东西，如果因为 Google 能让更多人知道、更多人学到，对我这来说，是一大幸事，我想其他参与开源的人也会这么想。类似的，据说，大部分新闻网站都有点郁闷 Google 抓他们的页面，整合入 Google News，可是，正是 Google News 给他们带来了大量的流量，所以，他们还是向 Google 敞开了大门。\u003c/p\u003e\n\n\u003cp\u003e我每天的生活差不多都离不开 Google，用 Google Reader 阅读分享新闻，用 Google 搜索信息，用 Gmail 交流；时常使用 Google 翻译，使用 Google Group，使用 Google Calendar，使用 Google music，使用 Google 文档；动不动怀念 Google Site，怀念 PicasaWeb……可是，我的内心很害怕 Google，万一哪天这个公司忽然关门了，我的生活可咋办啊……\u003c/p\u003e\n\n\u003cp\u003e作为一个用户，当你的生活和同一个网站的关系越来越密切的时候，也就越来越担心你的信息会被他所利用，担心这一垄断是否会带来什么后果，说实话，我并不相信其“不作恶”的口号，和很多人一样，依赖且害怕着Google，这种恐惧可能就是对 Google Book 的抵制的来源，当然，某些别有用心的利益方的引导也很重要哈。\u003c/p\u003e\n","cover":"","link":"misc/2009/11/05/也说google-book/index.html","preview":"","title":"也说Google Book"},{"content":"\n\u003cp\u003e\u003csmall\u003e\u003ca href=\"http://www.cloudera.com/blog/2009/11/avro-a-new-format-for-data-interchange/\"\u003eMonday, November 2nd, 2009 at 8:00 am \u003c/a\u003eby Doug Cutting, filed under \u003ca href=\"http://www.cloudera.com/blog/category/data-collection/\"\u003edata collection\u003c/a\u003e, \u003ca href=\"http://www.cloudera.com/blog/category/general/\"\u003egeneral\u003c/a\u003e, \u003ca href=\"http://www.cloudera.com/blog/category/hadoop/\"\u003ehadoop\u003c/a\u003e, \u003ca href=\"http://www.cloudera.com/blog/category/mapreduce/\"\u003emapreduce\u003c/a\u003e.\u003cbr /\u003e\n\n\u003ca href=\"http://wangxu.me/\"\u003e王旭\u003c/a\u003e [ gnawux(at)gmail.com , \u003ca href=\"http://twitter.com/gnawux\" target=\"_blank\"\u003e@gnawux\u003c/a\u003e, \u003ca href=\"http://wangxu.me\"\u003ehttp://wangxu.me\u003c/a\u003e ]于11月2-3日译\u003c/small\u003e\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e译注：Doug Cutting 是 Hadoop 的大佬，目前在 Cloudera，Avro 基本上将成为未来 Hadoop 的数据描述和 RPC 的基础，今天看到这篇，就立刻翻译了，水平有限且译的比较草，请见谅，且欢迎纠错。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://hadoop.apache.org/avro/\" target=\"_blank\"\u003eAvor\u003c/a\u003e 是 Apache 的 \u003ca href=\"http://hadoop.apache.org/\" target=\"_blank\"\u003eHadoop\u003c/a\u003e 项目族的一个新成员。Avro 定义了一种用于支持大数据应用的数据格式，并为这种格式提供了不同的编程语言的支持。\u003c/p\u003e\n\n\u003ch4\u003e背景\u003c/h4\u003e\n\n\u003cp\u003e我们希望处理大数据的应用可以更加动态化：人们应该能够快速的从不同的数据源合并数据集。我们希望能够让新颖的、创造性的数据分析变得更方便。比如说，有人需要完美地将销售各个网点的交易、网站的访问量以及外部的统计数据关联在一起，而不需要很多的准备工作。这应该可以使用脚本和交互工具即时完成。\u003c/p\u003e\n\n\u003cp\u003e目前的数据格式通常都做的不是很好。XML 和 \u003ca href=\"http://json.org/\"\u003eJSON\u003c/a\u003e 可以承载很多信息，但它们本身就很大，处理起来很慢。当你处理上 PB 的数据的时候，尺寸和速度绝对是个大问题。\u003c/p\u003e\n\n\u003cp\u003eGoogle 使用一个称为 \u003ca href=\"http://code.google.com/p/protobuf/\"\u003eProtocol Buffers\u003c/a\u003e 的系统来解决这个问题。（还有其他的系统，比如 \u003ca href=\"http://incubator.apache.org/thrift/\"\u003eThrift\u003c/a\u003e，与 Protocol Buffers 很类似，我不会在这里深入讨论它们，但我对 Protocol Buffers 的评价对它们同样适用。）Google 已经开放了 Protocol Buffers，但它对我们的目的来说也不完美。\u003c/p\u003e\n\n\u003ch4\u003e通用数据\u003c/h4\u003e\n\n\u003cp\u003e在 Protocol Buffers 中，用户首先定义数据结构，然后生成可以有效读写这些数据的代码。不过，如果你需要在一个脚本语言中直接使用 Protocol Buffer 的数据，你必须首先确定数据结构定义的位置；为它生成代码；最后，在获取数据之前装载代码。这么做可能还算是不错，但如果我们想要一个能浏览任意数据集的通用工具，它将不得不首先定位定义，再为每个数据集生成与装在代码。这让很多本来简单的事情变得复杂了。\u003c/p\u003e\n\n\u003cp\u003e与 Protocol Buffer 不同，Avro 格式将数据结构的定义以一种易于处理的形式存储在数据之中。这样，Avro 的实现可以在运行时使用这些定义，将数据以一种通用的方式展现给应用，而不需要生成代码。\u003c/p\u003e\n\n\u003cp\u003e代码生成在 Avro 中是可选的：如果某些编程语言要对某些数据结构是由代码生成的话也相当不错，比如需要频繁串行化的数据类型。但是，对于像 \u003ca href=\"http://hadoop.apache.org/hive/\"\u003eHive\u003c/a\u003e 和 \u003ca href=\"http://hadoop.apache.org/pig/\"\u003ePig\u003c/a\u003e 这样的脚本来说，代码生成可能会是一种过分的负担，所以，Avro 不需要代码生成。\u003c/p\u003e\n\n\u003cp\u003e把数据结构定义存储在数据中的一个附加的好处是允许数据可以被更快和更小巧地存储。Protocol Buffers 为数据增加了注释，以保证在定义和数据不完全匹配的时候仍然能够得到处理。然而这些注释会让数据略微增大、处理稍稍变慢。一些\u003ca href=\"http://code.google.com/p/thrift-protobuf-compare/wiki/Benchmarking\"\u003e评测结果\u003c/a\u003e显示，Avro 这样不需要这些注释的数据和其他串行化系统相比，更小而且处理起来更快。\u003c/p\u003e\n\n\u003ch4\u003eAvro Schemas\u003c/h4\u003e\n\n\u003cp\u003eAvro 使用 JSON 来定义数据结构的 schema。比如，一个二维平面上的点可以定义为如下的 Avro 记录：\u003c/p\u003e\n\n\u003cpre class=\"brush: javascript; gutter: true\"\u003e{\u0026quot;type\u0026quot;: \u0026quot;record\u0026quot;, \u0026quot;name\u0026quot;: \u0026quot;Point\u0026quot;, \n\u0026quot;fields\u0026quot;: [ \n  {\u0026quot;name\u0026quot;: \u0026quot;x\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;int\u0026quot;}, \n  {\u0026quot;name\u0026quot;: \u0026quot;y\u0026quot;, \u0026quot;type\u0026quot;: \u0026quot;int\u0026quot;}, \n] \n}\u003c/pre\u003e\n\n\u003cp\u003e指针的每个实例都包含两个整数，不包含附加的每个记录或每个域的注释。整数使用\u003ca href=\"http://lucene.apache.org/java/2_4_0/fileformats.html#VInt\"\u003e变长 zig-zag 编码\u003c/a\u003e存储。所以小的正负值可能只需要两个字节：100个点可能只需要两百个字节。\u003c/p\u003e\n\n\u003cp\u003e在记录和数值类型之外，Avro 支持数组、map、每句、变长与定长二进制数据以及字符串。它还定义了一个容器文件格式，这样可以更好的支持 MapReduce 和其他大数据处理框架。对于更多的细节信息，可以参考 \u003ca href=\"http://hadoop.apache.org/avro/docs/current/spec.html\"\u003eAvro 的规范\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch4\u003e兼容性\u003c/h4\u003e\n\n\u003cp\u003e应用程序都在演进，在这一过程中数据结构是可以改变的。我们希望应用的新版本仍然能够处理老版本创建的数据，反之亦然。Avro 和 Protocol Buffers 处理这个问题的方式比较类似。当应用需要的域没有出现的时候，Avro 会提供一个 schema 中规定的缺省值。Avro 忽略掉数据中的意外值。这并不能处理所有的后向兼容问题，但它让大部分的兼容性问题更容易处理。\u003c/p\u003e\n\n\u003ch4\u003eRPC\u003c/h4\u003e\n\n\u003cp\u003eAvro 也定义了一个 RPC 协议。尽管 RPC 中使用的数据类型和数据集中的类型通常是不同的，使用一个通用的串行化系统仍然是有用的。大数据需要一个分布式的基于 RPC 的框架。所以，在我们需要处理数据集文件的所有地方，我们也需要能够使用 RPC。这样，将 RPC 和数据集都建立在同一个基础之上将会最小化地减少那些代码可以处理数据，却无法使用分布式框架来这么做的可能性。\u003c/p\u003e\n\n\u003ch4\u003e与 Hadoop 集成\u003c/h4\u003e\n\n\u003cp\u003e我们希望在 Hadoop MapReduce 中可以简单地使用 Avro 数据。目前这项工作仍然在进展中。目前 issue \u003ca href=\"https://issues.apache.org/jira/browse/MAPREDUCE-1126\"\u003eMAPREDUCE-1126\u003c/a\u003e 和 \u003ca href=\"https://issues.apache.org/jira/browse/MAPREDUCE-815\"\u003eMAPREDUCE-815\u003c/a\u003e 在处理这个问题。\u003c/p\u003e\n\n\u003cp\u003e注意，Avro 数据结构可以定义它们的排序方式，所以一个编程语言中创建的复杂的数据可以在另一个语言中被排序。Avro 可以在不还原序列化的情况下进行排序，这可以加快处理速度。\u003c/p\u003e\n\n\u003cp\u003e我们希望 Avro 可以替换掉 Hadoop 中现有的 RPC。Hadoop 目前需要客户端和服务器必须使用相同版本的 Hadoop。我们希望使用 Avro 可以允许一个 Hadoop 应用能和多个运行不同版本的 HDFS 和/或 MapReduce 的多个集群交互工作。\u003c/p\u003e\n\n\u003cp\u003e最后，我们希望 Avro 可以允许 Hadoop 应用更容易的使用 Java 之外的语言开发。比如，一旦 Hadoop 构建在 Avro 之上，我们希望支持 Python，C 和 C++ 等语言的 HDFS 和 MapReduce 的原生客户端。\u003c/p\u003e\n\n\u003ch4\u003eHadoop World 访谈\u003c/h4\u003e\n\n\u003cp\u003e很多话题都已经包含在了我最近在 Hadoop World 的访谈，我很乐于在这篇 blog 里包含这段视频。（译注：译者撞墙看不到视频，不贴了哈。）\u003c/p\u003e\n","cover":"","link":"translation/2009/11/03/avro-format/index.html","preview":"","title":"[译文] Avro: 大数据的数据格式"},{"content":"\n\u003cp\u003eBeijingLSF = Linux Storage Filesystem Workshop in Beijing，这是 \u003ca href=\"http://blog.coly.li/\"\u003eColy\u003c/a\u003e 等大牛组织起来的一次国内 Linux 内核存储相关部分的主要开发者的聚会，会议由 Novell 提供了一定的资助，在 linuxfb 的老巢北邮教三楼召开，参与者来自 Novell, EMC, Oracle, Intel, Fujisu, Freescale, Lenovo, Xteam 等公司，2/3 的第二天 AKA 大会的讲演者都在 BeijingLSF 上介绍了他们的工作，来参加 AKA 大会的 Herbert Xu 也大驾光临，直接从机场来到了会场。作为 \u003ca href=\"http://blog.coly.li/\"\u003eColy\u003c/a\u003e 的信徒，我有幸参加了这一峰会，当然写Blog是必须的了。\u003c/p\u003e\n\n\u003cp\u003e正如我在最后所说的，我本来是跟着 \u003ca href=\"http://blog.coly.li/\"\u003eColy\u003c/a\u003e 来看大牛的，结果一不小心还被大牛围观了，这基本是由于我来自一个让中国的开源社区感到陌生而又熟悉的公司——中国移动。嗯……稍后再来感慨，先谈谈这次会议的实况。\u003c/p\u003e\n\n\u003cp\u003e第一个时段是 \u003ca href=\"http://blog.coly.li/\"\u003eColy\u003c/a\u003e 亲自主持的关于 ocfs2 和 DLM 的讨论，\u003ca href=\"http://blog.coly.li/\"\u003eColy\u003c/a\u003e 分享了很多开发过程中遇到的问题，Oracle 和 Novell 的同学基本上主导了这个话题的讨论，其他公司的同学也参与其中了。给我留下比较深刻印象的是那个32/64位 lvb 的问题以及最后的那个 race condition 的问题。\u003c/p\u003e\n\n\u003cp\u003e第二个时段应该是马涛主持的讨论，但他把这个时段几乎完全贡献给大家作为自我介绍时段了，也就是在这个时段，我从瞻仰变成了被围观，呵呵。不过，说实话，我最感兴趣的是马涛介绍的 reflink，对于大量使用虚拟机的情况，这一特性无疑非常具有吸引力，而且也获悉 btrfs 也具有类似特性，我确实希望能尝试一下这个文件系统了。\u003c/p\u003e\n\n\u003cp\u003e接下来胡欣蔚介绍了 clvm 等内容，之前尝试过 drbd8，不过还是被 md，dm 这些模块搞得有些晕晕的，呃……对于我们的某些应用来说，多节点构成一个逻辑卷的需求是切实存在的，以后可能有机会常和这些东东打交道。\u003c/p\u003e\n\n\u003cp\u003e下午，吴锋光首先介绍 writeback 和 readahead，大家对 SSD 的讨论很热闹，这也是世界范围的关注重点，头一次听说 SSD 的随机读取速度可能会超过连续读，非常有趣的情况，我想，下个月我会测试一下SSD的实际情况，可能会有更多可发言的东西，呵呵。\u003c/p\u003e\n\n\u003cp\u003e接下来，归剑锋介绍了 cgroup iocontroller，了解了很多相关的开发进程以及背后的八卦信息，当年我在翻译LWN的\u003ca href=\"http://wangxu.me/blog/?p=117\"\u003eCFS组调度\u003c/a\u003e的文章的时候接触过 cgroup 这个概念，这次听归剑锋的介绍，对 pdflush 的问题印象比较深刻。\u003c/p\u003e\n\n\u003cp\u003e最后的一个session是联想研究院的卢亿雷介绍他们的网盘系统的实现和一些问题，这个系统和我们的应用有些类似的地方，我也参与了一些性能相关的讨论。\u003c/p\u003e\n\n\u003cp\u003e结束前的light talk环节，EMC的同学们还提出下次可以分享一些不涉及机密的非开源产品的技术内容，其他参与者也表达了美好的憧憬，这让我也不由得期待明年还能有机会参与其中，呵呵。\u003c/p\u003e\n\n\u003cp\u003e本来没想在这里一直一天的，毕竟由于上周出差已经两个星期没和儿子有一整段时间在一起了，不过，内容和嘉宾太吸引人了，Herbert Xu这样的名人要来，如果不住在河北省，谁会早走呢，呵呵，不仅学到很多东西，而且认识了很多大牛，不虚此行。感谢 Coly，感谢组委会，感谢 Novell，感谢志愿者彭涛和李劼……\u003c/p\u003e\n","cover":"","link":"misc/2009/10/25/beijinglsf笔记/index.html","preview":"","title":"BeijingLSF笔记"},{"content":"\n\u003cp\u003eGTD最早还是第一次年终总结的时候周彬介绍给大家的呢，一直神往也学了一些，尝试过几次，效果还行但坚持的不好，买了一本戴维-艾伦的原书，但一直也没有细看，直到这次出差，往返都是十几个小时的路程，不仅看完了GTD，也看完了备受推崇的高效能人士的七习惯的电子版，收获颇多，尤其是看GTD的时候，总有赶快冲出去实践一下的冲动，要不是出差在外，手头东西收集不全，可能已经开始了，不过，就算如此，也先收集了一百多个要做的事情，放在stuff里，等着处理呢。\u003c/p\u003e\n\n\u003cp\u003e两本书很有趣，可以说一个形而上，一个形而下；一个讲内，一个讲外；一个讲人，一个讲事；一个讲理，一个讲法。但两者并不冲突，他们都讲求脚踏实地从小处做起，又都主张高瞻远瞩，要志存高远，都主张分角色、分场合地处理事务，都在追求内心的平静。\u003c/p\u003e\n\n\u003cp\u003e对于戴维-艾伦的《Get Things Done》，有这么几个要点——首先是关注下一步行动，一定要精确到可以执行的程度，原来在这方做的很不够，所以，也就很难坚持下去；另一点就是要每周回顾，看看自己达到什么程度了，这对于大局把握十分必要，也是我原来缺乏的。此外，戴维-艾伦还强调了，有趣的工具往往更能促进思考、帮助完成工作，我倒常常被太好的工具分心，呵呵。\u003c/p\u003e\n\n\u003cp\u003e对于史蒂夫 科维的《高效能人士的七个习惯》，我觉得，这里所谓习惯不是我们常说的习惯，而是一种观念，由观念固化到习惯，这里不是具体的七个习惯，而是体现这些观念的习惯、行为与思考方式。\u003c/p\u003e\n\n\u003cp\u003e两本书都强调了给自己找到目标，与目标比，而不是与人比，这对于自我提升、管理，乃至家庭教育都很有意义。\u003c/p\u003e\n\n\u003cp\u003e而七个习惯中提到了很多值得我注意的地方，感触最深的就是这句“自以为是的人总是觉得自己最客观”，作为一个自以为是的人，我同意这点，将来的与人交往中，一定要避免这种主观的客观。\u003c/p\u003e\n\n\u003cp\u003e对于我本人来说，七个习惯的另一个提示在于，经过这么多年的教训和思考，我明白了很多自己的缺点，已经可以正视它们、接受他们，却不曾乐意或勇于为了自己的目标去改变自己，而是纯粹的接受，现在，我要做的是——找到真正的目标、改变自己、执行。\u003c/p\u003e\n","cover":"","link":"misc/2009/10/19/gtd与七个习惯读后感/index.html","preview":"","title":"GTD与七个习惯读后感"},{"content":"\n\u003cp\u003e今天，会议结束，我已经告别了Banff，来到Calgary，明天一早就将起飞，在温哥华转机，回到北京，在出发之前，留下一张有自己模样的加拿大照片吧，虽然拍的不算好，但也算是有图有真相吧。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_773.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_773\" border=\"0\" alt=\"IMAGE_773\" src=\"/assets/IMAGE_773_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e说实话，落基山下的这块地方还挺漂亮的，可是我没啥时间出去走，大部分都在会议室里憋着了，会场的景观也不错\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_750.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_750\" border=\"0\" alt=\"IMAGE_750\" src=\"/assets/IMAGE_750_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160;\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_770.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_770\" border=\"0\" alt=\"IMAGE_770\" src=\"/assets/IMAGE_770_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e国外有一点很人性化，不管到哪，都能找到很方便的地图，伦敦的时候每个地铁站都有，这里，饭店也提供免费的地图，趁着开会间隙，循着地图，我去了一回 downtown banff，买了一点小纪念品，呵呵 \u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_759.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_759\" border=\"0\" alt=\"IMAGE_759\" src=\"/assets/IMAGE_759_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e等我拿到本了，一定把这个上在我家车的后面，太可爱了。 这次会安排了很多的大家互相聊天的机会，只是我聊的云计算话题虽然是个主要话题，但这里的大部分人却都是高性能计算背景的，随便抓来就聊还是不怎么成功，经常互相郁闷。\u003c/p\u003e\n\n\u003cp\u003e不过有一个哥们倒是很nice，还送我一个钥匙链+瓶起子\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_786.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_786\" border=\"0\" alt=\"IMAGE_786\" src=\"/assets/IMAGE_786_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160;\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_787.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_787\" border=\"0\" alt=\"IMAGE_787\" src=\"/assets/IMAGE_787_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e 原来他是下次OGF的主办方，本来以为他是看到人就送一个呢，还觉得我挺幸运，结果，最后大会散场的时候，每人都发……唉，白兴奋了。不过这个点子不错啊，我们其实也应该多弄一些这样的很便宜的小纪念品，在建立联系方面很有用啊，成本也很低。\u003c/p\u003e\n\n\u003cp\u003e收拾行李的时候，看到我老婆怕我饿着，给我带的吃的，当时说万一没饭吃，靠这点也能挺回来，不过，今天，他们大多还完好地保存着，看来要成为一批海龟事务啦。\u003c/p\u003e\n\n\u003cp\u003e此行的一个个人目的——给儿子买奶粉的目的也差不多达到了，借助Google 地图，我独自徒步找到了DeerFoot Mall，虽然饭店前台说不行到不了吧——\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_781.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_781\" border=\"0\" alt=\"IMAGE_781\" src=\"/assets/IMAGE_781_thumb.jpg\" width=\"184\" height=\"244\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e远景，不清楚哈，路对面还有一个有施乐大名的建筑，不知道是啥。在DeerFoot，还吃到了这个\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_780.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_780\" border=\"0\" alt=\"IMAGE_780\" src=\"/assets/IMAGE_780_thumb.jpg\" width=\"184\" height=\"244\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e挺贵的泰国快餐，一开始还觉得挺好吃，到后面吃不下了，不过还是吃完了，呵呵。 \u003c/p\u003e\n\n\u003cp\u003e哦，好了，不早了，我要休息了，明天还要早起赶飞机呢，不出意外的话，到温哥华机场再上网了。\u003c/p\u003e\n","cover":"","link":"misc/2009/10/17/告别banff，告别ogf27/index.html","preview":"","title":"告别Banff，告别OGF27"},{"content":"\n\u003cp\u003e现在是山地时间10月15日晚上，我也来响应一下号召。刚好这次OGF27也有很多人谈绿色IT，有些人看到了绿色IT之后，能减少碳排放到原来的1/40，也有些人看到，因为成本和收益的原因，绿色IT在大多数地方还是口号。\u003c/p\u003e\n\n\u003cp\u003e不论如何，绿色IT、降低CO2排放已经是迫在眉睫的了，这方面，我们中国移动也在努力，呵呵。\u003c/p\u003e\n\n\u003cp\u003e另一个问题，中国现在似乎还没办法让用户选择是否购买清洁能源，这个方面的比重实际好像是最大的。\u003c/p\u003e\n\n\u003cp\u003e嗯，本来没想写，语无伦次的，就写这些吧。\u003c/p\u003e\n","cover":"","link":"misc/2009/10/16/博客行动日，我也来一篇吧/index.html","preview":"","title":"博客行动日，我也来一篇吧"},{"content":"\n\u003cp\u003e这周在加拿大开会，偶尔上了一下msn，发现有人加我msn，说明大概是买了我的书，觉得挺好，想和作者交流一下。\u003c/p\u003e\n\n\u003cp\u003e忽然感觉受宠若惊啊，虽然由于出差在外时差的原因，下周前可能不会有真的交流，但仅仅是这个好友添加，就让我感到非常荣幸了，至少，他把本人当作是个活生生的、可交流的人了，而不是个搜索爬虫，即使他骂我说我写的太烂，我也感到非常高兴了。\u003c/p\u003e\n\n\u003cp\u003e这基本不是我在装x（嗯，还是有那么点装x的意思），我确实对读者反映没什么信心，要知道，连我自己现在都很难找到花自己的工资区买一本书的冲动了，网络上的信息如此之丰富，你能指望谁去花钱买一本只是有点小意思的书呢。我自信，这书里倾注着我几年的心血，我也自信，这本书对大家来说是有用的，但仅仅有用仍然让我没有信心认为你会买它。\u003c/p\u003e\n\n\u003cp\u003e出版社的态度本来只是维持他们的产品线完整，呃，当然，能赚钱更好；我只是发自内心的想分享我已经做过的，当然，也是能赚钱更好。而如今，甚至还有读者真的觉得这本书还能读，太惊喜了。\u003c/p\u003e\n\n\u003cp\u003e出版的时候只是感到一个任务完成了，一种放松的快乐，而现在，则感觉自己真的做了一件有意义的事情，一种由衷的兴奋，谢谢大家，真的谢谢。\u003c/p\u003e\n","cover":"","link":"misc/2009/10/15/收到一个读者回应/index.html","preview":"","title":"收到一个读者回应"},{"content":"\n\u003cp\u003e嗯，没错，就是这么久，上一篇写到温哥华登机，结果那飞机延误了不止30分钟，而是一个小时，直接后果是没赶上预定好的下午六点半的从机场到 banff 的车，只能再等两个小时，这样，抵达班芙的时间就是晚上快11点了，办完check-in，到屋里收拾一下，等上来写blog就这点了，嗯，写了就睡，累死了。\u003c/p\u003e\n","cover":"","link":"misc/2009/10/12/抵达班芙/index.html","preview":"","title":"抵达班芙"},{"content":"\n\u003cp\u003egnawux发自温哥华机场的报道。感谢eeepc的续航力和温哥华机场的wifi，转机卡尔加里途中，第一时间发点旅途话题。\u003c/p\u003e\n\n\u003cp\u003e11日中午到达首都机场，先来几张T3的小火车的照片：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_709.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_709\" border=\"0\" alt=\"IMAGE_709\" src=\"/assets/IMAGE_709_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_710.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_710\" border=\"0\" alt=\"IMAGE_710\" src=\"/assets/IMAGE_710_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_711.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_711\" border=\"0\" alt=\"IMAGE_711\" src=\"/assets/IMAGE_711_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_712.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_712\" border=\"0\" alt=\"IMAGE_712\" src=\"/assets/IMAGE_712_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e站台几乎没有啥间隙，对的也非常齐，真的是非常齐，呵呵。\u003c/p\u003e\n\n\u003cp\u003e找到登机口，发现又是在航站楼的尖端，为啥每次来T3都要走到头呢\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_714.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_714\" border=\"0\" alt=\"IMAGE_714\" src=\"/assets/IMAGE_714_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e来得早，而且坐的位置合适，看到了装运食品和行李的全过程\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_716.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_716\" border=\"0\" alt=\"IMAGE_716\" src=\"/assets/IMAGE_716_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_717.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_717\" border=\"0\" alt=\"IMAGE_717\" src=\"/assets/IMAGE_717_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003c/p\u003e\n\n\u003cp\u003e上了飞机，A330，第一次在国航的飞机上看到每个座位的电视，后来发现还有视频点播，座位的间距也还算满意吧。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_718.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_718\" border=\"0\" alt=\"IMAGE_718\" src=\"/assets/IMAGE_718_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; \u003c/p\u003e\n\n\u003cp\u003e经过10个小时飞行，中间吃了两顿饭、断断续续睡了两三个小时，看了会书，看了会功夫熊猫和一个不知道名字的英语片，终于到了温哥华，中间感到很对不起老婆，时差计算失误，告诉她到温哥华给她电话的，结果在飞机上发现，到温哥华的时候，北京时间都快3点了……还好她没傻等着，也没太着急，给她发了短信。\u003c/p\u003e\n\n\u003cp\u003e一到温哥华机场就发现有很多中文提示，有点感受不到是出国了……\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_719.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_719\" border=\"0\" alt=\"IMAGE_719\" src=\"/assets/IMAGE_719_thumb.jpg\" width=\"184\" height=\"244\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e转机非常方便，有人指导，刚取出行李就又送进卡尔加里方向的行李了，登机牌在首都机场就办了，很方便，呵呵，不过飞卡尔加里的航班那么多，托运行李不会搞混了吧……有点担心的说。\u003c/p\u003e\n\n\u003cp\u003e卡尔加里的飞机晚点半小时，不知道能不能赶上预定的大巴车……嗯，就到这吧，预计还有两个小时起飞，应该还有一个半小时登机吧，EEEPC-1000H的电池非常赞，用了这么久还有83%呢。\u003c/p\u003e\n","cover":"","link":"misc/2009/10/12/着陆温哥华/index.html","preview":"","title":"着陆温哥华"},{"content":"\n\u003cp\u003e长假里，和儿子的相处时间总是觉得不够。瞧瞧这是什么：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_693.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_693\" border=\"0\" alt=\"IMAGE_693\" src=\"/assets/IMAGE_693_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e嗯，这是在沙发上就地取材搭出来的屋子，给儿子“捉迷藏”用的——\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_694.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_694\" border=\"0\" alt=\"IMAGE_694\" src=\"/assets/IMAGE_694_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e这张不太好，有点虚——\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_696.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_696\" border=\"0\" alt=\"IMAGE_696\" src=\"/assets/IMAGE_696_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e叫他看镜头，结果给了这么个哀怨的眼神——\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_699.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_699\" border=\"0\" alt=\"IMAGE_699\" src=\"/assets/IMAGE_699_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e \u003c/p\u003e\n\n\u003cp\u003e估计也在发愁将来娶媳妇用的房子的问题呢。发愁久了，太投入了，就造成了这个后果——\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_701.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_701\" border=\"0\" alt=\"IMAGE_701\" src=\"/assets/IMAGE_701_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e房子也只好搬家了——\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/wp-content/uploads/2009/10/IMAGE_700.jpg\"\u003e\u003cimg style=\"border-bottom: 0px; border-left: 0px; display: inline; border-top: 0px; border-right: 0px\" title=\"IMAGE_700\" border=\"0\" alt=\"IMAGE_700\" src=\"/assets/IMAGE_700_thumb.jpg\" width=\"244\" height=\"184\" /\u003e\u003c/a\u003e\u0026#160; \u003c/p\u003e\n\n\u003cp\u003e长假太快了，又开始和儿子聚少离多的工作时光了，好想每天从早到晚和他玩啊……\u003c/p\u003e\n","cover":"","link":"misc/2009/10/08/斯屹捉迷藏/index.html","preview":"","title":"斯屹捉迷藏"},{"content":"\n\u003cp\u003e作者：Peter Hutterer   \u003cbr /\u003e原文发布时间：2009年6月26日    \u003cbr /\u003e原文来源：\u003ca title=\"http://who-t.blogspot.com/2009/05/xi2-recipes-part-1.html\" href=\"http://who-t.blogspot.com/2009/05/xi2-recipes-part-1.html\"\u003ehttp://who-t.blogspot.com/2009/05/xi2-recipes-part-1.html\u003c/a\u003e    \u003cbr /\u003e译者：王旭 ( \u003ca href=\"http://wangxu.me\"\u003ehttp://wangxu.me\u003c/a\u003e , \u003ca href=\"http://twitter.com/gnawux\"\u003e@gnawux\u003c/a\u003e )    \u003cbr /\u003e翻译时间：2009年9月28日\u003c/p\u003e\n\n\u003cp\u003eXI2 （X Input 2）目前已经进入 XServer 的主线了。在接下来的几天里，我将发布出来一组“食谱”，来介绍如何和这些新功能打交道。这里的例子仅仅是一些片段，每部分的完整的示例都将放在\u003ca href=\"http://people.freedesktop.org/%7Ewhot/xi2-recipes/\"\u003e这里\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e09年7月13日更新：调整到新的 \u003ca href=\"http://who-t.blogspot.com/2009/07/xlib-cookie-events.html\"\u003ecookie event API\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e在第一部分中，我将介绍一些总体的信息，初始化以及事件选择。\u003c/p\u003e\n\n\u003ch4\u003e\u003cstrong\u003e为什么需要\u003c/strong\u003e XI2?\u003c/h4\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e引入 XI2 的一个重要原因是要将 MPX 并入 X Server。当前的 1.5 版本的 X Input 扩展余地非常有限，很难进行扩展以完全支持 MPX。在 XI 1.5 上编程非常痛苦，所以，我们开始寻找一个替代方案，从而让支持多设备的程序更容易写一些，并且能灵活地应付将来的应用场景。\u003c/p\u003e\n\n\u003cp\u003eXI2 的协议时相当保守的，只增加了一些新的请求和事件，但它也留下了很多的发展空间。XI2 和它的 API 与 X 核心 API 的模式非常接近。从客户应用（X Client）的角度看，与 XI 的最大不同在于调用需要附带一个设备ID参数，不需要去打开设备，而事件类型和掩码都是常数（更多的在下面）。\u003c/p\u003e\n\n\u003cp\u003e现在，惟一的 XI2 绑定是 Xlib 绑定。尽管如此，我仍鼓励你开始采用 XI2 并思考程序如何使用它。通过现在进行测试，你可以在 2.0 发布之前帮助发现问题和当前版本中的缺陷。当然，在发布前修正 bug 可以惠及所有人。\u003c/p\u003e\n\n\u003ch4\u003eMPX\u003c/h4\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003eMPX允许同时使用多个鼠标指针和键盘焦点。这将有助于引领相当时髦的用户界面——双手操作、多人操作……所有你能说出来的。它还抛弃了当前 GUI 设计的一些假设，但我将在将来再去谈这些。\u003c/p\u003e\n\n\u003cp\u003eMPX引入了一个显式的主/从设备层次关系。最简单的记住这个层次关系的方式是：物理设备是从设备，而鼠标指针或键盘焦点是主设备。\u003c/p\u003e\n\n\u003cp\u003e从设备附着到一个主设备上，每当从设备产生一个事件，这个事件将被通过主设备路由到客户应用上。主设备总是成对出现（一个指针，一个键盘焦点）。\u003c/p\u003e\n\n\u003cp\u003e这样，一个常见的配置可能是一个笔记本有四个主设备（两个键盘焦点和两个鼠标指针），触控板和内建键盘控制第一对主设备，一个USB无线键鼠套装控制第二对主设备。标准配置是有一堆主设备，所有设备都附着到这对主指针和焦点上。这个方案意外地（或无意外地）和我们自从 X Server 1.4 的配置是一样的。这也意味着除非你建立一对新的主设备，否则 MPX 根本就不可见。\u003c/p\u003e\n\n\u003cp\u003e我将在后面的文章里更多的介绍 MPX，从大多数客户应用的角度看，主设备是惟一需要关心的问题，只有配置工具和一些其他的特殊程序才真的需要去关心从设备。\u003c/p\u003e\n\n\u003ch4\u003eXI2 初始化\u003c/h4\u003e\n\n\u003cp\u003e\u0026#160;\u003c/p\u003e\n\n\u003cp\u003e一个典型的 XI2 程序如下面这么开头：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cpre\u003e/* Connect to the X server */\u003cbr /\u003eDisplay *dpy = XOpenDisplay(NULL);\u003cbr /\u003e\u003cbr /\u003e/* XInput Extension available? */\u003cbr /\u003eint opcode, event, error;\u003cbr /\u003eif (!XQueryExtension(dpy, \u0026quot;XInputExtension\u0026quot;, \u0026amp;opcode, \u0026amp;event, \u0026amp;error)) {\u003cbr /\u003e   printf(\u0026quot;X Input extension not available.\\n\u0026quot;);\u003cbr /\u003e   return -1;\u003cbr /\u003e}\u003cbr /\u003e\u003cbr /\u003e/* Which version of XI2? We support 2.0 */\u003cbr /\u003eint major = 2, minor = 0;\u003cbr /\u003eif (XIQueryVersion(dpy, \u0026amp;major, \u0026amp;minor) == BadRequest) {\u003cbr /\u003e  printf(\u0026quot;XI2 not available. Server supports %d.%d\\n\u0026quot;, major, minor);\u003cbr /\u003e  return -1;\u003cbr /\u003e}\u003cbr /\u003e\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e首先，客户应用连接 X Server，之后询问可用的 XI 扩展的版本。XQueryExtension 不仅告诉我们 XI 扩展是否存在，也会返回扩展的 opcode。这个 opcode 在事件处理时需要用到（所有的 XI2 事件都用到了这个 opcode）。这个 opcode 是在 X Server 启动时设置的，所以，在跨 X Server 的应用中，你不能把它当做个常量。\u003c/p\u003e\n\n\u003cp\u003e最后，我们宣布我们支持 XI 2.0，服务器返回它支持的版本。 XIQueryVersion 是一个纯 XI2 调用，即使你在一个不支持 XI2 的服务器上调用，它的实现也不会返回一个 BadRequest 错误（这是在 Xlib 中的实现，所以如果你使用xcb，这个行为可能会不同）。\u003c/p\u003e\n\n\u003cp\u003eXIQueryVersion 不仅返回支持的版本，X Server 也会存储你的客户应用支持的版本。随着 XI2 的进程，使用这个调用变得非常重要，服务器将根据支持的版本来区别对待不同的客户应用。\u003c/p\u003e\n\n\u003ch4\u003e事件的选择\u003c/h4\u003e\n\n\u003cp\u003e\n  \u003cbr /\u003e初始化GUI之后，客户应用通常需要选择事件。这一工作可以通过 XISelectEvents 实现。\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003e\n    \u003cbr /\u003eXIEventMask eventmask;\u003c/p\u003e\n\n\u003cp\u003eunsigned char mask[1] = { 0 }; /* the actual mask */\u003c/p\u003e\n\n\u003cp\u003eeventmask.deviceid = 2;\u003c/p\u003e\n\n\u003cp\u003eeventmask.mask_len = sizeof(mask); /* always in bytes */\u003c/p\u003e\n\n\u003cp\u003eeventmask.mask = mask;\u003c/p\u003e\n\n\u003cp\u003e/* now set the mask */\u003c/p\u003e\n\n\u003cp\u003eXISetMask(mask, XI_ButtonPress);\u003c/p\u003e\n\n\u003cp\u003eXISetMask(mask, XI_Motion);\u003c/p\u003e\n\n\u003cp\u003eXISetMask(mask, XI_KeyPress);\u003c/p\u003e\n\n\u003cp\u003e/* select on the window */\u003c/p\u003e\n\n\u003cp\u003eXISelectEvents(display, window, \u0026amp;eventmask, 1);\u003c/p\u003e\n\n\u003cp\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003eXIEventMask 定义了一个设备的掩码。掩码定义为（1 事件类型），匹配位必须在 eventmask.mask 域中设置。eventmask.mask 的尺寸可以是任意大小的，倡导可以满足所有需要设置的掩码。XI_LASTEVENT 定义为当前 XI2 协议中的最高的事件类型，所以你可以使用它来确定需要设置的掩码的位数。在本例中，我们只需要6位，所以一个字节就够了。\u003c/p\u003e\n\n\u003cp\u003eXISelectEvents 携带了多个事件掩码，所以，你可以一次提交多个事件的选择（比如每个对应一个设备）。\u003c/p\u003e\n\n\u003cp\u003e如上所示，每个 XIEventMask 都带有一个设备ID。要么是一个设备的数字ID，或是 XIAllDevices 或 XIAllMasterDevices 这样的特殊 ID。如果你选择 XIAllDevices 的事件掩码，所有的设备都会送来选择的事件。XIAllMasterDevices 也是一样，但只是所有的主设备。\u003c/p\u003e\n\n\u003cp\u003eXIAllDevices 和 XIAllMasterDevices 的事件掩码是特定设备事件掩码的一个补充。例如，你可以选择所有设备的按下事件，所有主设备的松开事件，以及设备2的移动事件，设备2将会向客户应用报告所有三类事件（有效掩码是按位或的）。\u003c/p\u003e\n\n\u003cp\u003e并且，XIAllDevices 和 XIAllMasterDevices 对所有设备都会生效，即使设备在客户应用选择事件之后才加入也会生效。所以，你只要设置事件掩码一次，无需关心当前有多少设备可用，将来还会进入多少设备。\u003c/p\u003e\n\n\u003cp\u003e检查事件的非常简单：\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cpre\u003eXEvent event;\u003cbr /\u003eXNextEvent(display, \u0026amp;event);\u003cbr /\u003eif (ev.xcookie.type == GenericEvent \u0026amp;\u0026amp;\u003cbr /\u003e    ev.xcookie.extension == opcode \u0026amp;\u0026amp;\u003cbr /\u003e    XGetEventData(dpy, \u0026amp;ev.xcookie))\u003cbr /\u003e{\u003cbr /\u003e    switch(ev.xcookie.evtype)\u003cbr /\u003e    {\u003cbr /\u003e        case XI_ButtonPress:\u003cbr /\u003e        case XI_Motion:\u003cbr /\u003e        case XI_KeyPress:\u003cbr /\u003e            do_something(ev.xcookie.data);\u003cbr /\u003e            break;\u003cbr /\u003e    }\u003cbr /\u003e}\u003cbr /\u003eXFreeEventData(dpy, \u0026amp;ev.xcookie);\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e\n  \u003cbr /\u003e对每个事件的数据进行更加细节的分析将在后面的文章中被介绍。\u003c/p\u003e\n\n\u003cp\u003e注意，你需要检查 XI 扩展的 opcode，和 XQueryExtension(3) 返回的 opcode 进行比较（如前所述）。 \u003c/p\u003e\n\n\u003cp\u003e就这么简单，有了这些信息，你已经可以开始写简单的监听所有设备的事件的程序了。在下一部分，我将介绍如何列出输入设备，并监听主/从设备层次结构发生的变化。\u003c/p\u003e\n","cover":"","link":"translation/2009/09/28/[译文]-xi2-食谱（1）/index.html","preview":"","title":"[译文] XI2 食谱（1）"},{"content":"\n\u003cp\u003e先让命令行亮相一下：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cfont face=\"Courier New\"\u003ecat conf/slaves| xargs echo |sed -e \u0026quot;s/ /,/g\u0026quot; | \\\u003c/font\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cfont face=\"Courier New\"\u003esed -e \u0026quot;s/^\\(.*\\)$/pdsh -f 200 -w \\\u0026quot;\\1\\\u0026quot; \\\u0026quot;jps|grep JobShell|cut -f1 -d\\' \\' |xargs kill -9 \\\u0026quot;/\u0026quot; | \\\u003c/font\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cfont face=\"Courier New\"\u003e /bin/bash \u003c/font\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e第一行主要就是将一行一个的 slave 整成全在一行里，逗号分隔，第一行的 sed 用 tr 也能干。\u003c/p\u003e\n\n\u003cp\u003e第二行的用途是整成一个 pdsh 命令行，这是个同时操作多台机器的工具，pdsh –w 后面是节点列表，也就是刚才那个一行的文件列表。后面用引号引起来一群命令行，这些命令行会送到每台计算机去执行，上面这行实际是去杀掉每个节点上的 JobShell Java 进程。最后，第三行里，是把上面合成的命令行交给 shell 执行\u003c/p\u003e\n\n\u003cp\u003e这个命令行看起来长，但实际上并不复杂，这里还有一个变形版本\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cfont face=\"Courier New\"\u003ecat conf/slaves| xargs echo |sed -e 's/ /,/g' | \\\u003c/font\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cfont face=\"Courier New\"\u003esed -e \u0026quot;s/^\\(.*\\)$/pdsh -f 200 -w \\\u0026quot;\\1\\\u0026quot;        \u003cbr /\u003e\\' for i in \u003cfont color=\"#ff0000\"\u003e\\`seq 2001 2100\\`\u003c/font\u003e;        \u003cbr /\u003edo\u0026#160; \\/share\\/home\\/testhdp\\/hadoop-0\\.19\\.2\\/bin\\/hadoop fs -touchz \u003cfont color=\"#ff0000\"\u003e\\`uname -n\\`\u003c/font\u003e\\.\u003cfont color=\"#ff0000\"\u003e\\$\u003c/font\u003ei ;         \u003cbr /\u003edone \\' /\u0026quot; | \\\u003c/font\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cfont face=\"Courier New\"\u003e /bin/bash\u003c/font\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e中间一行被断成四行写了，实际不应该断行的，这里面的头一部分和上面是一样的，之后的关键实际是怎么把反引号送出去，而不是当场在本机shell被直接变量替换了，实际处理很简单——将命令行放在单引号里，当然，各种引号和 i 前面的 $ 需要反斜线，否则在送到 bash 之前就被当前 shell 给解释了。这样处理后，反引号会被送到每台机器上，由那台机器上的shell来将反引号打开、变量替换也会在远程进行。\u003c/p\u003e\n\n\u003cp\u003e嗯，这个命令行长，但是并不很复杂，有兴趣的朋友可以修改并反馈哈。\u003c/p\u003e\n","cover":"","link":"scripts/2009/09/27/同时操作多台主机的命令行/index.html","preview":"","title":"同时操作多台主机的命令行"},{"content":"\n\u003cp\u003e今天在labs的站内消息看到这么一条：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e下午好！我是XXX网站的编辑。看了您博客上的文章，如果您并未在XXX上开博或已注册但很少使用，若您不介意的话，我们希望可以由我们动手为您在XXX上开博并自动转载您在博客上的文章。您无需维护，我们会为您申请好账号并自动同步更新文章，您即可得到更多的曝光率和个人知名度的提高。      \u003cbr /\u003e如果您想通过XXX这个平台推广出去，请将Email地址和您希望使用的xxxx账号回复给我。有任何疑问和问题均可联系我——电话：……；邮件：\u003ca href=\"mailto:keyan@csdn.net\"\u003e……\u003c/a\u003e；MSN：…...。       \u003cbr /\u003e[…..]\u003c/p\u003e\n\n\u003cp\u003e祝秋爽安康！ \u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e嗯，略过一些内容，总的讲，该网站有足够的水平，而且这条消息也很厚道，其实我都不介意不具名转载的，在我国这样以盗版为荣的地方，根本就不可能憧憬什么尊重版权的，而这个网站还会愿意帮我更新自己的博客，实在是非常难能可贵的，而且，以该网站的影响力，说极大增加我的曝光率和个人知名度绝非虚言。\u003c/p\u003e\n\n\u003cp\u003e呵呵，不知道有多少人收到编辑的消息了，要是就有少数几个收到的话，我真是受宠若惊了。\u003c/p\u003e\n\n\u003cp\u003e不过，我还是谢绝了他们，因为，我写blog的时候，无非就是与读者分享我的八卦与心得，不论是技术还是生活内容都是如此，对我来说，我差不多每天都来看有没有人comments我的blog，会为一句新增留言兴奋不已。我在给别人留言后，也会经常去那看看，有没有博主的回应。blog 是个交流的平台，而非单向发送，因此，我也不希望单纯地在该网站上发布，而冷落那里的访客，既然无力维护，就割爱吧。\u003c/p\u003e\n\n\u003cp\u003e嗯，等着回复差不多就是我公开发布这些不太成功的blog的原因，不知道其他人是什么原因啊。\u003c/p\u003e\n\n\u003cp\u003ePS：呵呵，路过的兄弟，顺便留个言吧，我这等的挺着急的，哈哈。\u003c/p\u003e\n","cover":"","link":"misc/2009/09/27/你为什么写blog？/index.html","preview":"","title":"你为什么写blog？"},{"content":"\n\u003cp\u003e我们成年人常常会忘记自己的生日，而小朋友似乎每个月的“生日”都会被注意到，更何况半岁这样的“整数”了。\u003c/p\u003e\n\n\u003cp\u003e斯屹今天一岁半了，最近两个周末，我们都把斯屹接到自己家这边来了，一方面让父母休息一下，另一方面也享受一下三口之家的生活。斯屹很享受这样的生活，他非常开心，以至于我们把他送回父母那里时都十分舍不得，而另一方面，这两天他都非常有精神，“舍不得”睡觉，“舍不得”停下来，我们俩都被他累的腰酸腿疼的，呵呵。\u003c/p\u003e\n\n\u003cp\u003e斯屹最近非常粘妈，最近两三个星期，只要妈妈在就会让妈妈抱，让妈妈推车，完全忽视我这个爸爸的存在。而如果妈妈不在，我就作为替补，会成为他的焦点。据说这是孩子成长的一个阶段，过去了可能就失去了，好好珍惜这些依赖吧。\u003c/p\u003e\n\n\u003cp\u003e斯屹的语言方面，他开始尝试组合了，如“妈妈抱抱”，“打鸟鸟”，“大袜袜”，“钓鱼鱼”……终于开始向复杂方面前进了\u003c/p\u003e\n\n\u003cp\u003e行动方面，小处讲，他更准确了，能比较准确的用磁性的吊钩吊起小鱼了；大处讲，他还是到处乱跑，爬凳子、桌子、床……通行能力空前强大，也让大人们十分害怕\u003c/p\u003e\n\n\u003cp\u003e行为方面，斯屹很有主见了，不论正着说反着说，他都不太会被绕进去，会坚持己见。另一方面也很会捣乱了，到处尿尿，然后指着喊“尿尿”，让大人们来打扫是他的一个惯用伎俩，常常会逗逗大人。\u003c/p\u003e\n\n\u003cp\u003e人际方面，有一点懂得害羞了，初到一个地方的时候会不太好意思，以至于今天徐萌居然说他像女孩，不过，熟了之后就会如常的捣乱了。斯屹手不太紧，会乐意的按照家长的要求，把东西送给其他人。\u003c/p\u003e\n\n\u003cp\u003e一提到孩子，似乎收不住了，就到这吧，早点休息了。\u003c/p\u003e\n","cover":"","link":"misc/2009/09/20/斯屹一岁半了/index.html","preview":"","title":"斯屹一岁半了"},{"content":"\n\u003cp\u003e这件始于03年的事情终于几乎尘埃落定了，而且结局基本还算圆满，目前，已经在china-pub, 卓越亚马逊和当当上看到这本书在卖了，回忆一下书里的故事吧。\u003c/p\u003e\n\n\u003cp\u003e嗯，最后说一下，稿酬还没拿到，也不是很清楚会拿到多少，呵呵，样书也还没拿到，等拿到后，我想我会送二三十本出去吧，估计会有自己买的部分，好多周围关心我的人都想管我要一本，毕竟周围有个人出本书，过程还这么磨磨蹭蹭的不多，我会尽力满足大家的，不过也不会送太多哈。\u003c/p\u003e\n\n\u003cp\u003e先说说书的由来——一方面，03-04年的我还少不更事，自视颇高，换做今天的心气，恐怕都不相信自己能写出这么多东西来了。另一方面，自己在折腾机器的同事也收藏了很多文档，有些有用的，有些没用的，有些错误的，有些过时的，良莠不齐，自己总想好好整理一下。于是，我竟然决定用一本书的形式来整理这些知识，顺便练习一下正在学习中的 LaTeX 和 CVS。那时候甚至直到现在的我，都挺喜欢写或翻译一些技术文章，肚子里没啥墨水却总喜欢卖弄点文笔，还喜欢“深入浅出”一下，于是就逐渐有了这本书。\u003c/p\u003e\n\n\u003cp\u003e关于书名——这本书在写的过程中曾用名很多，最著名的一个是 unleashed debian gnu/linux，简称 unleashed，这也是我的书的代号，这么叫就是学那本 red hat 的书的，其实我自己也不是特明白这里面的意思。期间还用过一个 《debian 的小康生活》的中文名字，最终，我希望它叫《Debian生活手册》，不过出版社说他们调查《Debian标准教程》这个名字是大家喜欢的，我想，既然麻烦他们这么多了，这里我就从了吧，于是书名就这样了。\u003c/p\u003e\n\n\u003cp\u003e关于署名——本来是王旭“编著”的，但我还是个挺好“名”，争面子的人的，和责编黄焱煲了可能有一个小时的电话粥，最后，他扛不住了，答应为我争下了一个“著”字，就为了这个，还在blog上写了一篇\u003ca href=\"http://wangxu.me/blog/?p=230\"\u003e酸文\u003c/a\u003e，哀叹现如今的世道，技术工作者们就算踏踏实实的干活，别人也觉得是抄的了。呃……这里我具体说一下，确实都是我敲的，没有从别人那贴的抄的东西，没有成段引用，有部分标明的文字引用，有引用手册页的内容，文责自负。\u003c/p\u003e\n\n\u003cp\u003e关于我的blog和那些在BBS上的帖子——书里大量使用了我曾经发在BBS和Blog里的内容，甚至有些实际是先写的章节，然后又发的blog或帖子。由于我的生活圈子有限，知识也是有限的，我可没有真的做到一切尽在掌握，于是，在写书的时候，也是以点带面，重点介绍我个人所使用的、配置的、熟悉的系统，而不是所有的系统。由于水平原因，起承转合自然也没有那么天衣无缝，所以唐sir（北邮的young），要么就是李sir（北邮的hop），评价说，\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e王旭这不是写书呢，他是在写杂志\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e嗯，对，是杂志，那时不流行寂寞呢。\u003c/p\u003e\n\n\u003cp\u003e关于稿酬啥的——我一直打心里特崇拜那些淡泊名利的大侠，但说实话，我也就是一个俗人，哪谈得上什么淡泊名利啊，又没有“千斤散尽还复来”的本事，当然还是看重稿酬的，虽然虚伪地表示不为了赚钱，但心里巴不得多给点呢。呵呵，不过还总不好意思提钱的事，所以就只好说不为了赚钱了。\u003c/p\u003e\n\n\u003cp\u003e关于GFDL——这本书在写作的大部分过程中是使用GFDL（GNU自由文档许可证）发布的，原因是因为我是\u003ca href=\"http://www.linuxfocus.org/Chinese/team/fdl.html\"\u003eGFDL最早的中文译者\u003c/a\u003e（据我所知还有另一个人在我之后也翻译了这个东东），也就是说，如果在网上找到并散播我的进入出版流程之前的版本是合法的，不算盗版，当然，未经我本人同意的大量印刷是不行的。至于后来没有使用的原因也很简单，在我国出版业似乎还罕有这种先例，我还没有足够的影响力说这些，既然想出版，就不要想那么理想化了，呵呵。\u003c/p\u003e\n\n\u003cp\u003e附一下这本书的一些相关链接：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e豆瓣上的链接：\u003ca title=\"http://www.douban.com/subject/4012031/\" href=\"http://www.douban.com/subject/4012031/\"\u003ehttp://www.douban.com/subject/4012031/\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003eChina-pub上的链接：\u003ca title=\"http://www.china-pub.com/47717\u0026amp;ref=browse\" href=\"http://www.china-pub.com/47717\u0026amp;ref=browse\"\u003ehttp://www.china-pub.com/47717\u0026amp;ref=browse\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e卓越亚马逊上的链接：\u003ca title=\"http://www.amazon.cn/mn/detailApp/ref=sr_1_1?_encoding=UTF8\u0026amp;s=books\u0026amp;qid=1253057777\u0026amp;asin=B002NPB9FU\u0026amp;sr=1-1\" href=\"http://www.amazon.cn/mn/detailApp/ref=sr_1_1?_encoding=UTF8\u0026amp;s=books\u0026amp;qid=1253057777\u0026amp;asin=B002NPB9FU\u0026amp;sr=1-1\"\u003ehttp://www.amazon.cn/mn/detailApp/ref=sr_1_1?_encoding=UTF8\u0026amp;s=books\u0026amp;qid=1253057777\u0026amp;asin=B002NPB9FU\u0026amp;sr=1-1\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e当当上的链接：\u003ca title=\"http://product.dangdang.com/product.aspx?product_id=20669783\" href=\"http://product.dangdang.com/product.aspx?product_id=20669783\"\u003ehttp://product.dangdang.com/product.aspx?product_id=20669783\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003eChina-Unix （有样章）：\u003ca title=\"http://bbs2.chinaunix.net/viewthread.php?tid=1380166\u0026amp;extra=\u0026amp;page=1\" href=\"http://bbs2.chinaunix.net/viewthread.php?tid=1380166\u0026amp;extra=\u0026amp;page=1\"\u003ehttp://bbs2.chinaunix.net/viewthread.php?tid=1380166\u0026amp;extra=\u0026amp;page=1\u003c/a\u003e\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e欢迎各位来围观 :)\u003c/p\u003e\n","cover":"","link":"misc/2009/09/17/我的书的那些事/index.html","preview":"","title":"我的书的那些事"},{"content":"\n\u003cp\u003e我写了五年的的 Debian GNU/Linux 的书上架啦！请\u003ca href=\"http://www.china-pub.com/47717\u0026amp;ref=browse\" target=\"_blank\"\u003e来 china-pub 围观\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.china-pub.com/47717\u0026amp;ref=browse\"\u003ehttp://www.china-pub.com/47717\u0026amp;ref=browse\u003c/a\u003e\u003c/p\u003e\n","cover":"","link":"misc/2009/09/15/上架啦！/index.html","preview":"","title":"上架啦！"},{"content":"\n\u003cp\u003e作者：\u003cstrong\u003eJonathan Corbet\u003c/strong\u003e\u003cbr /\u003e\n原文发布日期：July 21, 2009\u003cbr /\u003e\n来源：\u003ca title=\"http://lwn.net/Articles/342420/\" href=\"http://lwn.net/Articles/342420/\"\u003ehttp://lwn.net/Articles/342420/\u003c/a\u003e\u003cbr /\u003e\n译者：王旭 ( \u003ca href=\"http://wangxu.me\"\u003ehttp://wangxu.me\u003c/a\u003e , \u003ca href=\"http://twitter.com/gnawux\"\u003e@gnawux\u003c/a\u003e )\u003cbr /\u003e\n翻译时间：2009年9月14日\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e译者注：本来没准备翻译本系列的2，翻译文章实际上是译者的一种自我消遣方式，不过，翻译了1之后，有很多朋友的反应很不错，也有朋友在期待2，所以，就接着把2翻译了，时间仓促，翻译得不一定到位，请各位将就着看吧 :)\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e\u003ca href=\"http://wangxu.me/blog/?p=39\"\u003e本系列的第一篇\u003c/a\u003e详细分析了一长串的偶然错误，利用它们可以用一个空指针解引用来对内核进行攻击。清除这个 bug 本身可以直接修改；实际上在这个问题的本质被大部分人所理解之前就已经修正了。从这个意义上讲，这个问题本身相当小，很少有发布版带有有问题的内核版本。但是，这个攻击证明了，内核中会有一大类类似的问题，在被修正之前，绝对有攻击者有机会可以发现这些错误并利用它们。\u003c/p\u003e\n\n\u003cp\u003e一个显而易见的问题是，\u003cspan style=\"text-decoration: line-through;\"\u003e当安全模块机制被配置入内核的时候，管理员指定的最小合法用户控件虚拟地址会被忽略，\u003c/span\u003e安全模块允许覆盖管理员指定的最小合法用户空间地址限制（(\u003ctt\u003emmap_min_addr\u003c/tt\u003e）。这个行为颠覆了人们对安全模块工作的理解：它们被认为能够限制权限而从不增加权限。而在这种情况下，SELinux 的存在实际是增加了权限，大部分部署的 SELinux 都没能关闭这个漏洞（攻击代码的注释中指出，AppAmor 也不会更好）。\u003c/p\u003e\n\n\u003cp\u003e此外，当完全不配置安全模块的 时候，\u003ctt\u003emmap_min_addr\u003c/tt\u003e 也没有被完全强制执行。目前主线（译注：2.6.31）内核有一个补丁来保证 \u003ctt\u003emap_min_addr\u003c/tt\u003e sysctl 设置永远可用，这个补丁同时也被提交进入 2.6.27.27 和 2.6.30.2 更新了（以及其他的地方）。\u003c/p\u003e\n\n\u003cp\u003e问题同时也\u003ca href=\"http://blog.namei.org/2009/07/18/a-brief-note-on-the-2630-kernel-null-pointer-vulnerability/\"\u003e在SELinux层面进行了修复\u003c/a\u003e。Red Hat 未来的版本的 SELinux 将不再允许无限制的（在其他方面却无特权的）进程将页面映射到地址空间底端。虽然这里仍然有\u003ca href=\"http://lwn.net/Articles/342573/\"\u003e一些未解决问题\u003c/a\u003e，特别是像WINE这样的程序将陷入混乱。目前仍然不确定如何让系统安全地支持一小撮需要映射到0页面的程序。有个想法是让 WINE 以 root 权限运行，这样，或许太过类似 Windows 的行为了，这些想法只收到很少的关注。\u003c/p\u003e\n\n\u003cp\u003e另一个关于 \u003ctt\u003emap_min_addr\u003c/tt\u003e 的方法也必须要谈到：一个带有 SVR4 个性化的特权进程在 \u003ctt\u003eexec()\u003c/tt\u003e 的时候，会有一个只读页面映射到0页面。在十分罕见的情况下，一些老的 SVR4 程序会需要那里有这么一个页面，但是，它实际让空指针攻击成为了可能。于是，另一个被并入主线和稳定版更新中的补丁用来在 setuid 的程序运行的时候重置 SVR4 个性化（或者，至少重置那个关于映射0页面的部分）。\u003c/p\u003e\n\n\u003cp\u003e这个改变对有些用户仍然不够，他们\u003ca href=\"http://lwn.net/Articles/342425/\"\u003e要求\u003c/a\u003e能够完全关闭这个个性化功能。这个能力用于直接运行基于 386 的 Unix 的程序，其实已经没有它 1995 年的时候所拥有的重要性了，所以，很多人质疑是否值得为这个个性化特征付出这样的代价了。Linus \u003ca href=\"http://lwn.net/Articles/342427/\"\u003e答道\u003c/a\u003e：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我们可能可以扔掉那个愚蠢的特征。它已经不再那么重要了。有人真的关心么？同时，这么多年来，我们已经发展出了很多\u003cstrong\u003e其他\u003c/strong\u003e个性化标志，其中有些仍然是有用的。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e特别的，禁止地址空间随机化（一个个性化特征）的能力在很多情况下是很有用的。所以 \u003ctt\u003epersonality()\u003c/tt\u003e 应该被留下来，不过，0页映射的特征可能要一去不返了。\u003c/p\u003e\n\n\u003cp\u003e这一连串错误中的一个就是被编译器优化掉的空指针校验。这个校验可以阻止攻击，但 GCC 却把它优化掉了，因为理论上说这个指针不应该是空的（因为它已经被正常的解引用过了）。GCC（本身）有一个标志可以禁止某种特殊优化；所以，从现在开始，内核将缺省使用 \u003ctt\u003e-fno-delete-null-pointer-checks\u003c/tt\u003e 编译开关。由于在内核中空指针的确可能是个合法的指针，无限地禁止这种优化史合理的。\u003c/p\u003e\n\n\u003cp\u003e有人可能会提出，虽然所有上面的改变都是好的，但可能部分地没有切中要害：高质量的内核不应该在第一次发生的地方允许解引用空指针。这些解引用本身确实是 bug，这里才是最该修正的地方。这有些有趣的历史，实际上内核开发者们常常\u003ca href=\"http://lkml.org/lkml/2008/2/1/74\"\u003e被\u003c/a\u003e\u003ca href=\"http://lkml.org/lkml/2008/2/13/71\"\u003e建议\u003c/a\u003e忽略空指针校验。比如，如下 \u003ctt\u003eBUG_ON()\u003c/tt\u003e 代码：\u003c/p\u003e\n\n\u003cpre\u003e    BUG_ON(some_pointer == NULL);\n    /* dereference some_pointer */\u003c/pre\u003e\n\n\u003cp\u003e经常被以这样的注释而删除掉：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e如果我们解引用 NULL，那么内核将基本上会和 BUG 一样显示一个信息，也会采取相同的措施。所以添加一个 BUG_ON 实际无法得到任何收益。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这是因为，解引用空指针会导致一个内核 oops。表面上，这是合理的：如果我们的硬件可以检测到空指针解引用，那么添加软件开销来检测它没什么意义。但这个原因实际上不是无懈可击的，这次的攻击代码就说明了这一点。映射到0页确实是有一定原因的，所以，一个空指针未必总是非法的。你可能会假设所有相关开发者都理解这一点，但实际上内核中仍然有很多地方确实有游泳的空指针检验代码被删除掉了。\u003c/p\u003e\n\n\u003cp\u003e虽然如此，大部分内核中的空指针问题可能仅仅就是失察造成的。如果没有方法在相关代码中实际使用空指针的话，大部分的空指针问题是不可被利用的，缺少检验并不能带来什么。不过，如果能把它们全都修复肯定是件好事。\u003c/p\u003e\n\n\u003cp\u003e发现这些问题可能可以通过 \u003ca href=\"http://smatch.sourceforge.net/\"\u003eSmatch\u003c/a\u003e 静态代码分析工具。Smatch悄无声息很多年了，不过 Dan Carpenter 正在让它死灰复燃；他最近发布了 Smatch 为他发现的\u003ca href=\"http://lwn.net/Articles/342439/\"\u003e一个空指针 bug\u003c/a\u003e。如果 Smatch 能成为一个通用的发现此类错误的工具的话，内核将会更加安全。但不幸的是，这个检查器似乎没有吸引开发者们的很多兴趣，自由软件依旧落后这个领域中的先进技术很远，这让我们都很受伤。\u003c/p\u003e\n\n\u003cp\u003e另一个方法由 Kulia Lawall 所采用，她使用一个 \u003ca href=\"http://lwn.net/Articles/315686/\"\u003eCoccinelle\u003c/a\u003e “语义补丁”来发现并修复 TUN 驱动中发现的这种先解引用再检查的 bug。一系列补丁（\u003ca href=\"http://lwn.net/Articles/342440/\"\u003e例\u003c/a\u003e）被发布出来，用于修复一系列类似 bug。指针在检查之前被解引用可能只是内核中的空指针问题的一个子集，但每个都被程序员们认为有可能出现空指针，并且是有问题的。所以它们显然是应该被修复的。\u003c/p\u003e\n\n\u003cp\u003e总之，这个攻击代码可以看做是内核社区的一个起床号，十分幸运，它将帮助清理很多代码，并消灭很多安全问题。攻击代码的作者 Brad Spengler 还明确的希望得到更多：他经常会发布一些对于内核安全问题的关切：严重的内核安全 bug 被悄悄地修复，或在最差情况下被变为拒绝服务的问题。这个问题是否会改变现状呢，在内核环境中，很多 bug 会造成安全隐患，这些在 bug 被修复的时候并不会立刻显现出来。所以我们无法看到更多 bug 被以安全问题的方式被发布出来，不过幸运的是，我们将会看到更多的 bug 被修复。\u003c/p\u003e\n","cover":"","link":"translation/2009/09/14/null-pointers-2/index.html","preview":"","title":"[译文] 空指针的乐趣（2）"},{"content":"\n\u003cp\u003e[补充部分细节]\u003c/p\u003e\n\n\u003cp\u003e今天，我的亲爱的老婆、亲爱的孩子他妈，极其不幸的坠入井中，受到严重外伤，但又极其幸运的只是一些皮外伤。恳请大家和我一起为她祝福吧。\u003c/p\u003e\n\n\u003cp\u003e这篇blog以感谢开头\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e感谢老婆单位的实习生、也是她的师弟——靳盛浩，他在关键时刻用一只手将我的爱人从死亡线上拉了回来，他跑前跑后的张罗了很多事情，在我没有赶到医院的时候，是他在全心地照顾她；我向各位在招聘的朋友推荐这位有责任心的同学，向各位女同学推荐这个勇敢、细心、有爱心、值得托付的男人；\u003c/p\u003e\n\n\u003cp\u003e感谢那位不肯留下联系方式的的哥，稍后我会补充上他的一些可以查到的信息，他不仅把我老婆送到了医院，而且在我赶到前一直留在医院帮忙照顾，毫不计较留在车上的大量血迹；\u003c/p\u003e\n\n\u003cp\u003e感谢另一位在我赶到前帮忙的朋友，似乎是老婆的同事的同学，或是同学的同事，\u003c/p\u003e\n\n\u003cp\u003e感谢广安门医院的那位急诊大夫，他在我们找遍全市十余家（也可能是二十余家）大医院都找不到合适疫苗的时候，在辛苦帮我们通过繁琐手续找到疫苗的同时，还不忘安慰焦虑的我们；\u003c/p\u003e\n\n\u003cp\u003e感谢我的同事徐萌mm，不仅帮我把书包带回家，还亲自熬了小米粥送到我家。\u003c/p\u003e\n\n\u003cp\u003e还有其他很多帮忙的和出力的人，虽然我不知道或没能够一一点名，但你们已经是我们的生命中不可缺少的一部分了。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e此外，还有一条忠告，敬告各位亲朋好友、领导同事及亲属还有各位素未平生的朋友\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cspan style=\"color: #333333\"\u003e珍爱生命，远离井盖\u003c/span\u003e\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e具体场面过于血腥，这里只是向各位关心我们的朋友澄清事情的一些情况，就不过多描述了\u003c/p\u003e\n\n\u003cp\u003e今天中午，我老婆在酒仙桥附近某所测试的时候，午饭后，在踏上一个疑似不合格的井盖后，坠入井中。随后，井盖翻转一周，重新扣上，如果不是靳盛浩在场，移开井盖，后果不堪设想。\u003c/p\u003e\n\n\u003cp\u003e井中有深水，坠井后始终未触底，在老婆快要憋气不住呛水的时候，终于浮上水面，此时，靳盛浩已经移开井盖顺梯子下入井中，井中水面比井口开阔，所幸老婆浮上来的位置距离靳盛浩很近，他召唤我老婆伸手，并一把抓住，将她拉上来，此时老婆头部后面大量出血，随即被送往医院。谢天谢地，靳盛浩本科是军校毕业，而且读研究生前已经服役一年，感谢解放军啊，换做常人，不知道是否有如此迅速有效的施救。\u003c/p\u003e\n\n\u003cp\u003e送往医院的途中，老婆将我的电话号码告知靳盛浩，他和我联系，我立刻赶往医院，这时，一方面老婆语言还正常也还记得我的电话号码，但也无法记起自己所处位置等信息了。\u003c/p\u003e\n\n\u003cp\u003e我赶到医院的时候，她已经缝合完伤口，做完CT了，应无大碍。老婆满头满脸满身是血，衣服完全湿透，上身身着靳盛浩的外衣，裤子还穿着湿的，冻得浑身发抖，打吊瓶的时候，因为失血，血管都很不清晰了，十分心疼。\u003c/p\u003e\n\n\u003cp\u003e在后面的时间里，我照顾老婆，为老婆重新买了衣服；靳盛浩和的哥帮我们把和老婆一起落入井中的书包捞了回来，随后，老婆的领导们也来了。\u003c/p\u003e\n\n\u003cp\u003e中间的一个小插曲，老婆的第二袋药是治疗脑震荡的，但老婆对该药反应剧烈，心慌，心跳加速，满脸通红，幸亏她反应及时，并及时停止了注射，否则不堪设想。\u003c/p\u003e\n\n\u003cp\u003e其后，由于普通破伤风疫苗过敏，我们必须使用人免疫球蛋白，这个药需要24小时内注射，可是酒仙桥医院没有这种药，老婆公司的同事、我这边少陵所长，还有我父亲都参与到了找药的行列。最终，我父亲在中医研究院广安门医院、靳盛浩在人民医院分别找到了这个药。\u003c/p\u003e\n\n\u003cp\u003e虽然算不上什么好事，但也确实多磨，当我们赶到人民医院的时候，他们居然说药刚刚用完了，幸好广安门医院的医生如上所说，打了n个电话，帮我们开出了一支针剂，注射后观察了20分钟，我们离开医院回到家。\u003c/p\u003e\n\n\u003cp\u003e回来后，徐萌不仅给我送回来了我的书包，还送来了一盆小米粥，感谢这位善良体贴的mm，祝福她心想事成。\u003c/p\u003e\n\n\u003cp\u003e最后，在感谢大家的同时，诅咒一下那个不合格的井盖的责任人。另外，请各位注意安全，生命太tmd脆弱了，为了爱你和你爱的人，请保护好自己。\u003c/p\u003e\n","cover":"","link":"misc/2009/09/07/a-terrible-day/index.html","preview":"","title":"心有余悸"},{"content":"\n\u003cp\u003e作者：\u003cstrong\u003eJonathan Corbet\u003c/strong\u003e\u003cbr /\u003e\n原文发布日期：July 20, 2009\u003cbr /\u003e\n来源：\u003ca title=\"http://lwn.net/Articles/342330/\" href=\"http://lwn.net/Articles/342330/\"\u003ehttp://lwn.net/Articles/342330/\u003c/a\u003e\u003cbr /\u003e\n译者：王旭 ( \u003ca href=\"http://wangxu.me\"\u003ehttp://wangxu.me\u003c/a\u003e , \u003ca href=\"http://twitter.com/gnawux\"\u003e@gnawux\u003c/a\u003e )\u003cbr /\u003e\n翻译时间：2009年9月2-3日\u003c/p\u003e\n\n\u003cp\u003e现在，大部分读者都已经知道了 Brad Spengler 发布的“\u003ca href=\"http://lwn.net/Articles/341773/\"\u003ethe local kernel exploit\u003c/a\u003e”（本地内核漏洞利用）。这一漏洞会影响 2.6.30 内核（以及 RHEL5的一个测试版 2.6.18 内核），受到了多方关注。本文将详细分析如何利用这一漏洞，以及让这个漏洞得以成真的令人震惊的一连串错误。\u003c/p\u003e\n\n\u003cp\u003eTUN/TAP 驱动提供了一个虚拟的网络设备，它会建立一个隧道；这一驱动在多种场合都有很有用，包括虚拟化、VPN 等很多地方。使用 TUN 时，程序通常打开 \u003ctt\u003e/dev/net/tun\u003c/tt\u003e，然后使用 \u003ctt\u003eioctl()\u003c/tt\u003e 调用来建立网络端点。Herbert Xu 近来注意到，缺少对包的审计可能会导致恶意程序能够占用大量的内核内存，并导致系统性能下降。他的解决方案是通过\u003ca href=\"http://git.kernel.org/?p=linux/kernel/git/torvalds/linux-2.6.git;a=commitdiff;h=33dccbb050bbe35b88ca8cf1228dcf3e4d4b3554\"\u003e一个补丁\u003c/a\u003e给该设备添加一个“伪 socket”，使它可以使用内核的审计机制。问题是解决了，但是，回头看来，它的代价是已入了一个更严重问题。\u003c/p\u003e\n\n\u003cp\u003eTUN 设备支持 \u003ctt\u003epoll()\u003c/tt\u003e 系统调用。（在 2.6.30 内核中）实现这个功能的函数的开头是这样的：\u003c/p\u003e\n\n\u003cpre\u003e    static unsigned int tun_chr_poll(struct file *file, poll_table * wait)\n    {\n\tstruct tun_file *tfile = file-\u0026gt;private_data;\n\tstruct tun_struct *tun = __tun_get(tfile);\n\t\u003cspan style=\"text-decoration: underline;\"\u003estruct sock *sk = tun-\u0026gt;sk;\u003c/span\u003e\n\tunsigned int mask = 0;\n\n\tif (!tun)\n\t    return POLLERR;\u003c/pre\u003e\n\n\u003cp\u003e上面有下划线的的那行代码是 Herbert 的补丁中添加的，这正是惹祸的开始。精心编写的内核代码都会小心的避免对指针的解引用，以避免 NULL；事实上，这里只在那个条件语句那里检查了 \u003ctt\u003etun\u003c/tt\u003e 指针。并且，这是件好事；现在看来，如果进行了 configuring \u003ctt\u003eioctl()\u003c/tt\u003e 调用，\u003ctt\u003etun\u003c/tt\u003e 确实将是 NULL。这时，按照预期，本来 \u003ctt\u003etun_chr_poll()\u003c/tt\u003e 应该返回一个错误状态。\u003c/p\u003e\n\n\u003cp\u003e但 Herbert 的补丁添加的指针解引用是在检查之前的，这显然是一个 bug。在正常操作中，这个 bug 的影响会比较有限，如果 \u003ctt\u003etun\u003c/tt\u003e 是 NULL 的话，会导致内核 oops。oops 会首先杀掉进行这个系统调用的进程，并将回溯信息加入系统日志，此外就不应该发生什么其他的事情了。最坏情况下，这应该也就是个拒绝服务问题。\u003c/p\u003e\n\n\u003cp\u003e依照上述推理，这是一个小问题，虽人 NULL （0）可能确实是个合法的指针地址。缺省的，不论在用户空间还是内核空间，虚拟地址空间的底部（“0页”和它上面的一些页面）都是不允许任何访问的，以用来捕捉空指针错误（如上描述）。不过，使用 \u003ctt\u003emmap()\u003c/tt\u003e 系统调用将真实的内存映射到虚拟地址空间的底部仍然是可能的。这个功能有一些合法的用例，包括运行一些过时的程序。尽管如此，大部分现代的系统都通过使用 \u003ctt\u003emmap_min_addr\u003c/tt\u003e sysctl 设置来禁止映射到0页。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e安全模块检查被认为可以作为内核已经进行了的检查的一个补充，但这次，它并没有如愿工作。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这一设置应该阻止用户空间的程序区映射零页，这也就保证了空指针的解引用只会导致一次内核的oops。但是，不知何故，如果安全模块机制被配置入内核的话，2.6.30 中的 \u003ctt\u003emmap()\u003c/tt\u003e 的代码会显示地拒绝执行 \u003ctt\u003emmap_min_addr\u003c/tt\u003e 。取而代之的是将这个工作留给特定的安全模块来进行。安全模块的检查工作被认为是内核中已有的检查工作的一个补充，但它此时却并不工作。对于 0 页，安全模块会授权访问，而其他情况下则会拒绝访问。这个错误的最后一步是，Red Hat 的缺省 SELinux policy 允许映射 0 页。这样，运行 SELinux 实际是降低了系统的安全性。\u003c/p\u003e\n\n\u003cp\u003e但没有 SELinux 的生活也不是就一马平川了。在没有 SELinux 的时候，攻击行为会被 \u003ctt\u003emmap_min_addr\u003c/tt\u003e 限制，这似乎足够让一切结束了。但这是可以通过使用 \u003ctt\u003epersonality()\u003c/tt\u003e 系统调用绕过的。打开 SVR4 个性化会在程序被 \u003ctt\u003eexec()\u003c/tt\u003e 调用的时候将一个只读页面映射到 0 地址，但只有进程有 CAP_SYS_RAWIO 能力的时候才会这样。所以，需要一个更进一步的欺诈行为：顶级的攻击代码设置 SVR4 更兴华，然后使用 exec 运行有特殊插件的 pulseaudio 服务器。pulseaudio 服务器是 setuid root 的，所以它将会在调用时映射到 0 页面。当调用到插件代码的时候，pulseaudio 将会放弃它的权限，但是，这时 0 页已经对攻击代码可用了，攻击代码可以让 0 页可写，并将其自己的数据放在这里。\u003c/p\u003e\n\n\u003cp\u003e上面这些攻击的结果就是，用户空间进程是有可能映射0页而不让 \u003ctt\u003etun_chr_poll()\u003c/tt\u003e 发生内核 oops。不过，你可能会想，攻击者还不能高兴得太早，毕竟接下来 \u003ctt\u003etun\u003c/tt\u003e 就会检查空指针。这正是这一系列错误中的下一个：GCC编译器缺省会优化掉 NULL 的彻底检验。原因在于，因为这个指针已经被解引用过了（而且也什么都没发生），所以它不可能是 NULL。所以，没有理由再去检查它了。于是，尽管这个逻辑本来在大部分情况下都有效，但是在 NULL 是一个合法指针的时候却是错误的。\u003c/p\u003e\n\n\u003cp\u003e所以，攻击者这时就能通过一个空 \u003ctt\u003etun\u003c/tt\u003e 指针而成功进入 \u003ctt\u003etun_chr_poll()\u003c/tt\u003e 内部了。接下来需要指出如何利用这种情况控制内核。\u003ctt\u003etun_chr_poll()\u003c/tt\u003e 中后面的下一步代码是这样的：\u003c/p\u003e\n\n\u003cpre\u003e\tif (sock_writeable(sk) ||\n\t    (!test_and_set_bit(SOCK_ASYNC_NOSPACE, \u0026amp;sk-\u0026gt;sk_socket-\u0026gt;flags) \u0026amp;\u0026amp;\n\t     sock_writeable(sk)))\n\t\tmask |= POLLOUT | POLLWRNORM;\u003c/pre\u003e\n\n\u003cp\u003e注意，\u003ctt\u003esk\u003c/tt\u003e 的值来自于 \u003ctt\u003etun\u003c/tt\u003e 的解引用，所以它位于攻击者的控制之下。\u003ctt\u003eSOCK_ASYNC_NOSPACE\u003c/tt\u003e 是 0，所以 \u003ctt\u003etest_and_set_bit()\u003c/tt\u003e 调用可以用于设置内存中任何字的最低权重位。这是个小小的内存冲突，但这已经被证实是足够的了，在 Brad 展示的攻击代码中，\u003ctt\u003esk-\u0026gt;sk_socket-\u0026gt;flags\u003c/tt\u003e 指针指向了 TUN 驱动的 \u003ctt\u003efile_operations\u003c/tt\u003e 结构；特别的，它是指向了 \u003ctt\u003emmap()\u003c/tt\u003e 函数。TUN驱动不支持 \u003ctt\u003emmap()\u003c/tt\u003e 调用，所以这个指针通常应该是 NULL，在 \u003ctt\u003epoll()\u003c/tt\u003e 调用之后，它就是 1 了。\u003c/p\u003e\n\n\u003cp\u003e攻击代码的最后一步就是调用这个打开的 TUN 设备的文件描述符的 \u003ctt\u003emmap()\u003c/tt\u003e 调用。由于内部的 \u003ctt\u003emmap()\u003c/tt\u003e 已经不是空了（刚刚被我们设置成了 1），内核将会跳到哪里。那个地址已经在攻击代码所映射的0页面中了，所以，它在攻击者的控制之下。于是，攻击代码使用下一个跳转跳到其自己的代码处即可。这样，当内核调用（它以为的）TUN 驱动的 \u003ctt\u003emmap()\u003c/tt\u003e 函数的时候，结果就是任意代码都可以在内核模式下运行；这里，攻击代码获得了完全的控制权。\u003c/p\u003e\n\n\u003cp\u003e在一个良好设计的系统中，一个单独的错误很少导致灾难性的故障。而这里就是这样一个例子。很多东西都出错才导致了这个攻击成为可能：安全模块能够不顾系统策略而授权访问地位内存，SELinux 策略允许这些映射，pulseaudio 可以被攻击代码利用从而让这一映射可以被攻击代码使用，空指针在解引用之前未被检验，并且检验被编译器优化掉了，代码以某种方式使用空指针可以获取系统的控制权。这是一条长长的错误链，其中的每一环节都是让这一攻击成功的必要条件。\u003c/p\u003e\n\n\u003cp\u003e这个漏洞如今已经被关闭了，不过几乎可以肯定还有类似的问题。本系列的\u003ca href=\"http://lwn.net/Articles/342420/\"\u003e下一篇文章\u003c/a\u003e将会介绍内核开发者们如何应对这一攻击行为。\u003c/p\u003e\n","cover":"","link":"translation/2009/09/04/null-pointers-1/index.html","preview":"","title":"[译文] 空指针的乐趣（1）"},{"content":"\n\u003cp\u003e作者：Neil Brown\u003cbr /\u003e\n原文发布日期：June 8, 2009\u003cbr /\u003e\n来源：\u003ca title=\"http://lwn.net/Articles/336224/\" href=\"http://lwn.net/Articles/336224/\"\u003ehttp://lwn.net/Articles/336224/\u003c/a\u003e\u003cbr /\u003e\n译者：王旭 ( \u003ca href=\"http://wangxu.me\"\u003ehttp://wangxu.me\u003c/a\u003e , \u003ca href=\"http://twitter.com/gnawux\"\u003e@gnawux\u003c/a\u003e )\u003cbr /\u003e\n翻译时间：2009年8月29-30日\u003c/p\u003e\n\n\u003cp\u003e[译注：初稿，未经审校，欢迎意见建议。]\u003c/p\u003e\n\n\u003cp\u003e内核社区中，始终受到关注的一个话题便是维持代码质量。显而易见，我们需要维护乃至提高内核的质量，不过，如何能更好的做到这一点却不那么显而易见了。一个已经取得一定成果的普适方法便是提升内核的各个方面的可见性。这将让这些方面的质量更加透明，进而可以提高它们的质量。\u003c/p\u003e\n\n\u003cp\u003e可见性的提高以不同的形式发生：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003ctt\u003echeckpatch.pl\u003c/tt\u003e 脚本会检查代码的各式风格，将不一致的风格高亮标出，这会帮助（还记得使用这个脚本的）人们来修正代码风格上的错误。这样，通过提高代码风格指南的可见性，我们统一了代码的外观，于是在某种意义上说，提高了质量。\u003c/li\u003e\n\n\u003cli\u003e在打开“lockdep”系统时，它可以动态计算锁（以及相关状态，比如是否允许中断等）之间的依赖性。如果有什么东西看起来比较异常的话，它会进行报告。这些异常并非总意味着可能死锁或有类似问题，但很多时候确实如此，而且这种死锁可能性是可以被消除掉的。这样，通过提升锁依赖关系图的可见性，可以提高代码质量。\u003c/li\u003e\n\n\u003cli\u003e内核还包含着其他的可见性改进，如对不用的内存空间进行“poisoning（下毒）”，这样非法访问将更为明显，或者通过在 stack trace 中直接使用符号名称替代十六进制地址，从而使得 bug 报告能更有意义。\u003c/li\u003e\n\n\u003cli\u003e在更高层面上，用于跟踪内核变化的”git”版本管理系统让观察补丁提交的时间和补丁作者变得十分容易。它鼓励让每个补丁的提交者都附加一个说明，由此可以获知为什么代码应该是这样的。这个可见性可以帮助理解代码，并且由于更多开发者能更好地了解代码的含义，从而可以提高质量。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e除此之外，还有很多种方法可以提高其他方面的可见性，从而提高代码质量。在本系列文章中，我们将探讨一个特定的领域，这让作者们可以感到可见性可以发生质的改变的方式改进。这个领域就是阐明内核特定的设计模式。\u003c/p\u003e\n\n\u003ch6\u003e设计模式\u003c/h6\u003e\n\n\u003cp\u003e“设计模式”这个概念最早见于建筑学，1994年出版的《设计模式：可重用面向对象软件元素》一书将这个概念引入到了计算机工程，特别是面向对象编程领域之中。Wikipedia上有关于此主题的\u003ca href=\"http://en.wikipedia.org/wiki/Design_pattern_%28computer_science%29\"\u003e更加深入的介绍\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e简而言之，设计模式描述了一类特定的设计问题，并描述了已经被验证有效的解决这一类问题的方法细节。设计模式的一个特别的好处是，它将问题描述与解决方法的描述结合在一起并进行命名。一个模式具有一个简单好记的名称非常有好处。如果开发者和审阅者都知道一个模式的名字，那么重要的设计决策就可以用一两个词就做到有效沟通，决策问题也就变得非常具有可视性了。\u003c/p\u003e\n\n\u003cp\u003e在 Linux 内核代码中，很多设计模式都已经被证实是有效的了。不过，它们中的大多数都还从来没有被文档化过，对其他开发者来说也就不怎么可用了。我的希望就是显式地描述这些模式，让这些模式被更广泛地使用，进而开发者可以更快更有效的解决常见问题。\u003c/p\u003e\n\n\u003cp\u003e在本系列文章的后面的部分，我们将考察三个问题域，并从中发现适用范围和重要性迥然不同的各种设计模式。我们的目标不仅是描述这些模式，而且要介绍这些模式适用的范围和所具有的价值，这样，其他人也可以尝试来描述他们遇到的模式。\u003c/p\u003e\n\n\u003cp\u003e这个系列中将引用很多 Linux 内核中的例子，因为例子是解释模式的一个重要部分。如无特殊声明，这些例子都取自2.6.30-rc4。\u003c/p\u003e\n\n\u003ch6\u003e引用计数\u003c/h6\u003e\n\n\u003cp\u003e使用引用计数来管理对象的生命周期的想法非常普遍。核心思想就是使用一个计数器，当有一个新引用的时候就加一，释放引用的时候就减一。当计数器到达0的时候，这个对象所占用的所有资源（如用于存储它本身的内存）就都可以释放了。\u003c/p\u003e\n\n\u003cp\u003e管理引用计数的机制看起来非常直接。不过，实际上有一些陷阱会使得它非常容易出错。部分的处于这个原因，Linux 内核（自从 2004 年）就有了一个“kref”类型和一组相关机制（参考 \u003ctt\u003eDocumentation/kref.txt\u003c/tt\u003e, \u003ctt\u003e\u0026lt;linux/kref.h\u0026gt;\u003c/tt\u003e, 和 \u003ctt\u003elib/kref.c\u003c/tt\u003e）。这些方法封装了一部分陷阱，特别的，让一个计数器明确地作为引用计数被以一种特定的方式来使用。如上所述，设计模式的名称非常有价值，开发者只提供要使用的设计模式的名字对于审阅者非常有好处。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://lkml.indiana.edu/hypermail/linux/kernel/0403.1/1656.html\"\u003eAndrew Morton 语录\u003c/a\u003e：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我更希望开发者们能这么说：“啊，这里用了kref。这样，我理解它用了 refcounting，我知道它被很好的 debug 了，并且知道它能处理一般的错误了。”这比下面这样强多了：“哦，这个东西实现了自己的refcounting --- 这样我就得在这里对常见错误进行审阅”。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003eLinux 内核中引入 kref  为其显式支持设计模式既打了一个勾也打了一个叉。勾就是 kref 就是具体实现了一个重要的设计模式，良好的文档化，并在使用的时候使得代码清晰可见。而这个叉则是因为 kref 仅仅封装了部分关于引用计数的内容。有些引用计数的应用并未被 kref 模型所惠及，稍后我们将看到。一个没有提供所需的方法的引用计数具有“blessed”机制实际可以导致错误，因为人们可能会在 kref 不该使用的地方使用它，在实际上它不能工作的地方认为它可以工作。\u003c/p\u003e\n\n\u003cp\u003e了解引用计数的复杂性的有用的第一步是要了解，经常有两类截然不同的引用指向某个对象。事实上，可能会有三类甚至更多，但这并不常见，并且可以被理解成为更广义的两类的情况。我们将这两类引用称为“外部的”和“内部的”，虽然有的场合“强的”和“弱的”可能更合适一些。\u003c/p\u003e\n\n\u003cp\u003e“外部”引用是指我们最习惯于考虑到的引用。外部引用在“get”与“put”的时候被计数，可以被与管理对象的子系统相去甚远的子系统所持有。一个对象的外部引用的存在代表着一个强烈而简单的含义：对象在使用中。\u003c/p\u003e\n\n\u003cp\u003e与之相对应的，“内部”引用常常会被忽略，它仅在管理对象的系统内部（或与其密切相关的系统内）持有。不同的内部引用具有不同的含义，因此实现的含义也十分不同。\u003c/p\u003e\n\n\u003cp\u003e最常见的内部引用的例子是提供“按名称查询”服务的缓存。如果你知道了一个对象的名称，那么只要缓存中确实存在这个对象，就可以通过缓存来得到一个外部引用。这个缓存会在一个列表或一组链表中的一个链表，如一个哈希表中保存每个对象。这个列表中存在的对象实际是一个对对象的引用。但是它却不应该是一个被计数的引用。它不具有“对象在使用中”这样的语义，而仅仅是“当有人想用这个对象的时候，它是可用的”。在所有外部引用被释放之前，对象将一直不会被从列表中删除，而且即使所有外部引用都被释放的时候，它也可能不会被立刻从列表中删除。内部引用的存在和本意喻示着着引用计数的实现方式。\u003c/p\u003e\n\n\u003cp\u003e一个有用的对不同引用计数风格进行分类的方法是通过其所需要的“put”操作的实现来进行区分。“get”方法一般是一样的。它获取一个外部引用，并产生了另一个外部引用。它的实现差不多是这样的：\u003c/p\u003e\n\n\u003cpre\u003e    assert(obj-\u0026gt;refcount \u0026gt; 0) ; increment(obj-\u0026gt;refcount);\u003c/pre\u003e\n\n\u003cp\u003e或者如 Linux 内核中的 C 代码：\u003c/p\u003e\n\n\u003cpre\u003e    BUG_ON(atomic_read(\u0026amp;obj-\u0026gt;refcnt)) ; atomic_inc(\u0026amp;obj-\u0026gt;refcnt);\u003c/pre\u003e\n\n\u003cp\u003e注意，“get”不能被用于一个已经被释放了的对象。还需要一些其他的处理。\u003c/p\u003e\n\n\u003cp\u003e“put” 操作有三个变种。尽管在用例上还有一些重叠，但区分这三者对于保持代码的简洁是有好处的。这三种方式以 Linux C 的写法是这样的：\u003c/p\u003e\n\n\u003cpre\u003e   1      atomic_dec(\u0026amp;obj-\u0026gt;refcnt);\n\n   2      if (atomic_dec_and_test(\u0026amp;obj-\u0026gt;refcnt)) { ... do stuff ... }\n\n   3      if (atomic_dec_and_lock(\u0026amp;obj-\u0026gt;refcnt, \u0026amp;subsystem_lock)) {\n                 ..... do stuff ....\n\t\t spin_unlock(\u0026amp;subsystem_lock);\n\t  }\u003c/pre\u003e\n\n\u003ch6\u003e\"kref\" 风格\u003c/h6\u003e\n\n\u003cp\u003e从中间一种方法开始，第2项是 kref 使用的风格。这个风格适用于对象没有其外部引用活得长的情况。当引用计数到达0的时候，对象需要被释放，否则就要进行处理，这就需要使用 \u003ctt\u003eatomic_dec_and_test()\u003c/tt\u003e 来检查引用计数为为0的情况。\u003c/p\u003e\n\n\u003cp\u003e符合这一风格的对象通常都没有需要顾虑的内部引用，大部分 sysfs 中的对象就是这样，它们也使用了大量的 kref。但如果一个使用 kref 风格引用计数的对象有内部引用，那么它就不允许用一个内部引用来创建外部引用，除非能确定仍有其它的外部引用。如果有此必要，可以使用如下原语：\u003c/p\u003e\n\n\u003cpre\u003e     atomic_inc_not_zero(\u0026amp;obj-\u0026gt;refcnt);\u003c/pre\u003e\n\n\u003cp\u003e这样，在计数器不为零的情况下自加，返回值指示操作是否成功。在 linux 内核中，\u003ctt\u003eatomic_inc_not_zero()\u003c/tt\u003e 是一个较新引入的操作，在2005年末作为不加锁的 page cache 的一部分引入。因而，这个原语的使用还不够广泛，一些本可以使用这个原语的代码使用了自旋锁。遗憾的是，kref 包也没使用它。\u003c/p\u003e\n\n\u003cp\u003e这个风格的引用有一个没用 kref 的有意思的例子，甚至连 \u003ctt\u003eatomic_dec_and_test()\u003c/tt\u003e 都没有用（虽然实际可以用并且确实应该用），这就是 struct super 里面的两个引用计数：\u003ctt\u003es_count\u003c/tt\u003e 和 \u003ctt\u003es_active \u003c/tt\u003e。\u003c/p\u003e\n\n\u003cp\u003e\u003ctt\u003es_active\u003c/tt\u003e 非常符合 kref 的风格。超级块的生命周期开始时 \u003ctt\u003es_active\u003c/tt\u003e 为1（\u003ctt\u003ealloc_super()\u003c/tt\u003e 中设置），并且，当 \u003ctt\u003es_active\u003c/tt\u003e 变成零之后，就无法再获取外部引用了。这个规则位于 \u003ctt\u003egrab_super()\u003c/tt\u003e，虽然超级块没有立刻被清除。当前的代码（由于历史原因）在 \u003ctt\u003es_active\u003c/tt\u003e 非零时给加上一个很大的数（S_BIAS），而 \u003ctt\u003egrab_super()\u003c/tt\u003e 去检查 \u003ctt\u003es_count\u003c/tt\u003e 是否超过 S_BIAS 而不是 \u003ctt\u003es_active\u003c/tt\u003e 是否为零。后面这次检查实际上可以直接使用 \u003ctt\u003eatomic_inc_not_zero()\u003c/tt\u003e，从而避免使用自旋锁。\u003c/p\u003e\n\n\u003cp\u003e\u003ctt\u003es_count \u003c/tt\u003e提供了另一类不同类型的引用，既是内部引用，又是外部引用。它的内部。从语义远弱于 \u003ctt\u003es_active\u003c/tt\u003e 方面说，它是内部引用计数。\u003ctt\u003es_count\u003c/tt\u003e 引用计数的意思仅在于“超级块还不能立刻被释放”，而不检查它是否真的处于 active 状态。而它却又非常类似 kref 那样，从 1 开始生命周期（实际是 1*S_BIAS），当它到 0 的时候（在 \u003ctt\u003e__put_super()\u003c/tt\u003e 中）超级块就被销毁了，从这个意义上讲又是外部引用计数。\u003c/p\u003e\n\n\u003cp\u003e只要进行如下操作，这两个引用计数就可以用两个 kref 所代替：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eS_BIAS 置为 1\u003c/li\u003e\n\n\u003cli\u003e\u003ctt\u003egrab_super()\u003c/tt\u003e 使用 \u003ctt\u003eatomic_inc_not_zero()\u003c/tt\u003e 原语，而不是和 S_BIAS 进行比较\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这样，很多自旋锁都可以不用了。具体细节可以作为练习留给各位读者了。\u003c/p\u003e\n\n\u003ch6\u003e\"kcref\" 风格\u003c/h6\u003e\n\n\u003cp\u003eLinux 内核并没有 “kcref” 对象，但这个名字似乎适用于接下来的这种引用计数风格。“c”是指的“缓存（cached）”，这种风格经常用于缓存之中。所以可以称为 Kernel Cached REFerence。\u003c/p\u003e\n\n\u003cp\u003ekcref 引用计数如上面第三种情况使用 \u003ctt\u003eatomic_dec_and_lock()\u003c/tt\u003e 。这是因为，最后一次 put 的时候，需要释放掉资源或检验是否需要其他特定的处理。这需要进行一次加锁来保证当前状态被重新求值期间不会再产生新的引用。\u003c/p\u003e\n\n\u003cp\u003e一个简单的例子是 \u003ctt\u003estruct inode \u003c/tt\u003e中的 \u003ctt\u003ei_count\u003c/tt\u003e 引用计数。\u003ctt\u003eiput()\u003c/tt\u003e 中的主要部分是这样的：\u003c/p\u003e\n\n\u003cpre\u003e    if (atomic_dec_and_lock(\u0026amp;inode-\u0026gt;i_count, \u0026amp;inode_lock))\n\tiput_final(inode);\u003c/pre\u003e\n\n\u003cp\u003e其中 \u003ctt\u003eiput_final()\u003c/tt\u003e 检验 inode 的状态，并决定它是否可以被销毁，或是还要留在缓存中，以备稍后重用。\u003c/p\u003e\n\n\u003cp\u003e特别的，\u003ctt\u003einode_lock\u003c/tt\u003e 会阻止从 inode 哈希表中的内部引用建立外部引用。由于这个原因，仅有持有 \u003ctt\u003einode_lock\u003c/tt\u003e 的时候才能将内部引用转化为外部引用。支持这个操作的函数称为 \u003ctt\u003eiget_locked()\u003c/tt\u003e （或 \u003ctt\u003eiget5_locked()\u003c/tt\u003e）。\u003c/p\u003e\n\n\u003cp\u003e略有一点复杂的例子是 \u003ctt\u003estruct dentry\u003c/tt\u003e，这里的 \u003ctt\u003ed_count\u003c/tt\u003e 是用的类似 kcref 的方式管理的。它更复杂一些的原因在于在我们获得引用之前，需要先获取两个锁—— \u003ctt\u003edcache_lock\u003c/tt\u003e 和 \u003ctt\u003ede-\u0026gt;d_lock\u003c/tt\u003e。这要求我们必须先获得一个锁，然后再用 \u003ctt\u003eatomic_dec_and_lock()\u003c/tt\u003e 来获取另一个（如 \u003ctt\u003eprune_one_dentry\u003c/tt\u003e 之中），或者先用 \u003ctt\u003eatomic_dec_and_lock()\u003c/tt\u003e 然后请求另一个锁并重新检查引用计数，如 \u003ctt\u003edput()\u003c/tt\u003e 中的操作。这是一个很好的例子，它说明了你永远不能肯定你已经封装了所有的可能的引用计数风格。需要两个锁的情况很难被预见到。\u003c/p\u003e\n\n\u003cp\u003e一个更复杂的例子是 \u003ctt\u003estruct vfsmount\u003c/tt\u003e 中的 \u003ctt\u003emnt_count\u003c/tt\u003e。这里的复杂性源于两个引用计数的相互影响：\u003ctt\u003emnt_count\u003c/tt\u003e 是一个典型的外部引用计数，而 \u003ctt\u003emnt_pinned\u003c/tt\u003e 是进程审计模块的内部引用计数。特别地，它统计文件系统中打开的审计文件的数量（实际应该使用个更贴切的名字）。复杂性来自于当只有内部引用存在的时候，它们将全被转化为外部引用。关于这个例子的细节同样留作练习，留给感兴趣的读者。\u003c/p\u003e\n\n\u003ch6\u003e\"plain\"风格\u003c/h6\u003e\n\n\u003cp\u003e最后一种引用计数涉及到的风格就是直接对引用计数进行减值操作（\u003ctt\u003eatomic_dec()\u003c/tt\u003e）而不做其他任何事情。这个风格在内核中并不常见，必须有充分的理由才会使用。毕竟随意放着一个无人饮用的对象不是个好主意。\u003c/p\u003e\n\n\u003cp\u003e这个风格的一个例子出现在 \u003ctt\u003estruct buffer_head\u003c/tt\u003e 中，位于 \u003ctt\u003efs/buffer.c\u003c/tt\u003e 和 \u003ctt\u003e\u0026lt;linux/buffer_head.h\u0026gt;\u003c/tt\u003e。函数非常简单 \u003ctt\u003eput_bh()\u003c/tt\u003e：\u003c/p\u003e\n\n\u003cpre\u003e    static inline void put_bh(struct buffer_head *bh)\n    {\n        smp_mb__before_atomic_dec();\n        atomic_dec(\u0026amp;bh-\u0026gt;b_count);\n    }\u003c/pre\u003e\n\n\u003cp\u003e这样做没什么问题，因为 buffer_heads 有它们自己的生命周期管理规则，他们是紧密和页相关的。一个页面中会分配出一个或多个 buffer_heads，以分成小片（buffer）。它们会被保存着，直到页面本身被释放，这时，所有的 buffer_heads 都会被清除（通过 \u003ctt\u003etry_to_free_buffers()\u003c/tt\u003e 调用 \u003ctt\u003edrop_buffers()\u003c/tt\u003e）。\u003c/p\u003e\n\n\u003cp\u003e通常，”plain”风格适用于那些内部引用会一直存在，对象不会丢的情况，这个内部引用的所在的进程会最终找到并释放对象。\u003c/p\u003e\n\n\u003ch6\u003e反模式（Anti-patterns）\u003c/h6\u003e\n\n\u003cp\u003e现在要回顾一下这个引用计数来作为设计模式的介绍，我们将要讨论反模式的相关概念。设计模式都是已经经过检验可以工作的方法，并应该鼓励使用，而反模式则是那些已经证明不能良好工作，并应被慎用的。\u003c/p\u003e\n\n\u003cp\u003e作者建议把在引用计数中使用”偏置（bias）“作为一个反模式的例子。偏置是一个大数，在引用计数中进行加减，它被用于保存一些信息。我们已经在超级块的 \u003ctt\u003es_count\u003c/tt\u003e 中见过这种方式了。在这个例子中，偏置的存在表示 \u003ctt\u003es_active\u003c/tt\u003e 是非零值，这很容易直接检验。所以偏置实际没有任何价值，只是使得代码的真实用意更不清楚了。\u003c/p\u003e\n\n\u003cp\u003e另一个使用偏置的例子是 \u003ctt\u003efs/sysfs/sysfs.h\u003c/tt\u003e 和 \u003ctt\u003efs/sysfs/dir.c \u003c/tt\u003e中的 \u003ctt\u003estruct sysfs_dirent \u003c/tt\u003e。十分有趣，\u003ctt\u003estruct sysfs_dirent\u003c/tt\u003e 和超级块一样，有两个以用，也是叫做 \u003ctt\u003es_count\u003c/tt\u003e 和 \u003ctt\u003es_active\u003c/tt\u003e。这里，当选项被去激活时，\u003ctt\u003es_active\u003c/tt\u003e 有一个大的负数偏置。同样信息可以被有效并更清晰地存储在一个标志字 \u003ctt\u003es_flags\u003c/tt\u003e 中。在标识中存放一些信息比用偏置的方法存放在计数器中更为易懂，也更应该被推荐。\u003c/p\u003e\n\n\u003cp\u003e总之，使用偏置不能增加清晰度，不是一个常用模式。它不能比一个单独的标志位提供更多的信息，极端缺少内存、无法发现其它可用内存的情况下使用偏置来存放信息的情况非常罕见。因此，引用计数中，偏置应该被视为反模式并尽力避免使用。\u003c/p\u003e\n\n\u003ch6\u003e总结\u003c/h6\u003e\n\n\u003cp\u003e到时候结束我们对各种引用计数相关的设计模式的介绍了。简单列出如”kref”与”kcref”，”外部“与”内部“引用这样的术语是非常有帮助的。像我们一样找到 kref 和可以用 kcref 的代码，并在所有可用的地方使用它们，这对开发者和审阅者都有好处，开发者可以在一开始就找到正确的方法，而审阅者也更容易知道代码的用意。\u003c/p\u003e\n\n\u003cp\u003e我们本文中涉及的设计模式包括\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003cstrong\u003ekref\u003c/strong\u003e: 当对象的生命周期仅仅延续到最后一次释放外部引用的时候，kref 是恰当的设计模式。如果对象有内部引用，那么它们只有使用 \u003ctt\u003eatomic_inc_not_zero() 才能变成外部引用。例子：\u003ctt\u003estruct super_block\u003c/tt\u003e 中的\u003ctt\u003es_active\u003c/tt\u003e 和 \u003ctt\u003es_count\u003c/tt\u003e 。\u003c/tt\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003cstrong\u003ekcref\u003c/strong\u003e: 如果对象的生命周期超出最后一次释放外部引用，那么应该使用 \u003ctt\u003eatomic_dec_and_lock()\u003c/tt\u003e 和 kcref。内部引用只有在获得了子系统锁的时候才能转化为外部引用。例如：\u003ctt\u003ei_count\u003c/tt\u003e 中的 \u003ctt\u003ei_count\u003c/tt\u003e。\u003c/li\u003e\n\n\u003cli\u003e\u003cstrong\u003eplain\u003c/strong\u003e: 当对象的生命周期挂靠在其他对象之上的时候，应该采用plain 引用模式。对象的非零引用计数必须被看作是对父对象的内部引用，内部引用转化为外部引用必须遵循和父对象相同的规则。例子：\u003ctt\u003estruct buffer_head\u003c/tt\u003e 中的 \u003ctt\u003eb_count\u003c/tt\u003e。\u003c/li\u003e\n\n\u003cli\u003e\u003cstrong\u003ebiased-reference\u003c/strong\u003e: 当你想要在引用计数中使用一个大的偏移值来表征一些特殊状态的时候，停下，别这么干。使用个别的标志位吧，这是反模式。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e下个星期我们将换一个领域看其中 Linux 内核已经证明了的成功的设计模式，并看一些复杂的数据结构略多的地方。\u003c/p\u003e\n\n\u003ch6\u003e练习\u003c/h6\u003e\n\n\u003cp\u003e作者在准备这个系列的时候就被提醒到，没有比直接研究代码更能让人理解这些问题了。所以也给感兴趣的读者留了一些练习。\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e使用 kref 在 \u003ctt\u003estruct super\u003c/tt\u003e 中替换 \u003ctt\u003es_active\u003c/tt\u003e，抛弃 S_BIAS。比较使用 trifecta 进行正确性、可维护性和性能检查的结果 。\u003c/li\u003e\n\n\u003cli\u003e为 \u003ctt\u003emnt_pinned\u003c/tt\u003e 和处理它的相关函数选择一个更贴切的名字。\u003c/li\u003e\n\n\u003cli\u003e给 kref 库添加一个使用 \u003ctt\u003eatomic_inc_not_zero()\u003c/tt\u003e 的函数，并使用它（或相反的操作）去掉 \u003ctt\u003enet/sunrpc/svcauth.c\u003c/tt\u003e 中使用的\u003ctt\u003eatomic_dec_and_lock()\u003c/tt\u003e ，这里它破坏了 kref 的抽象。\u003c/li\u003e\n\n\u003cli\u003e检查 \u003ctt\u003estruct page\u003c/tt\u003e （如 \u003ctt\u003emm_types.h\u003c/tt\u003e 中） 的 \u003ctt\u003e_count\u003c/tt\u003e 引用计数，观察它的行为更像 kref 还是 kcref （提示：肯定不是 plain）。这应该包括标记所有的内部引用和相关的锁定规则。指明为什么 page cache (\u003ctt\u003estruct address_space.page_tree\u003c/tt\u003e) 有一个引用计数或为什么不应该有。浙江包括理解 \u003ctt\u003epage_freeze_refs()\u003c/tt\u003e 和它在 \u003ctt\u003e__remove_mapping()\u003c/tt\u003e 中的使用，以及 \u003ctt\u003epage_cache_{get,add}_speculative()。\u003c/tt\u003e\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e补充：一个系列的最小的自包含的补丁来实现上述这些研究结果的改变被证实是有用的。\u003c/p\u003e\n","cover":"","link":"translation/2009/08/30/[译文]-linux-内核设计模式--1-/index.html","preview":"","title":"[译文] Linux 内核设计模式 (1)"},{"content":"\n\u003cp\u003e10年前就已经开始有了所谓“内核汉化”的噱头，而今，某Windows盗版团队又“转战”Linux，推出了个“中文友好”的Linux Distro（以下简称为Y），走的还是那一套换个皮肤/主题、集成点自己选择的软件的老路，有意思么，还不如写点文档有意义呢。\u003c/p\u003e\n\n\u003cp\u003e现如今的Linux环境下的软件，普遍是通过 i18n 来支持多语言环境的，简单的说，就是将程序和显示与处理的字符分开，由社区中的国际化团队来进行翻译，在集成入主流发布版之前，都已经具备了包括中文在内的多语言支持了，上面说到的那个Y的基础，Fedora 本来已经对中文足够友好了，不知道他们的友好是怎么弄出来的，当然，我也没有兴趣知道。\u003c/p\u003e\n\n\u003cp\u003e对于开源，与其说是做好软件，还不如说是做好社区呢，好的想法和好的社区会让本来普普通通的软件变成好的软件，而萎缩的社区会让好的软件创意无疾而终。空拿个中文做噱头根本经营不出自己的社区，还不如琢磨琢磨，写点fedora的文档呢。\u003c/p\u003e\n","cover":"","link":"misc/2009/07/20/“中文linux发行版”有出路么/index.html","preview":"","title":"“中文Linux发行版”有出路么"},{"content":"\n\u003cp\u003eGoogle OS 是个流传已久的噱头了，可当 Chrome OS 真的被 Announce 出来的时候，还是瞬间成为了讨论的热点，这里也谈谈我的看法。\u003c/p\u003e\n\n\u003cp\u003e有人说这不过是另一个 Linux Distro ，因为 Google 说他基于 Linux 内核；也有人，比如（@Fenng）断言这个操作系统一定没有文件之类的概念，只有URL，会和 Google 的 Web 服务结合起来，显而易见，Chrome 浏览器是核心。相比之下，我赞同后者，虽然为了照顾用户的感情，传统的桌面之类的概念还可能会被部分保留，但系统一定是以浏览器为核心的，Gears和save site as an icon已经将桌面和web的界限变得十分模糊了。但这些和 Chrome OS 作为一个 Linux Distro 并不矛盾。\u003c/p\u003e\n\n\u003cp\u003e不过，\u003cstrong\u003e\u003cfont color=\"#ff0000\"\u003eChrome OS 一定不是一个 Linux Distro\u003c/font\u003e\u003c/strong\u003e。除了 Google 不需要很多已有的 GNU 工具这一点以外，至少还有这么几个重要原因：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eGoogle 不满目前 Linux 的现状。Google 早先已经对 Linux 的不同 Distro 之间的差异性表示了反感，这种反感可能意味着他们已经在开发一个“更好的”平台了，当然，也可能只是在抱怨而已。 \u003c/li\u003e\n\n\u003cli\u003e浏览器的一个发展趋势是承担部分操作系统的功能。微软研究院 Gazelle 已经开始将一部分操作系统的任务调度和资源分配之类的任务向浏览器转移，这既是浏览器的演进方向之一，也是操作系统的演进方向之一，毫无疑问，Google 更愿意让自己的浏览器承担更多的责任。 \u003c/li\u003e\n\n\u003cli\u003eGoogle 的一贯风格是不遵循已有的规范。Android 就不是一个纯粹的 Linux，而只是使用 Linux 内核打造的一个手机操作系统，它不遵循 FHS，一般的 Linux 平台上的工具也很难在上面运行。同样，Chrome OS 也声称是基于 Linux 内核，所以，我们有理由相信，这是另一个基于 Linux 内核的操作系统，而非一个 Linux Distro。 \u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003eGoogle 的野心远远不止打破微软的垄断，从善意的方面讲，Google有自己的理想和抱负，他不会安于 Linux 的现状；从另一方面讲，Google 也在营造属于自己的垄断，他会致力于建立另一个有壁垒的而非完全开放的平台，开放只是在 Google 自己的壁垒之内的开放。\u003c/p\u003e\n","cover":"","link":"misc/2009/07/09/chrome-os,-another-linux-distro?/index.html","preview":"","title":"Chrome OS, Another Linux Distro?"},{"content":"\n\u003cp\u003e首先，非常感谢看到我的nick向我老婆送去祝福的朋友。结婚两年感慨良多，和差不多所有年轻的夫妻一样，有幸福也有争执、有快乐也有艰辛，在第三年开始的第一天，我来回忆一下这两年的经历、收获和对未来的一点期望。\u003c/p\u003e\n\n\u003cp\u003e结婚这两年以一个有一点小误会但还是很圆满的婚礼开始，这差不多也是这两年的缩影吧。紧接着，我们一起用了不到九个月的时间孕育了一个新的生命——是的，就是这么长时间，这不是奉子成婚，嗯。在这期间，我们还努力经营着自己的小家，几次迁徙，终于稳定下来。没有蜜月，平平淡淡，甚至还有些孕期的紧张与艰苦，我们一起携手度过，回想起来，那是一段充满了期望和忐忑的紧张的准备期。\u003c/p\u003e\n\n\u003cp\u003e随后，斯屹的出生改变了一切，全家（包括老人们）的工作一下子有了明确的中心，在接下来大约十四个月中，家庭的概念差不多是“夫妻+孩子+爷爷奶奶”这五个人组成的，年龄跨度很大的这么多人在一起，需要关爱、忍让和智慧才能和谐相处，而我们基本做到了这一点，孩子也很健康活泼的成长着。这一期间，我们不仅经历了哺育的辛劳、成长的快乐，还在后期忙里偷闲地去三亚度了假，在朋友的协助下买了车，在父母的帮助下装修了自己的小家，也做好了迎接新生活的准备。\u003c/p\u003e\n\n\u003cp\u003e最近的一个多月的时间里，为了将重心适当向工作转移，我们搬回了自己的小家，每周在小家和大家中切换，有点重回二人世界的轻松，也有很多对疏远孩子的不舍，这就是生活，没有完美但我们在进步，我们的努力会让生活更美好。\u003c/p\u003e\n\n\u003cp\u003e就在这两年行将结束的几天里，有些事情让我再次意识到了父辈们已经进入晚年，我们还需要承担更多工作中和家庭上的责任，如何平衡、如何做好也就成为了未来的主旋律，这都需要我们两人携手奏出。\u003c/p\u003e\n\n\u003cp\u003e再次感谢各位的祝福。\u003c/p\u003e\n","cover":"","link":"misc/2009/07/09/结婚这两年/index.html","preview":"","title":"结婚这两年"},{"content":"\n\u003cp\u003e修几条全封闭的高架直达快速路，分别从中心某地通往首都机场、西郊机场、香山啥的，这样每天都不用临时交通管控了，中心城区通畅程度会大幅提高。\u003c/p\u003e\n","cover":"","link":"misc/2009/07/09/我找到解决北京交通问题的方法了/index.html","preview":"","title":"我找到解决北京交通问题的方法了"},{"content":"\n\u003cp\u003e把有用信息全都淹没了，简直没法活了……\u003c/p\u003e\n","cover":"","link":"misc/2009/06/25/唉，除了绿坝就是gfw/index.html","preview":"","title":"唉，除了绿坝就是GFW"},{"content":"\n\u003cp\u003e情况异常惊险，已经进入Windows安装程序了，不过XP的安装盘似乎不支持串口硬盘，又没准备驱动，所以作罢。之前本来想用Thinkpad的系统恢复来着，但我的这个居然只能整盘恢复出厂状态，代价太大，没敢尝试。再之前想一键恢复来着，但似乎装过grub之后，就无法一键恢复了。\u003c/p\u003e\n\n\u003cp\u003e回来说为啥想重装——原因很简单——很多软件都不能正常工作了，影响最大的是.Net Framework，导致一系列程序都不能工作。这件事情的起因是因为我为了腾磁盘空间，把系统目录里的一些以往的安装文件删掉了，没想到这些东西删掉虽然不影响运行，但会影响删除程序。后来某天想尝试blu（一个twitter客户端），不得不升级dotNetFx到3.5，这时问题就出现了，系统中已有2.0版本，于是dotNetFx就进入了一个\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e欲删不可，欲装不能\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e的状态，包括飞信、Paint.Net等大量日常生活用品都不能启动了，于是，忍了俩月之后，昨天终于下决心要重装了。\u003c/p\u003e\n\n\u003cp\u003e由于开头所说的囧原因，重装未果，只好回来想法修正，想法倒是很简单——想办法清除dotNetFx的一些信息，主要应该在注册表，只要让系统觉得没有装过它，就可以直接覆盖安装了。不过，手工编辑注册表确实太挑战了一些，于是，再次求助搜索引擎。\u003c/p\u003e\n\n\u003cp\u003e终于，有\u003ca title=\"飞信不能启动-双击fetion.exe文件无反应(解决办法)\" href=\"http://hi.baidu.com/%D2%F8%C9%AB%CA%A5%C6%EF%CA%BF/blog/item/c79d4c95157110007bf480ca.html\" target=\"_blank\"\u003e先行者提供了方法\u003c/a\u003e，使用\u003ca title=\"Windows Installer 清理实用工具说明\" href=\"http://support.microsoft.com/kb/290301\" target=\"_blank\"\u003e微软安装程序清理工具（msicuu2, windows installer cleanup utility）\u003c/a\u003e可以清除包括dotNetFx, MS Office等各种因为丢失安装文件无法卸载、重装的软件。\u003c/p\u003e\n\n\u003cp\u003e删除dotNetFx之后，重新安装就可以了。\u003c/p\u003e\n","cover":"","link":"misc/2009/05/22/昨晚险些重装xp/index.html","preview":"","title":"昨晚险些重装XP"},{"content":"\n\u003cp\u003e今天给橱柜装水槽，我领悟了一个道理\u003c/p\u003e\n\n\u003cp\u003e先说故事——装橱柜的部队不管装水槽，说如果装也行，要收50 。50啊，要知道，就是接几根管子嘛，这不是摆明了欺负人么！老婆当然不能吃这个亏，于是，安装水槽的责任就落在我身上了。\u003c/p\u003e\n\n\u003cp\u003e呃……是啊，老婆决定不吃亏，干活的是我……\u003c/p\u003e\n\n\u003cp\u003e话说我使用了钳子、大号活扳子、壁纸刀、水槽原配零件以及大量生料带终于完成了此项工作，期间调试多次，漏水无数。\u003c/p\u003e\n\n\u003cp\u003e最后，临走的时候没忘切断总闸，因为我还是觉得多少有些渗水。\u003c/p\u003e\n\n\u003cp\u003e话说，今天领悟到的道理是——不是拧到最紧密封就最好——生料带本身有一定弹性，用手将接头拧住，扳子紧一下，生料带就会帮助密封好接头，不漏水。可是，如果拼命拧到最近，生料带就会被接头的金属扣咯破，从而漏水。\u003c/p\u003e\n\n\u003cp\u003e很多生活上的事情不也是如此么，放松反而会比一味施压收到更好的效果。\u003c/p\u003e\n","cover":"","link":"misc/2009/05/10/今天装水槽/index.html","preview":"","title":"今天装水槽"},{"content":"\n\u003cp\u003e原来都是svn出来，加到eclipse里面，两个独立操作。前两天想用subclipse，却发现新建的svn project里的东西不是java project的东东，不能被build。\u003c/p\u003e\n\n\u003cp\u003e今天终于明白了，subclipse装上之后，svn里的项目要import进来，然后在这个source上建java project而不是直接建svn的project。\u003c/p\u003e\n\n\u003cp\u003e呵呵，凑合用了这么久才明白这么简单个东东，请大家笑话我吧，脸红ing\u003c/p\u003e\n","cover":"","link":"misc/2009/05/10/终于明白subclipse怎么用了/index.html","preview":"","title":"终于明白subclipse怎么用了"},{"content":"\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e目前版本的dfsadmin的帮助信息是没写清楚的，已经\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003ca href=\"http://https//issues.apache.org/jira/browse/HADOOP-5778\" target=\"_blank\"\u003efile了一个bug\u003c/a\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e了，正确的方法如下：\u003c/p\u003e\n\n\u003cp\u003e1. \u003c/span\u003e将\u003cspan class=\"921042102-06052009\"\u003e dfs.hosts  置为当前的 slaves，文件名用完整路径，注意，列表中的节点主机名要用大名，即 uname -n 可以得到的那个。\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e2. 将 slaves 中要被退服的节点的全名列表放在另一个文件里，如 slaves.ex，使用  dfs.host.exclude 参数指向这个文件的完整路径\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e3. 运行命令 bin/hadoop dfsadmin  -refreshNodes\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e4. web界面或 bin/hadoop dfsadmin -report 可以看到退服节点的状态是  Decomission in progress，直到需要复制的数据复制完成为止\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e5. 完成之后，从 slaves 里（指 dfs.hosts  指向的文件）去掉已经退服的节点\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e附带说一下 -refreshNodes  命令的另外三种用途：\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e2. 添加允许的节点到列表中（添加主机名到 dfs.hosts  里来）\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e3. 直接去掉节点，不做数据副本备份（在 dfs.hosts  里去掉主机名）\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n\n\u003cdiv style=\"color: #000000;\" dir=\"ltr\"\u003e\u003cspan style=\"font-family: 宋体;\"\u003e\u003cspan style=\"font-size: x-small;\"\u003e\u003cspan class=\"921042102-06052009\"\u003e4. 退服的逆操作——停止 exclude 里面和 dfs.hosts 里面都有的，正在进行  decomission 的节点的退服，也就是把 Decomission in progress 的节点重新变为 Normal （在 web 界面叫 in  service)\u003c/span\u003e\u003c/span\u003e\u003c/span\u003e\u003c/div\u003e\n","cover":"","link":"misc/2009/05/06/hdfs退服节点的方法/index.html","preview":"","title":"HDFS退服节点的方法"},{"content":"\n\u003cp\u003e新的两篇读后感发在CMS里的同时，也发在了我的labs blog里，并在blog里直接给出到本站的链接了。\u003c/p\u003e\n\n\u003cp\u003e低调，低调\u003c/p\u003e\n","cover":"","link":"misc/2009/05/04/开始悄悄推荐我的网站/index.html","preview":"","title":"开始悄悄推荐我的网站"},{"content":"\n\u003cp\u003e昨天和老婆一起从乐友搬回三个大箱子，除了奶粉和纸尿裤以外，有个四轮电动摩托车，是奶粉的赠品，充电之后可以骑上去开，另一个是一辆三轮车，我和老婆废了一晚上力气才装上，难怪店员想直接给我们车，不想让我们散件，让我们自己装呢，可整车真的太不好搬回家了。鄙视一下根本看不清楚的装配图。\u003c/p\u003e\n","cover":"","link":"misc/2009/05/03/斯屹又多了两辆车/index.html","preview":"","title":"斯屹又多了两辆车"},{"content":"\n\u003cp\u003e有些文章读过后很有收获，记下了很多东西，不过由于时间关系或内容问题，也没有完全翻译，既不算个人作品，也不算译作，就算是读后感吧，也发到网站上来。\u003c/p\u003e\n","cover":"","link":"misc/2009/05/03/准备放些读后感到cms里/index.html","preview":"","title":"准备放些读后感到CMS里"},{"content":"\n\u003cp\u003e\u003c!--正文内容：\u003cbr /\u003e\n--\u003e \t\t\t\t\t\t\t\t该参数限制了datanode所允许同时执行的发送和接受任务的数量，缺省为256，hadoop-defaults.xml中通常不设置这个参数。\u003c/p\u003e\n\n\u003cp\u003e这个限制看来实际有些偏小，高负载下，DFSClient 在put数据的时候会报 could not read from stream 的 Exception。\u003c/p\u003e\n\n\u003cp\u003e值得注意的是，程序里进行比较的数值来自于java的ThreadGroup，据JDK API文档解释，这个参数并不确保准确，仅供参考用途，Core Java也建议不要使用ThreadGroup，hadoop在此使用ThreadGroup有些值得商榷。\u003c/p\u003e\n","cover":"","link":"misc/2009/04/30/dfs.datanode.max.xcievers:-hadoop-的无文档的参数/index.html","preview":"","title":"dfs.datanode.max.xcievers: hadoop 的无文档的参数"},{"content":"\n\u003cp\u003e某项目的代码中的一个匪夷所思的逻辑判断错误与一个离奇的错误参数相遇了，然后，整个hadoop文件系统被清空了，几十TB的数据在随后两个小时中不可阻挡的彻底从一百多个节点中被清空了。\u003c/p\u003e\n\n\u003cp\u003e这个真实的故事再次验证了墨菲定律……\u003c/p\u003e\n","cover":"","link":"misc/2009/04/29/一次诡异的事故再次证明了墨菲定律/index.html","preview":"","title":"一次诡异的事故再次证明了墨菲定律"},{"content":"\n\u003cp\u003e在这里足够低调了，恭喜并祝福这一对 :)\u003c/p\u003e\n","cover":"","link":"misc/2009/04/27/低调地恭喜胡铮于静潇/index.html","preview":"","title":"低调地恭喜胡铮于静潇"},{"content":"\n\u003cp\u003e呵呵，也就两天功夫，斯屹原来还走几步就趴下呢，很快就变成张牙舞爪的走了，然后就不用张牙舞爪也走得挺好了，估计再过几天就得让我们追他了。\u003c/p\u003e\n","cover":"","link":"misc/2009/04/26/斯屹走得很好了/index.html","preview":"","title":"斯屹走得很好了"},{"content":"\n\u003cp\u003e真的属于自己的blog。\u003ca title=\"我的个人网站\" href=\"http://wangxu.me/site/\" target=\"_blank\"\u003eCMS\u003c/a\u003e的内容还在添加中，等添加的差不多了再来发布。\u003c/p\u003e\n","cover":"","link":"misc/2009/04/25/低调地开始我的新blog/index.html","preview":"","title":"低调地开始我的新Blog"},{"content":"\n\u003cp\u003eWelcome to WordPress. This is your first post. Edit or delete it, then start blogging!\u003c/p\u003e\n\n\u003cp\u003e测试中文\u003c/p\u003e\n","cover":"","link":"misc/2009/04/24/hello-world!/index.html","preview":"","title":"Hello world!"},{"content":"\n\u003cp\u003e\u003ca href=\"http://lwn.net/Articles/321696/\"\u003ehttp://lwn.net/Articles/321696/\u003c/a\u003e\u003cbr /\u003e\nBy \u003cstrong\u003eJonathan Corbet\u003c/strong\u003e\u003cbr /\u003e\nMarch 4, 2009\u003cbr /\u003e\n王旭 2009年3月22日译\u003c/p\u003e\n\n\u003cp\u003e曾几何时，Xen是炙手可热的虚拟化技术。Xen的开发者们拥有一个自由软件中最为领先的虚拟化解决方案，Xen看起来正是Linux虚拟化的未来。很多风投在追逐这个神话，各个发行版也竞相提供基于Xen的虚拟化平台。然而，在这条路上，Xen似乎已经走失了。XenSource的开发者们看起来似乎没有兴趣让他们的代码进入主线内核，而其他人的努力也遇到了没完没了的障碍。于是，Xen在多年以来就一直停留在主线之外了。Xen首次对外发布是2003年的事了，可Xen的核心代码仅仅在2007年10月才进入了2.6.23。\u003c/p\u003e\n\n\u003cp\u003e就在同时，KVM出现了，而且一下子抢走了众多的注意力。它以难以置信的速度一下子就进入了主线内核，而且很多内核开发者都毫不掩饰的表达了他们对于KVM锁采用的方法的青睐。就在最近，Red Hat\u003ca href=\"http://www.redhat.com/about/news/prarchive/2009/agenda.html\"\u003e发布\u003c/a\u003e了他们的KVM虚拟化时间表，让这种偏爱更加官方了。同时，\u003ca href=\"http://lwn.net/Articles/218766/\"\u003elguest\u003c/a\u003e 成为了那些想要尝试虚拟化的人的简单选择。\u003c/p\u003e\n\n\u003cp\u003eXen的故事是“上游优先”策略产生的原因的一个经典实例，该策略要求代码在被提供给客户之前应该首先进入主线。发布者们忙不迭地首先发布Xen，然后就发现他们自己正在支持一段out-of-tree的代码，这些代码常常根本不被他们的开发者所支持。特别地，对外发布的Xen通常只支持相当老的内核，希望提供一些更新的内容的发布者需要做很多工作来让它们一起工作。现在，至少部分的发布者（发行版）已经开始走向其他的选择了，而高层的内核开发者则在问一个问题——事到如今，是否还值得来把剩下的Xen代码merge进来。\u003c/p\u003e\n\n\u003cp\u003e所有人都在说，Xen已经岌岌可危了。不过，或许更严重的所谓Xen已经死掉了的流言有些言过其实了。\u003c/p\u003e\n\n\u003cp\u003e主线中的代码实现了 Xen 的 DomU 概念——一没有访问硬件的权限的非特权域。而一个完整的Xen则需要更多功能；需要一个用户空间（原文如此）的hypervisor（是以GPL许可发布的）和内核中的Dom0代码。Dom0是hypervisor启动的第一个域；定性情况下，它比其他Xen guest拥有更多的特权。Dom0用于在管理策略的管理下小心的向其他域提供那些诸如访问硬件、网络等的特权。一个实用的Xen系统必须包含Dom0代码——目前是一大块out-of-tree的kernel代码。\u003c/p\u003e\n\n\u003cp\u003eJeremy Fitzhardinge 希望改变这一局面。他发出了\u003ca href=\"http://lwn.net/Articles/321298/\"\u003e一组Xen Dom0 patch\u003c/a\u003e ，希望能够进入 2.6.30。在审阅者中，Andrew Morton问了\u003ca href=\"http://lwn.net/Articles/321699/\"\u003e这个问题\u003c/a\u003e ：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我讨厌成为说这句话的人，不过，我们确实应该坐下来弄明白把它merge到Linux当中来是否真的合适。我觉得Xen是实现虚拟化功能的老方法了，世界已经专项新方向KVM了。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e三年之内，我们是不是会后悔我们merge了Xen？\u003c/p\u003e\n\n\u003cp\u003eAndrew的问题本质上是：（1）完成这个工作需要什么代码（这次提交的代码之外），和（2）这么做的原因是什么?第一个问题的\u003ca href=\"http://lwn.net/Articles/321701/\"\u003e答案\u003c/a\u003e 是“再有2-3个尺寸差不多的补丁集就将提供引导dom0所需的所有代码”。之后有一些其他的不同内容可能不会进入主线。不过，Jeremy说，让核心代码进入主线将会减少发行版需要打的out-of-tree的补丁，让所有人的生活变轻松一些。对于第二个问题，Jeremy回应到：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e尽管kernel周期中有来自kvm的影响，Xen还是拥有庞大并且仍在增长的用户群的。此时，他们都工作在大量的out-of-tree补丁之上，这对大家来说都十分不快。让他们成为主线内核的一部分再好不过了。你知道，这和我们争论的所有其他事情都一样。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e此外，Jeremy表示，Xen仍然有其存在的价值。它的设计在很多方面和KVM有本质的不同；\u003ca href=\"http://lwn.net/Articles/321702/\"\u003e这封邮件\u003c/a\u003e 精辟的解释了这些差异。所以，Xen作为另一个解决方案已然有意义。\u003c/p\u003e\n\n\u003cp\u003eJeremy指出的一些Xen的优势包括：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eXen的实现页表的方法消除了shadow页表或guest中嵌入页表的需要；这样，可以让许多负载获得更好的性能。\u003c/li\u003e\n\n\u003cli\u003eXen的hypervisor是非常轻的，并且可以独立运行；而KVM的hypervisor则就是Linux内核本身。似乎有些厂商（HP 和Dell被点到名了）在他们的很多系统的firmware中会提供一个Xen的hypervisor。这些代码于是和可以和其他的东西一样具有可以立即使用的特性了。\u003c/li\u003e\n\n\u003cli\u003eXen的半虚拟化方式可以使用不支持虚拟化的硬件一起工作。而KVM则需要硬件支持。\u003c/li\u003e\n\n\u003cli\u003e分离hypervisor, Dom0和 DomeU的方式让安全性检查更简单了。各个域之间的隔离还允许让每个设备都在一个独立的域中提供服务，这可以看做是一种重量级的微内核架构。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e与此不同，KVM相对更简单、更易用，并且可以访问所有的内核特征。在Jeremy看来，两个系统在Linux中各有不同的位置。\u003c/p\u003e\n\n\u003cp\u003e这个讨论在最后重归沉默，这表明Jeremy的解释相当不错。Xen历史上犯过错误，但这个项目仍然活着，而且仍然有它的原因继续存在下去。你的编辑（译 著：编辑就是本文原文作者）预测，Dom0的代码在尝试进入2.6.30的merge window的时候还会遇到一定的反对意见。\u003c/p\u003e\n","cover":"","link":"translation/2009/03/22/xen-to-kernel/index.html","preview":"","title":"[译文] Xen: 完成工作"},{"content":"\n\u003cp\u003e按，与其说是安装，不如说是灌输，由于硬件支持性、软件版本等原因，无法实施正常安装，因此，退而求其次，进行了这次“灌输+激活”的“非典型”安装。   \u003cbr /\u003e问题描述    \u003cbr /\u003e1 内核支持问题：    \u003cbr /\u003eSW的内核是打过补丁的 2.6.16内核，对于我们的计算机来说它的问题是网卡不支持，无法继续安装。目前回想看，重新编译SW的时候单独采用更新的网卡驱动可能可以，不过，当时采用了另一个极端手段——更新内核版本，于是遇到了下一个问题（即使不遇到问题2，问题3可能也无法避免）。    \u003cbr /\u003e2 补丁兼容性问题：    \u003cbr /\u003e最大的问题来自 openswan 补丁，该补丁，尤其是 NAT-T，和选用的 2.6.25 内核的 udp 部分似乎存在某种尚未解决的 bug，手工修订了半天，但无法证明效果    \u003cbr /\u003e3 软件版本一致性问题：    \u003cbr /\u003e由于 SW 指定的某些软件源无法获取软件包，不得不下载了版本尽量接近的软件来代替，但不知道是否会有依赖性问题。    \u003cbr /\u003e综合上述问题，但尚未确定哪个是最终导致问题的问题，重新编译的 SW 无法正常安装，于是，我采用了下面的手段。    \u003cbr /\u003e灌输系统    \u003cbr /\u003e1 在虚拟机中安装 SW3-devel    \u003cbr /\u003e2 用移动硬盘引导目标系统，分区并挂载要安装 SW 的分区    \u003cbr /\u003e3 用 tar+ssh，将虚拟机中的内容悉数原样复制到目标系统    \u003cbr /\u003e4 将移动硬盘的内核（vmlinuz, initrd, modules）复制给目标机，重新写lilo，让系统可引导    \u003cbr /\u003e5 在新机器上编译新版本内核 （2.5.25），打开必要的 netfilter 相关选项    \u003cbr /\u003e6 sw3-devel 里没有 mkinitrd/initramfs，因此，应把启动需要的 ata/scsi/sata/ext3 等相关选项全部编译到内核里，而不是编译成模块；编译完成后，再次重写 lilo，以引导新内核。    \u003cbr /\u003e5 修改配置文件，包括\u003c/p\u003e\n\n\u003cp\u003e/var/smoothwall/main/settings   \u003cbr /\u003e/var/smoothwall/ethernet/settings    \u003cbr /\u003e/etc/fstab\u003c/p\u003e\n\n\u003cp\u003e\u0026#160; 至此，配置完成，但应注意，如果 /var/smoothwall 不是属于 nobody 用户的的话，请重新修改此目录的权限，保证将来可以通过web管理界面管理设置。   \u003cbr /\u003e6 如果出现问题，请注意查阅日志解决\u003c/p\u003e\n","cover":"","link":"works/2008/12/07/smoothwall-exp-3-安装札记/index.html","preview":"","title":"SmoothWall Exp 3 安装札记"},{"content":"\n\u003cp\u003e为了分析hadoop的日志，特地写了个一行的程序，来分析日志程序。Hadoop 是个分布式程序，程序分布在多个节点上，日志自然也是多份的，这里用一行脚本提取所有日志中的关键内容，进行重新排序，方便跟踪，主要是 sed 应用\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003egrep \u0026quot;blk_\u0026quot; hadoop-testhdp-* | sed -ne 's/^hadoop-testhdp-\\([a-z]\\{8\\}\\)-[a-z]\\+-\\([0-9]\\{1,2\\}-[0-9]\\{1,2\\}\\).local.log[^:]*:\\(20[0-9]\\{2\\}-1\\?[0-9]-[0-9]\\{1,2\\} [0-9:,]\\{10,12\\}\\)\\(.*\\)\\(blk_-\\?[0-9]\\{19\\}_[0-9]\\{4\\}\\)\\(.*\\)$/ \\5 \\3 [\\1] c\\2: \\4 [The BLK] \\6/p'| sort |while read blk remain;do [ \u0026quot;$blk\u0026quot; != \u0026quot;$last\u0026quot; ] \u0026amp;\u0026amp; echo \u0026quot;----------------\u0026quot; ; last=$blk ; echo $blk $remain ;done \u0026gt; blocks_log_seg.txt\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这个程序主要有两个部分，while之前的是将所有日志放在一起，并提取每行的关键信息，重新排列，然后排序，这样就按照我们关心的方式来排列了，后面一部分（while）是将首个字段发生变化的位置标记出来，以方便查看。sed里面有这么一些关键点：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e指定某个表达式的长度：\n\n\u003cul\u003e\n\n\u003cli\u003e\\{8\\} 8个长 \u003c/li\u003e\n\n\u003cli\u003e\\{10,12\\} 10到12个长\u003c/li\u003e\n\n\u003cli\u003e\\+ 至少一个长 \u003c/li\u003e\n\n\u003cli\u003e\\? 可能有一个 \u003c/li\u003e\n\n\u003cli\u003e* 多少个都有可能，没有也有可能\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\\( \\) 括起来的内容在后面依次可以用\u0026#160; \\1, \\2, \\3.... 的方式来引用 \u003c/li\u003e\n\n\u003cli\u003e使用 [ ] 来指定可能的字符，或用 [^] 来排除没有的，如 [^:] 就是不包含冒号的，上述[^:]* 如果替换成 .* 的话，可能在 log: 2008-11-28 13:05:33 中做最大匹配，一直到33前面，红色部分的匹配可能是无门不希望看到的。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e后面的 while 实际上保存了上一行的 $blk，然后和当前行作比较，如果不同就加如一行减号，从而分隔开不同的行，如果没有需要的话可以去掉，这样会运行得更快些。   \u003cbr /\u003e注意，该程序的 while 部分在 linux 中运行速度尚可，在 cygwin 中几乎无法接受，如果用 cygwin 的话，建议要么去掉这部分，要么做好等很长时间的准备。\u003c/p\u003e\n","cover":"","link":"scripts/2008/11/30/一行的日志分析脚本/index.html","preview":"","title":"一行的日志分析脚本"},{"content":"\n\u003cp\u003e来源：\u003ca href=\"http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html\"\u003ehttp://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html\u003c/a\u003e  \u003cbr /\u003e王旭\u0026#160; [ gnawux (at) gmail.com ; http://www.wangxu.me ] 于2008年11月译  \u003cbr /\u003e译者按：有些术语实在很别扭，不过译者文采有限，没法找到合适的中文词汇，不太影响理解，凑合看吧。\u003cbr /\u003e\n\n\u003ch4\u003e\u003ca name=\"1._概述\"\u003e\u003c/a\u003e1. 概述\u003c/h4\u003e\n\n\u003cp\u003e Java 平台标准版（Java SE™）被广泛应用于各种应用，从桌面上的小小的 applet 到大型服务器上的 Web Service 无处不在。为了支持各种不同的部署场景，Java HotSpot™ 虚拟机提供了多种垃圾回收器，每种都为满足不同的需求而设定。这是也为了满足大大小小不同应用需求的一部分。不过，那些需要高性能应用的用户、开发者和管理员们也被选择适合他们应用的恰当的垃圾回收器的繁琐困扰着。取消这些额外操作的重要一步是在 J2SE™ 5.0 中作出的：垃圾回收器会根据应用运行的计算机类型而作出选择。\n\n\u003cp\u003e这个垃圾回收器的“更好的选择”总的说是一种进步，不过，这并不意味着对所有的应用这都是最好的选择。对于有极端的性能或其他需求的用户，仍需要显式地指定垃圾回收器，并调优某些参数，以达到满意的性能。本文就为这些需求提供了一些相关信息。首先，本文会基于串行的 stop-the-world 垃圾回收器来介绍垃圾回收器的一般性特征和基本调优开关。接下来会介绍其他垃圾回收器的特点和如何选择一个垃圾回收器。\u003c/p\u003e\n\n\u003cp\u003e何时选择垃圾回收器？对于一些应用，这个答案可能是“永远不”。也就是说，在有低频率、短时的垃圾收集器造成的停顿的情况下，大部分程序都运行良好。不过，这并不适用于很多程序，特别是那些处理大量数据（若干GB）、很多线程和需要处理很多事务的情况。\u003c/p\u003e\n\n\u003cp\u003eAmdahl 观察到，大部分工作负载并不能被很好的并行化；有部分情况下总是会被顺序执行，无法从并行化中获益。这对 Java™ 平台也是如此。特别的，在 J2SE 1.4 以前，Sun Java 平台的虚拟机并不支持并行垃圾回收，这样，在多处理器系统中，垃圾回收会对并行应用产生严重影响。\u003c/p\u003e\n\n\u003cp\u003e下图显示了一个除了垃圾回收以外均为完美可伸缩的理想系统的性能曲线。红色曲线是一个在但处理器系统中会花费 1% 的时间在垃圾回收上的程序。它在 32 处理器的系统中，将损失 20% 的吞吐量。而一个花费 10% 时间在垃圾回收上的应用（不考虑单处理器系统中额外的垃圾回收时间）在系统扩张到 32 处理器系统中时，会损失超过 75% 的吞吐量 。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/File?id=d98mwqq_141hpgh8x5q_b\" width=\"442\" height=\"333\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e这意味着在小型开发系统中微不足道的速度问题当扩张到大规模系统中就可能成为严重的性能瓶颈。从另一个角度看，减少这样的性能瓶颈的小改动就可以获得很大的性能收益。对足够大规模的系统，选择合适的垃圾收集器并进行必要调优是绝对值得的。\u003c/p\u003e\n\n\u003cp\u003e对于大多数“小”应用（在现代处理器上大约需要100MB堆内存的应用）来说通常是足够的。其他垃圾收集器会带来额外的负载或复杂性，这回让系统的某些行为付出一定的代价。如果一个应用不需要一个垃圾收集器的某个功能。那么就使用串行的垃圾收集器好了。一个不应该使用串行垃圾收集器场景是一个超多线程的大程序运行在一个大型的、有大量内存和两个或多个处理器的系统中。当应用运行在这些服务器级的计算机上的时候，并行垃圾收集器会被缺省选择（参见下面的功效学 ）。\u003c/p\u003e\n\n\u003cp\u003e本文以 Solaris™ 操作系统（SPARC\u003csup\u003e(R)\u003c/sup\u003e 平台版本）中的 Java SE 6 作为参考。不过，文中所述的概念和建议适用于所有支持的平台，包括 Linux, Microsoft Windows 和 Solaris 操作系统（x86 平台版本）。此外，文中的命令行参数也对所有平台有效，虽然它们的缺省值在各个平台可能有所不同。 \u003c/p\u003e\n\n\u003ch4\u003e\u003ca name=\"ergonomics\"\u003e\u003c/a\u003e\u003ca name=\"2._工作环境\"\u003e\u003c/a\u003e2. 功效学（Ergonomics）\u003c/h4\u003e\n\n\u003cp\u003e \u003ca name=\"ergonomics\"\u003e\u003c/a\u003e\n\n\u003cp\u003e“功效学”是一个 J2SE 5.0 引入的概念。引入功效学概念是为了通过不设置或设置很少的几个命令行参数的情况下提供更好的性能，这些参数包括：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e垃圾收集器，\u003c/li\u003e\n\n\u003cli\u003e堆尺寸， \u003c/li\u003e\n\n\u003cli\u003e和运行时编译器\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e这里的参数选择假定应用所运行的主机类型和应用的类型一致（也就是说，大型应用运行在大型的机器上）。这些选项简化了垃圾回收的调优。选择并行垃圾回收器，用户可以指定应用的最大中断时间和希望的吞吐量。这和指定堆大小来调优性能是相对应的。最常用的功效学相关的内容在可以参考 “Ergonomics in the 5.0 Java Virtual Machine” 这篇文章。建议在尝试本文提到的细节配置之前尝试该文章中介绍的功效学手段。\u003c/p\u003e\n\n\u003cp\u003e本文中的功效学特性被作为并行垃圾回收器的自适应尺寸策略的一部分。这包括指定垃圾回收性能的目标和性能调优的一些附加选项。\u003c/p\u003e\n\n\u003ch4\u003e3.代\u003c/h4\u003e\n\n\u003cp\u003e J2SE 平台的优势之一是它将内存分配、垃圾回收这些繁复的细节屏蔽了起来。然而，一旦垃圾回收成为主要的瓶颈，那么理解一下这些隐藏在背后的细节就变得有必要了。垃圾回收器对应用程序对对象的使用方式进行判断，这个判断会反映在可调优参数中，他们可以被调整，以提高性能而不牺牲掉抽象性。\n\n\u003cp\u003e当一个对象不再可能被从其他任何地方访问到的时候就会被认为是垃圾了。最直接的垃圾回收算法就是简单地迭代所有可找到的对象。任何没有被跌带到的对象都可以被认为是垃圾了。这个方法的用时和活着的对象数量成正比，这对于那些维护着大量活数据的程序来说是不可接受的。\u003c/p\u003e\n\n\u003cp\u003e从 J2SE 1.2 开始，虚拟机就引入了各种不同的垃圾回收算法，这些算法都使用分代垃圾收集。尽管原生的垃圾回收会检查堆中的所有活着的对象，分代垃圾收集采用了很多观测到的大部分应用程序的经验特征，用来最小化发现废弃的对象的工作量。最重要的经验特征是 weak generational 假设，该假设认为大部分对象都只存活一少段时间。\u003c/p\u003e\n\n\u003cp\u003e下图中的蓝色区域是对象生存期的典型分布。横轴是对象被分配后的生存期。纵轴方向计算的字节数是相应生存期的对象的总字节数。左侧的尖峰表明，对象在分配之后不久就被废弃了。比如，迭代器对象常常只会在一个循环中被用到。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/File?id=d98mwqq_142gz4f6cgn_b\" width=\"484\" height=\"298\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e当然，有些对象确实活得要长一些，于是，分布曲线延伸到了右边。比如，典型情况下，有些对象在初始化的时候被创建，并一直存活到进程结束。在这两种极限情况之间，那些对象活的时间也是中等的，在图中表现初来的就是从开始的峰值泄漏初来的蓝色区域。有些应用可能会有看起来十分不同的分布曲线，不过绝大多数的进程都是这个常见的形状。大部分对象都会“英年早逝”这个事实让高效的垃圾收集变得具有可能性了。\u003c/p\u003e\n\n\u003cp\u003e为了为这样的应用环境优化，内存被按照“代” （generation）进行管理，或者说，内存池中存放不同年龄的对象。当一个年龄断被填满后，就对该代的垃圾进行回收。在内存池中的大部分对象都是年轻的对象（年轻的代），而大部分对象也会在年轻的时候就成为垃圾。当年轻代被填满的时候，会导致一次“小回收”（译注：原文minor，似乎“未成年”更贴切一些，不过咱们读起来会很别扭），这里只有年轻代的对象惠北回收，而其他年龄断的垃圾则不与理会。该回收算法的成本是，一阶情况下，正比于被回收的活的对象的数量；年轻代因为满是死对象，所以回收非常迅速。而在“小回收”中存活下来的对象于是乎就会被转移到所谓的年老代（tenured generation）。最终，当年老代被填满而需要回收的时候，就会导致一次主回收，这时整个堆都会被回收。主回收通常会运行锝比小回收慢很多，因为大量的对象都会被处理。\u003c/p\u003e\n\n\u003cp\u003e如上文记述，对不同的应用，“工效学”会动态选择垃圾收集器来提供较好的性能。串行垃圾收集器用于哪些数据量比较小的程序，而且它的缺省参数也让大多数小程序能够高效工作。而大吞吐量垃圾收集器用于那些有中到大数据量的数据集。工效学选择的堆尺寸参数和自适应尺寸策略用于为服务器提供更好的性能。这些选择的大多数而不是所有的情况下工作得很不错。这就引出了本文的核心宗旨：\u003c/p\u003e\n\n\u003cp\u003e如果垃圾收集器成为了瓶颈，你可能不得不调整整个堆的大小乃至每个代的尺寸。检查垃圾收集器的详细输出，然后检查垃圾收集器对你关注的各个性能指标的影响。\u003c/p\u003e\n\n\u003cp\u003e（并行垃圾收集器之外的）缺省的代排布大概就是这样的。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/File?id=d98mwqq_143hkp4rqgb_b\" width=\"542\" height=\"296\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e初始化的时候，最大的地址空间虚拟地保留住而没有分配出去，直到真的需要的时候为止。整个保留的对象地址空间被分给了年轻的和年老的代。\u003c/p\u003e\n\n\u003cp\u003e年轻代包括“伊甸园”和两个幸存者空间。大部分对象最初在伊甸园里被分配出来。一个幸存者空间在任意时刻都是空的，作为伊甸园中的活对象的目的地，另一个是用于下一次收集。对象在幸存者空间之间停留到足够老之后，就会被复制到年老代去了。\u003c/p\u003e\n\n\u003cp\u003e另一个和年老代有密切关系的代是永久的（permanent）代，这里保存着虚拟机需要的用来描述那些 Java 语言层面没有等价物的对象。比如，那些描述类和方法的的对象就存放在永久代。\u003c/p\u003e\n\n\u003ch5\u003e3.1 性能考虑\u003c/h5\u003e\n\n\u003cp\u003e 对于垃圾回收的性能，主要有两种量度方法：\n\n\u003col\u003e\n\n\u003cli\u003e吞吐量。吞吐量是在一段足够长的时间中，没有花费在垃圾回收上的时间占总时间的百分比。吞吐量包含了花在空间费配上的时间（不过空间分配速度的调优一般是没有必要的）。\u003c/li\u003e\n\n\u003cli\u003e延时。延时是由于等待垃圾回收而导致的程序没有响应的时间。\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e不同的用户对垃圾收集有不同的需求。比如，对于一个web server而言，吞吐量是合理的量度，因为垃圾收集带来的短时时延是可以容忍的，或者说是很容易就被网络时延所掩盖了。不过，对于交互的图形界面程序而言，极短的停顿都会影响用户的使用体验。\u003c/p\u003e\n\n\u003cp\u003e有些用户对其他的因素很敏感。Footprint是一个进程的工作集，由页和cache line来量度。对于内存相对于进程数量很有限的系统而言。Footprint会影响到程序的可伸缩性。Promptness是对象死掉和该块内存重新可用之间的时间间隔的量度，这是分布式系统的一个重要考虑因素，包括远程方法调用（RMI）。\u003c/p\u003e\n\n\u003cp\u003e总的说，一个特定的代的尺寸选择是上述这些因素之间的权衡的结果。比如，一个非常大的年轻代的大小可以最大化吞吐律，但会以Footprint、Promptness和延时作为代价。而年轻代延时可以通过缩小该代的大小来达到最小化，但同样会损失吞吐量。近似地，调整一个代的尺寸不会影响到其他代的垃圾收集频率和时延。\u003c/p\u003e\n\n\u003cp\u003e没有一个简单的方法来设置代的尺寸。最好的选择由程序使用内存的方式和用户的需求来决定。这样，虚拟机对垃圾收集器的选择并不总是最优的，而且可以通过后面介绍的命令行参数来调整。\u003c/p\u003e\n\n\u003ch5\u003e3.2 测量\u003c/h5\u003e\n\n\u003cp\u003e使用应用特定的量度，吞吐量和footprint很容易被测量。例如，web服务器的吞吐量可以使用一个客户端负载生成器来测量，而该服务器的 footprint 则可以在 Solaris 操作系统中使用 pmap 命令来测量。另一方面，垃圾收集导致的时延可以方便地通过监测虚拟机自己的诊断输出来估算出来。\u003c/p\u003e\n\n\u003cp\u003e命令行参数 -verbos:gc 可以送出每一次垃圾收集时的堆和垃圾收集信息。比如，这是一个大型服务器应用的输出：\u003c/p\u003e\n\n\u003cpre\u003e[GC 325407K-\u0026gt;83000K(776768K), 0.2300771 secs]\u003cbr /\u003e[GC 325816K-\u0026gt;83372K(776768K), 0.2454258 secs]\u003cbr /\u003e[Full GC 267628K-\u0026gt;83769K(776768K), 1.8479984 secs]\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e这里是两次小回收和之后的一次主回收。箭头前后的数字（比如第一行的325407K-\u0026gt;83000K）分别指垃圾回收前后的所有活着的对象占用的空间。在小回收之后，这个尺寸之中仍然包含一些没有被回收的垃圾（死掉的对象）。这些对象要么存在在年老代中，要么被年老或永久代中的对象所引用。\u003c/p\u003e\n\n\u003cp\u003e后面的括号中的数字（比如第一行中的 (776768K)）是全部提交的堆大小，也就是虚拟己不向操作系统申请内存的情况下，全部 java 对象可用的存储空间。注意，这个数字不包括幸存者空间中的一个，因为幸存者空间在一个给定时间只有一个可用，同时也不包括永久代的空间，这里面是虚拟机使用的元数据。\u003c/p\u003e\n\n\u003cp\u003e最后一个数字（比如 0.2300771 secs）是垃圾收集所用的时间；这个例子里大约是四分之一秒。\u003c/p\u003e\n\n\u003cp\u003e第三行中主垃圾回收的格式也是类似的。\u003c/p\u003e\n\n\u003cp\u003e-verbos:gc 输出的格式可能在将来的版本里有所改变。\u003c/p\u003e\n\n\u003cp\u003e通过-XX:+PrintGCDetails参数可以查看更多垃圾回收相关的信息。下面是串行垃圾收集器使用该参数打印出来的信息。\u003c/p\u003e\n\n\u003cpre\u003e[GC [DefNew: 64575K-\u0026gt;959K(64576K), 0.0457646 secs] 196016K-\u0026gt;133633K(261184K), 0.0459067 secs]\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e这个信息显示，这次小回收收回了 98% 的 DefNew 年轻代的数据，64575K-\u0026gt;959K(64576K) 并在其上消耗了 0.0457646 secs（大约45毫秒）。\u003c/p\u003e\n\n\u003cp\u003e整个堆的占用率下降了大约51％ 196016K-\u0026gt;133633K(261184K)，而且通过最终的时间 0.0459067 secs 显示在垃圾收集中有轻微的开销（在年轻代之外的时间）。\u003c/p\u003e\n\n\u003cp\u003e选项-XX:+PrintGCTimeStamps会提供每次回收开始时间的时间戳。这对于查看垃圾回收频率非常有用。\u003c/p\u003e\n\n\u003cp\u003e111.042: [GC 111.042: [DefNew: 8128K-\u0026gt;8128K(8128K), 0.0000505 secs] 111.042: [Tenured: 18154K-\u0026gt;2311K(24576K), 0.1290354 secs]\u0026#160; 26282K-\u0026gt;2311K(32704K), 0.1293306 secs] \u003c/p\u003e\n\n\u003cp\u003e如上，垃圾回收在程序运行后111秒开始。小回收同时启动。信息中还显示了主回收中的年老代的垃圾回收信息。年老代的空间使用率下降了大约 10% 18154K-\u0026gt;2311K(24576K) ，用时 0.1290354（大约130毫秒）。\u003c/p\u003e\n\n\u003cp\u003e和 -verbose:gc 一样，-XX:+PrintGCDetails 的输出格式在将来的版本里也可能会有所变动。\u003c/p\u003e\n\n\u003ch4\u003e4. 代的尺寸\u003c/h4\u003e\n\n\u003cp\u003e很多参数会应想到代的尺寸。下图是堆中的提交空间和虚拟空间的差别。虚拟机初始化的时候，整个堆空间都是保留的。保留空间可以通过参数 -Xmx 指定。如果-Xms参数小于-Xmx参数，那么不是所有的保留空间都会立刻提交到虚拟机之中。未提交的空间在途中标记为 virtual。堆的不同部分（永久时间段、年老时间段和年轻时间段）可以按需生长到虚拟空间的限制为止。\u003c/p\u003e\n\n\u003cp\u003e一些参数可以调整堆的不同部分的比例，比如参数NewRatio指定年老代对年轻代的比例。这些参数将在下面讨论。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/File?id=d98mwqq_144ddgx8hch_b\" width=\"486\" height=\"270\" /\u003e\u003c/p\u003e\n\n\u003ch5\u003e4.1 全部堆\u003c/h5\u003e\n\n\u003cp\u003e注意，下面的关于堆的生长、收缩和缺省堆大小都不适用于并行垃圾收集器，并行垃圾收集器请参考相关章节。不过，用于控制整个堆大小和代尺寸的参数对并行垃圾收集器都是适用的。\u003c/p\u003e\n\n\u003cp\u003e因为垃圾收集是发生在代被填满的时候，所以，吞吐量反比于可用此内存数量。总可用内存数是影响垃圾收集性能的最重要因素。\u003c/p\u003e\n\n\u003cp\u003e缺省情况下，虚拟己在每次垃圾收集后增加或减少堆尺寸，来尽量保持可用空间对活的对象之间的比例在一个区间之内。这个目标区间通过参数-XX:MinHeapFreeRatio=\u0026lt;minimum\u0026gt;和-XX:MaxHeapFreeRatio=\u0026lt;maximum\u0026gt;来设置，而总的堆大小的界限由-Xms\u0026lt;min\u0026gt;和-Xmx\u0026lt;max\u0026gt;来确定。这些参数在 32 位 Solaris 系统（SPARC 平台版本）中的缺省值如下表所示：\u003c/p\u003e\n\n\u003cp\u003eParameter \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eDefault Value \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eMinHeapFreeRatio\u003cbr /\u003e\n  \u003cbr /\u003e40\u003c/p\u003e\n\n\u003cp\u003eMaxHeapFreeRatio\u003cbr /\u003e\n  \u003cbr /\u003e70\u003c/p\u003e\n\n\u003cp\u003e-Xms\u003cbr /\u003e\n  \u003cbr /\u003e3670k\u003c/p\u003e\n\n\u003cp\u003e-Xmx\u003cbr /\u003e\n  \u003cbr /\u003e64m\u003c/p\u003e\n\n\u003cp\u003e64位系统中的堆尺寸的参数会大 30% 左右，这个增长用来补偿64位系统中更大的对象所带来的开销。\u003c/p\u003e\n\n\u003cp\u003e通过设置这些参数，当一个代的可用空间低于 40%，虚拟机就会把可用内存扩展到 40%，直到代的最大尺寸。同样的，如果可用空间超过 70%，代就会被缩小，使得只有 70% 可用空间，直到达到代最小的空间为止。\u003c/p\u003e\n\n\u003cp\u003e大型服务器程序在使用这些缺省设置时，经常遇到两种问题。其一是慢启动问题，初始的堆尺寸过小，经常需要经历多次主回收才能达到稳定值。另一个更现实的问题是，对于大多数服务器应用来说，这个缺省的最大堆大小太小了。对于服务器程序而言，设置的一般原则是：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e除非遇到了时延问题，给虚拟机尽量多的内存。缺省尺寸（64MB）通常都太小了。\u003c/li\u003e\n\n\u003cli\u003e把-Xms 和 -Xmx 设置成相同的值，把最重要的尺寸决定从虚拟机收回来，从而增强可预见性。\u003c/li\u003e\n\n\u003cli\u003e一般地，随着处理器数量的增加而增加内存，因为内存分配可以被并行化。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e作为参考，有一个单独的页面会介绍各个\u003ca href=\"http://java.sun.com/docs/hotspot/VMOptions.html\"\u003e命令行参数\u003c/a\u003e 。\u003c/p\u003e\n\n\u003ch5\u003e4.2 年轻代\u003c/h5\u003e\n\n\u003cp\u003e影响位居次席的是用于年轻代的堆比例。年轻代越大，小回收的次数也就越少。不过，在一定的堆大小的情况下，年轻代越大，年老代也就越小，这就增加了主回收的频率。最佳选择依赖于应用中分配的对象的生存期分布。\u003c/p\u003e\n\n\u003cp\u003e缺省的，年轻代的尺寸由 NewRatio 控制。比如，设置-XX:NewRatio=3意味着年轻代和年老代的比例是1:3。换句话说， eden 和幸存者空间的总和是整个堆大小的四分之一。\u003c/p\u003e\n\n\u003cp\u003e参数 NewSize 和 MaxNewSize 约束了年轻代的上下界限。可以把这两个参数设成相同的值来固定年轻代的大小，设置 -Xms 和 -Xmx 一样来设置堆大小为固定值。这样可以比使用NewRatio更细粒度地调整年轻代的大小。\u003c/p\u003e\n\n\u003cp\u003e4.2.1 幸存者空间\u003c/p\u003e\n\n\u003cp\u003e如果需要，SurvivorRatio 可以用来调整幸存者空间的大小，不过这对于性能一般影响不大。比如，-XX:SurvivorRatio=6 会设置幸存者空间和eden的比例是 1:6。换句话说，每个幸存者空间将是 eden 的六分之一，是整个年轻代空间的八分之一（不是七分之一，因为一共有两个幸存者空间）。\u003c/p\u003e\n\n\u003cp\u003e如果幸存者空间过小的话，拷贝收集到的幸存者将会直接溢出到年老代的空间中去。如果幸存者空间太大的话，他们也就是空着浪费掉。每次垃圾收集中，虚拟机会选择一个对象在成为年老的之前被复制的次数门限。这个门限的设置会保证幸存者空间是半满的。命令行参数-XX:+PrintTenuringDistribution 可以显示这个门限和年轻代中对象的年龄。这对于观测应用中对象的生存期分布也是有用的。\u003c/p\u003e\n\n\u003cp\u003e下面是 SPARC 上的 32 位 Solaris 的各个参数的缺省值，在其他平台上可能有所差异。\u003c/p\u003e\n\n\u003cp\u003eDefault Value \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eParameter \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eClient JVM \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eServer JVM \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eNewRatio\u003cbr /\u003e\n  \u003cbr /\u003e8\u003c/p\u003e\n\n\u003cp\u003e2\u003c/p\u003e\n\n\u003cp\u003eNewSize\u003cbr /\u003e\n  \u003cbr /\u003e2228K\u003c/p\u003e\n\n\u003cp\u003e2228K\u003c/p\u003e\n\n\u003cp\u003eMaxNewSize\u003cbr /\u003e\n  \u003cbr /\u003enot limited\u003c/p\u003e\n\n\u003cp\u003enot limited\u003c/p\u003e\n\n\u003cp\u003eSurvivorRatio\u003cbr /\u003e\n  \u003cbr /\u003e32\u003c/p\u003e\n\n\u003cp\u003e32\u003c/p\u003e\n\n\u003cp\u003e年轻代的最大尺寸通过最大堆尺寸和 NewRatio 计算而得。所谓的“无限制”的缺省值是说这个计算的值不会受到 MaxNewSize 的约束，除非命令行中指定了这个值。\u003c/p\u003e\n\n\u003cp\u003e服务应用的设置准则是：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e首先确定可以提供给虚拟己的最大堆尺寸。然后根据性能需求来确定年轻代的尺寸，来找到最佳设置。\n\n\u003cul\u003e\n\n\u003cli\u003e注意：最大堆尺寸一定要小于系统中的内存数量，以防止过多的缺页错误和换页。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e如果总的堆尺寸是确定的，增加年轻代的尺寸就会减少年老代的尺寸。一定要保证年老代的尺寸，使之可以容纳所有在应用全程都要用到的活对象，并留有一定裕量（10-20%或更多）。\u003c/li\u003e\n\n\u003cli\u003e依照上述年老代的约束：\n\n\u003cul\u003e\n\n\u003cli\u003e给年轻代分配足够的内存。\u003c/li\u003e\n\n\u003cli\u003e如果有多个处理器，那么分配更多的内存给年轻代，因为内存分配可以并行化。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca name=\"available_collectors\"\u003e\u003c/a\u003e\u003c/p\u003e\n\n\u003ch4\u003e5. 可用的垃圾收集器\u003c/h4\u003e\n\n\u003cp\u003e到目前为止，我们讨论的还都是串行垃圾收集器。不过 Java HotSpot 虚拟机一共支持了三种不同的收集器，每种提供不同的性能特性。\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e串行垃圾收集器使用单线程进行所有垃圾收集工作，因为没有线程间通信的开销，串行垃圾收集器相当高效。串行垃圾收集器最适合于单处理器系统，因为它不会从多处理器硬件中获益，尽管在小数据量的应用中（不大于100MB的），它对于多处理器系统也是游泳的。串行垃圾收集器在一定的硬件和操作系统的配置时会缺省使用，也可以显式地用 -XX:+UseSerialGC 参数来指定。 \u003c/li\u003e\n\n\u003cli\u003e并行垃圾收集器（或吞吐垃圾收集器）并行进行小垃圾收集，这会显著减少垃圾收集的的开销。它适用于中等或大尺寸数据的运行在多处理器或多线程硬件上的应用。并行垃圾收集器也会在一定的硬件和操作系统配置下被缺省使用，同时，也可以使用 -XX:+UseParallelGC 参数来指定。\n\n\u003cul\u003e\n\n\u003cli\u003e更新：“并行压缩”是 J2SE 5.0 update 6 以上版本的新特性，并在 Java SE 6 之中得到加强，该特性允许主回收也并行收集。如果不使用并行压缩，主回收仍然会单线程运行，这会严重限制系统的可伸缩性。并行压缩可以使用命令行参数-XX:+UseParallelOldGC 来打开。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e并发垃圾收集器并发地进行大部分垃圾收集工作（也就是在应用运行当中进行）来尽可能煎炒垃圾收集带来的应用停顿。它是为哪些拥有中到大量数据的、对响应时间要求高于吞吐量要求的应用，因为最小化时延的技术会让吞吐能力付出代价。并发垃圾收集器通过 -XX:+UseConcMarkSweepGC 参数来启用。\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch5\u003e5.1 选择垃圾收集器\u003c/h5\u003e\n\n\u003cp\u003e除非你的应用有非常严酷的时延要求，那么就运行你的应用，并让系统自己选择垃圾收集器好了。如果有必要的话，就调整堆的大小来增进性能。如果性能仍然无法达到你的目标，那就按照如下设置来选择一个垃圾收集器。\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e如果应用的数据很少（大约不超过100MB），那么\n\n\u003cul\u003e\n\n\u003cli\u003e使用-XX:+UseSerialGC选择串行垃圾收集器。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e如果应用运行在单处理器系统中，并且没有什么时延要求，那么\n\n\u003cul\u003e\n\n\u003cli\u003e让虚拟机选择垃圾收集器，或者 \u003c/li\u003e\n\n\u003cli\u003e使用-XX:+UseSerialGC选择串行垃圾收集器。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e如果（a）程序峰值性能是第一位的，并且（b）没有时延要求，或时延要求是一两秒或更长，那么\n\n\u003cul\u003e\n\n\u003cli\u003e让虚拟机选择垃圾收集器，或者 \u003c/li\u003e\n\n\u003cli\u003e使用-XX:+UseParallelGC选择并行垃圾收集器，乃至（可选）通过 -XX:+UseParallelOldGC启用并行压缩。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e如果响应时间比总体吞吐量更为重要，并且垃圾收集时延需要控制在1秒以内，那么\n\n\u003cul\u003e\n\n\u003cli\u003eselect the concurrent collector with -XX:+UseConcMarkSweepGC. If only one or two processors are available, consider using \u003ca href=\"http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html#icms\"\u003eincremental mode\u003c/a\u003e, described below. \u003c/li\u003e\n\n\u003cli\u003e通过 -XX:+UseConcMarkSweepGC 参数启用并发垃圾收集器。进当你有一个或两个处理器可用的时候，考虑使用下文将要介绍的“增量模式”。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e这些指导意见仅仅是选择垃圾收集器的起点，因为性能依赖于堆的尺寸、应用中活数据的数量，以及处理器的数量和速度。时延参数对这些因素尤为敏感，所以，所谓的1秒门限值只是个大致数值：在很多硬件和数据量的组合情况下，并行垃圾收集器可能会导致停顿时间超过1秒；同样，在某些组合下，并发垃圾收集器也不能保证停顿小于1秒。\u003c/p\u003e\n\n\u003cp\u003e如果推荐的垃圾收集器没有达到期望的性能，首先应该尝试堆和代的尺寸，以期达到目标。如果仍然不成功的话，尝试更换一个垃圾收集器：使用并发垃圾收集器来减少停顿时间，使用并行垃圾收集器来增加多处理器系统中的吞吐量。\u003c/p\u003e\n\n\u003ch4\u003e6. 并行垃圾收集器\u003c/h4\u003e\n\n\u003cp\u003e并行垃圾收集器（也被称为吞吐量收集器）和串行收集器类似，也是一种分代垃圾收集器；其最大的不同在于它使用了多线程来加快垃圾收集的过程。并行垃圾收集器可以通过参数 -XX:+UseParallelGC 指定。缺省的，只有小回收会并行运行，主回收仍然单线程运行。不过，通过参数-XX:+UseParallelOldGC启动并行压缩可以让主回收和小回收都并行运行，从而进一步减少垃圾收集开销。\u003c/p\u003e\n\n\u003cp\u003e在一个有N个处理器的计算机上，并行垃圾收集器使用N个垃圾收集器线程。不过，这个数量可以在命令行参数里指定（参见下文）。在一台单处理器的计算机上，由于线程开销（比如同步），并行垃圾收集器的性能应该不如串行垃圾收集器。然而，当应用程序有中等或大尺寸的堆的时候，它在一个双处理器的机器上就会略优于串行垃圾收集器，而如果有多于两个处理器的话，它就能远胜于串行垃圾收集器。\u003c/p\u003e\n\n\u003cp\u003e垃圾收集器线程数的多少可以用-XX:ParallelGCThreads=\u0026lt;N\u0026gt;参数来控制。如果要使用命令行参数显式调整了堆的尺寸，使用并行垃圾收集器的情况下需要的堆的尺寸和使用串行垃圾收集器情况下的堆的尺寸是一阶相等的。使用并行垃圾收集器仅仅是让小回收造成的停顿更短一些。因为有多个垃圾收集器线程参与小回收的过程，有极少的可能性可能会在将年轻代移动到年老代的过程中造成一些碎片。每个垃圾收集线程都有一块专属的年老代的空间，用于年轻代向年老代的移动，将年老代的可用空间划分为“移动缓冲”（promotion buffer）的过程可能会造成一定的碎片效应。减少垃圾收集器线程的数量可以减少碎片、增加年老代的空间。\u003c/p\u003e\n\n\u003ch5\u003e6.1 代\u003c/h5\u003e\n\n\u003cp\u003e正如上面提到的，并行垃圾收集器的代的排布方式和串行垃圾收集器略有不同。其分布如下图所示。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/File?id=d98mwqq_145dnsx7mg9_b\" width=\"411\" height=\"223\" /\u003e\u003c/p\u003e\n\n\u003ch5\u003e6.2 功效学\u003c/h5\u003e\n\n\u003cp\u003e自 J2SE 5.0 以来，并行垃圾收集器成为了server级机器的缺省垃圾收集器，详细资料可以参考“\u003ca href=\"http://java.sun.com/j2se/1.5.0/docs/guide/vm/gc-ergonomics.html\"\u003eGarbage Collector Ergonomics\u003c/a\u003e”。此外，并行垃圾收集器使用一种自动调整机制来指定期望的行为而不是指定代的大小和其他底层调整细节。这些行为包括：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e最大垃圾收集停顿时间\u003c/li\u003e\n\n\u003cli\u003e吞吐量\u003c/li\u003e\n\n\u003cli\u003eFootprint (也就是堆尺寸)\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e最大停顿时间的目标由参数-XX:MaxGCPauseMillis=\u0026lt;N\u0026gt;来指定。这个参数被解释为指定停顿时间不得大于\u0026lt;N\u0026gt;毫秒；缺省情况下没有最大停顿时间目标。如果指定了一个停顿时间目标，堆尺寸和其他垃圾回收相关参数就会被相应调整，以便保持垃圾回收时间小于指定的值。注意，这些调整可能会导致总体吞吐量的降低，而且，在某些情况下，要求的停顿时间目标可能无法达到。\u003c/p\u003e\n\n\u003cp\u003e吞吐量目标测量垃圾回收时间和非垃圾回收时间（也就是应用时间）的比例。这个目标时间可以用命令行参数-XX:GCTimeRatio=\u0026lt;N\u0026gt;来指定，这样，垃圾回收时间和应用时间的比例将是1 / (1 + \u0026lt;N\u0026gt;)。例如，-XX:GCTimeRatio=19设置1/20活5%的时间用于垃圾回收。缺省值是99，目标是1%的时间用于垃圾回收。\u003c/p\u003e\n\n\u003cp\u003e最大堆footprint使用已经存在的 -Xmx\u0026lt;N\u0026gt; 参数。此外，如果没有其他的优化目标的话，垃圾收集器有一个隐式的最小化堆尺寸的目标。\u003c/p\u003e\n\n\u003cp\u003e6.2.1 目标的优先级\u003c/p\u003e\n\n\u003cp\u003e目标的优先级顺序如下：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e最大停顿时间目标 \u003c/li\u003e\n\n\u003cli\u003e吞吐量目标\u003c/li\u003e\n\n\u003cli\u003e最小堆尺寸目标\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e最大停顿时间目标会被首先满足。仅当最大停顿目标被满足的情况下，才会去满足吞吐量目标。类似的，仅当前两个目标都会满足的情况下，才会考虑去满足footprint目标。\u003c/p\u003e\n\n\u003cp\u003e6.2.2 时间段尺寸调整\u003c/p\u003e\n\n\u003cp\u003e每次垃圾收集结束的时候，垃圾收集器都会更新其保存的平均停顿时间之类的统计参量。同时它会检查各个目标是否被满足了，是否有调整代尺寸的需要。这之中的意外情况就是显式的垃圾收集（比如调用 System.gc()）会在统计和调整判断中被忽略掉。\u003c/p\u003e\n\n\u003cp\u003e增加和缩小一个代的大小是通过增加活缩小一个固定的百分比来达到的，这样一个代要分步来达到需要的尺寸。增加活所见是以不同的比率来进行的。缺省情况下，一次增加 20% 活减少 5%。年轻代和年老代增量的比例分别通过命令行参数 -XX:YoungGenerationSizeIncrement=\u0026lt;Y\u0026gt;和-XX:TenuredGenerationSizeIncrement=\u0026lt;T\u0026gt;来设定。而缩小比例的要通过-XX:AdaptiveSizeDecrementScaleFactor=\u0026lt;D\u0026gt;参数来设定。如果增量是X%，那么每次减小量就是(X/D)%。\u003c/p\u003e\n\n\u003cp\u003e如果垃圾收集器决定在启动的时候增加一个代的大小，会有一个额外的百分比的增量。这个附加的增量随着收集的次数而减少，不会长期影响。这个额外增量意在提高启动速度。缩小代的尺寸是没有这个额外的增量。\u003c/p\u003e\n\n\u003cp\u003e如果最大停顿时间目标没有达到，会有且仅有一个代的大小被缩小。如果两个代都在目标之上，停顿时间较大的那个代会首先被缩小。\u003c/p\u003e\n\n\u003cp\u003e如果总体吞吐量目标没有达到，那么两个代的大小都会增加。每个都按照各自对垃圾回收时间的贡献比例分别增加。比如，如果年轻代的垃圾回收时间占去了25%的总垃圾回收时间，并且年轻代的全部增量应该是20%，那么这时它的增量就是5%。\u003c/p\u003e\n\n\u003cp\u003e6.2.3 缺省堆尺寸\u003c/p\u003e\n\n\u003cp\u003e如果没有在命令行中进行设置，初始和最大堆尺寸会通过计算机内存计算而得。如下表所示，对大小占用的内存的比例是由参数 DefaultInitialRAMFraction和DefaultMaxRAMFraction来控制的。（表中的 memory 代表计算机的系统内存数量。）\u003c/p\u003e\n\n\u003cp\u003eFormula \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eDefault \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003einitial heap size\u003cbr /\u003e\n  \u003cbr /\u003ememory / DefaultInitialRAMFraction\u003c/p\u003e\n\n\u003cp\u003ememory / 64\u003c/p\u003e\n\n\u003cp\u003emaximum heap size\u003cbr /\u003e\n  \u003cbr /\u003eMIN(memory / DefaultMaxRAMFraction, 1GB)\u003c/p\u003e\n\n\u003cp\u003eMIN(memory / 4, 1GB)\u003c/p\u003e\n\n\u003cp\u003e注意，缺省的最大堆尺寸不会超过1GB，不论系统中到底有多少内存。\u003c/p\u003e\n\n\u003ch5\u003e6.3 过多的GC时间和OutOfMemory错误\u003c/h5\u003e\n\n\u003cp\u003e当有过多的时间花费在垃圾收集上的时候，并行垃圾收集器会跑出 OutOfMemoryError 错误：如果超过 98% 的时间花费在垃圾收集上并且只有 2% 的堆被释放的话，就会抛出一个 OutOfMemory。这个功能是用来防止堆太小导致程序长时间无法正常工作而设计的。如果必要，这个功能可以使用命令行参数-XX:-UseGCOverheadLimit来关闭。\u003c/p\u003e\n\n\u003ch5\u003e6.4 测量\u003c/h5\u003e\n\n\u003cp\u003e并行垃圾收集器的垃圾收集器详细输出和串行垃圾收集器是一样的。\u003c/p\u003e\n\n\u003ch4\u003e7. 并发垃圾收集器\u003c/h4\u003e\n\n\u003cp\u003e并发垃圾收集器适用于那些需要更短的垃圾收集停顿，并能为此付出程序运行期处理器资源的应用。典型情况下，那些拥有较多长期存在的对象（年老代比较大），并且运行在拥有两个活更多处理器的应用可能会因此获益。不过，在任何要求很低停顿时间的应用都应该考虑这个垃圾收集器；比如，拥有较小年老代的交互程序在但处理器上使用并发垃圾收集器就可以收到明显的好处，特别是使用增量模式的时候。并发垃圾收集器可以通过命令行参数-XX:+UseConcMarkSweepGC来启动。\u003c/p\u003e\n\n\u003cp\u003e和其他垃圾收集器类似，并发垃圾收集器也是分代的；所以也有小回收和主回收。并发垃圾收集器通过使用独立的垃圾收集线程于应用本身的线程并发执行跟踪所有可及的对象，以期降低主回收导致的停顿。在每个主回收周其中，并发垃圾收集器会在垃圾收集的开始让所有应用线程暂停一下，并在回收中段再暂停一次。第二次暂停相对而言会更长一些，在此期间会有多个线程来进行收集工作。剩下的收集工作包括大部分的活对象跟踪和清除不可及的对象的工作都由一个或多个和应用并发的垃圾收集器线程来进行。小回收会在进行的主回收周其中穿插进行，其模式和并行垃圾收集器十分类似（特别需要说明的就是，在小回收期间，应用线程是会有停顿的）。\u003c/p\u003e\n\n\u003cp\u003e并发垃圾收集器的基本算法在技术报告 \u003ca href=\"http://research.sun.com/techrep/2000/abstract-88.html\"\u003eA Generational Mostly-concurrent Garbage Collector\u003c/a\u003e里有介绍。主义，实际的实现细节在不同版本里手有细微的变化的，因为垃圾收集器也在一直进步。\u003c/p\u003e\n\n\u003ch5\u003e7.1 并发性的开销\u003c/h5\u003e\n\n\u003cp\u003e并发垃圾收集器的短主回收停顿时间是以处理器资源作为代价的（这些资源如果不用在收集器上肯定就要用在应用上了）。最明显的开销就是并发地使用了一个或多个处理器资源。在N处理器系统中，垃圾收集的并发部分会使用K/N的可用处理器，其中 1\u0026lt;=K\u0026lt;=ceiling{N/4}。（注意，K值的上限将来可能会有变化。）并发垃圾收集器不仅在并发阶段使用处理器，还引入了其他的开销。所以，尽管并发垃圾收集器显著减少了程序的停顿，但和其他垃圾收集器相比，应用的总体吞吐量会受到轻微的影响。\u003c/p\u003e\n\n\u003cp\u003e在拥有多个处理器的计算机上，在并发垃圾收集器运行的时候，应用程序仍然能使用到CPU，所以，并发垃圾收集器并没有让程序停顿。这通常意味着更短的停顿，谈也意味着更少的应用可用的处理器资源，并且让它运行得相对比较慢，特别是当应用可以完全的利用多个CPU核心的时候更是如此。随着N的上升，垃圾收集器导致的损失会相对变小，而从并发垃圾收集的获益则相对提高。下一节“并发模式失败”会讨论这种规模扩张的潜在局限。\u003c/p\u003e\n\n\u003cp\u003e因为在并发阶段至少有一个处理器用于了垃圾收集，所以在单处理器（单核）系统中，并发垃圾收集器一般不会带来什么好处。不过，并发垃圾收集有一个分离模式可以在单处理器或双处理器系统中显著减少停顿时间；后面的增量模式中将会进一步介绍其细节。\u003c/p\u003e\n\n\u003ch5\u003e7.2 并发模式失败\u003c/h5\u003e\n\n\u003cp\u003e并发垃圾收集器使用一个或多个垃圾收集线程在应用线程执行的同时运行，从而在年老代和永久代变满之前就完成垃圾收集。如前文所述，在一般的操作中，并发垃圾收集器的大部分跟踪与清理工作是在程序运行的同时进行的，所以，程序线程只有极少的停顿。但是，如果并发垃圾收集器在年老代变满的时候仍没有完成垃圾清除工作，或是年老代中的可用空间无法满足一次分配操作的需要的时候，应用就不得不被暂停下来以等待应用线程结束了。这种无法并发地完成垃圾收集的情况被称为“并发模式失败”，这就需要对并发垃圾收集器的参数进行调整了。\u003c/p\u003e\n\n\u003ch5\u003e7.3 过多的GC时间和OutOfMemory错误\u003c/h5\u003e\n\n\u003cp\u003e并发垃圾收集器会在垃圾收集消耗时间过多的时候抛出 OutOfMemoryError 错误：如果多于 98% 的时间被花费在了垃圾手机上，并且仅有少于 2% 的堆被回收的话，就会抛出 OutOfMemoryError。这个功能是用来防止堆太小导致程序长时间无法正常工作而设计的。如果必要，这个功能可以使用命令行参数-XX:-UseGCOverheadLimit来关闭。 \u003c/p\u003e\n\n\u003cp\u003e这个策略和并行垃圾收集器是基本一致的，惟一的区别就是并发的垃圾收集时间并未计算在内。也就是说，只有哪些程序停顿下来进行垃圾收集的时间才被计算在内了。这些垃圾收集常常是由于并发模式失败或是显式垃圾收集请求（如调用 System.gc()）导致的。\u003c/p\u003e\n\n\u003ch5\u003e7.4 浮动垃圾\u003c/h5\u003e\n\n\u003cp\u003e并发垃圾收集器与 HotSpot 中的其他垃圾收集器一样，是一种识别至少所有在堆中可以被访问到的对象的跟踪收集器。按照\u003ca href=\"http://java.sun.com/javase/technologies/hotspot/gc/gc_tuning_6.html#resources.jones_lins_book\"\u003eJones and Lins\u003c/a\u003e的说法，是一种增量更新（Incremental Update）垃圾收集器。因为应用现成和垃圾收集器线程在主回收过程中并发执行，那么那些垃圾收集器跟踪的对象就可能在垃圾收集完成之后变成垃圾这些无法访问却还没有被回收的对象被称为浮动垃圾（floating garbage）。浮动垃圾的数量取决于垃圾收集周期的长度和程序中引用更新的频率，也被称为转化率（mutation）。而且，另一个原因是年轻代和年老代的收集是独立的，彼此都是对方的根。一个粗略的配置规则是为年老代的浮动垃圾多预留出20%的空间来。一个垃圾回收周期中的堆中的浮动垃圾会在下一个垃圾回收周期中被回收。\u003c/p\u003e\n\n\u003ch5\u003e7.5 时延（停顿）\u003c/h5\u003e\n\n\u003cp\u003e并发垃圾收集器在一个并发回收周期中会两次暂停应用。第一次会从根从根（比如从对象线程栈和寄存器、静态对象等的引用）和堆的其他部分（如年轻代）开始标记所有直接可达的活的对象。第一次停顿被称为“初始标记停顿”（initial mark pause）。第二次停顿发生在并发跟踪阶段末尾，用来发现由于在垃圾收集线程跟踪完一个对象之后又被应用线程更新了其引用而没有被并发跟踪到的对象。这次停顿被称为“重标记停顿”（remark pause）。\u003c/p\u003e\n\n\u003ch5\u003e7.6 并发阶段\u003c/h5\u003e\n\n\u003cp\u003e可达对象的并发跟踪图发生在初始标记停顿和重标记停顿之间。在并发跟踪阶段中，一个或多个并发垃圾收集器线程会使用那些本来可能会被应用使用的处理器资源，所以尽管不会停顿，计算密集型应用可能会在此阶段和其他并发阶段受到相当的吞吐量损失。在重标记停顿之后，还有一个并发清理阶段，会收集所有标记为不可达的对象。一旦手机周期结束了，并发收集器就会进入等待阶段，这时就基本不会消耗任何计算资源了，直到下一个主回收周期开始为止。\u003c/p\u003e\n\n\u003ch5\u003e7.7 开始并发收集周期\u003c/h5\u003e\n\n\u003cp\u003e在串行收集器中，每当年老代满了的时候都会引发一次主回收，所有应用现成都会在主回收期间暂停运行。并发垃圾收集器与之不同，它需要在足够早的时间开始垃圾收集，以便能在年老代变满之前完成垃圾收集；否则的话就会因为并发模式失败而导致较长的时延。有很多种条件可以触发并发垃圾收集器启动。\u003c/p\u003e\n\n\u003cp\u003e基于最近的历史记录，并发垃圾收集器维护了一个年老代变满的预期剩余时间和一个垃圾收集周期的预期时间。基于这些动态估计，并发垃圾收集周期会以让垃圾收集周期在年老代变满之前完成为目标开始并发垃圾收集周期。因为并发模式失败的代价非常惨重，这些估值都流出了安全裕量。\u003c/p\u003e\n\n\u003cp\u003e并发垃圾收集在年老代的已用百分比超出了一个初始占有率值（initiating occupancy）的时候也会启动。这个初始占有率阈值的缺省值大约是 92%，不过这个值可能在不同版本中略有不同。它也可以通过命令行参数-XX:CMSInitiatingOccupancyFraction=\u0026lt;N\u0026gt; 来手工设置，其中N是一个0-100的整数，代表年老代的占用百分比。\u003c/p\u003e\n\n\u003ch5\u003e7.8 调度中断\u003c/h5\u003e\n\n\u003cp\u003e年轻代和年老代的垃圾收集的停顿发生彼此间是独立的。他们不会重合，但可能会连续发生，这样也就让一个垃圾收集的停顿连上下一个垃圾收集的停顿了，从外界来看就是一个长停顿了。为了避免这种情况，并发垃圾收集器会调度重标记停顿的时间，使之发生在前后两个年轻代停顿之间。这个调度目前还不应用于初始标记停顿，因为它通常会比重标记停顿短很多。\u003c/p\u003e\n\n\u003ch5\u003e7.9 增量模式\u003c/h5\u003e\n\n\u003cp\u003e并发垃圾收集器可以在这样一种模式下工作：并发阶段以增量的方式进行。回忆一下，在并发阶段，垃圾回收线程会使用一个或多个处理器。所谓增量模式是指减少长并发阶段的影响，周期性中断并发阶段，将处理器资源还给应用程序。这种模式又称为“i-cms”，将垃圾收集器的并发工作划分到小块时间，在年轻代垃圾收集之间进行。这个功能对于那些工作在没那么多处理器的机器上（1或2个处理器的）需要并发垃圾收集器的低时延应用非常有用。\u003c/p\u003e\n\n\u003cp\u003e并发垃圾收集周期通常包括如下几步：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e停止所有的应用线程，标记从根开始可达的对象集，然后继续所有的应用线程\u003c/li\u003e\n\n\u003cli\u003e在应用线程运行的同时，使用一个或更多的处理器，并发跟踪可达的对象图\u003c/li\u003e\n\n\u003cli\u003e使用一个处理器，并发跟踪对象图中在上一步开始之后的各个改动的部分\u003c/li\u003e\n\n\u003cli\u003e停止所有的应用线程，重新跟踪根和对象图中自从上次检查开始发生了变化的部分，然后继续运行线程\u003c/li\u003e\n\n\u003cli\u003e使用一个处理器，并发地把不可达对象清理到用于分配空间的 free list 上面去。\u003c/li\u003e\n\n\u003cli\u003e使用一个处理器并发地调整堆的大小，准备下一个回收周期所需的数据结构\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e正常情况下，并发垃圾收集器在并发跟踪阶段使用一个或多个处理器，不会让出它们。类似的，在清理阶段也会始终独占地使用一个处理器。这对于对于一个程序的响应时间可能是个不小的影响，特别是系统中只有一两个CPU的时候。增量模式通过将并发阶段分解为一系列的突发行为来降低这一影响，这些突发行为会散布在小回收之间。\u003c/p\u003e\n\n\u003cp\u003ei-cms 使用占空比来控制并发收集器自发的放弃处理器之前的工作量。占空比是年轻代收集之间的允许并发垃圾收集器运行时间的百分比。i-cms 可以根据应用的行为自动计算占空比（这也是推荐的方法，称为自动步长（auto pacing）），当然，也可以通过命令行指定一个固定的值。\u003cbr /\u003e\n  \u003cbr /\u003e7.9.1 命令行参数\u003c/p\u003e\n\n\u003cp\u003e下面是控制 i-cms的命令行参数（参考下文的初始设置建议）：\u003c/p\u003e\n\n\u003cp\u003e参数 \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e描述 \u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e缺省值\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eJ2SE 5.0 及以前\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003eJava SE 6 及以后\u003c/p\u003e\n\n\u003chr /\u003e\n\n\u003cp\u003e-XX:+CMSIncrementalMode\u003cbr /\u003e\n  \u003cbr /\u003e启动增量模式。注意，并发垃圾收集器必须也被选择(-XX:+UseConcMarkSweepGC) ，否则此参数无效。\u003c/p\u003e\n\n\u003cp\u003edisabled\u003c/p\u003e\n\n\u003cp\u003edisabled\u003c/p\u003e\n\n\u003cp\u003e-XX:+CMSIncrementalPacing\u003cbr /\u003e\n  \u003cbr /\u003e打开自动步长，这样，增量模式占空比将根据JVM统计到的信息自动调整。\u003c/p\u003e\n\n\u003cp\u003edisabled\u003c/p\u003e\n\n\u003cp\u003eenabled\u003c/p\u003e\n\n\u003cp\u003e-XX:CMSIncrementalDutyCycle=\u0026lt;N\u0026gt;\u003cbr /\u003e\n  \u003cbr /\u003e两次小回收之间的允许并发收集器运行的时间的百分比（0-100）。如果打开自动步长，那么这个值就是初始值。\u003c/p\u003e\n\n\u003cp\u003e50\u003c/p\u003e\n\n\u003cp\u003e10\u003c/p\u003e\n\n\u003cp\u003e-XX:CMSIncrementalDutyCycleMin=\u0026lt;N\u0026gt;\u003cbr /\u003e\n  \u003cbr /\u003e自动步长打开后，占空比值的下限 (0-100)。\u003c/p\u003e\n\n\u003cp\u003e10\u003c/p\u003e\n\n\u003cp\u003e0\u003c/p\u003e\n\n\u003cp\u003e-XX:CMSIncrementalSafetyFactor=\u0026lt;N\u0026gt;\u003cbr /\u003e\n  \u003cbr /\u003e计算占空比值时使用的一个裕量（0-100）\u003c/p\u003e\n\n\u003cp\u003e10\u003c/p\u003e\n\n\u003cp\u003e10\u003c/p\u003e\n\n\u003cp\u003e-XX:CMSIncrementalOffset=\u0026lt;N\u0026gt;\u003cbr /\u003e\n  \u003cbr /\u003e在小回收之间，增量模式中占空比开始的时间，或说是向右的平移量（0-100）\u003c/p\u003e\n\n\u003cp\u003e0\u003c/p\u003e\n\n\u003cp\u003e0\u003c/p\u003e\n\n\u003cp\u003e-XX:CMSExpAvgFactor=\u0026lt;N\u0026gt;\u003cbr /\u003e\n  \u003cbr /\u003e当进行并发回收统计，计算指数平均值时，当前采样所用的权值（0-100）\u003c/p\u003e\n\n\u003cp\u003e25\u003c/p\u003e\n\n\u003cp\u003e25\u003c/p\u003e\n\n\u003cp\u003e7.9.2 建议参数\u003c/p\u003e\n\n\u003cp\u003e要在 Java SE 6 里使用 i-cms，需要使用如下命令行参数\u003c/p\u003e\n\n\u003cpre\u003e-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode \\\u003cbr /\u003e-XX:+PrintGCDetails -XX:+PrintGCTimeStamps\u003c/pre\u003e\n\n\u003cp\u003e前两个参数分别启动并发垃圾收集器和 i-cms。后两个参数不是必须的，它们只是要求垃圾收集器将诊断信息打印到标准输出，这样，垃圾收集器的行为就可以被看到并用于以后分析了。\u003c/p\u003e\n\n\u003cp\u003e注意，对于 J2SE 5.0 和之前的版本，我们建议 i-cms 使用如下的初始命令行参数：\u003c/p\u003e\n\n\u003cpre\u003e-XX:+UseConcMarkSweepGC -XX:+CMSIncrementalMode \\\u003cbr /\u003e-XX:+PrintGCDetails -XX:+PrintGCTimeStamps \\\u003cbr /\u003e-XX:+CMSIncrementalPacing -XX:CMSIncrementalDutyCycleMin=0\u003cbr /\u003e-XX:CMSIncrementalDutyCycle=10\u003c/pre\u003e\n\n\u003cp\u003e这样，就是用了和 Java SE 6 一致的参数了，多出的三个参数用于自动调整占空比。这些多余的参数值完全是使用的 Java SE 6 的缺省值。\u003c/p\u003e\n\n\u003cp\u003e7.9.3 基本问题处理\u003c/p\u003e\n\n\u003cp\u003ei-cms 的自动占空比计算模式使用了程序运行时收集到的统计信息进行占空比计算，以保证并发垃圾收集器可以在堆占满之前完成。不过，使用过去的行为预测将来的变化的估计方式可能并不总是足够准确，可能在某些情况下无法阻止堆用满。如果需要收集的垃圾太多，可以尝试下面这些步骤，一次使用一个：\u003c/p\u003e\n\n\u003cp\u003eStep\u003cbr /\u003e\n  \u003cbr /\u003eOptions\u003c/p\u003e\n\n\u003cp\u003e1. 增加保险系数\u003cbr /\u003e\n  \u003cbr /\u003e-XX:CMSIncrementalSafetyFactor=\u0026lt;N\u0026gt;\u003c/p\u003e\n\n\u003cp\u003e2. 增加最小占空比\u003cbr /\u003e\n  \u003cbr /\u003e-XX:CMSIncrementalDutyCycleMin=\u0026lt;N\u0026gt;\u003c/p\u003e\n\n\u003cp\u003e3. 关闭自动占空比计算，使用固定占空比\u003cbr /\u003e\n  \u003cbr /\u003e-XX:-CMSIncrementalPacing -XX:CMSIncrementalDutyCycle=\u0026lt;N\u0026gt;\u003c/p\u003e\n\n\u003ch5\u003e7.10 测量\u003c/h5\u003e\n\n\u003cp\u003e下面是使用-verbose:gc和-XX:+PrintGCDetails参数时，并发垃圾收集器的输出，一些小细节已经被去掉了。注意，并发垃圾收集器的输出里掺杂着小回收的输出；典型情况下，很多小回收会发生在并发收集周期之中。其中的CMS-initial-mark表征了一个并发垃圾回收周期的开始。CMS-concurrent-mark: 标志着并发标记阶段的完成，而CMS-concurrent-sweep则标志着并发清除阶段的完成。之前没有提到过的预清除阶段以CMS-concurrent-preclean为标志。预清除可以和重标记阶段CMS-remark的准备工作同时运行。最后一个阶段是CMS-concurrent-reset，这是下一个并发收集周期的准备工作。\u003c/p\u003e\n\n\u003cpre\u003e\u003cbr /\u003e[GC [1 CMS-initial-mark: 13991K(20288K)] 14103K(22400K), 0.0023781 secs]\u003cbr /\u003e[GC [DefNew: 2112K-\u0026gt;64K(2112K), 0.0837052 secs] 16103K-\u0026gt;15476K(22400K), 0.0838519 secs]\u003cbr /\u003e...\u003cbr /\u003e[GC [DefNew: 2077K-\u0026gt;63K(2112K), 0.0126205 secs] 17552K-\u0026gt;15855K(22400K), 0.0127482 secs]\u003cbr /\u003e[CMS-concurrent-mark: 0.267/0.374 secs]\u003cbr /\u003e[GC [DefNew: 2111K-\u0026gt;64K(2112K), 0.0190851 secs] 17903K-\u0026gt;16154K(22400K), 0.0191903 secs]\u003cbr /\u003e[CMS-concurrent-preclean: 0.044/0.064 secs]\u003cbr /\u003e[GC [1 CMS-remark: 16090K(20288K)] 17242K(22400K), 0.0210460 secs]\u003cbr /\u003e[GC [DefNew: 2112K-\u0026gt;63K(2112K), 0.0716116 secs] 18177K-\u0026gt;17382K(22400K), 0.0718204 secs]\u003cbr /\u003e[GC [DefNew: 2111K-\u0026gt;63K(2112K), 0.0830392 secs] 19363K-\u0026gt;18757K(22400K), 0.0832943 secs]\u003cbr /\u003e...\u003cbr /\u003e[GC [DefNew: 2111K-\u0026gt;0K(2112K), 0.0035190 secs] 17527K-\u0026gt;15479K(22400K), 0.0036052 secs]\u003cbr /\u003e[CMS-concurrent-sweep: 0.291/0.662 secs]\u003cbr /\u003e[GC [DefNew: 2048K-\u0026gt;0K(2112K), 0.0013347 secs] 17527K-\u0026gt;15479K(27912K), 0.0014231 secs]\u003cbr /\u003e[CMS-concurrent-reset: 0.016/0.016 secs]\u003cbr /\u003e[GC [DefNew: 2048K-\u0026gt;1K(2112K), 0.0013936 secs] 17527K-\u0026gt;15479K(27912K), 0.0014814 secs]\u003cbr /\u003e\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e初始标记停顿在典型情况下比小回收的停顿时间还要小。而如上例所示，并发阶段（并发标记、并发预清除和并发清除）通常会比小回收长很多。不过注意，应用并没有在这些并发阶段中停顿下来。重标记停顿通常和一个小回收的长度相当。重标记停顿挥手道应用的某些特征（如高对象修改频率可能会增加这个停顿）和上一次小回收的时间（即，更多的年轻代对象可能会增加这个停顿）的影响。\u003c/p\u003e\n\n\u003ch4\u003e8. 其他考虑\u003c/h4\u003e\n\n\u003ch5\u003e8.1 永久代尺寸\u003c/h5\u003e\n\n\u003cp\u003e在大部分应用中，永久代对于垃圾回收性能没有显著的影响。不过，一些应用会动态的生成与加载很多类；比如，一些 JavaServer Pages（JSP）页面的实现。这些应用可能需要很大的永久代去存放一些多余的类。如果这样的话，最大永久代的尺寸可以用命令行参数-XX:MaxPermSize=\u0026lt;N\u0026gt;来增大。\u003c/p\u003e\n\n\u003ch5\u003e8.2 Finalization; Weak, Soft and Phantom References\u003c/h5\u003e\n\n\u003cp\u003e一些应用使用 finalization 和 weak, soft, phantom 引用与垃圾收集器交互。这些特征可以 Java 语言层带来性能影响。一个例子是通过 finalization 来关闭文件描述符，这会导致一个外部资源依赖于垃圾收集器。以来垃圾收集器来管理内存之外的资源是个坏主意。\u003c/p\u003e\n\n\u003cp\u003e参考资料章节中的文章深度讨论了一些finalization的常见错误和用来避免这些错误的技术。\u003c/p\u003e\n\n\u003ch5\u003e8.3 显式垃圾回收\u003c/h5\u003e\n\n\u003cp\u003e应用程序和垃圾回收器的另一个交互途径是显式调用 System.gc() 进行完整的垃圾回收。这回强制进行一次主回收，即使没有必要（也就是说一次小回收可能就足够了），所以应该避免这种情况。显式垃圾回收对性能的影响可以通过使用 -XX:+DisableExplicitGC 进行比较来进行测量，这样虚拟机会无视 System.gc() 的。\u003c/p\u003e\n\n\u003cp\u003e最常见的显式调用垃圾回收的场景是 RMI 的分布式垃圾回收。使用 RMI 的应用会引用到其他虚拟机中的对象。在这种分布式应用的场景下，本地堆中的垃圾可能不能被回收掉，所以 RMI 会周期性强制进行完整的垃圾回收。这些回收的频率可以使用参数来控制。如\u003c/p\u003e\n\n\u003cp\u003ejava -Dsun.rmi.dgc.client.gcInterval=3600000 -Dsun.rmi.dgc.server.gcInterval=3600000 ...\u003c/p\u003e\n\n\u003cp\u003e这里指定了垃圾回收每小时运行一次，而不是缺省的每分钟一次。不过，这可能会导致某些对象的清除消耗太长时间。这些参数可以被设置到高达Long.MAX_VALUE来让显式垃圾回收的间隔时间无限长，如果没有合适的DGC上限时间的话。 \u003c/p\u003e\n\n\u003ch5\u003e8.4 Soft References\u003c/h5\u003e\n\n\u003cp\u003eSoft reference在虚拟机中比在客户集中存活的更长一些。其清除频率可以用命令行参数 -XX:SoftRefLRUPolicyMSPerMB=\u0026lt;N\u0026gt;来控制，这可以指定每兆堆空闲空间的 soft reference 保持存活（一旦它不强可达了）的毫秒数，这意味着每兆堆中的空闲空间中的 soft reference 会（在最后一个强引用被回收之后）存活1秒钟。注意，这是一个近似的值，因为 soft reference 只会在垃圾回收时才会被清除，而垃圾回收并不总在发生。\u003c/p\u003e\n\n\u003ch5\u003e8.5 Solaris 8 替换 libthread\u003c/h5\u003e\n\n\u003cp\u003eSolaris 8 操作系统提供了一个替代的线程库，libthread, 它将线程直接绑定成了轻量级进程（LWP）。有些应用能够从中极大获益，并潜在的对所有多线程应用都或多或少的有好处。下面的命令会为 java 启用替换的 libthread（BASH 格式）\u003c/p\u003e\n\n\u003cpre\u003eLD_PRELOAD=/usr/lib/lwp/libthread.so.1\u003cbr /\u003eexport LD_PRELOAD\u003cbr /\u003ejava ...\u003c/pre\u003e\n\n\u003cp\u003e这个方法仅对 Solaris 8 适用，因为对 Solaris 9 操作系统来说，这是缺省的，而 Solaris 10 中，这是惟一的线程库。\u003c/p\u003e\n\n\u003ch4\u003e9. 相关资源\u003c/h4\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\u003ca href=\"http://java.sun.com/docs/hotspot/HotSpotFAQ.html\"\u003eHotSpot VM Frequently Asked Questions (FAQ)\u003c/a\u003e\u003c/li\u003e\n\n\u003cli\u003e\u003ca href=\"http://java.sun.com/docs/hotspot/gc1.4.2/example.html\"\u003eGC output examples\u003c/a\u003e 介绍了如何解释不同垃圾收集器的输出。 \u003c/li\u003e\n\n\u003cli\u003e\u003ca name=\"resources.finalization_article\"\u003e\u003c/a\u003e\u003ca href=\"http://www.devx.com/Java/Article/30192\"\u003eHow to Handle Java Finalization's Memory-Retention Issues\u003c/a\u003e 介绍了一些容易犯的错误和避免他们的方法。 \u003c/li\u003e\n\n\u003cli\u003e\u003ca name=\"resources.jones_lins_book\"\u003eRichard Jones and Rafael Lins, Garbage Collection: Algorithms for Automated Dynamic Memory Management, Wiley and Sons (1996), ISBN 0-471-94148-4\u003c/a\u003e\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e在本网站中，名词“Java Virtual Machine” 和“JVM” 都代表 Java 平台虚拟机。\u003c/p\u003e\n","cover":"","link":"translation/2008/11/16/java-se-6-hotspot-[tm]-虚拟机垃圾回收调优/index.html","preview":"","title":"Java SE 6 Hotspot [TM] 虚拟机垃圾回收调优"},{"content":"\n\u003cp\u003e2004年12月，我还是LinuxFocus的中文编辑（志愿者，呵呵），为她写了一篇关于Linux 下玩弄无线网卡的文章（\u003ca href=\"http://www.linuxfocus.org/ChineseGB/December2004/article361.shtml\"\u003e中文版\u003c/a\u003e、\u003ca href=\"http://www.linuxfocus.org/English/December2004/article361.shtml\"\u003e英文版\u003c/a\u003e），时至今日，仍在被转载中，也很容易 Google 到，不过该文章中对各种无线认证技术的描述语焉不详，这实在是当时水平有限，而且也缺少环境。直到今年，才自己在家弄了个 Linksys 搭上玩玩。\u003c/p\u003e\n\n\u003cp\u003e搭上无线网之后，一直也没准备写这篇介绍，一来是自己没什么长进，不想丢人来，二来也是 NetworkManager 实在很方便，比 Windows 的无线网卡配置要简单很多，觉得完全没有必要写东西介绍。不过，后来发现 NetworkManager 作为新兴工具，还存在很多不稳定的地方，有时会有一些莫名其妙的问题，因此，又回到了命令行/配置文件+后台Daemon的老朋友那，这里，向各位介绍 wpa_supplicant 的使用。\u003c/p\u003e\n\n\u003cp\u003e[注：如果你的环境中，NetworkManager 可以使用的话，大可不必如此费力，保持所有配置文件都是空的，在图形界面中配置即可。]   \u003cbr /\u003e[注2：本文适用于 Debian 系统，其它 Distro 有所不同，仅供参考。]\u003c/p\u003e\n\n\u003cp\u003eWPA_supplicant 是 WPA/WPA2 认证的客户端，同时也适用于 WEAP，对有线、无线网络都可以使用，不过，WPA2/TKIP （就是前两天说被破解了的那个，不过目前仍然是最安全的WLAN无线连接方式。哦？你说WAPI？哦，不好意思，我没见过真的，不好说哈。）还是我们最首选的方式。\u003c/p\u003e\n\n\u003cp\u003e要使用 WPA_Supplicant，在 /etc/network/interfaces （这个网卡配置文件的格式是 Debian 系的特点 RH/SuSE 系有明显不同，未做研究）中，需要指定使用 WPA_supplicant\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cpre\u003eallow-hotplug wlan0\niface wlan0 inet manual\nwpa-driver wext\nwpa-roam /etc/wpa_supplicant/wpa_supplicant.conf\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这里，注意第二行的 manual，指定既不配置固定IP，又不使用 DHCP，要“手工”配置，而后，指定了 WPA 的驱动，wext 是 Linux kernel 的 Wireless Extension，凡是使用 Linux 原生驱动的情况，只有使用固定网络的情况和使用 atmel 芯片的情况例外，关于这些例外，请参考软件文档。\u003c/p\u003e\n\n\u003cp\u003ewpa-roam （漫游模式）是指，根据后面指定的配置文件进行匹配，接入可以发现的网络，当然，也可以配置成不使用 wpa-roam，而是固定在这里写明配置，但对于大部分笔记本用户来说，在不同时间地点接入两个以上的网络是常有的事，因此 roam 是更常见的模式。\u003c/p\u003e\n\n\u003cp\u003ewpa_supplicant.conf 这个文件很简单，是用来描述一个个网络的，下面是我家的网络配置\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cpre\u003enetwork={\nssid=\u0026quot;fusion\u0026quot;\nscan_ssid=1\nkey_mgmt=WPA-PSK\nproto=WPA\npairwise=TKIP\ngroup=TKIP\u003c/pre\u003e\n\n\u003cpre\u003epsk=\u0026quot;my-wlan-passwd\u0026quot;\nid_str=\u0026quot;fusion\u0026quot;\n}\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e\n  \u003cbr /\u003e对每个网络都是这么一段，这里面 ssid 是无线路由器设置的 SSID，后面 key_mgment, proto, group 这几个字段指定了 WPA/TKIP 方式，而 psk 指定的就是我的密钥，这几个对于不同的认证方式有所不同，scan_ssid=1 是用来对付设置不广播网络SSID的路由器的，我的路由器就是这么配置的，呵呵，理由自然是增强一层安全性了。最后的 id_str 是这段描述的一个标记，在 /etc/network/interfaces 里，可以针对这个 id 进行配置，如\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003eiface fusion inet dhcp\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e指定对这个网络进行 dhcp 获取 IP。如果是 WEP 的话，设置可能是这样\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cpre\u003enetwork={\nssid=\u0026quot;wepnet\u0026quot;\nkey_mgmt=NONE\nwep_key0=\u0026quot;WEPKEY\u0026quot;\nwep_tx_keyidx=0\nid_str=\u0026quot;wep\u0026quot;\n}\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cpre\u003e字段含义与 WPA 的类似。 当然，在 wpa_supplicant.conf 里可以设定一个缺省的网络，在没有其他网络时进行尝试\u003c/pre\u003e\n\n\u003cblockquote\u003e\n\n\u003cpre\u003enetwork={\nkey_mgmt=NONE\n}\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e在 interfaces 里也可以指定一个缺省配置，如，对没有特殊声明的大多数网络都采用 dhcp\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003eiface default inet dhcp\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e以上就是使用 wpa_supplicant 配置无线网络认证的简单方法，wpa_supplicant 也提供了很多例子可供参考，大家可以尝试一下。\u003c/p\u003e\n","cover":"","link":"works/2008/11/14/linux下的wpa无线认证/index.html","preview":"","title":"Linux下的WPA无线认证"},{"content":"\n\u003cp\u003e这也是个一行命令\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003efind ../hadoop-0.18.1/ \\     \u003cbr /\u003e'(' -name \u0026quot;*.jar\u0026quot; -o -name \u0026quot;*.a\u0026quot; -o -name \u0026quot;*.so*\u0026quot; -o -name \u0026quot;*.gif\u0026quot;\u0026#160; -o -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.pdf\u0026quot;\u0026#160; ')' \\      \u003cbr /\u003e-exec 'echo' '{}' '{}' ';' | \\      \u003cbr /\u003esed -ne 's/\\([^ ]*\\) \\.\\.\\/hadoop-[\\.0-9]*\\/\\([^\\ ]*\\)/cp \\1 \\.\\/\\2/p' | \\      \u003cbr /\u003e/bin/sh\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这个命令的 find 部分从平级的一个子目录中寻找各种二进制文件，然后把文件路径完整地输出两次，而之后用 sed 把第二遍的目录前缀去掉，换到本目录中的相同位置，再在前面加上 cp 命令，这就构成了一个复制命令。\u003c/p\u003e\n\n\u003cp\u003e嗯，这个命令算不算变态要看有多少文件要处理，并且要处理多少次类似操作，如果多的话，费这么点力气写个超长命令行还是值得的。\u003c/p\u003e\n","cover":"","link":"scripts/2008/10/31/文件路径处理并生成处理命令/index.html","preview":"","title":"文件路径处理并生成处理命令"},{"content":"\n\u003cp\u003e这个命令行非常初级\u003c/p\u003e\n\n\u003cp\u003esvn status|grep '!'|awk '{print \u0026quot;svn del \u0026quot; $2}' |/bin/sh   \u003cbr /\u003esvn status|grep '?'|awk '{print \u0026quot;svn add \u0026quot; $2}' |/bin/sh\u003c/p\u003e\n\n\u003cp\u003e将有 ! 前缀的文件清除出去，将有 ? 前缀的文件纳入版本管理。\u003c/p\u003e\n","cover":"","link":"scripts/2008/10/31/清理svn仓库的异常状态文件/index.html","preview":"","title":"清理svn仓库的异常状态文件"},{"content":"\n\u003cp\u003e又是一个一句话操作\u003c/p\u003e\n\n\u003cp\u003efind . '(' -name \u0026quot;*.jar\u0026quot; -o -name \u0026quot;*.a\u0026quot; -o -name \u0026quot;*.so*\u0026quot; -o -name \u0026quot;*.gif\u0026quot; -o -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.pdf\u0026quot;\u0026#160; ')'\u0026#160; -exec 'echo' 'svn' 'del' '{}' ';'|/bin/sh\u003c/p\u003e\n\n\u003cp\u003e这里的要点主要是 find 命令的多条件“或”操作，另外，提供了一种 find 后执行的手段——echo 送至 shell，这样的好处是可以先不添加管道后面的东东，从而观察并验证命令的正确性。这个办法是和 hoplee 老师学的，呵呵。   \u003cbr /\u003e同理，还可以添加文件\u003c/p\u003e\n\n\u003cp\u003efind . '(' -name \u0026quot;*.jar\u0026quot; -o -name \u0026quot;*.a\u0026quot; -o -name \u0026quot;*.so*\u0026quot;\u0026#160; -o -name \u0026quot;*.gif\u0026quot; -o -name \u0026quot;*.png\u0026quot; -o -name \u0026quot;*.jpg\u0026quot; -o -name \u0026quot;*.pdf\u0026quot;\u0026#160; ')'\u0026#160; -exec 'echo' 'svn' 'add' '{}' ';'|grep -v '\\.svn\\/'|/bin/sh\u003c/p\u003e\n\n\u003cp\u003e只是要注意，放在 .svn/ 中的是 svn 的结构性文件，不能也添加进仓库的。\u003c/p\u003e\n","cover":"","link":"scripts/2008/10/31/从svn-working-copy-中删除部分文件/index.html","preview":"","title":"从svn working copy 中删除部分文件"},{"content":"\n\u003cp\u003e下了一个openclipart 的 daily 发布包，所有文件是按照用户名排序的，文件辨识分类很困难，不管别的了，先选择所有 svg 文件，计算 md5sum，并提取不包含路径的文件名、然后按文件名排序，方便索引。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003efind . -name \u0026quot;*.svg\u0026quot; -exec 'md5sum' '{}' | \\     \u003cbr /\u003esed -e \u0026quot;s/\\([^ ]*\\) .*\\/\\([-a-zA-Z0-9_().]*\\.svg\\)/\\2,\\1/g\u0026quot; | \\      \u003cbr /\u003esort\u0026#160; \u0026gt; md5sums_sorted.csv\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003emd5sum 的输出结果是 md5sum 路径名，这里去掉了前面的路径，只保留文件名，然后把它放在前面，md5sum放在后面，中间用逗号分开，构成csv格式，文件名包括字母、数字、横线、下划线、括号和点。\u003c/p\u003e\n","cover":"","link":"scripts/2008/10/25/md5sum-收集并排序/index.html","preview":"","title":"md5sum 收集并排序"},{"content":"\n\u003cp\u003e本文发于微软开始正版认证，让盗版Windows显示黑色桌面的时候，因为看不惯很多人这时挺盗版、骂微软而发。首发于本人博客（\u003ca href=\"http://labs.chinamobile.com/blog/gnawux\"\u003ehttp://labs.chinamobile.com/blog/gnawux\u003c/a\u003e ）。\u003c/p\u003e\n\n\u003cp\u003e我是Linux爱好者，但不是微软仇视者，主流开源社区懂得尊重版权，避免侵犯他人的版权，避免伤害别人。我们不赞成微软的生存和竞争方式，但我们尊重他们合法地利用自己的知识所创造出来的产品的价值。\u003c/p\u003e\n\n\u003cp\u003e微软的正版认证似乎让一些人黑屏了，于是，微软又一次回到骂声之巅。可是，就因为你们家里的某台计算机的盗版操作系统或盗版软件不能正常工作了就开始琢磨怎么骂微软，这是一种道德的行为么？\u003c/p\u003e\n\n\u003cp\u003e你不是微软的合法用户，或者说，中国大部分微软产品用户不是合法拷贝使用者，我们有什么资格声称微软在中国有垄断行为了？这些用户不向微软支付任何费用，微 软为什么要为此上缴什么“暴利税”？诚然，微软对盗版的纵容将金山WPS等国产软件几乎挤倒了最不为人知的角落里，又把自己的用户群扩大到几乎所有中国计 算机用户，但这一切过程中，微软没有做任何违法的事情，倒是我们这些口诛笔伐微软的人在一直非法盗用我们所“不齿”的微软的作品，到底谁更无耻一些？   \u003cbr /\u003e这一切太荒谬了。\u003c/p\u003e\n\n\u003ch3\u003e\u003ca name=\"TOC-1\"\u003e\u003c/a\u003e人不能无耻到这个地步（续篇）\u003c/h3\u003e\n\n\u003cp\u003e上文引发了一阵热议，因此，我对该文的讨论进行了总结，梳理了自己的观点，重新发文如下：   \u003c/p\u003e\n\n\u003cp\u003e这里总结一些我对于WGA、OGA的观点：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e 政府、企业和主流媒体应该把目光放得更长远，以此为契机，推行正版化、支持国产软件的改进、支持开源社区的进步，这才是可持续发展的选择。\u003c/li\u003e\n\n\u003cli\u003e盗版用户没有资格谴责微软用盗版来压制国产软件业，因为正是这些盗版用户背弃国产软件，才使得微软顺水推舟的策略成功，微软在这个问题上只是简单的不作为，政府实际上也是不作为，而盗版用户则是实实在在的欺压国产软件的执行者。\u003c/li\u003e\n\n\u003cli\u003e借口微软正版价格昂贵的用户基本上没有道理，因为通常只要你付出劳动，就可以使用其他廉价甚至免费的代用品来完成这一功能，如果不能，那么就应该放弃使用，因为自己的欲望得不到满足就采用违法行为不但不合法，也是不合理的。\u003c/li\u003e\n\n\u003cli\u003e借口“存在即合理”来论证盗版合理性的人犯了很多逻辑错误，首先，这不是黑格尔的原话，而是对其《法哲学原理》的曲解；其二，存在即合理这一命题不具有正 确性，如前文的评论里的推理：所有犯罪都是存在的，即使这些存在合理，它们也是不正确的，即，盗版是存在的，但存在也不能证明其合理性。\u003c/li\u003e\n\n\u003cli\u003e因为认为微软是“邪恶的”，所以用盗版，首先，盗版用户们还没有侠义到为了正义而用盗版，而只是为了一己之私才这么做的；其次，我们没有权利惩罚邪恶的人，更没有权利用邪恶的手段惩罚邪恶的人。总不会有人还说用盗版是正当防卫吧。\u003c/li\u003e\n\n\u003cli\u003e认为微软的产品是建立在前人的工作基础之上，因而认为盗版有理的，这个本身就没有逻辑，利用帕斯卡定律搞出的一切液压设备都不会因为帕斯卡定律早已存在而免费，为什么建立在前人计算机科学技术研究基础上的软件产品一定要免费提供？\u003c/li\u003e\n\n\u003cli\u003e有人认为挑战微软霸权的开源软件（或说自由软件）可以作为盗版存在的接口，恰恰相反，自由软件的发起人们相信软件是人类精神的共同财富，如牛顿定律般属于全人类，但他们同样尊重版权，他们以 Copyleft 的独特版权形式来保证自由的权利，和盗版是对立的。\u003c/li\u003e\n\n\u003cli\u003e我无意证明也不认同微软的正义性，但我认同软件的版权，即，微软的版权，或说软件著作权是合法的，应该得到保护，因此进行的收费的权利也是合法的，也不应受到侵犯。侵犯微软的合法权利是无理的。\u003c/li\u003e\n\n\u003cli\u003e捎带手说一下，中国移动的公文什么时候要是能摆脱微软的那几个格式就好了。\u003c/li\u003e\n\n\u003cli\u003eWGA/OGA 或许被很多人视为安全隐患的表现，但实际上这种问题早就存在，而且不难发现，根本就不是WGA/OGA的特质，没必要以此大做文章，并且，Google的云里本来就保存着各位的很多隐私数据，他们一样也是安全隐患。另一方面，这次 WGA/OGA 实际可以看做是微软的一次对微软的抗争，正当防卫，没有侵犯用户的数据，就我看没有防卫过当的问题。回到前面的第1条，如果这些微软的行动真的遏制了盗版 的话，那是国产软件、开源软件们的幸事，是我国的幸事。\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e没有在上面一段回到第1条，而看到这句的朋友，感谢您的关注，同时，感谢 Rocky, 陈健，wing, 剑鹏，项右键，LOVERC，尔乐，紫依，27886885，大黄，卡西（还在皇马么？）参与讨论，尤其感谢卡西和Rocky的支持。\u003c/p\u003e\n\n\u003cp\u003e本次节目就到这里。哦，顺便说一句，上面的项右键基本上是故意打错的，不过请不要介意哦，就是好玩而已。\u003c/p\u003e\n","cover":"","link":"works/2008/10/23/人不能无耻到这个地步/index.html","preview":"","title":"人不能无耻到这个地步"},{"content":"\n\u003cp\u003e选取上层目录下的 global 和 util 两个子目录之外的所有子目录的 c 源文件，并送至某程序（这里用 echo 代替）的命令行\u003c/p\u003e\n\n\u003cp\u003els ../*/*.c | grep -v \u0026quot;^../\\(global/\\|util/\\)\u0026quot; | xargs echo\u003c/p\u003e\n\n\u003cp\u003e这里主要是 grep 的或操作需要注意一下，其余没有什么特别的。\u003c/p\u003e\n","cover":"","link":"scripts/2008/10/22/按路径选择文件/index.html","preview":"","title":"按路径选择文件"},{"content":"\n\u003cp\u003e这里是脚本，用途是用 SSH 访问一组指定 ip 的 ilo，执行指定的一组命令，这个例子里是重新设置 IP\u003c/p\u003e\n\n\u003cp\u003e#!/usr/bin/expect   \u003cbr /\u003eset hostfile\u0026#160;\u0026#160;\u0026#160;\u0026#160; [open [lindex $argv 0] ]    \u003cbr /\u003eset cmdfile\u0026#160;\u0026#160;\u0026#160;\u0026#160; [open [lindex $argv 1] ]    \u003cbr /\u003eset prompt\u0026#160;\u0026#160;\u0026#160;\u0026#160; \u0026quot;.*iLO-\u0026gt;\\ \u0026quot;    \u003cbr /\u003eset passprompt\u0026#160;\u0026#160;\u0026#160;\u0026#160; \u0026quot;.*password:\\ \u0026quot;    \u003cbr /\u003eset rejprompt\u0026#160;\u0026#160;\u0026#160;\u0026#160; \u0026quot;.*refused\u0026quot;    \u003cbr /\u003eset password\u0026#160;\u0026#160;\u0026#160; \u0026quot;mypasswd\\r\u0026quot;    \u003cbr /\u003eset timeout\u0026#160;\u0026#160;\u0026#160; 20    \u003cbr /\u003eset origprefix 192.168.1.    \u003cbr /\u003eset newprefix 192.168.39.    \u003cbr /\u003ewhile {[gets $hostfile h] \u0026gt;0} {    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; seek $cmdfile 0    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; spawn ssh $origprefix$h    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; for {} {1} {} {    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; expect {    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; \u0026quot;$rejprompt\u0026quot; { puts \u0026quot;refused\u0026quot;;break }    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; \u0026quot;$passprompt\u0026quot; { send \u0026quot;$password\u0026quot; }    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; \u0026quot;$prompt\u0026quot; {     \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; while { [gets $cmdfile c] \u0026gt; 0 } {    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; send \u0026quot;$c\\r\u0026quot; ;     \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; }     \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; send \u0026quot;set SubnetMask=255.255.248.0 IPv4Address=$newprefix$h\\r\u0026quot;    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; expect $prompt    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; break    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; }    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; timeout {puts \u0026quot;timeout\u0026quot;; break}    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; }    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; }    \u003cbr /\u003e}    \u003cbr /\u003eclose $hostfile    \u003cbr /\u003eclose $cmdfile\u003c/p\u003e\n\n\u003cp\u003e这个脚本接受两个参数，ip尾号列表文件，如下：\u003c/p\u003e\n\n\u003cp\u003e85   \u003cbr /\u003e86    \u003cbr /\u003e87    \u003cbr /\u003e88    \u003cbr /\u003e89    \u003cbr /\u003e90    \u003cbr /\u003e91\u003c/p\u003e\n\n\u003cp\u003e和 iLO 命令列表文件：\u003c/p\u003e\n\n\u003cp\u003ecd map1   \u003cbr /\u003ecd enetport1    \u003cbr /\u003ecd lanendpt1    \u003cbr /\u003ecd ipendpt1\u003c/p\u003e\n\n\u003cp\u003e这个脚本有一点特别之处——最后一个操作是设置 IP 地址，设置生效之后 SSH 连接就会自动断开，因此没有 close。\u003c/p\u003e\n","cover":"","link":"scripts/2008/10/16/用expect进行ilo远程配置/index.html","preview":"","title":"用expect进行iLO远程配置"},{"content":"\n\u003cp\u003e命令如下\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eseq 79 158 | while read addr;do ping -c1 -w2\u0026#160; 192.168.1.$addr \u0026gt; /dev/null \u0026amp;\u0026amp; echo $addr ; done \u0026gt; iplist\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这行命令首先生成 79-158 一共 80 个 IP 尾号，进入循环后为每个尾号添加 “192.168.1.” 前缀，尝试 ping 操作，如果两秒钟之内成功 ping 通，那么将尾号输出，并重定向到 iplist 里面，ping 的其他输出会被抛弃。\u003c/p\u003e\n","cover":"","link":"scripts/2008/10/15/可用ip列表生成/index.html","preview":"","title":"可用IP列表生成"},{"content":"\n\u003cp\u003e目录中文件成分判断：\u003c/p\u003e\n\n\u003cpre\u003efind . -type f -exec 'file' '{}' ';' |cut -d: -f2| cut -d, -f1|sort|uniq -c|sort -n\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e首先利用 find 和 file，列出所有普通文件的类型描述，然后舍弃文件名，取出描述的主要部分，进行排序后统计数量，最终将统计出来的数量结果按大小个排序，输出的效果类似这样：\u003c/p\u003e\n\n\u003cpre\u003e      1  exported SGML document text\u003cbr /\u003e      1  gzip compressed data\u003cbr /\u003e      2  ms-windows icon resource - 1 icon\u003cbr /\u003e      2  Perl5 module source text\u003cbr /\u003e      4  Bourne-Again shell script text executable\u003cbr /\u003e     11  ASCII C++ program text\u003cbr /\u003e     12  JPEG image data\u003cbr /\u003e     13  PDF document\u003cbr /\u003e     21  Zip archive data\u003cbr /\u003e     35  GIF image data\u003cbr /\u003e     36  ASCII text\u003cbr /\u003e     37  HTML document text\u003cbr /\u003e     40  PNG image data\u003cbr /\u003e     50  Bourne shell script text executable\u003cbr /\u003e     63  XML document text\u003cbr /\u003e     88  ASCII C program text\u003cbr /\u003e    777  ASCII English text\u003c/pre\u003e\n","cover":"","link":"scripts/2008/10/15/文件成分判别/index.html","preview":"","title":"文件成分判别"},{"content":"\n\u003cp\u003e前不久\u003ca href=\"http://qianwuge.spaces.live.com/\"\u003e钱五哥\u003c/a\u003e曾经\u003ca href=\"http://labs.chinamobile.com/community/my_blog/384/2957\"\u003e论述\u003c/a\u003e过云计算，虽然同属一个研究小组，但我们的意见并不完全相同，作为小字辈，斗胆在这里论述一下我的个人观点。\u003c/p\u003e\n\n\u003cp\u003e何谓“云计算”？综合各方观点，我仍然坚持认为目前通行的“云计算”是一种商业模式或说服务模式，即，更细粒度的计算能力的贩售方式——用户按需购买所需的计算资源（计算能力以及存储资源），而无需关注计算服务的实现是由什么计算设施完成的。\u003c/p\u003e\n\n\u003cp\u003e基于这样一种商业模式，“云计算”的技术应该是一种可以提供满足用户需求的计算能力的技术，尽管由于 Google 的强大影响力，Google 的基础设施常常被认为是“云计算”的代名词，但任何一种可以用于满足用户计算能力需求的技术都可以成为“云”中的技术。\u003c/p\u003e\n\n\u003cp\u003e作为“云计算”的支撑技术，需要的是：低成本的计算服务——这方面的杰出代表就是 Google；适用于用户需求的计算模型，仍以 Google 为例，大规模的并行化的 MapReduce 和相应的基础设施就是很适合某类计算。\u003c/p\u003e\n\n\u003cp\u003e上面的要点就是：“云计算”是要考虑需求的，是按需的计算。\u003c/p\u003e\n\n\u003cp\u003e说到这里，我们实际需要思考的一个问题是——移动不是 Google，移动需要自己的蓝海，移动的计算系统需要什么样的“云”（或者是否需要）？移动的客户需要我们提供什么样的“云”？这几个问题我甚至不知道有没有人思考过。\u003c/p\u003e\n\n\u003cp\u003e先 从移动自己的需求说起，移动的支撑系统消耗大量的计算资源，是否有必要引入这种云计算？长远来看，支撑系统全面构建在“云”上有利于资源配置的优化和“绿 色计算”，尽管这个移植可能不是一蹴而就的，就像SOA的引入一样。但近期看，目前的技术仍然很难将低成本和高性能、高可靠性、高可用性完美结合起来，很 难直接应用于生产系统中，但其他非生产系统仍是有可能的。不过，不论难易，展开研究、进行尝试都是有益的。\u003c/p\u003e\n\n\u003cp\u003e对移动用户而言，从盈利角度看，主要应该是集团客户，应该考虑如何将集团业务和计算服务结合起来；从应用模式看，主要应该是个人性和位置相关性业务和个人计算服务的结合。通信和内容/计算服务从来都是相互促进的，提供“云计算”服务也可能会产生类似效应。\u003c/p\u003e\n\n\u003cp\u003e嗯，个人是个技术爱好者，不是营销专家或专业“观察家”、“评论家”，以上言论纯粹业余水平的闲聊，请拍。\u003c/p\u003e\n","cover":"","link":"works/2008/08/27/移动云计算我之见/index.html","preview":"","title":"移动云计算我之见"},{"content":"\n\u003cp\u003eJune 21, 2006 - 2:40am\u003c/p\u003e\n\n\u003cp\u003eSubmitted by \u003ca href=\"http://kerneltrap.org/user/3986\"\u003eKedar Sovani\u003c/a\u003e on June 21, 2006 - 2:40am.     \u003cbr /\u003e\u003ca href=\"http://kerneltrap.org/node/6741\"\u003ehttp://kerneltrap.org/node/6741\u003c/a\u003e     \u003cbr /\u003e原作者与版权信息：\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://kerneltrap.org/user/4448\"\u003eAmey Inamdar\u003c/a\u003e (\u003ca href=\"http://www.geocities.com/amey_inamdar\"\u003ewww.geocities.com/amey_inamdar\u003c/a\u003e) is a kernel developer working at Kernel Corporation. His interest areas include filesystems and distributed systems. \u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://kerneltrap.org/user/3986\"\u003eKedar Sovani\u003c/a\u003e (\u003ca href=\"http://www.geocities.com/kedarsovani\"\u003ewww.geocities.com/kedarsovani\u003c/a\u003e) works for Kernel Corporation as a kernel developer. His areas of interest include filesystems and storage technologies. \u003c/p\u003e\n\n\u003cp\u003eCopyright (c) 2004-2006 Kedar Sovani and Amey Inamdar\u003c/p\u003e\n\n\u003cp\u003e王旭 (gnawux(at)gmail.com, \u003ca href=\"http://wangxu.me/blog/\"\u003ehttp://wangxu.me/blog/\u003c/a\u003e) 于2008年8月19-21日译\u003c/p\u003e\n\n\u003cp\u003e原子性是操作的一种属性，标明这个操作要么完全成功，要么完全失败，不会处于中间状态。磁盘可以保证扇区级的原子性。这意味着写一个扇区的操作，要么完全成功，要么根本没写。不过，当一个操作涉及到多个扇区的时候，就需要高层机制了。这种机制应该确保全部的扇区修改都是原子性的。如果不能做到原子性的话将导致数据的不一致性。本文就将讨论 Linux 中的日志块设备（JBD）的实现。\u003c/p\u003e\n\n\u003cp\u003e首先来看看这些文件系统的不一致是如何产生的。假设一个应用程序建立了一个文件。文件系统内部于是就减少一个 inode 数量，初始化磁盘上的 inode，并为文件的父目录添加一个对应于新文件的条目。但如果在上述操作进行到一半的时候计算机崩溃了，那会怎样呢？在这种情况下，不一致性就被引入到文件系统当中了——可用的 inode 数量减少了，但磁盘上 inode 的初始化可能还没有进行。\u003c/p\u003e\n\n\u003cp\u003e要发现这种不一致性的惟一方法便是扫描整个文件系统，这个程序称为 fsck (filesystem consistency check)。对于很大的系统，一致性检查可能需要相当长的时间（可能高达数小时）来检查并修复这些不一致问题。和你想的一样，这么长的宕机时间是难以接受的。更好的手段当然是在第一时间就避免不一致性的产生，这可以通过为操作提供原子性来达到。日志就是为这些操作提供原子性的一种手段。简单地说，使用日志就像使用了一个草稿本。你在草稿本上进行操作，当操作正确，你满意了之后，可以把他们誊到最终版本上。\u003c/p\u003e\n\n\u003cp\u003e对于操作系统而言，所有的元数据和数据都存储在文件系统所在的块设备上。日志文件系统使用一个日志区域作为草稿。日志可以是同一个块设备的一部分，或者是一个单独的设备。一个日志文件系统首先记录所有在日志中的操作。一旦这些作为一个原子操作的操作们都被记录到日志之中了，它们才会被一起写到实际的块设备中。在后文中，“磁盘（disk）”将指代“真实的块设备”，而“日志（journal）”将指代“日志区域”。    \u003cbr /\u003e日志恢复场景     \u003cbr /\u003e这个例子中，根据上面的需求，改动了3个块——inode 计数块，包含了磁盘上的 inode 的块包含了用于插入条目的目录所在的块。所有这些块首先都被写入到日志中。之后，一个特殊的块——提交记录，被写入到日志中，提交记录用于指示写到日志中的所有的属于一个原子操作的块。\u003c/p\u003e\n\n\u003cp\u003e下面三个基本场景就反映了日志文件系统是如何工作的：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e当第一个块被写入日志的时候机器崩溃了。在这种情况下，当计算机重启之后检查日志，它会发现一个有没有提交的操作。这就标明可能有一个未完成操作。那么，既然现在还没有对磁盘进行修改操作，也就保持数据一致性。\u003c/li\u003e\n\n\u003cli\u003e当提交记录被写入日志的时候机器崩溃。在这种情况下，机器重新启动并检查日志，它会发现一个操作和它的提交记录正在那里。提交记录指明有一个完成了的操作可以被写入到磁盘之中。所有的属于这个操作的块都会依据日志被写到他们在磁盘中的实际位置。\u003c/li\u003e\n\n\u003cli\u003e所有的三块都被写入日志，但提交记录还没有进入日志的时候机器崩了。即使在这种情况下，因为没有提交记录，磁盘上还是没有任何修改。这个场景中实际和第一个场景区别不大。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e类似的，任何其他的崩溃场景都可以归到上面的头两种场景之中。这样，日志确保了文件系统的一致性。用于查找和重放日志的时间与文件系统一致性检查的时间相比简直是微不足道的。\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e日志块设备\u003c/b\u003e\u003c/p\u003e\n\n\u003cp\u003eLinux 日志块设备（JBD）提供了这个用于提供操作原子性的草稿纸。这样，由控制着一个块设备的文件系统可以在同一个设备或是其他块设备上使用JBD来保障一致性。JBD 实现为一个提供一组供这些应用使用的 API 的模块。下面的章节将描述 2.6 内核中的 Linux JBD 的原理和实现。\u003c/p\u003e\n\n\u003cp\u003e在转入到 JBD 的实现细节之前，我们需要了解一些 JBD 用到的对象。日志（journal）是管理一个块设备的更新的内部记录（log）。正如上文提到的，更新首先会放到日志之中，然后反射到它们在磁盘上的真实位置。日志区域被当作一个环状链表来管子。也就是说，当日志记满的时候会重用之前用过的区域。\u003c/p\u003e\n\n\u003cp\u003ehandle 代表一个原子更新。需要被原子地完成的全部一组改写被提取出来引用为一个 handle。\u003c/p\u003e\n\n\u003cp\u003e不过，将每个原子更新（handle）都写入到日志之中可能不那么高效。为了更高的性能，JBD 将一组 handle 打包为一个事务（transaction），并将事务一次写入日志。JBD 保障事务本身是原子性的。这样，作为事务的组成部分的 handle 们自然也是原子性的。\u003c/p\u003e\n\n\u003cp\u003e事务最重要的属性是它的状态（state）。当事务正在提交时，它的生命周期经历了下面的一系列状态。\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e运行（running）：事务当前是活着的，并且可以接受新的句柄。在一个系统中，仅有一个事务可以处于运行状态。\u003c/li\u003e\n\n\u003cli\u003e锁定（locked）：事务不再接受新的 handle，但现有 handle 们还没有完成。一旦所有 handle 都完成了，事务将进入下一个状态。\u003c/li\u003e\n\n\u003cli\u003e写入（flush）：事务中的所有 handle 都完成了，这时事务将它自己写入到日志中去。\u003c/li\u003e\n\n\u003cli\u003e提交（commit）：整个事务的记录都被写到日志里面这之后。事务会写一个提交块，来指到日志中的事务记录已经完成了。\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e完成：事务完整的写到日志种种之后，它会留在那直到所有的块都被更新到磁盘上的实际位置。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cb\u003eTransaction Committing 与 Checkpointing      \u003cbr /\u003e\u003c/b\u003e\u003c/p\u003e\n\n\u003cp\u003e一个处于运行状态的事务在一段时间之后会被写（write）到日志区域。这样，一个事务可能是在内存中（running）或是在磁盘上。将事务写入（flushing）到日志中并标记特定的事务已完成的过程称为事务的提交。\u003c/p\u003e\n\n\u003cp\u003e日志只控制一小块有限的区域，并且需要进行重用。对于已经提交的事务，也就是那些已经把全部块都写到磁盘上的事务，就不再需要停留在日志里了。这里，Checkpointing（这词儿咋翻译？咬不准啊）就是用于将完成的事务写入磁盘并重新声明日志中对应的空间可用的过程。\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e实现概要\u003c/b\u003e\u003c/p\u003e\n\n\u003cp\u003eJBD 层用于进行元数据的日志记录，期间数据简单的不经过日志直接写到磁盘上。但是这并不阻止应用程序记录数据的日志，因为它可以告诉 JBD，它自己是元数据。本文以 2.6.0 内核为例。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/journal_logical.png\" /\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003eCommit\u003c/b\u003e\u003c/p\u003e\n\n\u003cp\u003e[journal_commit_transaction(journal object)] \u003c/p\u003e\n\n\u003cp\u003eKjournald 线程与每个进行日志的设备相关联。Kjournald 线程保证运行中的事务会在一个特定间隔后被提交。事务提交的代码分成了如下八个不同阶段。图1 给出了日志的逻辑结构。\u003c/p\u003e\n\n\u003cp\u003e阶段0：将事务的状态从运行（T_RUNNING）变为锁定（T_LOCKED），这样，这个事务就不能再添加新的 handle 了。事务会等待所有的 handle 都完成的。当事务初始化的时候，会预留一部分缓冲区。在这一阶段，有些缓冲区可能没有使用，就被释放了。到这里，所有事务都完成了之后，事务就已经准备好了可以被提交了。\u003c/p\u003e\n\n\u003cp\u003e阶段1：事务进入到写入状态（T_FLUSH）。事务被标记为正在向日志提交的事。这一阶段中，也会标记该日志没有运行状态的事务存在；这样，新的 handles 请求将会导致新的事务的初始化。\u003c/p\u003e\n\n\u003cp\u003e阶段2：事务实际使用的缓冲们被写入到磁盘上。首先是数据缓冲。由于数据缓冲不存储到日志记录区域，所以没有什么麻烦的。相反，它们会直接写到磁盘的真实位置。这一阶段在这些缓冲都被接收、收到 IO 操作完成提示后结束。\u003c/p\u003e\n\n\u003cp\u003e阶段3：这时所有的数据缓冲都已经写入到磁盘上了，但它们的元数据还在内存之中。元数据的写入不像数据缓冲那么直接，因为元数据需要先写到日志区域之中，并需要记录它们实际要存放的位置。在这个阶段会首先写这些元数据缓存，这里需要一个日志描述块。日志描述块以标签（tag）的形式存储日志中的每个元数据缓存到它的实际位置的映射。之后，元数据缓存写入日志。一旦日志描述符中装满了标签，或者所有的元数据缓存都写入到日志之中了，日志描述符就会被写入到日志之中。现在，所有的元数据缓存都存在日志中了，而且它们在硬盘中的实际位置也被记录下来了。如果系统宕机，再启动的时候，这些要被永久化写入磁盘的数据就可以用来恢复数据了。\u003c/p\u003e\n\n\u003cp\u003e阶段4 和阶段5：这两个阶段分别在等元数据缓冲和日志描述符的 I/O 描述通告。一旦收到 I/O 完成消息，内存链表中对应的缓冲就可以释放掉了。 \u003c/p\u003e\n\n\u003cp\u003e阶段6：现在所有数据和元数据都已经安全地保存着了，数据就在它们的实际位置，而元数据在日志中。现在，事务要被标记为已提交，这样就表明所有的更新都妥善保存在日志之中了。因此，日志描述块再次分配。一个标签会被写入，以示事务已经被成功提交，这个块是同步写入到到日志之中的。这之后，事务便进入了已提交状态，T_COMMIT。\u003c/p\u003e\n\n\u003cp\u003e阶段7：当很多事务被写入到日志中但还没有写入到磁盘中的时候。当前事务中的一些元数据缓存可能是一些之前的事务的一部分。这就不需要保存之前的事务了，因为我们的当前提交的事务已经有了更新的版本了。这些缓冲于是就被从老的事务中删除了。\u003c/p\u003e\n\n\u003cp\u003e阶段8：事务被标记为完成状态，T_FINISHED。日志结构被更新以将当前事务标记为最新提交的事务。同时也将自己标到要被 checkpoint 的事务列表中去。\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003eCheckpointing\u003c/b\u003e\u003c/p\u003e\n\n\u003cp\u003e当日志要被写入磁盘的时候，checkpointing 就会被启动了——比如卸载文件系统，或者在新的 handle 开始的时候也可能会启动 checkpointing。一个新的 handle 可能发现需要保证的缓冲数量不足了，于是它就可能需要启动 checkpointing 进程来释放一些日志空间。\u003c/p\u003e\n\n\u003cp\u003echeckpointing 进程将写入那些还没有写到硬盘里实际位置上的元数据缓冲。于是这些事务就可以被从日志中删除了。一个日志区域可以有多个 checkpointing 事务，而每个 checkpointing 事务都可以有多个缓冲。checkpointing 进程处理每个提交的事务，对每个事务找出需要写入磁盘的元数据缓冲。所有这些缓冲被一批写入磁盘。一旦所有事务都被处理完，他们的记录就会被从日志中删掉了。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg src=\"/assets/journal_physical.png\" /\u003e \u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e恢复\u003c/b\u003e     \u003cbr /\u003e[journal_recover(journal object)] \u003c/p\u003e\n\n\u003cp\u003e当系统在崩溃之后启动的时候，它会发现日志条目不是空的，这就表明上次文件系统卸载并不成功，或者根本就没有进行。这就需要尝试进行修复了。图2 绘制了日志的物理结构的一个例子。修复分三个阶段进行。\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003ePASS_SCAN: 发现日志记录的尾部。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003ePASS_REVOKE: 为日志记录准备一串要被撤销的块。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003ePASS_REPLAY: 未被撤销的块以确保磁盘一致性的顺序被重新写入（重放）。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e对于恢复而言，可用信息已经在日志中提供了。但是日志的实际状态是不清楚的，就像我们不知道系统在那个具体的点崩溃的一样。这样，最后的事务可能在 checkpointing 或是提交的状态。一个在运行中的事务是不可能被发现的，因为它还在内存中。\u003c/p\u003e\n\n\u003cp\u003e对于提交状态的事务，我们不得不忘掉这些更新，因为可能不是所有的更新都在这里。这样，在 PASS_SCAN 阶段中，最后的记录条目会被发现。到这里，恢复进程知道了哪些事务需要被重写。\u003c/p\u003e\n\n\u003cp\u003e每个事务可以有一组撤销（revoked）块。这些块非常重要，通过它们可以防止同一个块的老的日志记录被重放在新的数据之上。在 PASS_REVOKE 过程中，会准备一个撤销块的哈希表。每当我们要找出某个快是否需要被在重放中写入到磁盘的时候，这个表就会被用到。\u003c/p\u003e\n\n\u003cp\u003e在最后一个阶段，所有的需要被重演的块都需要被处理。每个块都会检查是否存在在解除块撤销表之中。如果这个块没在表里，那么它就可以被安全的写入到磁盘上的实际位置之中。而如果这个块在表中，那么只有最新的版本才会写入到磁盘中。注意，我们还没有改变磁盘上的日志的任何内容。这样，如果在修复过程中系统再次崩溃的话不会造成任何破坏。同样的日志可以在下次用来重新恢复，在恢复的过程中，无关的操作不会被进行。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://kerneltrap.org/user/4448\"\u003e     \u003cbr /\u003e\u003c/a\u003e\u003c/p\u003e\n","cover":"","link":"translation/2008/08/21/journaling-block-device/index.html","preview":"","title":"[译文] Linux: The Journaling Block Device"},{"content":"\n\u003cp\u003eBy \u003cstrong\u003eJonathan Corbet\u003c/strong\u003e    \u003cbr /\u003eMay 28, 2008    \u003cbr /\u003e王旭于2008年8月8日译    \u003cbr /\u003e\u003ca href=\"http://lwn.net/Articles/283793/\"\u003ehttp://lwn.net/Articles/283793/\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e在 Linux 下，即使是在有了基础硬件的编程接口信息的情况系，得到高性能的 3D 渲染仍然是非常具有挑战性的。这个问题的一个原因就是内存管理：一个 GPU 本质上说是一个拥有它自己的独立的内存的计算机系统。要想管理GPU 的内存 —— 以及以它的视角看到的系统内存，让系统能够跑起来就必须要小心，更不要说还要获得可接受的性能了。\u003c/p\u003e\n\n\u003cp\u003e不久以前，这个问题看上去要被翻译表映射（TTM）子系统 解决了。TTM 目前仍然没有进入主线内核，依赖于它的所有驱动自然也没有进入。最近的一个关于 TTM 如何才能进入主线的提问引发了一场有趣的讨论，最终使得局面急转直下，TTM 可能根本就不是未来的显存管理系统。\u003c/p\u003e\n\n\u003cp\u003e很多关于 TTM 的抱怨都已经浮现出来了。它的 API 远大于任意一个开源 Linux 驱动的需求；换句话说，大量的代码都是用于二进制发布的驱动的。隔离机制（fence, 管理 CPU 和 GPU 的并发性的机制）非常复杂而难于使用，而且并不是总能得到很好的性能。大量的使用内存映射缓冲会给它自己带来性能问题。TTM API 尝试着提供所有情况下的一切东西；结果对于很多开发者来说很难让特定的硬件去匹配这些 API，很难开始使用 TTM，也缺乏足够的灵活性。对于使用TTM的开源驱动来说，这是一个重大的不足。所以 Dave Airlie 担忧地说 ：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e现在，我希望有一个 radeon 或是什么新的驱动已经使用了 TTM，或者，至少有个 demo 展示了如何使用它，可是现在什么也没有，这让我很痛苦……真正的问题是 TTM 是不是真的适合于 Linux 桌面和嵌入式驱动的开发者们，至少我在桌面方面还没看到足够的正面反馈。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e所有这些但有看来都是徒劳的，毕竟 TTM 已经在那了，而且也没有什么其他的替代品。然而，事情发生了，一个转机发生了，它就叫做图形执行管理器（这名字翻译的好难听阿，对不起观众了），简称 GEM。Intel 资助的 GEM 项目已经有一个月了（译注：原文写于08年5月底，目前 GEM 形势大好阿）。GEM 的开发者其实还没完全准备好来对外公布他们的工作，不过 TTM 的讨论让他们提前走上了前台。\u003c/p\u003e\n\n\u003cp\u003eKeith Packard （译注：Intel 的开源图形驱动项目的带头人）的 GEM 介绍 中包含了一个已有 API 的描述文档。GEM 在处理上面有很多显著不同。首先 GEM 使用普通、匿名、用户空间内存来用于分配图形缓冲对象。这意味着这些缓冲区可以在必要的时候被交换出物理内存。这个方法有其显著的优越性，不仅仅是内存使用的灵活性：它让挂起和恢复的实现可以直接通过恢复所有缓冲对象的方式自动完成了。\u003c/p\u003e\n\n\u003cp\u003eGEM API 尽量避免将缓冲区到用户空间的映射。映射工作代价高昂而且而且带来了 CPU 与 GPU 之间的缓存一致性问题。所以，GEM 用简单的 read() 和 write() 调用来取代映射，访问缓冲区对象。或者，至少，在 GEM 开发者能给每个缓冲对象附加一个文件描述符的时候的处理方法。而内核不会那么轻易管理这么多文件描述符，这样，实际的 API 使用了不同的缓冲对象 handle 和一系列的 ioctl() 调用。\u003c/p\u003e\n\n\u003cp\u003e也就是说，GEM可能映射一个缓冲对象到用户空间。不过，用户空间的驱动必须显示地承担管理缓存一致性的责任。为此，有一组 ioctl() 调用用于管理缓冲的“域”；所谓“域”，本质上说就是描述了系统中的哪个组件拥有这块缓冲区并有权操作它。改变一个缓冲的域（两类域，其一用于读访问，而另一个是写）将会进行必要的缓存刷新。在某种意义上说，这个机制重现了流 DMA API，DMA API 中的 DMA 缓冲区的所有权就可以在 CPU 和 外设控制器之间交换。不必惊讶，他们解觉得也是类似的问题。\u003c/p\u003e\n\n\u003cp\u003eGEM API 不需要显示的屏蔽 (fence) 操作。相反，当 CPU 操作需要访问缓冲区的时候，如果必要的话 CPU 就会简单地等待 GPU 完成对该缓冲区的操作。\u003c/p\u003e\n\n\u003cp\u003e最后，GEM API 并没有想要独自解决所有问题；很多重要操作（比如执行一组 GPU 指令）被留给硬件特定的驱动来实现了。GEM 本身在目前非常适于 Intel 驱动的需求；它不需要达到所有的 TTM 所有达到的目标。Eric Anholt 描述 到：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eTTM 的问题是它要对所有硬件提供一套统一的 API，即使我们的驱动不希望这样的时候也是如此……我们尽量从另一个方面来达到这一目的：实现一个驱动。当其他人实现了另一个驱动，又发现这里面有些代码应该是公共的，那么就将它移动到支撑库里并共享它。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这种方法的有点是更容易来给 Intel 新加入一些东西。而且这可能是个好的开始，一组工作的驱动总比没有强。另一方面，这也意味着要让 GEM 支持其它硬件的驱动还需要大量的工作。对于这些工作如何去做，目前大概有两种观点：(1) GEM 为新的驱动的需求增加新的能力，或者 (2) 让驱动使用它自己的内存管理器。\u003c/p\u003e\n\n\u003cp\u003e第一种方法在很多情况下看起来更漂亮。但它也预示着 GEM API 会经常发生很多变化。这可能会延缓整个系统进入主线内核的脚步；GEM API 会输出到用户空间，所以必须保持变化的兼容性。看起来必须要不断演进的 API 会在快速的进入主线内核的时候受到阻力。\u003c/p\u003e\n\n\u003cp\u003e而对于第二种方法，Dave Airlie 给出了最好的解释 ：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e嗯，事情是我不能相信我们还不足够知道如何以一种通用的方法来做到这点，不过 TTM vs GEM 可能已经证明了这是不可能的了。那么我们可以赌一赌每个驱动一个内存管理器，不过我怀疑这将成为一个维护的噩梦，所以如果人们决定了这就是下一步要走的，我会很高兴地看到他发生。不过提交第 n+1 个内存管理器的人必须解事情出接口后面的机制，而且解释清楚为什么不能复用内存管理器 1 到 n。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e一个还没被讨论过的问题就是性能。Keith Whitwell 给出了一组评分结果 ，该结果显示对于 i915 驱动，使用 TTM 或 GEM 的时候，性能会比不使用的情况显著降低。而 Keith Packard 的到了不同的结果 ，他的结果显示 GEM 驱动的性能明显更好。显然，目前需要一组一致的 benchmark；图形性能是重要的，但如果不能有效地测量也就没法优化。\u003c/p\u003e\n\n\u003cp\u003e使用匿名内存也会引起一些性能考虑：如果第一人称射击游戏 (FPS) 的血腥像素们要不停地被换页的话，体验可能就不尽如人意了。匿名内存可以位于高位内存，而且这样就不必使用32位指针来访问。一些 GPU 硬件不能访问高位内存；这将可能影响 kernel 的 bounce buffer (不好意思啊，这个不知道怎么翻译好了)。最后，GEM 还需要去证明它可以提供良好的性能，GEM的开发者们非常主动地使他们的硬件看起来很好，这也让工作在上面的东西有了一个更好的机会。（这句话翻译的比较晕）\u003c/p\u003e\n\n\u003cp\u003e所有这些能得到的结论是GPU的内存管理问题还不能简单认为是已经解决了。GEM可能最终称为这个答案，但它还是非常新的API，仍然需要大量的工作。这个领域中似乎还有很多的工作需要做。\u003c/p\u003e\n\n\u003cp\u003e（感谢 Timo Jyrinki 建议这个话题。）\u003c/p\u003e\n","cover":"","link":"translation/2008/08/08/[译文]-gem-vs.-ttm/index.html","preview":"","title":"[译文] GEM vs. TTM"},{"content":"\n\u003cp\u003eXenWiki 之 XenNetworking 译文版  \u003cbr /\u003e王旭 译\n\n\u003cp\u003e[译注：这是一篇 wiki 文章，由多人多次编辑完成，其中难免有些不协调的痕迹，但内容非常详实，很有帮助，译文保持了原文的状态，较少添加译注。]\u003c/p\u003e\n\n\u003ch4\u003e目录\u003c/h4\u003e\n\n\u003col\u003e\n\n\u003cli\u003e虚拟以太网接口\u003c/li\u003e\n\n\u003cli\u003eMAC地址\u003c/li\u003e\n\n\u003cli\u003e桥接\n\n\u003col\u003e\n\n\u003cli\u003e桥接中的包流向\u003c/li\u003e\n\n\u003cli\u003enetwork-bridge_脚本\u003c/li\u003e\n\n\u003cli\u003evif-bridge_脚本\u003c/li\u003e\n\n\u003cli\u003e补充说明\u003c/li\u003e\n\n\u003cli\u003e相关链接\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e路由\n\n\u003col\u003e\n\n\u003cli\u003enetwork-route脚本\u003c/li\u003e\n\n\u003cli\u003evif-route脚本\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e虚拟网络\n\n\u003col\u003e\n\n\u003cli\u003e相关链接\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e接口命名\u003c/li\u003e\n\n\u003cli\u003eVLAN\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch4\u003e\u003ca name=\"虚拟以太网接口\"\u003e\u003c/a\u003e虚拟以太网接口\u003c/h4\u003e\n\n\u003cp\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160; 缺省情况下，Xen 为 dom0 创建7对\u0026quot;对接的虚拟以太网接口\u0026quot;。就是使用交叉线对连的以太网口。veth0 连接到 vif0.0，veth1 连接到 vif0.1 等等，知道 veth7 连接到 vif0.7。你可以在 veth# 端配置 IP 和 MAC 地址，而另一端，vif0.# 被加入到了一个网桥之中。\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160; 每当建立一个 domU 实例的时候，就会分配一个新的域 ID。很遗憾，这个号码不能选择的。第一个 domU 的 id就是 1，第二个就是 2，即使第一个已经关机了也不会重新使用它的 id。\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160; 对于每个新的 domU，Xen 就会为它新建一对“对接的以太网口”，一端在 domU 里面，而另一端在 dom0 里面。对于 Linux 的 domU，这个设备一般会被命名为 eth0。这个虚拟以太网接口对在 dom0 之中的另一端称为 vif\u0026lt;id#\u0026gt;.0。举个例子，domU 5 的 eth0 连接到 vif5.0。如果为一个 DomU 建立多个网口，也就是 eth0, eth1....那么，在 dom0 之中对应的便是 vif\u0026lt;id#\u0026gt;.0, vif\u0026lt;id#\u0026gt;.1...\u003c/p\u003e\n\n\u003cp\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160; 当 domU 关机的时候，对应的虚拟以太网接口也会被删除。\u003c/p\u003e\n\n\u003ch4\u003e\u003ca name=\"MAC地址\"\u003e\u003c/a\u003eMAC地址\u003c/h4\u003e\n\n\u003cp\u003e虚拟以太网接口也具有以太网的 MAC 地址，缺省情况下，xend 会随机分配地址，这样，同一个 domain 的不同实例会具有不同的地址。如果你需要让一个 domain 具有固定的 MAC 地址（比如用于 DHCP），那么可以在 vif 配置中使用 \u0026quot;mac=\u0026quot; 选项（如 vif= ['mac=aa:00:00:00:00:11']）。\u003c/p\u003e\n\n\u003cp\u003e在选择要使用的 MAC 地址的时候，要确保你使用的是一个单播地址。也就是说第一个字节的最地位应该是0。比如，一个 aa 开头的地址是正确的，而 ab 是不正确的。最好将地址标明是“本地分配的” (而不是全局性地分配给硬件厂商的)。这样，要让第一个字节的次低位是 1。比如 aa 是正确的，而 a8 就不是。\u003c/p\u003e\n\n\u003cp\u003e总之，一个地址应该是这样的形式\u003c/p\u003e\n\n\u003cpre\u003eXY:XX:XX:XX:XX:XX\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e其中 X 是任意 16 进制数，而 Y 则是 2、6、A、E 之一。\u003c/p\u003e\n\n\u003cp\u003e另外，建议使用 00:16:3e:xx:xx:xx 区段的 MAC 地址。这段地址是为 Xen 保留的。\u003c/p\u003e\n\n\u003ch4\u003e\u003ca name=\"桥接\"\u003e\u003c/a\u003e桥接\u003c/h4\u003e\n\n\u003cp\u003e依照缺省的 Xen 配置，会在 dom0 中进行桥接来允许所有的域像独立的主机那样出现在网络上。如果在 dom0 中大量使用了 iptables （比如构筑防火墙），那么就可能影响桥接，因为桥接的包会通过 PREROUTING, FORWARD 和 POSTROUTING 三条 iptables 链。也就是说，从客户域桥接到外面的包需要通过这三条链。最常出现问题的可能是 FORWARD 链被配置为拒绝包或丢包 （这与在内核中的 IP forwarding 不同）。\u003c/p\u003e\n\n\u003cp\u003eiptables FORWARDING 可以设为禁止转发所有包，这样就禁止了 dom0 作为一个路由器的能力：echo 0 \u0026gt; /proc/sys/net/ipv4/ip_forward。\u003c/p\u003e\n\n\u003cp\u003e更安全一点的手段是允许在外部物理接口与 vif 们之间转发包。例如，一个只有一块以太网卡的计算机可以这么设置：\u003c/p\u003e\n\n\u003cpre\u003eiptables -A FORWARD -m physdev --physdev-in eth0 --physdev-out '!' eth0  -j ACCEPT\u003cbr /\u003eiptables -A FORWARD -m physdev --physdev-out eth0 --physdev-in '!' eth0  -j ACCEPT\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e（这里需要 ipt_physdev [就是 xt-physdev] 模块可用）。\u003c/p\u003e\n\n\u003cp\u003eebtables 项目有\u003ca href=\"http://ebtables.sourceforge.net/br_fw_ia/br_fw_ia.html\"\u003e一篇关于桥接与 iptables 互动的有趣文档\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch5\u003e\u003ca name=\"桥接中的包流向\"\u003e\u003c/a\u003e桥接中的包流向(\u003ca href=\"http://lists.xensource.com/archives/html/xen-users/2006-02/msg00586.html\"\u003eBy Ernst Bachman\u003c/a\u003e)\u003c/h5\u003e\n\n\u003cp\u003e当包到达硬件的时候，由 dom0 中的以太网驱动来归口处理，并出现在了 peth0 上面。peth0 被绑定在网桥上，所以，包被送到网桥上来。这一步在以太网层（第二层）运行，peth0 或网桥没有配置 IP 地址。\u003c/p\u003e\n\n\u003cp\u003e现在，网桥将分发来包，正像一个交换机那样。在这一阶段的过滤可以由 \u003ca href=\"http://ebtables.sourceforge.net/\"\u003eebtables\u003c/a\u003e 之类的工具进行。\u003c/p\u003e\n\n\u003cp\u003e接下来，因为有一组 vifX.Y 连接到网桥上，它将会根据 MAC 决定把哪些包放到哪个接收端上。\u003c/p\u003e\n\n\u003cp\u003evif接口会把包交给 Xen，由它把包送给 vif 对应的端口（dom0中也是同样进行的，这时走的是 vif0.0-\u0026gt;(v)eth0 这对接口）。\u003c/p\u003e\n\n\u003cp\u003e最终，dom0/domU 中的目标设备是有 IP 地址的，你可以对它们使用 iptables 进行过滤。\u003c/p\u003e\n\n\u003ch5\u003e\u003ca name=\"network-bridge_脚本\"\u003e\u003c/a\u003enetwork-bridge 脚本\u003c/h5\u003e\n\n\u003cp\u003e当 xend 启动的时候，它会运行 network-bridge 脚本，这个脚本会\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e建立一个称为 xenbr0 的网桥 \u003c/li\u003e\n\n\u003cli\u003e关闭真正的以太网接口 eth0\u003c/li\u003e\n\n\u003cli\u003e将 eth0 的 IP 和 MAC 地址拷贝给虚拟以太网接口 veth0\u003c/li\u003e\n\n\u003cli\u003e将真实的接口 eth0 重命名为 peth0 \u003c/li\u003e\n\n\u003cli\u003e将虚拟以太网接口 veth0 重命名为 eth0\u003c/li\u003e\n\n\u003cli\u003e将 peth0 和 vif0.0 连接到网桥 xenbr0\u003c/li\u003e\n\n\u003cli\u003e将网桥、peth0、eth0 和 vif0.0 都激活\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e将物理以太网接口和 dom0 的接口分开是个有益的设计，比如，这样你就可以为 dom0 配置防火墙而不会影响\u0026#160; domU 们（仅仅保护 dom0 自己）。\u003c/p\u003e\n\n\u003ch5\u003e\u003ca name=\"vif-bridge_脚本\"\u003e\u003c/a\u003evif-bridge 脚本\u003c/h5\u003e\n\n\u003cp\u003e当一个 domU 启动的时候，dom0 中运行的 xend 会运行 vif-bridge 脚本，这个脚本会：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e将 vif\u0026lt;id#\u0026gt;.0 连接到 xenbr0 \u003c/li\u003e\n\n\u003cli\u003e激活 vif\u0026lt;id#\u0026gt;.0\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch5\u003e\u003ca name=\"补充说明\"\u003e\u003c/a\u003e补充说明\u003c/h5\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e你可以在 xend-config.sxp 文件中改用如下配置，并重启 xend 来修改网桥 xenbr0 的名字：\n\n\u003cpre\u003e(network-script 'network-bridge bridge=mybridge')\u003cbr /\u003e\u003c/pre\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e当然要记得在 domU 的配置文件中修改要连接到的网桥的名字：\n\n\u003cpre\u003evif=[ 'bridge=mybridge' ]\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e或者是这样的配置：\u003c/p\u003e\n\n\u003cpre\u003evif=[ 'mac=00:16:3e:01:01:01,bridge=mybridge' ]\u003cbr /\u003e\u003c/pre\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e也可以创建多个网络接口，并连接到不同的网桥之上：\n\n\u003cpre\u003evif=[ 'mac=00:16:3e:70:01:01,bridge=br0', 'mac=00:16:3e:70:02:01,bridge=br1' ]\u003cbr /\u003e\u003c/pre\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e如果你希望有多个网桥，必须自己手工建立他们，可以是手工，也可以是通过启动脚本建立，或者是修改 network-bridge 脚本。比如\u003c/p\u003e\n\n\u003cpre\u003e$ cd /etc/xen/scripts\u003cbr /\u003e$ cp network-bridge network-custom\u003cbr /\u003e$ cp vif-bridge vif-custom\u003cbr /\u003e$ vi /etc/xen/xend-config.sxp\u003cbr /\u003e        (network-script network-custom)\u003cbr /\u003e        (vif-script vif-custom)\u003cbr /\u003e$ vi network-custom\u003cbr /\u003e        # whatever you want\u003cbr /\u003e\u003c/pre\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e在将物理接口连接到网桥之前，记得重置它的 mac 地址并关闭 arp。比如：\n\n\u003cpre\u003e# ip link set eth1 down\u003cbr /\u003e# ip link set eth1 mac fe:ff:ff:ff:ff:ff arp off\u003cbr /\u003e# brctl addif br1 eth1\u003cbr /\u003e# ip link set eth1 up\u003cbr /\u003e\u003c/pre\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e对于 Xen 3.0，添加网桥的最佳途径是使用一个略加修改的 Xen 缺省配置脚本。按照 \u003ca href=\"http://bugzilla.xensource.com/bugzilla/show_bug.cgi?id=332\"\u003eXenBug #332\u003c/a\u003e 所述。例如，对一个连着 eth0 和 eth1 两个网桥的配置，可以建立这样一个 /etc/xen/scripts/my-network-script：\u003c/p\u003e\n\n\u003cpre\u003e#!/bin/sh\u003cbr /\u003edir=$(dirname \u0026quot;$0\u0026quot;)\u003cbr /\u003e\u0026quot;$dir/network-bridge\u0026quot; \u0026quot;$@\u0026quot; vifnum=0\u003cbr /\u003e\u0026quot;$dir/network-bridge\u0026quot; \u0026quot;$@\u0026quot; vifnum=1\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e（steve_from_moreover 的附加说明——可能是显而易见的，但一定要记住，让 /etc/xen/scripts/my-network-script 的访问权限为 755，否则重启之后你会发现它仍旧保持沉默而没有运行）。\u003c/li\u003e\n\n\u003cli\u003e至少对于 SuSE Linux，每个接口都需要配置 /etc/sysconfig/network 之下的 ifcfg 脚本。否则 network-bridge 将会创建没有人何接口连接于其上的网桥。\u003c/li\u003e\n\n\u003cli\u003e修改脚本后不要忘记修改 /etc/xen/xend-config.sxp 中的网络配置为 (network-script my-network-script)。\u003c/li\u003e\n\n\u003cli\u003e同样的源里可以用于没有物理以太网卡的环境中。可以使用 dummy 接口：\n\n\u003cpre\u003e\u0026quot;$dir/network-bridge\u0026quot; \u0026quot;$@\u0026quot; vifnum=2 netdev=dummy0\u003cbr /\u003e\u003c/pre\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch5\u003e\u003ca name=\"相关链接\"\u003e\u003c/a\u003e相关链接\u003c/h5\u003e\n\n\u003cp\u003e邮件列表中一些相关话题的讨论：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003eeth0 IP in dom0 \u003ca href=\"http://lists.xensource.com/archives/html/xen-devel/2005-01/msg00425.html\"\u003e2005/01/14\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003eBridging vs. Routing \u003ca href=\"http://lists.xensource.com/archives/html/xen-devel/2005-01/msg00368.html\"\u003e2005/01/13\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003eBridging vs. Routing \u003ca href=\"http://lists.xensource.com/archives/html/xen-devel/2004-07/msg00223.html\"\u003e2004/07/18\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003eAn attempt to explain Xen networking \u003ca href=\"http://lists.xensource.com/archives/html/xen-users/2006-02/msg00030.html\"\u003e2006-02-01\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://lists.xensource.com/archives/html/xen-users/2006-02/msg00602.html\"\u003eFirewall in domU with bridging\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.shorewall.net/Xen.html\"\u003eXen and Shorewall\u003c/a\u003e (with bridging)\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www1.shorewall.net/XenMyWay.html\"\u003eXen and the Art of Consolidation\u003c/a\u003e (with bridging)\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://lists.xensource.com/archives/html/xen-users/2006-03/msg00109.html\"\u003eAnother way for making multiple Xen bridges\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch4\u003e\u003ca name=\"路由\"\u003e\u003c/a\u003e路由\u003c/h4\u003e\n\n\u003cp\u003e本节仅当你选用了 network-route 和 vif-route 而不是 network-bridge 和 vif-bridge 时有意义。\u003c/p\u003e\n\n\u003cp\u003e通过路由，在 dom0 和 domU 之间建立点对点连接。到每个 domU 的路由会添加到 dom0 的路由表当中，这里 domU 必须有一个确定的（固定）IP。DHCP 无法工作，因为无法创建路由，DHCP offer 也就无法送到 domU。\u003c/p\u003e\n\n\u003ch5\u003e\u003ca name=\"network-route脚本\"\u003e\u003c/a\u003enetwork-route脚本\u003c/h5\u003e\n\n\u003cp\u003e当 xend 启动的时候，它会运行 network-route 脚本，进行如下工作：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e打开 dom0 的 ip forwarding\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch5\u003e\u003ca name=\"vif-route脚本\"\u003e\u003c/a\u003evif-route脚本\u003c/h5\u003e\n\n\u003cp\u003e当 domU 启动的时候，xend（在 dom0 之中）运行 vif-route 脚本，进行如下工作：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e将 eth0 的 ip 地址拷贝到 vif\u0026lt;id#\u0026gt;.0\u003c/li\u003e\n\n\u003cli\u003e激活 vif\u0026lt;id#\u0026gt;.0\u003c/li\u003e\n\n\u003cli\u003e为 domU 的配置文件中给出的 domU 的 IP 地址增加一个主机固定路由，指向 vif\u0026lt;id#\u0026gt;.0 接口。\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch4\u003e\u003ca name=\"虚拟网络\"\u003e\u003c/a\u003e虚拟网络\u003c/h4\u003e\n\n\u003cp\u003e目前虚拟网络是一种非标准配置。\u003c/p\u003e\n\n\u003cp\u003e虚拟网络配置将所有 domU 放在 dom0 的一个虚拟网络中。这样允许 domU 使用 dom0 提供的 DHCP 服务器，不允许 domU 的 DHCP 请求出到物理网络之中。（据我所知，vif0.0 和 dummy0 都不是必须的。）\u003c/p\u003e\n\n\u003ch5\u003e\u003ca name=\"相关链接(虚拟网络)\"\u003e\u003c/a\u003e相关链接\u003c/h5\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003eSapphirecat 的虚拟网络和 DHCP 设置： \u003ca href=\"http://www.sapphirepaw.org/pawprints/index.php?/archives/127-Xen-part-II.html\"\u003ehttp://www.sapphirepaw.org/pawprints/index.php?/archives/127-Xen-part-II.html\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e另一个虚拟网络的设置：\u003ca href=\"http://en.opensuse.org/Xen3_and_a_Virtual_Network\"\u003ehttp://en.opensuse.org/Xen3_and_a_Virtual_Network\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch4\u003e\u003ca name=\"接口命名\"\u003e\u003c/a\u003e接口命名\u003c/h4\u003e\n\n\u003cp\u003eXen 系统的缺省配置是使用桥接。当 xend 启动的时候，它会建立一个称为 xenbr0 的网桥。xend 将会把 eth0 的 ip 地址之类的分配到 xenbr0 (作为 dom0 连接到网桥上的接口的名称)。所以，现在 dom0 的对外的接口已经是 xenbr0 了，注意防火墙之类的配置要指向它。（译注：新版本 xen 中，或说译者使用的版本中，这个接口被重命名成了 eth0，而物理的 eth0 早被重命名成了 peth0 了。）\u003c/p\u003e\n\n\u003ch4\u003e\u003ca name=\"VLAN\"\u003e\u003c/a\u003eVLAN\u003c/h4\u003e\n\n\u003cp\u003e如果将 802.1Q VLAN 支持配置到 dom0 当中来，Xen 可以支持多标签 VLAN。每个需要的 VLAN 都需要 dom0 中的一个本地接口，虽然不一定需要一个 IP 地址。每个 VLAN 都可以配置一个网桥，客户 OS 可以连接到合适的网桥。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://wiki.xensource.com/xenwiki/JamesBulpin\"\u003eJamesBulpin\u003c/a\u003e 倾向于将网桥定以为一个不自动激活的接口（比如，在 Debian 的 /etc/network/interfaces 中，不使用 \u0026quot;auto\u0026quot; 选项）\u003c/p\u003e\n\n\u003cpre\u003eiface xen-br293 inet manual\u003cbr /\u003e    up vconfig add eth0 293\u003cbr /\u003e    up /etc/xen/scripts/network start netdev=eth0.293 bridge=xen-br293 antispoof=no\u003cbr /\u003e    up /sbin/ifconfig eth0.293 up\u003cbr /\u003e    down /etc/xen/scripts/network stop netdev=eth0.293 bridge=xen-br293 antispoof=no\u003cbr /\u003e    down vconfig rem eth0.293\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e之后，可以添加一个 init.d 脚本在 xend 和 xendomains 之间启动这个接口。\u003c/p\u003e\n\n\u003cp\u003eXenNetworking (\u003ca href=\"http://wiki.xensource.com/xenwiki/PhilipGarrett\"\u003ePhilipGarrett\u003c/a\u003e 于 2008-07-06 18:49:56 最后一次编辑本文)\u003c/p\u003e\n","cover":"","link":"translation/2008/08/04/xen-组网/index.html","preview":"","title":"Xen 组网"},{"content":"\n\u003cp\u003e原来还真没注意，原来的 bind mount 不能只读挂载，嗯，无所谓了，2.6.26的可以了。\u003c/p\u003e\n\n\u003cp\u003e我一般是在这么几种情况下用 bind mount 的：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003echroot 的时候 bind mount\u0026#160; /dev 和 /proc，不过经检验 proc 不用 bind，直接再 mount 一个出来就行，不过 /dev 似乎还是要 bind 的吧。whatever，这里应该不用只读 \u003c/li\u003e\n\n\u003cli\u003e复制整个系统的时候 bind mount 一下 /，这样，/ 下面的其他分区（如果有的话，比如 /home, /usr, /var, /boot 之类的）就不会出现在新挂载点下面了，这样 tar 不会涉及到其他分区，正好适合备份。\u003cstrong\u003e这种情况下，read-only bind mount 应该比较有用，而且更安全\u003c/strong\u003e。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e嗯，就是这样。\u003c/p\u003e\n\n\u003cp\u003e哦，kernel.org 上，2.6.26 已经发布了，2008-07-13 22:44 UTC，距离现在两个多小时吧，算是个新闻哦。\u003c/p\u003e\n","cover":"","link":"works/2008/07/14/2.6.26内核新特性：read-only-bind-mounts/index.html","preview":"","title":"2.6.26内核新特性：Read-only bind mounts"},{"content":"\n\u003cp\u003e标题党了，呵呵，不过我还是隐隐地感到了严重问题的存在。\u003c/p\u003e\n\n\u003cp\u003eLabs这里是个我自己的空间，我可以随意发表言论。\u003c/p\u003e\n\n\u003cp\u003e我的unleashed已经进入出版流程，这里是和编辑老师的一些交流之后的感想，这里的问题不是责编老师的错，不是出版社的错，但这个现象我想并不能称为“没错”。\u003c/p\u003e\n\n\u003cp\u003e我们中国人长期以来认为自己是一个富于创造力的民族，可是，私下也自认经常在利益面前发生抄袭或盗版这些与创造力背道而驰的现象，这在出版界的体现便是“编”胜于“著”。\u003c/p\u003e\n\n\u003cp\u003e在我面前，在技术领域，这个问题尖锐地体现了出来，出版社会在我的名字后面加上“编著”两个字，而我只希望留下后者。\u003c/p\u003e\n\n\u003cp\u003e我说——我承担责任，我的文字全部原创，不摘录、不抄袭、不编纂，我的例子全部是实践的结果，亲自动手、亲手修改，亲手保存实验结果和截屏。我是在为我自己写，写我自己。出版与否，报酬多少，我并不关心，我只想写出真的我的经验和感受。\u003c/p\u003e\n\n\u003cp\u003e但是，我不是国外作者，不是学术权威，没有“开创学科”，所以，编辑也只能帮我争取。\u003c/p\u003e\n\n\u003cp\u003e你可以说我写书的对象——Debian 不是我编写的， 可写人物传记的主人公也不是专辑作者生的养的啊，写纪实文学的作者也没有做那些事情啊，写科学专著的院士们更没有发明自然界的规律，那些规律甚至在院士们出生之前就已经至少存在了上百亿年了，而我也只是一个记录自己言行的人，却没有权利代表自己发表自己的感受。\u003c/p\u003e\n\n\u003cp\u003e我个人对这个问题的看法是两个字“责任”，或另外两个字“信任”，尽管我个人愿意承担自己的文字的责任，可出版界早已不信任国内技术从业者的创造力了，而我，一个业余爱好者就更不必说了。\u003c/p\u003e\n\n\u003cp\u003e这个问题的解决，又是谁的责任呢？\u003c/p\u003e\n","cover":"","link":"misc/2008/07/08/遗失的创造力/index.html","preview":"","title":"遗失的创造力"},{"content":"\n\u003cp\u003e\u003ca href=\"http://www.linux-mag.com/id/6070\"\u003ehttp://www.linux-mag.com/id/6070\u003c/a\u003e\n\n\u003cp\u003e了解一下下一代 Oracle 集群文件系统，GFS的一个替代品。\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e\u003ca href=\"http://www.linux-mag.com/author/55\"\u003eJeremy Garcia\u003c/a\u003e\u003c/b\u003e\u003c/p\u003e\n\n\u003cp\u003eMonday, June 2nd, 2008   \u003cbr /\u003e翻译：王旭    \u003cbr /\u003e2008年6月3日，星期二\u003c/p\u003e\n\n\u003cp\u003e传统的 Linux 重，如果你需要从多台机器上访问一个文件系统，那么就必须在一台机器上加载它，然后通过 NFS、CIFS 或其他方式 export 它。这样做是稳定、成熟而且有良好说明文档的，不过，这样做有它的明显不足，性能还不是最显著的一个，这样还会带来锁问题、潜在的安全问题、还有最糟的单点故障问题。\u003c/p\u003e\n\n\u003cp\u003e如果你的 NFS 服务器宕了，所有的客户端都会立刻无法访问。幸运的是，还有另一个方法来达到这个功能。集群文件系统是一种同时加载到多台服务器上的文件系统。实现一个集群文件系统在过去是非常复杂而昂贵的。通常包含了高价的SAN，光纤通道 HBA 卡、交换机，以及私有版权的文件系统。\u003c/p\u003e\n\n\u003cp\u003e现在，我们有了 iSCSI 和开源的集群文件系统可用。最流行的集群文件系统是 GFS，这是 Red Hat 在收购 Sistina 之后开源的集群文件系统。如今，GFS 随 Fedora 和 CentOS 一起发布，并在 RHEL 上提供了可选支持。从 2.6.19 内核开始，GFS 进入了主线内核。\u003c/p\u003e\n\n\u003cp\u003e另一个可选的文件系统是OCFS2，这是下一代的 Oracle 集群文件系统。这是一种可扩展的、POSIX兼容的文件系统。与前一个版本（OCFS）不同，OCFS2 是一个通用文件系统。到本文写作时为止，你可能会注意到 OCFS2 不支持 mmap (译注：VFS 的文件操作方法中声明了 mmap 方法，用于将文件映射到指定的地址空间上；译注2：据Colyli介绍，OCFS2 1.4里，已经实现了mmap方法，因为他正在调试一个相关bug)。尽管在不久的将来 OCFS2 将会支持它，但如果你现在就需要 mmap 的支持，你最好还是去看看 GFS。\u003c/p\u003e\n\n\u003cp\u003eOCFS2 的用户空间工具在多个发布版中可用，可以从 Oracle 或发布版处获得。OCFS 以 GPL 发布。\u003ca href=\"http://oss.oracle.com/projects/ocfs2/\"\u003e这里\u003c/a\u003e是项目的主页。要使用 OCFS2，你需要安装 ocfs2-tools 包和相应的内核模块（ocfs2-`uname -r`）。\u003c/p\u003e\n\n\u003cp\u003eocfs2console 包不是必须的，但为了使用方便，建议安装。安装了这些工具后，我们就可以建立一个 OCFS2 分区了。设置共享存储不在本文的讨论范围之内，我们假设你已经完成了这一步了。本文的例子是在 RHEL 5.1 环境中进行的。\u003c/p\u003e\n\n\u003cp\u003e不同的发布版中，一些命令或文件的位置可能不尽相同。即使 Oracle 没有提供当前的 RHEL 的内核对应的 OCFS 内核模块 RPM 包，你也可以从官方的 ocfs2 tarball 轻松地编译一个出来。和GFS一样，现在OCFS2也是主线内核的一部分了，所以，如果你用的发布版足够新的话，找内核模块包之前可以看看是不是已经支持OCFS2了。\u003c/p\u003e\n\n\u003cp\u003e首先，你需要编辑 /etc/sysconfig/o2cb，确保它包含这行内容：\u003c/p\u003e\n\n\u003cpre\u003eO2CB_ENABLED=true\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e接下来，在每台主机上创建 /etc/ocfs2/cluster.conf 文件。下面是用于三个节点的集群的设置。对于多个接入IP的主机，节点的参数应该对应于主机名，不论它在使用哪个IP。\u003c/p\u003e\n\n\u003cpre\u003enode:\u003cbr /\u003e        ip_port = 7777\u003cbr /\u003e        ip_address = 192.168.100.1\u003cbr /\u003e        number = 0\u003cbr /\u003e        name = host1.domain.com\u003cbr /\u003e        cluster = ocfs2\u003cbr /\u003enode:\u003cbr /\u003e        ip_port = 7777\u003cbr /\u003e        ip_address = 192.168.100.2\u003cbr /\u003e        number = 1\u003cbr /\u003e        name = host2.domain.com\u003cbr /\u003e        cluster = ocfs2\u003cbr /\u003enode:\u003cbr /\u003e        ip_port = 7777\u003cbr /\u003e        ip_address = 192.168.100.3\u003cbr /\u003e        number = 2\u003cbr /\u003e        name = host3.domain.com\u003cbr /\u003e        cluster = ocfs2\u003cbr /\u003ecluster:\u003cbr /\u003e        node_count = 3\u003cbr /\u003e        name = ocfs2\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e现在，可以运行 /etc/init.d/o2cb start 来启动集群服务。如果一切都顺利的话，运行 /etc/init.d/o2cb status 可以看到类似这样的结果：\u003c/p\u003e\n\n\u003cpre\u003eModule \u0026quot;configfs\u0026quot;: Loaded\u003cbr /\u003eFilesystem \u0026quot;configfs\u0026quot;: Mounted\u003cbr /\u003eModule \u0026quot;ocfs2_nodemanager\u0026quot;: Loaded\u003cbr /\u003eModule \u0026quot;ocfs2_dlm\u0026quot;: Loaded\u003cbr /\u003eModule \u0026quot;ocfs2_dlmfs\u0026quot;: Loaded\u003cbr /\u003eFilesystem \u0026quot;ocfs2_dlmfs\u0026quot;: Mounted\u003cbr /\u003eChecking O2CB cluster ocfs2: Online\u003cbr /\u003e  Heartbeat dead threshold: 31\u003cbr /\u003e  Network idle timeout: 30000\u003cbr /\u003e  Network keepalive delay: 2000\u003cbr /\u003e  Network reconnect delay: 2000\u003cbr /\u003eChecking O2CB heartbeat: Active\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e现在，你可以格式化你的 OCFS2 分区了。\u003c/p\u003e\n\n\u003cpre\u003e# mkfs.ocfs2 -b 4k -C 32K -L \u0026quot;label\u0026quot; -N 4 /dev/sdxX\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e现在在每台主机上加载你的分区。\u003c/p\u003e\n\n\u003cpre\u003e# mount -L \u0026quot;label\u0026quot; /dir\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e如果一切正常的话，你应该把它添加到你的 fstab 里面，并确保 o2cb 和 ocfs2 服务在系统引导时启动。\u003c/p\u003e\n\n\u003cpre\u003e/sbin/chkconfig o2cb on\u003cbr /\u003e/sbin/chkconfig ocfs2 on\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e本文讨论了所有的基础只是，应该足可以搭建一个可用的 OCFS2 了。如果你计划在生产环境中使用 OCFS2，你应该看看 FAQ，其中包含乐更多的高级话题，如更改大小，quorum and fencing, 限制，以及 rolling upgrades。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.linux-mag.com/author/55\"\u003e\u003c/a\u003eJeremy Garcia 是 LinuxQuestions 的创始人和管理员，那是一个使用 SpamAssassin 过滤邮件的自由、友善、活跃的 Linux 社区。请把问题和反馈发送到 jeremy@linuxquestions.org。\u003c/p\u003e\n","cover":"","link":"translation/2008/06/04/using-ocfs2,-a-clustering-file-system/index.html","preview":"","title":"Using OCFS2, A Clustering File System"},{"content":"\n\u003cp\u003e\u003ca href=\"http://lwn.net/Articles/262464/\"\u003ehttp://lwn.net/Articles/262464/\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003eDecember 17, 2007\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003ePaul E. McKenney, IBM Linux Technology Center\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003eJonathan Walpole, Portland State University Department of Computer Science\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e王旭 [gnawux(at)gmail.com] 翻译，2008年5月26日–6月1日\u003c/p\u003e\n\n\u003cp\u003e[编者注：本文是解释 read-copy-update 工作机制的三部曲的第一部。十分感谢 Paul McKenney 和 Jonathan Walpole 允许我们发表这些文章。剩余的两片将在随后几周中陆续发出。]\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cbr /\u003e\n\n\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e《RCU是什么？》\u003c/strong\u003e第一部分\u003c/p\u003e\n\n\u003ch4\u003e概述\u003c/h4\u003e\n\n\u003cp\u003eRead-copy update (RCU) 是一种 2002 年 10 月被引入到内核当中的同步机制。通过允许在更新的同时读数据，RCU 提高了同步机制的可伸缩性（scalability）。相对于传统的在并发线程间不区分是读者还是写者的简单互斥性锁机制，或者是哪些允许并发读但同时不允许写的读写锁，RCU 支持同时一个更新线程和多个读线程的并发。RCU 通过保存对象的多个副本来保障读操作的连续性，并保证在预定的读方临界区没有完成之前不会释放这个对象。RCU定义并使用高效、可伸缩的机制来发布并读取对象的新版本，并延长旧版本们的寿命。这些机制将工作分发到了读和更新路径上，以保证读路径可以极快地运行。在某些场合（非抢占内核），RCU 的读方没有任何性能负担。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题1\u003c/strong\u003e：seqlock 不是也允许读线程和更新线程并发工作么？\u003c/p\u003e\n\n\u003cp\u003e这个问题可以归结到 “确切地说，什么是RCU？” 这个问题，或许还是 “RCU 可能是如何工作的？” （再或者，不太可能的情况下，问题会变为什么情况下 RCU 不太可能工作）。本文从几个基本的出发点来回答这些问题；之后还会分批地从使用的角度和 API 的角度来看这些问题。最后一篇连载还会给出一组参考文献。\u003c/p\u003e\n\n\u003cp\u003eRCU 由三个基本机制组成，第一个用于插入，第二个用于删除，而第三个则用于让读线程可以承受并发的插入或删除。这三个机制将在下面的三节中介绍，讲述如何将 RCU 转化为链表：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e订阅发布机制 （用于插入）\u003c/li\u003e\n\n\u003cli\u003e等待已有的RCU读者完成 （用于删除）\u003c/li\u003e\n\n\u003cli\u003e维护多个最近更新的对象的版本 （为读者维护）\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e这三个章节之后还有上重点回顾与快速问题答案。\u003c/p\u003e\n\n\u003ch4\u003e订阅发布机制\u003c/h4\u003e\n\n\u003cp\u003eRCU的一个关键特性是它可以安全地扫描数据，即使数据正被同时改写也没问题。要提供这种并发插入的能力，RCU使用了一种订阅发布机制。举例说，考虑一 个被初始化为 NULL 的全局指针变量 gp 将要被修改为新分配并初始化的数据结构。下面这段代码（使用附加的合适的锁机制）可以用于这个目的：\u003c/p\u003e\n\n\u003cp\u003e1 struct foo {\u003cbr /\u003e\n2 int a;\u003cbr /\u003e\n3 int b;\u003cbr /\u003e\n4 int c;\u003cbr /\u003e\n5 };\u003cbr /\u003e\n6 struct foo *gp = NULL;\u003cbr /\u003e\n7\u003cbr /\u003e\n8 /* . . . */\u003cbr /\u003e\n9\u003cbr /\u003e\n10 p = kmalloc(sizeof(*p), GFP_KERNEL);\u003cbr /\u003e\n11 p-\u0026gt;a = 1;\u003cbr /\u003e\n12 p-\u0026gt;b = 2;\u003cbr /\u003e\n13 p-\u0026gt;c = 3;\u003cbr /\u003e\n14 gp = p;\u003c/p\u003e\n\n\u003cp\u003e不幸的是，没有方法强制保证编译器和CPU能顺序执行最后四条语句。如果gp的赋值早于p的各个域的初始化的话，那么并发的读操作将访问到未初始化的变 量。内存屏障（barrier）可以用于保障操作的顺序，但内存屏障以难以使用而闻名。这样我们将他们封装到具有发布语义的 rcu_assign_pointer() 原语之中。最后的四条将成为这样：\u003c/p\u003e\n\n\u003cp\u003e1 p-\u0026gt;a = 1;\u003cbr /\u003e\n2 p-\u0026gt;b = 2;\u003cbr /\u003e\n3 p-\u0026gt;c = 3;\u003cbr /\u003e\n4 rcu_assign_pointer(gp, p);\u003c/p\u003e\n\n\u003cp\u003ercu_assign_pointer() 将会发布新的结构，强制编译器和CPU在给p的各个域赋值之后再把指针赋值给gp。然而，仅仅强制更新操作的顺序是不够的，读者也必须强制使用恰当的顺序。考虑下面的这段代码：\u003c/p\u003e\n\n\u003cp\u003e1 p = gp;\u003cbr /\u003e\n2 if (p != NULL) {\u003cbr /\u003e\n3 do_something_with(p-\u0026gt;a, p-\u0026gt;b, p-\u0026gt;c);\u003cbr /\u003e\n4 }\u003c/p\u003e\n\n\u003cp\u003e尽管这段代码看起来不会受到顺序错乱的影响，不过十分不幸，DEC Alpha CPU 和投机性编译器优化可能会引发问题，不论你是否相信，这的确有可能会导致 p-\u0026gt;a, p-\u0026gt;b, p-\u0026gt;c 的读取会在读取 p 之前！这种情况在投机性编译器优化的情况中最有可能会出现，编译器会揣测p的值，取出 p-\u0026gt;a, p-\u0026gt;b 和 p-\u0026gt;c，之后取出 p 的真实值来检查拽侧的正确性。这种优化非常激进，或者说疯狂，不过在确实会在profile-driven优化时发生。\u003c/p\u003e\n\n\u003cp\u003e毫无疑问，我们需要在CPU和编译器上阻止这种情况的发生。rcu_dereference() 原语使用了必要的内存屏障指令和编译器指令来达到这一目的：\u003c/p\u003e\n\n\u003cp\u003e1 rcu_read_lock();\u003cbr /\u003e\n2 p = rcu_dereference(gp);\u003cbr /\u003e\n3 if (p != NULL) {\u003cbr /\u003e\n4 do_something_with(p-\u0026gt;a, p-\u0026gt;b, p-\u0026gt;c);\u003cbr /\u003e\n5 }\u003cbr /\u003e\n6 rcu_read_unlock();\u003c/p\u003e\n\n\u003cp\u003ercu_dereference() 原语可以被看作是订阅了指针指向的值，保证接下来的取值操作将会看到对应的发布操作（rcu_assign_pointer()）发生之前被初始化的值。 rcu_read_lock() 和 rcu_read_unlock() 绝对是必须的：他们定义了 RCU 读方临界区的范围。他们的目的将在下一节 解释，不过，他们不会自旋或阻塞，也不阻止 list_add_rcu() 的并发执行。事实上，对于非抢占内核，它们不产生任何代码。\u003c/p\u003e\n\n\u003cp\u003e虽然 rcu_assign_pointer() 和 rcu_dereference() 在理论上可以用于构建任意 RCU 保护的数据结构，但实际上，使用高层构造常常更好。因此，rcu_assign_pointer() 和 rcu_dereference() 原语被嵌入到了 Linux 的链表维护 API 中的特殊 RCU 变量之中了。Linux 有两个双向链表的变种，循环链表 struct list_head 和线性链表 struct hlist_head/struct hlist_node。前者的结构如下图所示，绿色的方块表示表头，蓝色的是链表中的元素。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/Linux_list.jpg\" alt=\"Linux list\" width=\"503\" height=\"103\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e将上面的指针发布例子放到链表的场景中来就是这样：\u003c/p\u003e\n\n\u003cp\u003e1 struct foo {\u003cbr /\u003e\n2 struct list_head list;\u003cbr /\u003e\n3 int a;\u003cbr /\u003e\n4 int b;\u003cbr /\u003e\n5 int c;\u003cbr /\u003e\n6 };\u003cbr /\u003e\n7 LIST_HEAD(head);\u003cbr /\u003e\n8\u003cbr /\u003e\n9 /* . . . */\u003cbr /\u003e\n10\u003cbr /\u003e\n11 p = kmalloc(sizeof(*p), GFP_KERNEL);\u003cbr /\u003e\n12 p-\u0026gt;a = 1;\u003cbr /\u003e\n13 p-\u0026gt;b = 2;\u003cbr /\u003e\n14 p-\u0026gt;c = 3;\u003cbr /\u003e\n15 list_add_rcu(\u0026amp;p-\u0026gt;list, \u0026amp;head);\u003c/p\u003e\n\n\u003cp\u003e第15行被使用某种同步机制保护住了，通常是某种所，以组织多个 list_add() 实例并发执行。然而，这些同步不能组织同时发生的RCU读者。订阅一个 RCU 保护的链表非常直接：\u003c/p\u003e\n\n\u003cp\u003e1 rcu_read_lock();\u003cbr /\u003e\n2 list_for_each_entry_rcu(p, head, list) {\u003cbr /\u003e\n3 do_something_with(p-\u0026gt;a, p-\u0026gt;b, p-\u0026gt;c);\u003cbr /\u003e\n4 }\u003cbr /\u003e\n5 rcu_read_unlock();\u003c/p\u003e\n\n\u003cp\u003elist_add_rcu() 原语发布一个节点到制定的链表中去，保证对应的 list_for_each_entry_rcu() 调用都正确的订阅到同一个节点上。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题2\u003c/strong\u003e：如果在 list_for_each_entry_rcu() 运行时，刚好进行了一次 list_add_rcu()，如何防止 segfault 的发生呢？\u003c/p\u003e\n\n\u003cp\u003eLinux 中的另一个双向链表，hlist，是一个线性表，也就是说，它的头部仅需要一个指针，而不是向循环链表一样需要两个指针。这样，使用 hlist 作为大型哈希表的 hash-bucket 数组的容器将仅消耗一半的内存空间。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/Linux_hlist.jpg\" alt=\"Linux hlist\" width=\"423\" height=\"63\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e将一个新元素添加到一个 RCU 保护的 hlist 里面与添加到循环链表里非常类似：\u003c/p\u003e\n\n\u003cp\u003e1 struct foo {\u003cbr /\u003e\n2 struct hlist_node *list;\u003cbr /\u003e\n3 int a;\u003cbr /\u003e\n4 int b;\u003cbr /\u003e\n5 int c;\u003cbr /\u003e\n6 };\u003cbr /\u003e\n7 HLIST_HEAD(head);\u003cbr /\u003e\n8\u003cbr /\u003e\n9 /* . . . */\u003cbr /\u003e\n10\u003cbr /\u003e\n11 p = kmalloc(sizeof(*p), GFP_KERNEL);\u003cbr /\u003e\n12 p-\u0026gt;a = 1;\u003cbr /\u003e\n13 p-\u0026gt;b = 2;\u003cbr /\u003e\n14 p-\u0026gt;c = 3;\u003cbr /\u003e\n15 hlist_add_head_rcu(\u0026amp;p-\u0026gt;list, \u0026amp;head);\u003c/p\u003e\n\n\u003cp\u003e和上面一样，第15行一定使用了锁或其他某种同步机制。\u003c/p\u003e\n\n\u003cp\u003e订阅一个 RCU 保护的 hlist 也和循环链表非常接近。\u003c/p\u003e\n\n\u003cp\u003e1 rcu_read_lock();\u003cbr /\u003e\n2 hlist_for_each_entry_rcu(p, q, head, list) {\u003cbr /\u003e\n3 do_something_with(p-\u0026gt;a, p-\u0026gt;b, p-\u0026gt;c);\u003cbr /\u003e\n4 }\u003cbr /\u003e\n5 rcu_read_unlock();\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题3\u003c/strong\u003e：为什么我们需要传递两个指针给 hlist_for_each_entry_rcu()， list_for_each_entry_rcu() 可是只需要一个指针的啊？\u003c/p\u003e\n\n\u003cp\u003eRCU 发布与订阅原语在如下表中列出，同时给出了 “取消发布”或是撤回的原语\u003c/p\u003e\n\n\u003cp\u003e类别\u003cbr /\u003e\n发布\u003cbr /\u003e\n撤销\u003cbr /\u003e\n订阅\u003c/p\u003e\n\n\u003cp\u003e类别\u003cbr /\u003e\n发布\u003cbr /\u003e\n撤销\u003cbr /\u003e\n订阅\u003c/p\u003e\n\n\u003cp\u003e指针\u003cbr /\u003e\n\n\u003ctt\u003ercu_assign_pointer()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003ercu_assign_pointer(…, NULL)\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003ercu_dereference()\u003c/tt\u003e\u003c/p\u003e\n\n\u003cp\u003e循环链表\u003cbr /\u003e\n\n\u003ctt\u003elist_add_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003elist_add_tail_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003elist_replace_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003elist_del_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003elist_for_each_entry_rcu()\u003c/tt\u003e\u003c/p\u003e\n\n\u003cp\u003e双向链表\u003cbr /\u003e\n\n\u003ctt\u003ehlist_add_after_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003ehlist_add_before_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003ehlist_add_head_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003ehlist_replace_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003ehlist_del_rcu()\u003c/tt\u003e\u003cbr /\u003e\n\n\u003ctt\u003ehlist_for_each_entry_rcu()\u003c/tt\u003e\u003c/p\u003e\n\n\u003cp\u003e注意，list_replace_rcu(), list_del_rcu(), hlist_replace_rcu(), 以及 hlist_del_rcu() 增加了一些复杂度。什么时候释放被替换或删除掉的数据元素才是安全的呢？具体地说，我们怎么能知道所有的读者都释放了他们手中对数据元素的引用呢？\u003c/p\u003e\n\n\u003cp\u003e这些问题将在下面的章节中得到回答。\u003c/p\u003e\n\n\u003ch5\u003e等待已经存在的RCU读者完成\u003c/h5\u003e\n\n\u003cp\u003eRCU的最基本的功能就是等待一些事情的完成。当然，还有很多其他方法也是用于等待事情完成的，包括引用计数、读写锁、事件等。RCU最大的好处在于它可以等待所有（比如说）两万件不同点事情，而无需显式地跟踪它们中的每一个，也不需要担心性能的下降、可伸缩性限制、复杂度死锁场景，以及内存泄露等所有这些显式跟踪手法所固有的问题。\u003c/p\u003e\n\n\u003cp\u003eRCU 中，被等待的东西被叫做“RCU读方临界区”。一个RCU读方临界区始于 rcu_read_lock() 原语，止于 rcu_read_unlock() 原语。RCU 读方临界区可以嵌套，也可以放入很多代码，只要这些代码显式阻塞或睡眠即可（有一种称为“\u003ca href=\"http://lwn.net/Articles/202847/\"\u003eSRCU\u003c/a\u003e”的特殊RCU允许在它的读方临界区中睡眠）。只要你遵守这些约定，你就可以使用RCU来等待任何期望的代码段的完成。\u003c/p\u003e\n\n\u003cp\u003e正如其他地方对\u003ca href=\"http://www.rdrop.com/users/paulmck/RCU/whatisRCU.html\"\u003e经典RCU\u003c/a\u003e和\u003ca href=\"http://lwn.net/Articles/253651/\"\u003e实时RCU\u003c/a\u003e的描述，RCU 通过间接确定这些其他事情的完成时间来达到这一目的。\u003c/p\u003e\n\n\u003cp\u003e具体地说，如下图所示，RCU是一种等待已经存在的RCU读方临界区结束的方法，包括这些临界区中执行的内存操作。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/GracePeriodGood.png\" alt=\"Grace periods extend to contain pre-existing RCU read-side critical sections.\" width=\"525\" height=\"261\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e注意，开始于一个给定宽限期开始之后的RCU读方临界区能够、并可以延续到该宽限期结束之后。\u003c/p\u003e\n\n\u003cp\u003e下面的伪码展示了使用RCU等待读者的基本算法形式：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e进行改动，比如，替换链表中的一个元素。\u003c/li\u003e\n\n\u003cli\u003e等待所有已经存在的RCU读方临界区完成（比如，使用synchronize_rcu()原语）。关键点是接下来的RCU读方临界区将无法得到新近删除的元素的引用了。\u003c/li\u003e\n\n\u003cli\u003e清理，比如，释放上述所有被替换的元素。\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e下面的代码段是从前一节修改而得的，用于说明这一过程，这里面的域a是这个搜索的键值。\u003c/p\u003e\n\n\u003cp\u003e1 struct foo {\u003cbr /\u003e\n2 struct list_head list;\u003cbr /\u003e\n3 int a;\u003cbr /\u003e\n4 int b;\u003cbr /\u003e\n5 int c;\u003cbr /\u003e\n6 };\u003cbr /\u003e\n7 LIST_HEAD(head);\u003cbr /\u003e\n8\u003cbr /\u003e\n9 /* . . . */\u003cbr /\u003e\n10\u003cbr /\u003e\n11 p = search(head, key);\u003cbr /\u003e\n12 if (p == NULL) {\u003cbr /\u003e\n13 /* Take appropriate action, unlock, and return. */\u003cbr /\u003e\n14 }\u003cbr /\u003e\n15 q = kmalloc(sizeof(*p), GFP_KERNEL);\u003cbr /\u003e\n16 *q = *p;\u003cbr /\u003e\n17 q-\u0026gt;b = 2;\u003cbr /\u003e\n18 q-\u0026gt;c = 3;\u003cbr /\u003e\n19 list_replace_rcu(\u0026amp;p-\u0026gt;list, \u0026amp;q-\u0026gt;list);\u003cbr /\u003e\n20 synchronize_rcu();\u003cbr /\u003e\n21 kfree(p);\u003c/p\u003e\n\n\u003cp\u003e第19、20 和 21 行实现了上面所说的三个步骤。第 16-19行展现了 RCU 的名字（读-复制-更新）：在允许进行并发读操作的同时，第16行进行了复制，而第17-19行进行了更新。\u003c/p\u003e\n\n\u003cp\u003e乍一看会觉得 synchronize_rcu() 原语显得比较神秘。毕竟它必须等所有读方临界区完成，而且，正如我们前面看到的，用于限制RCU读方临界区的rcu_read_lock() 和 rcu_read_unlock() 原语在非抢占内核中甚至什么代码都不会生成。\u003c/p\u003e\n\n\u003cp\u003e这里有一个小伎俩，经典RCU通过 rcu_read_lock() 和 rcu_read_unlock() 界定的读方临界区是不允许阻塞和休眠的。因此，当一个给定的CPU要进行上下文切换的时候，我们可以确定任何已有的RCU读方临界区都已经完成了。也就是说，只要每个CPU都至少进行了一次上下文切换，那么所有先前的 RCU 读方临界区也就保证都完成了，即 synchronize_rcu() 可以安全返回了。\u003c/p\u003e\n\n\u003cp\u003e因此，经典RCU的 synchronize_rcu() 从概念上说可以被简化成这样：\u003c/p\u003e\n\n\u003cp\u003e1 for_each_online_cpu(cpu)\u003cbr /\u003e\n2 run_on(cpu);\u003c/p\u003e\n\n\u003cp\u003e这里，run_on() 将当前线程切换到指定 CPU，来强制该 CPU 进行上下文切换。而 for_each_online_cpu() 循环强制对每个 CPU 进行一次上下文切换。虽然这个简单的方法可以在一个不支持抢占的内核上工作，换句话说，对 non-CONFIG_PREEMPT 和 CONFIG_PREEMPT，但对 CONFIG_PREEMPT_RT 实时 (-rt) 内核无效。因此，\u003ca href=\"http://lwn.net/Articles/253651/\"\u003e实时RCU\u003c/a\u003e使用了一个（松散地）基于引用计数的方法。\u003c/p\u003e\n\n\u003cp\u003e当然，在真实内核中的实现要复杂得多了，因为它需要管理终端，NMI，CPU热插拔和其他实际内核中的可能有的风险，而且还要维护良好的性能和可伸缩性。RCU的实时实现还必须拥有良好的实时响应能力，这就使得（像上面两行那样）直接禁止抢占变得不可能了。\u003c/p\u003e\n\n\u003cp\u003e虽然我们了解到了 synchronize_rcu() 的简单实现原理，不过还有很多其它问题呢。比如，RCU读者们在读一个正在被并发地更新的链表的时候究竟读到了什么呢？这个问题将在下一节讲到。\u003c/p\u003e\n\n\u003ch5\u003e维护多个版本的近期更新的对象\u003c/h5\u003e\n\n\u003cp\u003e本节将展示 RCU 如何为多个不需要同步的读者维护不同版本的链表。我们使用两个例子来展示一个可能被给定的读者引用的元素必须在该读者处于读方临界区的整个过程中保持完好无损。第一个例子展示了链表元素的删除，而第二个例子则展示了元素的替换。\u003c/p\u003e\n\n\u003ch5\u003e例1：在删除时维护多个版本\u003c/h5\u003e\n\n\u003cp\u003e要开始这个“删除”的例子，我们先把上节这个例子的 11-21行改成如下的形式：\u003c/p\u003e\n\n\u003cp\u003e1 p = search(head, key);\u003cbr /\u003e\n2 if (p != NULL) {\u003cbr /\u003e\n3 list_del_rcu(\u0026amp;p-\u0026gt;list);\u003cbr /\u003e\n4 synchronize_rcu();\u003cbr /\u003e\n5 kfree(p);\u003cbr /\u003e\n6 }\u003c/p\u003e\n\n\u003cp\u003e这个链表以及指针p的最初情况是这样的：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion1.jpg\" alt=\"Initial list state.\" width=\"429\" height=\"111\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e表中每个元素的三元组分别代表域a, b, c。红色的便捷表明读者可以获取它们的指针，而且因为读操作和更新操作不是直接同步的，读者可以在这个删除的过程中同时发生。这里我们为了清晰没有画出双向链表的反向指针。\u003c/p\u003e\n\n\u003cp\u003e在第三行的 list_del_rcu() 完成的时候，5,6,7 这个元素已经被从链表中删除了（如下图）。由于读者并不直接和更新操作同步，读者可能同时正在扫描这个链表。由于访问时间不同，这些并发读者可能看到、也可能没看到新近删除的元素。不过，那些在获取指针之后延迟了读操作的读者（比如因为中断、ECC内存错误，或在\u003ccode\u003e CONFIG_PREEMPT_RT\u003c/code\u003e内核中因为抢占而延迟了的）可能仍然会在删除之后的一段时间内看到那个老的链表的版本。下图中 5,6,7 元素的边框仍然是红色的，这意味着仍然有读者可能会引用它。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersionDelete2.jpg\" alt=\"After deletion.\" width=\"429\" height=\"138\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这里注意，在退出读方临界区之后，读者们就不能再持有 5,6,7 这个元素的引用了。所以，一旦第4行的 synchronize_rcu() 完成了，所有已有读者也就保证都完成了，这样就没有读者会访问这个元素了，下图中，这个元素的边框也变黑了。我们的链表也回到了一个单一的版本了。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersionDelete3.jpg\" alt=\"After deletion.\" width=\"429\" height=\"138\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这之后，5,6,7 这个元素就可以被安全的释放了：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersionDelete4.jpg\" alt=\"After deletion.\" width=\"429\" height=\"49\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e这里，我们完成了删除 5,6,7 这个元素的操作，下一小节将介绍替换操作。\u003c/p\u003e\n\n\u003ch5\u003e例2：在替换的过程中维护数据的多个不同版本\u003c/h5\u003e\n\n\u003cp\u003e在开始替换的例子钱，我们再修改一下前面例子的最后几行：\u003c/p\u003e\n\n\u003cp\u003e1 q = kmalloc(sizeof(*p), GFP_KERNEL);\u003cbr /\u003e\n2 *q = *p;\u003cbr /\u003e\n3 q-\u0026gt;b = 2;\u003cbr /\u003e\n4 q-\u0026gt;c = 3;\u003cbr /\u003e\n5 list_replace_rcu(\u0026amp;p-\u0026gt;list, \u0026amp;q-\u0026gt;list);\u003cbr /\u003e\n6 synchronize_rcu();\u003cbr /\u003e\n7 kfree(p);\u003c/p\u003e\n\n\u003cp\u003e这个链表的初始状态和指针p和删除的那个例子是完全一样的：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion1.jpg\" alt=\"Initial list state.\" width=\"429\" height=\"111\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e和之前一样，每个元素里面的三元组分别代表域 a, b 和 c。红色的边框代表了读者可能会持有这个元素的引用，因为读者和更新者没有直接的同步，读者可能会和整个替换过程并发进行。再次说明，这里我们为了清晰，再次省略了反向指针。\u003c/p\u003e\n\n\u003cp\u003e第一行的 kmalloc() 生成了一个替换元素，如下：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion2.jpg\" alt=\"List state after allocation.\" width=\"492\" height=\"168\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e第二行把旧的元素的内容拷贝给新的元素：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion3.jpg\" alt=\"List state after copy.\" width=\"429\" height=\"168\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e第三行，将 q-\u0026gt;b 更新为2：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion4.jpg\" alt=\"List state after update of b.\" width=\"429\" height=\"168\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e第四行，将 q-\u0026gt;c 更新为3：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion5.jpg\" alt=\"List state after update of c.\" width=\"429\" height=\"168\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e现在，第5行进行替换操作，这里，新元素最终对读者可见了。到了这里，如下所示，我们有了这个链表的两个版本。先前已经存在的读者可以看到 5,6,7 元素，而新读者将看到 5,2,3 元素。不过，任何读者都被保证可以看到一个完整的链表。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion6.jpg\" alt=\"List state after replacement.\" width=\"429\" height=\"171\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e第6行的 synchronize_rcu() 返回后，宽限期将完成，所有在 list_replace_rcu() 之前开始的读者都将完成。具体地说，任何可能持有 5,6,7 的读者都已经退出了他们的读方临界区，这就保证他们不再持有一个引用。因而也在没有任何读者持有老元素的引用了，途中，5,6,7 元素的边框也就变黑了。对于读者来说，目前又只有一个单一的链表版本了，只是新的元素已经替代了旧元素的位置。\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion7.jpg\" alt=\"List state after grace period.\" width=\"429\" height=\"171\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e第七行的 kfree() 完成后，链表旧成为了如下的样子：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e\u003cimg src=\"/assets/MultiVersion8.jpg\" alt=\"List state after grace period.\" width=\"429\" height=\"109\" /\u003e\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e尽管 RCU 是以替换而命名的，但内核中的大多数使用都是前面小节 中的简单删除的情况。\u003c/p\u003e\n\n\u003ch5\u003e讨论\u003c/h5\u003e\n\n\u003cp\u003e这个例子假设在更新操作的过程中保存着一个互斥量，也就是说，这个链表在一个给定时间最多有两种版本。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题4\u003c/strong\u003e：如何修改删除的例子，来允许超过两个版本的链表可以同时存在？\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题5\u003c/strong\u003e：在某一时刻，RCU最多可以有多少个链表的版本？\u003c/p\u003e\n\n\u003cp\u003e这组例子显示了RCU使用多个版本来保障在存在并发读者的情况下的安全更改数据。当然，一些算法是无法很好地支持多个版本的。有一个\u003ca href=\"http://www.rdrop.com/users/paulmck/RCU/RCUdissertation.2004.07.14e1.pdf\"\u003e参考文献\u003c/a\u003e 介绍了如何对这些算法进行改造以使用RCU，不过，这超出了本文的讨论范围了。\u003c/p\u003e\n\n\u003ch5\u003e小结\u003c/h5\u003e\n\n\u003cp\u003e本文介绍了基于RCU的算法的三个基本部分：\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003e对与添加新数据的发布-订阅机制\u003c/li\u003e\n\n\u003cli\u003e等待已有RCU读者完成，以及\u003c/li\u003e\n\n\u003cli\u003e维护多个版本以便在不顺坏或严重延迟RCU读者的情况下，允许更改。\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题6\u003c/strong\u003e：如果 rcu_read_lock() 与 rcu_read_unlock() 之间没有自旋锁或阻塞，RCU更新者会如何影响RCU读者的性能？\u003c/p\u003e\n\n\u003cp\u003e这三个RCU的组成部分允许数据在并发读者访问的同时更新数据，并可以以多种方式实现基于RCU的算法，一些算法将会在接下来的“What is RCU, Really?”系列中继续介绍。\u003c/p\u003e\n\n\u003ch5\u003e致谢\u003c/h5\u003e\n\n\u003cp\u003e我 们十分感激本文草稿的审阅者，他们极大地提高了本文的价值，这些审阅者是 Andy Whitcroft, Gautham Shenoy, 和 Mike Fulton。同时，我们要感谢 Relativistic Programming 项目的成员和 PNW TEC 的成员，他们带来乐很多有价值的讨论。我们还要感谢 Dan Frye 的支持。最后，本文基于 NSF CNS-0719851 资助项目的工作。\u003c/p\u003e\n\n\u003cp\u003e本文仅代表作者的个人观点，并不反映 IBM 或波特兰州立大学的观点。\u003c/p\u003e\n\n\u003cp\u003eLinux 是 Linus Torvalds 的注册商标。\u003c/p\u003e\n\n\u003cp\u003e其他涉及到的公司、产品和服务的名称是各自的商标或服务标志。\u003c/p\u003e\n\n\u003ch5\u003e问题解答\u003c/h5\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题1\u003c/strong\u003e：seqlock 不是也允许读线程和更新线程并发工作么？\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e答\u003c/strong\u003e：是或不是。虽然 seqlock 的读者可以在 seqlock 写的同时并发访问，不过一旦写操作发生，read_seqretry() 原语都会强制要求读者重试。这意味着任何与 seqlock 更新者并发发生的 seqlock 读者所做的工作都将被放弃并重做。所以，seqlock 读者可以与更新者同时\u003cem\u003e运行\u003c/em\u003e，但不能真的在这种情况下做什么工作。\u003c/p\u003e\n\n\u003cp\u003e与此相反，RCU 读者可以在存在并发 RCU 更新者的同时完成有效地工作。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题2\u003c/strong\u003e：如果在 list_for_each_entry_rcu() 运行时，刚好进行了一次 list_add_rcu()，如何防止 segfault 的发生呢？\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e答\u003c/strong\u003e：在所有运行着的 Linux 系统中，从指针读取或写入指针都是原子操作，也就是说，如果一个存储到指针和一个从指针读取操作是同时发生的，那么，读取要么读回初始值，要么读回存入值，而不会返回两者的混合体。另外，list_for_each_entry_rcu() 总会前向遍历链表，而从不反向遍历。因而，list_for_each_entry_rcu() 要么看到 list_add_rcu() 加入后的元素，要么看不到，不论如何，都会看到一个正确的链表。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cbr /\u003e\n\n\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题3\u003c/strong\u003e：为什么我们需要传递两个指针给 hlist_for_each_entry_rcu()， list_for_each_entry_rcu() 可是只需要一个指针的啊？\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e答\u003c/strong\u003e：因为一个 hlist 必须检查 NULL 而不是检查是不是回到头部了。（尝试编一个单指针的 hlist_for_each_entry_rcu()。如果你能得到一个不错的答案，那当然是非常好的事情啦！）\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题4\u003c/strong\u003e：如何修改删除的例子，来允许超过两个版本的链表可以同时存在？\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003ea答\u003c/strong\u003e：一个方法可以通过如下代码达到：\u003c/p\u003e\n\n\u003cp\u003espin_lock(\u0026amp;mylock);\u003cbr /\u003e\np = search(head, key);\u003cbr /\u003e\nif (p == NULL)\u003cbr /\u003e\nspin_unlock(\u0026amp;mylock);\u003cbr /\u003e\nelse {\u003cbr /\u003e\nlist_del_rcu(\u0026amp;p-\u0026gt;list);\u003cbr /\u003e\nspin_unlock(\u0026amp;mylock);\u003cbr /\u003e\nsynchronize_rcu();\u003cbr /\u003e\nkfree(p);\u003cbr /\u003e\n}\u003c/p\u003e\n\n\u003cp\u003e注意，这意味着 synchronize_rcu() 可以等待多个并发的删除操作。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cbr /\u003e\n\n\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题5\u003c/strong\u003e：在某一时刻，RCU最多可以有多少个链表的版本？\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e答\u003c/strong\u003e：这依赖于同步时如何设计的。如果用一个信号量来保护宽限期内的变更操作，那么最多有新旧两个版本。然而，如果仅仅搜索、更新，并用锁来保护 list_replace_rcu()，那么可以有任意数量的活动版本，只受到内存和宽限期内可以完成多少个更新操作的限制。不过，要注意，那些如此频繁更新的数据结构不是实施RCU的好场所。这只是说，RCU 可以在必要时应付高更新速率。\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e\u003cbr /\u003e\n\n\u003c/strong\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e问题6\u003c/strong\u003e：如果 rcu_read_lock() 与 rcu_read_unlock() 之间没有自旋锁或阻塞，RCU更新者会怎样影响RCU读者的性能？\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e答\u003c/strong\u003e：某个CPU上运行的更新者会导致所在CPU上的 cache line 失效，并强制其他运行 RCU读者的 CPU 也丢弃 cache line，从而导致 cache 重新映射造成的昂贵代价。（你能设计一个算法来改变一个数据结构而\u003cem\u003e不导致\u003c/em\u003e并发读者的昂贵的 cache 丢失么？对接下来的其他读者呢？）\u003c/p\u003e\n\n\u003cp\u003e\u0026nbsp;\u003c/p\u003e\n","cover":"","link":"translation/2008/06/01/what-is-rcu/index.html","preview":"","title":"[译文]What is RCU, Fundamentally?"},{"content":"\n\u003cp\u003e嗯，今天 (May 14th, 2006) 清理一下系统，使用了一个命令行，可能对其他人有参考价值\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003edpkg -l |grep \u0026quot;^rc\u0026quot;|awk '{print $2}' |xargs aptitude -y purge\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e用途:\u003c/p\u003e\n\n\u003cp\u003e删除已经删除的软件包的残留配置文件。因为 debian 中 remove 包不删除配置文件，purge 才能清除，但根据依赖关系自动清除都是 remove，在加上自己失手操作，所以用得时间长了，难免残留很多没必要的配置文件，比较烦，于是有了上述操作。\u003c/p\u003e\n\n\u003cp\u003e说明:\u003c/p\u003e\n\n\u003cp\u003e1) dpkg –l\u003c/p\u003e\n\n\u003cp\u003e列出系统中安装的所有包的状态，`ii' 开头的是正常安装的包，`rc'开头的则是删除但仍留下配置文件的包，其他状态则是有错误的状态，自己执行一次就明白了，输出结果的开头有说明的。\u003c/p\u003e\n\n\u003cp\u003e2) grep \u0026quot;^rc\u0026quot;\u003c/p\u003e\n\n\u003cp\u003e提取以 rc 开头的包，也就是被删除但仍残留配置文件的包的信息的行\u003c/p\u003e\n\n\u003cp\u003e3) awk '{print $2}'\u003c/p\u003e\n\n\u003cp\u003e打印这些包的名字，他们位于 dpkg -l 输出结果的第二个字段，估计有很多人是通过这个命令认识到 awk 的，也有很多人只在这个命令行中才使用 awk，我就是其中之一。\u003c/p\u003e\n\n\u003cp\u003e4) xargs aptitude -y purge\u003c/p\u003e\n\n\u003cp\u003e把上述输出，也就是要清除配置文件的包的名字放在 aptitude -y purge 后面，purge 命令会清除配置文件，而 -y 参数会自动对后面 aptitude 命令的提示回答是，这个开关通常是危险的，所以在一般情况下不要轻易使用，而在这里，如果你确定这些包的配置文的清除是没有问题的的话，可以使用这个开关。\u003c/p\u003e\n\n\u003cp\u003e完毕 :)\u003c/p\u003e\n","cover":"","link":"scripts/2008/05/14/清除已删除软件包的配置文件的方法/index.html","preview":"","title":"清除已删除软件包的配置文件的方法"},{"content":"\n\u003cp\u003e[基本仓库]： 拥有 GIT 仓库的人需要的命令——也就是所有人，因为 git 的每个工作拷贝都是一个仓库。\u003c/p\u003e\n\n\u003cp\u003e之后，[个人开发者 (独立工作)]： 任何需要进行 commit 的人都需要的命令，即使是一个人工作的情况。\u003c/p\u003e\n\n\u003cp\u003e如果你和其他人一起工作，你还需要列在[个人开发者 (参与者)]小节的命令。\u003c/p\u003e\n\n\u003cp\u003e扮演[集成者]角色的人还需要学习这一节中的命令。\u003c/p\u003e\n\n\u003cp\u003e[仓库管理]命令是给哪些负责维护 GIT 仓库的系统管理员的。\u003c/p\u003e\n\n\u003ch4\u003e基本仓库\u003ca\u003e\u003c/a\u003e\u003c/h4\u003e\n\n\u003cp\u003e所有人都可以用这些命令来维护 git 仓库。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-init.html\"\u003egit-init(1)\u003c/a\u003e 或 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-clone.html\"\u003egit-clone(1)\u003c/a\u003e : 创建一个新仓库。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-fsck.html\"\u003egit-fsck(1)\u003c/a\u003e : 检查仓库的错误。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-gc.html\"\u003egit-gc(1)\u003c/a\u003e 进行日常维护工作，如 repack 或 prune。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch5\u003e实例：\u003c/h5\u003e\n\n\u003cp\u003e 检查健康状况并去除无用的内容 (译注：cruft 不知如此翻译是否妥当，git-gc 基本是这个含义)。\n\n\u003cpre\u003e$ git fsck \u003cb\u003e(1)\u003c/b\u003e\n$ git count-objects \u003cb\u003e(2)\u003c/b\u003e\n$ git gc \u003cb\u003e(3)\u003c/b\u003e\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e不加--full参数的情况下，这个命令一般会以非常低廉的代价确保仓库在一个不错的健康状态之中。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e统计有多少松散的对象，没有 repack 的对象消耗了多少硬盘空间。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e在本地仓库进行 repack，并进行其他日常维护工作。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e将一个小项目 repack 进入一个单独的 pack。 \u003c/p\u003e\n\n\u003cpre\u003e$ git gc \u003cb\u003e(1)\u003c/b\u003e\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e将所有可以从 refs 访问到的对象都打包添加进一个 pack，然后删除其他 pack。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch4\u003e个人开发者 (独立工作)\u003ca\u003e\u003c/a\u003e\u003c/h4\u003e\n\n\u003cp\u003e独立工作的个人开发者不需要和其他人交换补丁，在单一的仓库中独自工作，通常会用到这些命令。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-show-branch.html\"\u003egit-show-branch(1)\u003c/a\u003e: 查看当前的分支位置。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-log.html\"\u003egit-log(1)\u003c/a\u003e：查看发生了些什么。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html\"\u003egit-checkout(1)\u003c/a\u003e 和 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-branch.html\"\u003egit-branch(1)\u003c/a\u003e：在分支间切换。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-add.html\"\u003egit-add(1)\u003c/a\u003e：管理索引文件。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-diff.html\"\u003egit-diff(1)\u003c/a\u003e和\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-status.html\"\u003egit-status(1)\u003c/a\u003e：查看正在改动些什么。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-commit.html\"\u003egit-commit(1)\u003c/a\u003e：向前推进当前分支。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-reset.html\"\u003egit-reset(1)\u003c/a\u003e 和 (带有路径参数的)\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-checkout.html\"\u003egit-checkout(1)\u003c/a\u003e：撤销变更。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-merge.html\"\u003egit-merge(1)\u003c/a\u003e：合并两个本地分支。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-rebase.html\"\u003egit-rebase(1)\u003c/a\u003e：维护局部分支。\u003ci\u003e(译注：git rebase 的工作大致是这样：原来在本地基于上游版本v，进行了一些改进，现在上游版本进化到了v+n，这时，在本地将基础首先进化到 v+n，然后把对 v 提交的、但还没进入 v+n 的 commit 加入到 v+n，其中可能会有冲突，这可能需要进行一些冲突处理，这里的这个在上游版本基础上添加内容而成的分支称为 topic 分支，这里翻译为局部分支。)\u003c/i\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-tag.html\"\u003egit-tag(1)\u003c/a\u003e：标记标签。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch5\u003e实例：\u003c/h5\u003e\n\n\u003cp\u003e以一个 tarball 来作为新仓库的起点。 \u003c/p\u003e\n\n\u003cpre\u003e$ tar zxf frotz.tar.gz\u003cbr /\u003e$ cd frotz\u003cbr /\u003e$ git-init\u003cbr /\u003e$ git add . \u003cb\u003e(1)\u003c/b\u003e\n$ git commit -m \u0026quot;import of frotz source tree.\u0026quot;\n$ git tag v2.43 \u003cb\u003e(2)\u003c/b\u003e\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e将当前目录的所有内容加入仓库。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e添加一个轻量级的，没有注释的标签。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e简历一个局部分支并进行开发。 \u003c/p\u003e\n\n\u003cpre\u003e$ git checkout -b alsa-audio \u003cb\u003e(1)\u003c/b\u003e\n$ edit/compile/test\n$ git checkout -- curses/ux_audio_oss.c \u003cb\u003e(2)\u003c/b\u003e\n$ git add curses/ux_audio_alsa.c \u003cb\u003e(3)\u003c/b\u003e\n$ edit/compile/test\n$ git diff HEAD \u003cb\u003e(4)\u003c/b\u003e\n$ git commit -a -s \u003cb\u003e(5)\u003c/b\u003e\n$ edit/compile/test\n$ git reset --soft HEAD^ \u003cb\u003e(6)\u003c/b\u003e\n$ edit/compile/test\n$ git diff ORIG_HEAD \u003cb\u003e(7)\u003c/b\u003e\n$ git commit -a -c ORIG_HEAD \u003cb\u003e(8)\u003c/b\u003e\n$ git checkout master \u003cb\u003e(9)\u003c/b\u003e\n$ git merge alsa-audio \u003cb\u003e(10)\u003c/b\u003e\n$ git log --since='3 days ago' \u003cb\u003e(11)\u003c/b\u003e\n$ git log v2.43.. curses/ \u003cb\u003e(12)\u003c/b\u003e\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e创建一个新的局部分支。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e取消对curses/ux_audio_oss.c的修改。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e如果添加了文件的话，需要告诉 git；而删除或修改文件的话，一会的 git commit -a 就可以处理了。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e查看将会提交哪些变更。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e签署并提交所有你测试过的内容。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e回到上一个 commit，但保存工作拷贝中的内容。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e查看自从上一个我们取回的不成熟提交以来的所有变更。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e重新进行上一步中没有完成的提交，使用你自己写的提交信息。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e切换到 master 分支。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e将局部分支合并入你的主分支。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e检查提交日志；其他的可以一起用上的输出选择方式包括--max-count=10 (最多显示10个commit), --until=2005-12-10 等等。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e只查看curses/ 目录中，v2.43标签以来的变更。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch4\u003e个人开发者 (参与者)\u003ca\u003e\u003c/a\u003e\u003c/h4\u003e\n\n\u003cp\u003e在一个小组中参与协同工作的开发者需要学会下面一些命令，以和他人沟通，同时也需要独立的开发者们会用到的命令。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-clone.html\"\u003egit-clone(1)\u003c/a\u003e：从上游来复制出本地仓库。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-pull.html\"\u003egit-pull(1)\u003c/a\u003e 和 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-fetch.html\"\u003egit-fetch(1)\u003c/a\u003e：同上游保持同步更新。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-push.html\"\u003egit-push(1)\u003c/a\u003e：共享仓库，这是是用 CVS 风格的情况下共享仓库的方法。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html\"\u003egit-format-patch(1)\u003c/a\u003e：准备邮件形式提交补丁，如果采用 Linux 内核风格的工作方法。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch5\u003e实例：\u003c/h5\u003e\n\n\u003cp\u003e克隆上游源，并在此基础上工作。最后，将变更送回到上游。 \u003c/p\u003e\n\n\u003cpre\u003e$ git clone git://git.kernel.org/pub/scm/.../torvalds/linux-2.6 my2.6\u003cbr /\u003e$ cd my2.6\u003cbr /\u003e$ edit/compile/test; git commit -a -s \u003cb\u003e(1)\u003c/b\u003e\n$ git format-patch origin \u003cb\u003e(2)\u003c/b\u003e\n$ git pull \u003cb\u003e(3)\u003c/b\u003e\n$ git log -p ORIG_HEAD.. arch/i386 include/asm-i386 \u003cb\u003e(4)\u003c/b\u003e\n$ git pull git://git.kernel.org/pub/.../jgarzik/libata-dev.git ALL \u003cb\u003e(5)\u003c/b\u003e\n$ git reset --hard ORIG_HEAD \u003cb\u003e(6)\u003c/b\u003e\n$ git gc \u003cb\u003e(7)\u003c/b\u003e\n$ git fetch --tags \u003cb\u003e(8)\u003c/b\u003e\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e若干次类似操作。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e从本地分支输出 email 形式的补丁用于提交。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003egit pull从origin取出更新并合并如当前分支。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e取出之后，查看上次取出后上游产生的变更，只观察我们感兴趣的部分。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e从某仓库的某分支取出变更并合并。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e回退上一次取出的内容。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e用垃圾回收去掉上次回退造成的残余物。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e时常从origin取出标签信息，并放到.git/refs/tags/目录下。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e推送入另一个仓库。 \u003c/p\u003e\n\n\u003cpre\u003esatellite$ git clone mothership:frotz frotz \u003cb\u003e(1)\u003c/b\u003e\nsatellite$ cd frotz\nsatellite$ git config --get-regexp '^(remote|branch)\\.' \u003cb\u003e(2)\u003c/b\u003e\nremote.origin.url mothership:frotz\nremote.origin.fetch refs/heads/*:refs/remotes/origin/*\nbranch.master.remote origin\nbranch.master.merge refs/heads/master\nsatellite$ git config remote.origin.push \\\n           master:refs/remotes/satellite/master \u003cb\u003e(3)\u003c/b\u003e\nsatellite$ edit/compile/test/commit\nsatellite$ git push origin \u003cb\u003e(4)\u003c/b\u003e\n\nmothership$ cd frotz\nmothership$ git checkout master\nmothership$ git merge satellite/master \u003cb\u003e(5)\u003c/b\u003e\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003emothership 主机上的你的归属目录中有一个 frotz 仓库，从那里克隆仓库到 satellite 主机上来。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e克隆缺省会设置这些配置变量。这样，git pull 命令就会从 mothership 取出内容，并放到到本地的remotes/origin/*目录下的跟踪分支来。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e设置git push命令将本地的master分支推送到 mothership 主机的 remotes/satellite/master分支去。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003epush 将会把我们的工作存储到 mothership 主机的 remotes/satellite/master 跟踪分支上。你可以把这作为是一种备份手段。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e在 mothership 主机上，合并 satellite 主机上来的工作到 master 分支。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e从某个标签开始分支。 \u003c/p\u003e\n\n\u003cpre\u003e$ git checkout -b private2.6.14 v2.6.14 \u003cb\u003e(1)\u003c/b\u003e\n$ edit/compile/test; git commit -a\n$ git checkout master\n$ git format-patch -k -m --stdout v2.6.14..private2.6.14 |\n  git am -3 -k \u003cb\u003e(2)\u003c/b\u003e\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e基于一个众所周知的(但在什么东西后面的)标签创建一个私有分支。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e不适用正式的 \u0026quot;merge\u0026quot;，将 private2.6.14 分支上的改动移植到 master 分支上来。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch4\u003e集成者\u003ca\u003e\u003c/a\u003e\u003c/h4\u003e\n\n\u003cp\u003e项目中的中心人物会扮演一个集成者的角色，收集他人提供的变更，查看并集成在一起，对外发布结果。与一般参与者相比，集成者还需要用到这样一些命令。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-am.html\"\u003egit-am(1)\u003c/a\u003e：应用来自各个开发者的 email 形式的补丁。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-pull.html\"\u003egit-pull(1)\u003c/a\u003e：合并来自你信任的副手的变更。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html\"\u003egit-format-patch(1)\u003c/a\u003e：准备并发送替换建议给贡献者们。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-revert.html\"\u003egit-revert(1)\u003c/a\u003e：撤销修补。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-push.html\"\u003egit-push(1)\u003c/a\u003e：发布新的版本。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch5\u003e实例：\u003c/h5\u003e\n\n\u003cp\u003e我的典型 GIT 一天。 \u003c/p\u003e\n\n\u003cpre\u003e$ git status \u003cb\u003e(1)\u003c/b\u003e\n$ git show-branch \u003cb\u003e(2)\u003c/b\u003e\n$ mailx \u003cb\u003e(3)\u003c/b\u003e\n\u0026amp; s 2 3 4 5 ./+to-apply\n\u0026amp; s 7 8 ./+hold-linus\n\u0026amp; q\n$ git checkout -b topic/one master\n$ git am -3 -i -s -u ./+to-apply \u003cb\u003e(4)\u003c/b\u003e\n$ compile/test\n$ git checkout -b hold/linus \u0026amp;\u0026amp; git am -3 -i -s -u ./+hold-linus \u003cb\u003e(5)\u003c/b\u003e\n$ git checkout topic/one \u0026amp;\u0026amp; git rebase master \u003cb\u003e(6)\u003c/b\u003e\n$ git checkout pu \u0026amp;\u0026amp; git reset --hard next \u003cb\u003e(7)\u003c/b\u003e\n$ git merge topic/one topic/two \u0026amp;\u0026amp; git merge hold/linus \u003cb\u003e(8)\u003c/b\u003e\n$ git checkout maint\n$ git cherry-pick master~4 \u003cb\u003e(9)\u003c/b\u003e\n$ compile/test\n$ git tag -s -m \u0026quot;GIT 0.99.9x\u0026quot; v0.99.9x \u003cb\u003e(10)\u003c/b\u003e\n$ git fetch ko \u0026amp;\u0026amp; git show-branch master maint 'tags/ko-*' \u003cb\u003e(11)\u003c/b\u003e\n$ git push ko \u003cb\u003e(12)\u003c/b\u003e\n$ git push ko v0.99.9x \u003cb\u003e(13)\u003c/b\u003e\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e查看有什么正在做、没提交的东西。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e查看有哪些局部分支，思考他们是否成熟了。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e阅读邮件，保存那些可以用的，也保存那些还不是很成熟的。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e交互式打补丁，使用自己的签名。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e如果需要，建立局部分支，并用自己的签名打补丁。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e将内部的还没有并入 master 也没有成为稳定分支的一部分的局部分支用 rebase 移植到 master 上。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003ereset pu，让它总是从 next 开始。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e将仍在工作中的分支们合并在一起。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e对先前的版本进行问题修正。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e建立一个有签名的标签。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e确信我没有偶然将 master 退回到已经发布出去的版本的后面了。ko 是我在 kernel.org 的仓库的简写，看起来类似这样： \u003c/p\u003e\n\n\u003cpre\u003e$ cat .git/remotes/ko\u003cbr /\u003eURL: kernel.org:/pub/scm/git/git.git\u003cbr /\u003ePull: master:refs/tags/ko-master\u003cbr /\u003ePull: next:refs/tags/ko-next\u003cbr /\u003ePull: maint:refs/tags/ko-maint\u003cbr /\u003ePush: master\u003cbr /\u003ePush: next\u003cbr /\u003ePush: +pu\u003cbr /\u003ePush: maint\u003c/pre\u003e\n\n\u003cp\u003e在 git show-branch 的输出中, master 应该包含 ko-master 的所有内容, 而 next 应该包含ko-next 的所有内容。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e推送出最新版本。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e把标签也推送出去。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003ch4\u003e仓库管理\u003ca\u003e\u003c/a\u003e\u003c/h4\u003e\n\n\u003cp\u003e仓库管理员会使用如下工具来设置和维护开发者们对仓库的访问方法。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-daemon.html\"\u003egit-daemon(1)\u003c/a\u003e：允许匿名下载仓库。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-shell.html\"\u003egit-shell(1)\u003c/a\u003e 可以被用于\u003ci\u003erestricted login shell\u003c/i\u003e 来将中心仓库共享给用户。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/howto/update-hook-example.txt\"\u003eupdate hook howto\u003c/a\u003e 有一个不错的关于管理一个共享的中心仓库的例子。\u003c/p\u003e\n\n\u003ch5\u003e实例：\u003c/h5\u003e\n\n\u003cp\u003e我们假设如下内容位于 /etc/services 文件之内： \u003c/p\u003e\n\n\u003cpre\u003e$ grep 9418 /etc/services\u003cbr /\u003egit             9418/tcp                # Git Version Control System\u003c/pre\u003e\n\n\u003cp\u003e用 git-daemon 通过 inetd 提供 /pub/scm 服务。 \u003c/p\u003e\n\n\u003cpre\u003e$ grep git /etc/inetd.conf\u003cbr /\u003egit     stream  tcp     nowait  nobody \\\u003cbr /\u003e  /usr/bin/git-daemon git-daemon --inetd --export-all /pub/scm\u003c/pre\u003e\n\n\u003cp\u003e实际配置文件中应该是一行。\u003c/p\u003e\n\n\u003cp\u003e用 git-daemon 通过 xinetd 提供 /pub/scm 服务。 \u003c/p\u003e\n\n\u003cpre\u003e$ cat /etc/xinetd.d/git-daemon\u003cbr /\u003e# default: off\u003cbr /\u003e# description: The git server offers access to git repositories\u003cbr /\u003eservice git\u003cbr /\u003e{\u003cbr /\u003e        disable = no\u003cbr /\u003e        type            = UNLISTED\u003cbr /\u003e        port            = 9418\u003cbr /\u003e        socket_type     = stream\u003cbr /\u003e        wait            = no\u003cbr /\u003e        user            = nobody\u003cbr /\u003e        server          = /usr/bin/git-daemon\u003cbr /\u003e        server_args     = --inetd --export-all --base-path=/pub/scm\u003cbr /\u003e        log_on_failure  += USERID\u003cbr /\u003e}\u003c/pre\u003e\n\n\u003cp\u003e设置时请参考你的 xinetd(8) 文档，上述设置适用于 Fedora 系统。其他系统可能有所不同。\u003c/p\u003e\n\n\u003cp\u003e仅提供 push/pull 权限给开发者。 \u003c/p\u003e\n\n\u003cpre\u003e$ grep git /etc/passwd \u003cb\u003e(1)\u003c/b\u003e\nalice:x:1000:1000::/home/alice:/usr/bin/git-shell\nbob:x:1001:1001::/home/bob:/usr/bin/git-shell\ncindy:x:1002:1002::/home/cindy:/usr/bin/git-shell\ndavid:x:1003:1003::/home/david:/usr/bin/git-shell\n$ grep git /etc/shells \u003cb\u003e(2)\u003c/b\u003e\n/usr/bin/git-shell\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e将 login shell 设置为 /usr/bin/git-shell, 这样，只有git push 和 git pull 操作才被允许。用户如果要访问计算机，需要通 ssh 访问权限。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003ein many distributions /etc/shells needs to list what is used as the login shell. 很多发布版中，只有 /etc/shells 列出的程序才能作为 login shell. \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003eCVS 风格的共享仓库。 \u003c/p\u003e\n\n\u003cpre\u003e$ grep git /etc/group \u003cb\u003e(1)\u003c/b\u003e\ngit:x:9418:alice,bob,cindy,david\n$ cd /home/devo.git\n$ ls -l \u003cb\u003e(2)\u003c/b\u003e\n  lrwxrwxrwx   1 david git    17 Dec  4 22:40 HEAD -\u0026gt; refs/heads/master\n  drwxrwsr-x   2 david git  4096 Dec  4 22:40 branches\n  -rw-rw-r--   1 david git    84 Dec  4 22:40 config\n  -rw-rw-r--   1 david git    58 Dec  4 22:40 description\n  drwxrwsr-x   2 david git  4096 Dec  4 22:40 hooks\n  -rw-rw-r--   1 david git 37504 Dec  4 22:40 index\n  drwxrwsr-x   2 david git  4096 Dec  4 22:40 info\n  drwxrwsr-x   4 david git  4096 Dec  4 22:40 objects\n  drwxrwsr-x   4 david git  4096 Nov  7 14:58 refs\n  drwxrwsr-x   2 david git  4096 Dec  4 22:40 remotes\n$ ls -l hooks/update \u003cb\u003e(3)\u003c/b\u003e\n  -r-xr-xr-x   1 david git  3536 Dec  4 22:40 update\n$ cat info/allowed-users \u003cb\u003e(4)\u003c/b\u003e\nrefs/heads/master       alice\\|cindy\nrefs/heads/doc-update   bob\nrefs/tags/v[0-9]*       david\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e将开发者们都放入 git 组。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e并让整个共享仓库对组可写。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e使用 Carl 写的 Documentation/howto 中的 update-hook 例子用于分支策略控制。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003ealice 和 cindy 可以向 master 中 push 内容，只有 bob 可以向 doc-update 中 push 内容。david 是对外发布管理员，是惟一可以创建并 push 版本标签的人。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e支持哑协议传输的 HTTP Server. \u003c/p\u003e\n\n\u003cpre\u003edev$ git update-server-info \u003cb\u003e(1)\u003c/b\u003e\ndev$ ftp user@isp.example.com \u003cb\u003e(2)\u003c/b\u003e\nftp\u0026gt; cp -r .git /home/user/myproject.git\u003c/pre\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e确认 info/refs 和 objects/info/packs 的内容是更新过的。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e上传到你的 ISP 提供的公共 HTTP 服务器。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e原文最新更新： 23-Apr-2008 16:08:38 UTC\u003cbr /\u003e\n  \u003cbr /\u003e翻译时间：2008年5月3日，王旭 (gnawux\u0026lt;at\u0026gt;gmail.com) \u003c/p\u003e\n","cover":"","link":"translation/2008/05/03/git日常命令20来条/index.html","preview":"","title":"GIT日常命令20来条"},{"content":"\n\u003cp\u003e原文链接：\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/tutorial.html\"\u003ehttp://www.kernel.org/pub/software/scm/git/docs/tutorial.html\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e这个教程将介绍如何将一个新的项目导入到 git 之中，如何修改项目并如何将这些变更与其他开发者分享。\u003c/p\u003e\n\n\u003cp\u003e如果你更感兴趣如何用 git 取出一个项目，比如，测试软件的最新版本，你可能更应该看看\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/user-manual.html\"\u003eThe Git User's Manual\u003c/a\u003e的前两章。\u003c/p\u003e\n\n\u003cp\u003e首先，记住你可以用 man 来获取 git 的文档，比如 \u0026quot;git diff\u0026quot; 的文档可以用如下命令察看:\u003c/p\u003e\n\n\u003cpre\u003e$ man git-diff\u003c/pre\u003e\n\n\u003cp\u003e在做任何改动之前，最好把自己的名字和 email 地址介绍给大家，最简单的方法就是:\u003c/p\u003e\n\n\u003cpre\u003e$ git config --global user.name \u0026quot;Your Name Comes Here\u0026quot;\u003cbr /\u003e$ git config --global user.email you@yourdomain.example.com\u003c/pre\u003e\n\n\u003ch4\u003e导入一个新项目\u003c/h4\u003e\n\n\u003cp\u003e假设你有一个名为 project.tar.gz 的 tarball 作为项目的初始内容。你可以如下操作来把它至于 git 版本控制之下。\u003c/p\u003e\n\n\u003cpre\u003e$ tar xzf project.tar.gz\u003cbr /\u003e$ cd project\u003cbr /\u003e$ git init\u003c/pre\u003e\n\n\u003cp\u003eGit 将会如下回复:\u003c/p\u003e\n\n\u003cpre\u003eInitialized empty Git repository in .git/\u003c/pre\u003e\n\n\u003cp\u003e现在，你已经初始化了工作目录——你可能已经注意到了名为 \u0026quot;.git\u0026quot; 的一个新目录了。\u003c/p\u003e\n\n\u003cp\u003e下一步就是使用 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-add.html\"\u003egit-add(1)\u003c/a\u003e 命令告诉 git 当前目录的所有文件 (注意这个点：\u003ci\u003e.\u003c/i\u003e) 全是项目的一个快照:\u003c/p\u003e\n\n\u003cpre\u003e$ git add .\u003c/pre\u003e\n\n\u003cp\u003e这个快照目前存放在一个临时区域之中，在 git 中称为 \u0026quot;index\u0026quot;(索引)。使用 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-commit.html\"\u003egit-commit(1)\u003c/a\u003e 命令，你可以把 index 的所有内容永久性地存放到软件仓库之中: \u003c/p\u003e\n\n\u003cpre\u003e$ git commit\u003c/pre\u003e\n\n\u003cp\u003e这条命令会向你提示输入版本变更信息。这样，你的项目的第一个版本就已经存入 git 之中了。\u003c/p\u003e\n\n\u003ch4\u003e进行修改\u003c/h4\u003e\n\n\u003cp\u003e修改一些文件之后，你可以将更新这些内容到 index 之中:\u003c/p\u003e\n\n\u003cpre\u003e$ git add file1 file2 file3\u003c/pre\u003e\n\n\u003cp\u003e现在，你已经准备就绪，可以提交了。现在你可以使用 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-diff.html\"\u003egit-diff(1)\u003c/a\u003e 命令的 --cache 参数:\u003c/p\u003e\n\n\u003cpre\u003e$ git diff --cached\u003c/pre\u003e\n\n\u003cp\u003e(如果不使用 --cached 参数，\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-diff.html\"\u003egit-diff(1)\u003c/a\u003e会显示所有还没添加进 index 的已经做出的改动。) 你也可以使用 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-status.html\"\u003egit-status(1)\u003c/a\u003e来获得一些当前状况的概要信息:\u003c/p\u003e\n\n\u003cpre\u003e$ git status\u003cbr /\u003e# On branch master\u003cbr /\u003e# Changes to be committed:\u003cbr /\u003e#   (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\u003cbr /\u003e#\u003cbr /\u003e#       modified:   file1\u003cbr /\u003e#       modified:   file2\u003cbr /\u003e#       modified:   file3\u003cbr /\u003e#\u003c/pre\u003e\n\n\u003cp\u003e如果你需要进行更多改动，现在就可以进行，然后可以添加到 index 之中。最后，使用如下命令提交改动: \u003c/p\u003e\n\n\u003cpre\u003e$ git commit\u003c/pre\u003e\n\n\u003cp\u003e这将再次要求你输入关于这次改动内容的描述性信息，之后记录下的项目新版本。\u003c/p\u003e\n\n\u003cp\u003e此外，如果想省掉提交之前的git add命令，你可以直接用\u003c/p\u003e\n\n\u003cpre\u003e$ git commit -a\u003c/pre\u003e\n\n\u003cp\u003e这样会自动检测所有修改过的文件 (不包括新文件) ，并一气呵成地将它们添到 index 之中，并提交。\u003c/p\u003e\n\n\u003cp\u003e关于提交的描述信息: 虽然这个信息不是必须的，但提交信息描述最好以一行不超过50个字符的概要性信息来开头，在一个空行之后再进行更多的描述。比如那些将 commit 转化为 email 的工具就会把这个第一行作为邮件标题，其余的提交内容则放在邮件内部。\u003c/p\u003e\n\n\u003ch4\u003eGit 跟踪内容而不是文件\u003c/h4\u003e\n\n\u003cp\u003e很多版本控制系统提供了一个 \u0026quot;add\u0026quot; 命令用来记录一个新文件。而 git 的 \u0026quot;add\u0026quot; 命令更加简单也更加强大: git add既用于新文件也用于新近改动的文件，在所有这些情况下，它在 index 中对所有的文件与状态进行一次快照，这样就可以在下一次 commit 命令中进行提交。 \u003c/p\u003e\n\n\u003ch4\u003eViewing project history\u003c/h4\u003e\n\n\u003cp\u003e在任何时候，你都可以如下查看所有你进行过的改动\u003c/p\u003e\n\n\u003cpre\u003e$ git log\u003c/pre\u003e\n\n\u003cp\u003e你可能还想看到每一步改进中的所有完整的 diff ，这可以使用如下命令\u003c/p\u003e\n\n\u003cpre\u003e$ git log -p\u003c/pre\u003e\n\n\u003cp\u003e浏览改动的概要对于获得每一步修改的情况常常是比较有用的，可以使用如下命令\u003c/p\u003e\n\n\u003cpre\u003e$ git log --stat --summary\u003c/pre\u003e\n\n\u003ch4\u003e管理分支\u003c/h4\u003e\n\n\u003cp\u003e一个 git 仓库可以包含多个开发分支。使用如下命令可以建立一个称为 \u0026quot;experimental\u0026quot; 的新分支 \u003c/p\u003e\n\n\u003cpre\u003e$ git branch experimental\u003c/pre\u003e\n\n\u003cp\u003e如果你运行命令\u003c/p\u003e\n\n\u003cpre\u003e$ git branch\u003c/pre\u003e\n\n\u003cp\u003e你将可以得到类似下面的已有分支的列表\u003c/p\u003e\n\n\u003cpre\u003e  experimental\u003cbr /\u003e* master\u003c/pre\u003e\n\n\u003cp\u003e\u0026quot;experimental\u0026quot; 就是你刚刚建立的那个分支，而 \u0026quot;master\u0026quot; 分支则是建立仓库的时候自动创建的缺省分支，里面的星号表示你当前所在的分支；输入命令\u003c/p\u003e\n\n\u003cpre\u003e$ git checkout experimental\u003c/pre\u003e\n\n\u003cp\u003e就可以切换到 experimental 分支。现在修改一个文件，并提交改变，然后重新回到 master 分支:\u003c/p\u003e\n\n\u003cpre\u003e(edit file)\u003cbr /\u003e$ git commit -a\u003cbr /\u003e$ git checkout master\u003c/pre\u003e\n\n\u003cp\u003e你会发现，刚才的变更已经不可见了，这是因为这个改变是发生于 experimental 分支的，而你现在已经回到 master 分支了。\u003c/p\u003e\n\n\u003cp\u003e现在，你可以在 master 分支上做一些不同的变更：\u003c/p\u003e\n\n\u003cpre\u003e(edit file)\u003cbr /\u003e$ git commit -a\u003c/pre\u003e\n\n\u003cp\u003e这里，两个分支已经产生不同了，每个分支上都发生了不同的改动。要把 experimental 中的改变也合并到 master 之中，运行命令\u003c/p\u003e\n\n\u003cpre\u003e$ git merge experimental\u003c/pre\u003e\n\n\u003cp\u003e如果两者的改变并不冲突，那么就算是完成了。而如果这里有冲突，有问题的文件左边会显示出标记，以表明这个文件发生了冲突；\u003c/p\u003e\n\n\u003cpre\u003e$ git diff\u003c/pre\u003e\n\n\u003cp\u003e上述命令将会列出具体的冲突。一旦你编辑文件解决了冲突，\u003c/p\u003e\n\n\u003cpre\u003e$ git commit -a\u003c/pre\u003e\n\n\u003cp\u003e这个命令将把合并的结果提交。最终，\u003c/p\u003e\n\n\u003cpre\u003e$ gitk\u003c/pre\u003e\n\n\u003cp\u003e会显示出漂亮的图标以展示历史变革。\u003c/p\u003e\n\n\u003cp\u003e这里你可以使用如下命令删除 experimental 分支。\u003c/p\u003e\n\n\u003cpre\u003e$ git branch -d experimental\u003c/pre\u003e\n\n\u003cp\u003e这个命令会确定 experimental 中的所有改动已经在当前分支当中了。\u003c/p\u003e\n\n\u003cp\u003e如果你在 crazy-idea 分支中进行开发，然后又后悔了，你可以用如下命令删除分支\u003c/p\u003e\n\n\u003cpre\u003e$ git branch -D crazy-idea\u003c/pre\u003e\n\n\u003cp\u003e分支操作十分简单而且代价低廉，所以适合于尝试一些东西。\u003c/p\u003e\n\n\u003ch4\u003e使用 git 进行协作\u003c/h4\u003e\n\n\u003cp\u003e假设 Alice 在 /home/alice/project 中的 git 仓库启动了一个新项目，而在本机中也拥有 home 目录的 Bob 想要贡献一些代码。\u003c/p\u003e\n\n\u003cp\u003e他可以以如下工作开始:\u003c/p\u003e\n\n\u003cpre\u003e$ git clone /home/alice/project myrepo\u003c/pre\u003e\n\n\u003cp\u003e这会新建一个名为 \u0026quot;myrepo\u0026quot; 的目录，里面包含了 Alice 的仓库的一份克隆。这份克隆与原始项目完全一致，可以处理自己的一份原始项目历史。\u003c/p\u003e\n\n\u003cp\u003e之后，Bob 进行了一些变更并提交了这些变动:\u003c/p\u003e\n\n\u003cpre\u003e(edit files)\u003cbr /\u003e$ git commit -a\u003cbr /\u003e(repeat as necessary)\u003c/pre\u003e\n\n\u003cp\u003e当他完成的时候，他告诉 Alice 将 /home/bob/myrepo 之中的变动导入到原始仓库之中。她使用如下命令来完成这一工作:\u003c/p\u003e\n\n\u003cpre\u003e$ cd /home/alice/project\u003cbr /\u003e$ git pull /home/bob/myrepo master\u003c/pre\u003e\n\n\u003cp\u003e这会合并 Bob 的 \u0026quot;master\u0026quot; 分支到 Alice 的当前分支。如果 Alice 也已经修改了某些内容，她需要手工修复冲突。(注意，\u0026quot;master\u0026quot; 参数实际上并不是必要的，因为这是缺省分支。) \u003c/p\u003e\n\n\u003cp\u003e\u0026quot;pull\u0026quot; 命令包括两个操作: 从远端分支中取出改动，然后合并到当前分支之中。\u003c/p\u003e\n\n\u003cp\u003e当你只在一个很小的小组里工作的时候，通常不会频繁地访问同一个仓库。通过定义仓库的快捷方式，可以让访问远程仓库更方便一些:\u003c/p\u003e\n\n\u003cpre\u003e$ git remote add bob /home/bob/myrepo\u003c/pre\u003e\n\n\u003cp\u003e这样，Alice 可以如下用 \u0026quot;git fetch\u0026quot; 命令仅取出改动，而不把它们合并到当前分支之中:\u003c/p\u003e\n\n\u003cpre\u003e$ git fetch bob\u003c/pre\u003e\n\n\u003cp\u003e和长格式不同，当 Alice 使用 git remote设置的快捷方式从 Bob 的仓库中获取内容的时候，取出的内容存储在一个 remote tracking 分支之中，在本例中是 bob/master。所以，如下操作：\u003c/p\u003e\n\n\u003cpre\u003e$ git log -p master..bob/master\u003c/pre\u003e\n\n\u003cp\u003e将会列出从 Bob 从 Alice 的主分支中分支出去以后的所有改动。\u003c/p\u003e\n\n\u003cp\u003e检查了这些变动之后，Alice 可以将这些变动合并到自己的 master 分支中：\u003c/p\u003e\n\n\u003cpre\u003e$ git merge bob/master\u003c/pre\u003e\n\n\u003cp\u003e这个合并也可以通过从自己的 remote tracking 分支中 pull 来做到，如:\u003c/p\u003e\n\n\u003cpre\u003e$ git pull . remotes/bob/master\u003c/pre\u003e\n\n\u003cp\u003e注意，git pull 总是合并进当前的分支，不论命令行给出的是什么。\u003c/p\u003e\n\n\u003cp\u003e之后，Bob 可以如下使用 Alice 的最近改动更新自己的仓库\u003c/p\u003e\n\n\u003cpre\u003e$ git pull\u003c/pre\u003e\n\n\u003cp\u003e这里，他不需要给出 Alice 的仓库的位置；当 Bob 克隆了 Alice 的仓库的时候，git 在仓库设置中保存了她的仓库的位置，即 pull 所使用的位置:\u003c/p\u003e\n\n\u003cpre\u003e$ git config --get remote.origin.url\u003cbr /\u003e/home/alice/project\u003c/pre\u003e\n\n\u003cp\u003e(git-clone 创建的完整配置信息可以用 \u0026quot;git config -l\u0026quot; 获得，\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-config.html\"\u003egit-config(1)\u003c/a\u003e的 man page 解释了所有选项的含义。)\u003c/p\u003e\n\n\u003cp\u003eGit 也在 \u0026quot;origin/master\u0026quot; 分支保存了一份 Alice 的主分支的原始拷贝:\u003c/p\u003e\n\n\u003cpre\u003e$ git branch -r\u003cbr /\u003e  origin/master\u003c/pre\u003e\n\n\u003cp\u003e如果其后 Bob 决定转到另一台主机上工作，他还可以通过 ssh 来克隆原始仓库:\u003c/p\u003e\n\n\u003cpre\u003e$ git clone alice.org:/home/alice/project myrepo\u003c/pre\u003e\n\n\u003cp\u003e此外，git 本身也有远程协议，并且可以使用 rsync 或 http，详细情况可以查看 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-pull.html\"\u003egit-pull(1)\u003c/a\u003e的 man page。\u003c/p\u003e\n\n\u003cp\u003eGit 也可以使用类似 CVS 的工作方式，使用一个中心仓库，所有用户将改动推送到仓库之中，相关内容可以查阅 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-push.html\"\u003egit-push(1)\u003c/a\u003e的手册页或\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/cvs-migration.html\"\u003egit for CVS users\u003c/a\u003e。\u003c/p\u003e\n\n\u003ch4\u003e浏览历史\u003c/h4\u003e\n\n\u003cp\u003eGit 的历史是通过一系列相互关联的 commit 构成的。我们已经通过 git log 命令看到了这些提交的列表。注意，每个 git log 条目的第一行是那次提交的名称:\u003c/p\u003e\n\n\u003cpre\u003e$ git log\u003cbr /\u003ecommit c82a22c39cbc32576f64f5c6b3f24b99ea8149c7\u003cbr /\u003eAuthor: Junio C Hamano \u0026lt;junkio@cox.net\u0026gt;\u003cbr /\u003eDate:   Tue May 16 17:18:22 2006 -0700\u003cbr /\u003e\u003cbr /\u003e    merge-base: Clarify the comments on post processing.\u003c/pre\u003e\n\n\u003cp\u003e把这个名称用于 git show 命令，可以得到提交的详情。\u003c/p\u003e\n\n\u003cpre\u003e$ git show c82a22c39cbc32576f64f5c6b3f24b99ea8149c7\u003c/pre\u003e\n\n\u003cp\u003e不过还有其他办法来指代这次提交。你可以只使用名称的开始部分，只要它足够长，保证在所有提交中是惟一的就行了: \u003c/p\u003e\n\n\u003cpre\u003e$ git show c82a22c39c   # the first few characters of the name are\u003cbr /\u003e                        # usually enough\u003cbr /\u003e$ git show HEAD         # the tip of the current branch\u003cbr /\u003e$ git show experimental # the tip of the \u0026quot;experimental\u0026quot; branch\u003c/pre\u003e\n\n\u003cp\u003e每一次提交通常都有一次提交作为 \u0026quot;parent\u0026quot; ，它是项目的前一个状态: \u003c/p\u003e\n\n\u003cpre\u003e$ git show HEAD^  # to see the parent of HEAD\u003cbr /\u003e$ git show HEAD^^ # to see the grandparent of HEAD\u003cbr /\u003e$ git show HEAD~4 # to see the great-great grandparent of HEAD\u003c/pre\u003e\n\n\u003cp\u003e要注意，合并提交可能会有多个 \u0026quot;parent\u0026quot;:\u003c/p\u003e\n\n\u003cpre\u003e$ git show HEAD^1 # show the first parent of HEAD (same as HEAD^)\u003cbr /\u003e$ git show HEAD^2 # show the second parent of HEAD\u003c/pre\u003e\n\n\u003cp\u003e你还可以给你的提交一个名字; 命令\u003c/p\u003e\n\n\u003cpre\u003e$ git-tag v2.5 1b2e1d63ff\u003c/pre\u003e\n\n\u003cp\u003e让你可以使用 \u0026quot;v2.5\u0026quot; 来指代 1b2e1d63ff。如果你想把这个名字与他人共享 (比如标记一个发布版本)，你应该建立一个 \u0026quot;tag\u0026quot; 对象，可能还需要签署它; 详情请查看 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-tag.html\"\u003egit-tag(1)\u003c/a\u003e的 man page。\u003c/p\u003e\n\n\u003cp\u003e任何 git 命令都可以使用上述任何一种名字。比如:\u003c/p\u003e\n\n\u003cpre\u003e$ git diff v2.5 HEAD     # compare the current HEAD to v2.5\u003cbr /\u003e$ git branch stable v2.5 # start a new branch named \u0026quot;stable\u0026quot; based\u003cbr /\u003e                         # at v2.5\u003cbr /\u003e$ git reset --hard HEAD^ # reset your current branch and working\u003cbr /\u003e                         # directory to its state at HEAD^\u003c/pre\u003e\n\n\u003cp\u003e小心使用上述最后一个命令: 这将丢失工作目录中的所有改动，他还会清除本分支内随后的所有提交。如果这个分支是包含这些提交的惟一分支，它们将永远地丢失了。此外，不要对一个公众可见的、有其他开发者从中 pull 内容的分支使用 \u0026quot;git reset\u0026quot; 命令，这将导致一些不必要的合并来清除其他开发者的历史信息。如果你需要取消已经推送的改动，可以使用\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-revert.html\"\u003egit-revert(1)\u003c/a\u003e命令。\u003c/p\u003e\n\n\u003cp\u003egit grep 可以在项目的所有版本历史中寻找字符串，如下命令\u003c/p\u003e\n\n\u003cpre\u003e$ git grep \u0026quot;hello\u0026quot; v2.5\u003c/pre\u003e\n\n\u003cp\u003e会在版本 v2.5 中寻找所有 \u0026quot;hello\u0026quot; 的踪迹。\u003c/p\u003e\n\n\u003cp\u003e如果你不提供 commit 名称，git grep 会在你当前的目录中搜索所有由 git 管理的文件。于是，如下命令\u003c/p\u003e\n\n\u003cpre\u003e$ git grep \u0026quot;hello\u0026quot;\u003c/pre\u003e\n\n\u003cp\u003e是搜索 git 跟踪的所有文件的便捷的方式。\u003c/p\u003e\n\n\u003cp\u003e很多 git 命令可以处理一组提交，可以通过多种方式来指定版本。这里是一些 git log 的例子: \u003c/p\u003e\n\n\u003cpre\u003e$ git log v2.5..v2.6            # commits between v2.5 and v2.6\u003cbr /\u003e$ git log v2.5..                # commits since v2.5\u003cbr /\u003e$ git log --since=\u0026quot;2 weeks ago\u0026quot; # commits from the last 2 weeks\u003cbr /\u003e$ git log v2.5.. Makefile       # commits since v2.5 which modify\u003cbr /\u003e                                # Makefile\u003c/pre\u003e\n\n\u003cp\u003e你给出的范围的上下边界不一定是严格的时间先后关系，比如，\u0026quot;stable-release\u0026quot; 分支可能会在 \u0026quot;master\u0026quot; 分支之后相当长一段时间才会引入同一个提交内容，这样\u003c/p\u003e\n\n\u003cpre\u003e$ git log stable..experimental\u003c/pre\u003e\n\n\u003cp\u003e将会列出 expermental 分支之中已经有的，而 stable 分支却还没有的提交，而命令\u003c/p\u003e\n\n\u003cpre\u003e$ git log experimental..stable\u003c/pre\u003e\n\n\u003cp\u003e将会列出 stable 中已有、但 experimental 却没有的提交。\u003c/p\u003e\n\n\u003cp\u003e\u0026quot;git log\u0026quot; 命令有一个弱点：必须将所有提交在一个列表中呈现出来。当项目历史中有多个不同开发分支并最终合并到一起时，\u0026quot;git log\u0026quot; 中呈现出来的顺序可能没什么意义。\u003c/p\u003e\n\n\u003cp\u003e大部分有大量开发者的项目 (比如 linux kernel 或 git 本身) 都经常合并分支，gitk 可以更好地将这些合并变化展示出来。比如，\u003c/p\u003e\n\n\u003cpre\u003e$ gitk --since=\u0026quot;2 weeks ago\u0026quot; drivers/\u003c/pre\u003e\n\n\u003cp\u003e这个命令允许你浏览过去两个星期中在 \u0026quot;drivers\u0026quot; 目录之中的任意提交。(注意: 你可以按住 ctrl 键然后用 \u0026quot;-\u0026quot; 和 \u0026quot;+\u0026quot; 来调整 gitk 的字体大小。)\u003c/p\u003e\n\n\u003cp\u003e最后，大部分命令可以带有文件名，这可以用于指定某次提交中的某个文件，从而指定某个文件的某个版本:\u003c/p\u003e\n\n\u003cpre\u003e$ git diff v2.5:Makefile HEAD:Makefile.in\u003c/pre\u003e\n\n\u003cp\u003e你还可以用 \u0026quot;git show\u0026quot; 命令去查看任意文件的任意版本:\u003c/p\u003e\n\n\u003cpre\u003e$ git show v2.5:Makefile\u003c/pre\u003e\n\n\u003ch4\u003e下一步学习\u003c/h4\u003e\n\n\u003cp\u003e这个教程应该足够你的项目进行基本的项目发布版本管理。不过，要完全深入地理解 git 的强大功能可能还需要理解两个简单的概念:\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e对象数据库是个相当阳春的系统，用于存储你的项目的历史，包括文件、目录以及各次提交。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e索引文件是目录树的状态的缓存，用于建立提交、取出工作目录并保存一次合并中包含的不同的目录树。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/tutorial-2.html\"\u003e本教程的第二部分\u003c/a\u003e解释了对象数据库、索引文件以及一些其他你在使用 git 中所需要了解的零七八碎的概念。\u003c/p\u003e\n\n\u003cp\u003e如果你不想在这条路上继续下去，还有一些细枝末节的东西可能十分有趣:\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-format-patch.html\"\u003egit-format-patch(1)\u003c/a\u003e, \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-am.html\"\u003egit-am(1)\u003c/a\u003e: 用于将一系列 git 提交转化成 email 发送的补丁或反之，对于 linux 内核这样的高度依赖于邮件发送的补丁的项目来说十分有用。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-bisect.html\"\u003egit-bisect(1)\u003c/a\u003e: 当你的项目发生问题 (功能或性能上的退步) 的时候，一个跟踪发现错误的方法就是通过历史发现那个罪魁祸首的提交。Git bisect 可以帮助你进行二分查找发现那个提交。它能在一个有很多分支合并的具有复杂非线性历史的项目中十分灵巧地进行接近最优的搜索。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/everyday.html\"\u003eEveryday GIT with 20 Commands Or So\u003c/a\u003e\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/cvs-migration.html\"\u003egit for CVS users\u003c/a\u003e. \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e原文最后更新 25-Aug-2007 03:53:15 UTC\u003cbr /\u003e\n  \u003cbr /\u003e译文初稿：2007年7月，王旭 (gnawux\u0026lt;at\u0026gt;gmail.com)\u003c/p\u003e\n\n\u003cp\u003e译文最后更新：2008年5月2日，王旭 (gnawux\u0026lt;at\u0026gt;gmail.com) \u003c/p\u003e\n","cover":"","link":"translation/2008/05/02/[译文]-git-简要教程--适用于-1.5.1-或更新版本-/index.html","preview":"","title":"[译文] git 简要教程 (适用于 1.5.1 或更新版本)"},{"content":"\n\u003cp\u003e阅读本教程之前，你应该已经阅读过\u003ca href=\"http://wangxu.me/blog/?p=156\"\u003e《GIT简要教程》\u003c/a\u003e（译注：本人曾经翻译过）了。\u003c/p\u003e\n\n\u003cp\u003e本教程将介绍GIT架构中的两个基础概念——对象数据库和索引文件——并为读者提供阅读其他GIT文档所需的基础知识。\u003c/p\u003e\n\n\u003ch4\u003eGIT对象数据库\u003c/h4\u003e\n\n\u003cp\u003e让我们从一个新项目开始，并加入少量的变更历史：\u003c/p\u003e\n\n\u003cpre\u003e$ mkdir test-project\u003cbr /\u003e$ cd test-project\u003cbr /\u003e$ git init\u003cbr /\u003eInitialized empty Git repository in .git/\u003cbr /\u003e$ echo 'hello world' \u0026gt; file.txt\u003cbr /\u003e$ git add .\u003cbr /\u003e$ git commit -a -m \u0026quot;initial commit\u0026quot;\u003cbr /\u003eCreated initial commit 54196cc2703dc165cbd373a65a4dcf22d50ae7f7\u003cbr /\u003e create mode 100644 file.txt\u003cbr /\u003e$ echo 'hello world!' \u0026gt;file.txt\u003cbr /\u003e$ git commit -a -m \u0026quot;add emphasis\u0026quot;\u003cbr /\u003eCreated commit c4d59f390b9cfd4318117afde11d601c1085f241\u003c/pre\u003e\n\n\u003cp\u003egit 响应 commit 时给出的 40 位 16 进制数是什么？\u003c/p\u003e\n\n\u003cp\u003e在教程的第一部分里我们就看到，commit 都有类似的 40 位 16 进制的名字。 git的版本历史中，每个对象都被使用这样一个字，它是对象内容的 SHA1 哈希结果；对于变更和其他各种东西来说，这样的名字保证了 git 永远不会把同样的东西保存两次 (因为同样的内容会产生同样的 SHA1 结果)，并且，一个 git 对象的内容的永远都不会改变 (因为内容改变了名字也就肯定会跟着变了)。\u003c/p\u003e\n\n\u003cp\u003e当然，如果你重复上面的例子的话，将会得到不一样的 SHA1 哈希结果，因为创建 commit 的时间和人都不一样。\u003c/p\u003e\n\n\u003cp\u003e我们可以用 cat-file 命令来向 git 查询这个对象。不要用上面那 40 位数字，应该用你自己的 commit 名字来做这个操作。事实上，你可以用开头几位数字，而不一定要敲全整个 40 位：\u003c/p\u003e\n\n\u003cpre\u003e$ git-cat-file -t 54196cc2\u003cbr /\u003ecommit\u003cbr /\u003e$ git-cat-file commit 54196cc2\u003cbr /\u003etree 92b8b694ffb1675e5975148e1121810081dbdffe\u003cbr /\u003eauthor J. Bruce Fields \u0026lt;bfields@puzzle.fieldses.org\u0026gt; 1143414668 -0500\u003cbr /\u003ecommitter J. Bruce Fields \u0026lt;bfields@puzzle.fieldses.org\u0026gt; 1143414668 -0500\u003cbr /\u003e\u003cbr /\u003einitial commit\u003c/pre\u003e\n\n\u003cp\u003e一个 tree 可以对应一个或多个 blob 对象，每个都对应于一个文件。此外，一个 tree 还可以对应于多个 tree 对象，从而可以创建一个目录树。可以通过 ls-tree 命令来查看树中的内容 (注意，一个足够长的 tree 名字的开始部分就足矣了)：\u003c/p\u003e\n\n\u003cpre\u003e$ git ls-tree 92b8b694\u003cbr /\u003e100644 blob 3b18e512dba79e4c8300dd08aeb37f8e728b8dad    file.txt\u003c/pre\u003e\n\n\u003cp\u003e这样，我们看到这个 tree 里面有一个文件。文件对应的 SHA1 哈希值是该文件内容的索引：\u003c/p\u003e\n\n\u003cpre\u003e$ git cat-file -t 3b18e512\u003cbr /\u003eblob\u003c/pre\u003e\n\n\u003cp\u003eblob 对应着文件数据，我们可以用 cat-file 来看其中的内容：\u003c/p\u003e\n\n\u003cpre\u003e$ git cat-file blob 3b18e512\u003cbr /\u003ehello world\u003c/pre\u003e\n\n\u003cp\u003e注意，这是那个老文件的内容；即 initial tree 这个 commit 对象里所对应的 tree 是当时记录下来的目录的状态。\u003c/p\u003e\n\n\u003cp\u003e所有的对象都在 git 目录之中，以其 SHA1 名称存放：\u003c/p\u003e\n\n\u003cpre\u003e$ find .git/objects/\u003cbr /\u003e.git/objects/\u003cbr /\u003e.git/objects/pack\u003cbr /\u003e.git/objects/info\u003cbr /\u003e.git/objects/3b\u003cbr /\u003e.git/objects/3b/18e512dba79e4c8300dd08aeb37f8e728b8dad\u003cbr /\u003e.git/objects/92\u003cbr /\u003e.git/objects/92/b8b694ffb1675e5975148e1121810081dbdffe\u003cbr /\u003e.git/objects/54\u003cbr /\u003e.git/objects/54/196cc2703dc165cbd373a65a4dcf22d50ae7f7\u003cbr /\u003e.git/objects/a0\u003cbr /\u003e.git/objects/a0/423896973644771497bdc03eb99d5281615b51\u003cbr /\u003e.git/objects/d0\u003cbr /\u003e.git/objects/d0/492b368b66bdabf2ac1fd8c92b39d3db916e59\u003cbr /\u003e.git/objects/c4\u003cbr /\u003e.git/objects/c4/d59f390b9cfd4318117afde11d601c1085f241\u003c/pre\u003e\n\n\u003cp\u003e并且，这些文件的内容只是压缩数据和用来标识它们的类型和长度的头部。可能的类型包括 blob, tree, commit 和 tag。\u003c/p\u003e\n\n\u003cp\u003e最容易被找到的 commit 是 HEAD commit，可以通过 .git/HEAD 找到：\u003c/p\u003e\n\n\u003cpre\u003e$ cat .git/HEAD\u003cbr /\u003eref: refs/heads/master\u003c/pre\u003e\n\n\u003cp\u003e可以看到，这个命令给出了我们的当前分支，并且给出了 .git 目录下的一个文件名，该文件中包含着指向对应的 commit 对象的 SHA1 名字，这样我们就可以通过 cat-file 命令来查看这个 commit：\u003c/p\u003e\n\n\u003cpre\u003e$ cat .git/refs/heads/master\u003cbr /\u003ec4d59f390b9cfd4318117afde11d601c1085f241\u003cbr /\u003e$ git cat-file -t c4d59f39\u003cbr /\u003ecommit\u003cbr /\u003e$ git cat-file commit c4d59f39\u003cbr /\u003etree d0492b368b66bdabf2ac1fd8c92b39d3db916e59\u003cbr /\u003eparent 54196cc2703dc165cbd373a65a4dcf22d50ae7f7\u003cbr /\u003eauthor J. Bruce Fields \u0026lt;bfields@puzzle.fieldses.org\u0026gt; 1143418702 -0500\u003cbr /\u003ecommitter J. Bruce Fields \u0026lt;bfields@puzzle.fieldses.org\u0026gt; 1143418702 -0500\u003cbr /\u003e\u003cbr /\u003eadd emphasis\u003c/pre\u003e\n\n\u003cp\u003e这里的 tree 对象对应着新的 tree 的状态：\u003c/p\u003e\n\n\u003cpre\u003e$ git ls-tree d0492b36\u003cbr /\u003e100644 blob a0423896973644771497bdc03eb99d5281615b51    file.txt\u003cbr /\u003e$ git cat-file blob a0423896\u003cbr /\u003ehello world!\u003c/pre\u003e\n\n\u003cp\u003e而 parent 对象对应着上一个 commit：\u003c/p\u003e\n\n\u003cpre\u003e$ git-cat-file commit 54196cc2\u003cbr /\u003etree 92b8b694ffb1675e5975148e1121810081dbdffe\u003cbr /\u003eauthor J. Bruce Fields \u0026lt;bfields@puzzle.fieldses.org\u0026gt; 1143414668 -0500\u003cbr /\u003ecommitter J. Bruce Fields \u0026lt;bfields@puzzle.fieldses.org\u0026gt; 1143414668 -0500\u003cbr /\u003e\u003cbr /\u003einitial commit\u003c/pre\u003e\n\n\u003cp\u003e这里，tree 对象就是我们开始时看过的那个，这个 commit 比较特殊，没有 parent。\u003c/p\u003e\n\n\u003cp\u003e大部分的 commit 都有且仅有一个 parent，不过一个 commit 有几个 parent 的情况也不少见。当一个 commit 表示一次合并的时候，parent 将指向被合并的各个分支的头部。\u003c/p\u003e\n\n\u003cp\u003e介绍了 blob, tree 和 commit，惟一还没有介绍的对象类型就是 tag 了，这个我们就不在这里介绍了，可以参考它的手册页 \u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/git-tag.html\"\u003egit-tag(1)\u003c/a\u003e\u003c/p\u003e\n\n\u003cp\u003e现在，我们总结一下 git 的版本历史中如何使用对象数据库：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003ecommit 对象会指向一个 tree 对象，即当时的目录树的镜像，还会指向 parent commit，以表征项目的版本历史。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003etree 对象代表一个目录的一个状态，将目录名与包含文件内容的 blob 对象和包含子目录信息的 tree 对象联系在一起。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003eblob 对象包含文件内容，没有其他结构。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e每个分支的头部的 commit 对象的引用位于 .git/ref/heads/ 目录。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e当前分支的名字存储在 .git/HEAD 文件之中。 \u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e顺便提一句，很多命令都用一个 tree 作为参数。不过上面已经看到，tree 可以有多种指代方式——tree 的 SHA1 名称、指向该 tree 的 commit 名称，当该 tree 恰好是某分支头部时，该分支的名称，等等——大部分这样的命令都接受这些名字作为参数。\u003c/p\u003e\n\n\u003cp\u003e在命令格式描述中，tree-ish 有时被用于表示这样的参数。\u003c/p\u003e\n\n\u003ch4\u003e索引文件\u003c/h4\u003e\n\n\u003cp\u003e上文中用于提交 commit 的主要方法是 \u0026quot;git commit -a\u0026quot;，这条命令将所有我们的工作拷贝中改动过的文件做成一个 commit。不过，如果我们只想提交部分文件怎么办？部分文件中的部分改动呢？\u003c/p\u003e\n\n\u003cp\u003e如果看看幕后 commit 是怎么产生的，那我们将可以得到生成 commit 的更灵活的方法。\u003c/p\u003e\n\n\u003cp\u003e继续我们的测试项目，现在再次修改 file.txt：\u003c/p\u003e\n\n\u003cpre\u003e$ echo \u0026quot;hello world, again\u0026quot; \u0026gt;\u0026gt;file.txt\u003c/pre\u003e\n\n\u003cp\u003e不过这次，我们不立刻 commit，让我们多做一个中间步骤，并查看 diff，看看都发生了什么：\u003c/p\u003e\n\n\u003cpre\u003e$ git diff\u003cbr /\u003e--- a/file.txt\u003cbr /\u003e+++ b/file.txt\u003cbr /\u003e@@ -1 +1,2 @@\u003cbr /\u003e hello world!\u003cbr /\u003e+hello world, again\u003cbr /\u003e$ git add file.txt\u003cbr /\u003e$ git diff\u003c/pre\u003e\n\n\u003cp\u003e最后一个 diff 是空的，不过还没有进行 commit 呢，head 还没有包含这行新的内容呢：\u003c/p\u003e\n\n\u003cpre\u003e$ git-diff HEAD\u003cbr /\u003ediff --git a/file.txt b/file.txt\u003cbr /\u003eindex a042389..513feba 100644\u003cbr /\u003e--- a/file.txt\u003cbr /\u003e+++ b/file.txt\u003cbr /\u003e@@ -1 +1,2 @@\u003cbr /\u003e hello world!\u003cbr /\u003e+hello world, again\u003c/pre\u003e\n\n\u003cp\u003e所以，git diff 实际是在和 head 之外的什么东西比较。实际上，这个被比较的东西是索引文件，它以二进制形式存储在 .git/index 之中，其内容可以用 ls-files 查看：\u003c/p\u003e\n\n\u003cpre\u003e$ git ls-files --stage\u003cbr /\u003e100644 513feba2e53ebbd2532419ded848ba19de88ba00 0       file.txt\u003cbr /\u003e$ git cat-file -t 513feba2\u003cbr /\u003eblob\u003cbr /\u003e$ git cat-file blob 513feba2\u003cbr /\u003ehello world!\u003cbr /\u003ehello world, again\u003c/pre\u003e\n\n\u003cp\u003e我们的 git add 的实际工作是存储一个新的 blob ，之后将其索引信息放到索引文件中。如果我们再次修改文件，将会在 git-diff 中看到这些变更：\u003c/p\u003e\n\n\u003cpre\u003e$ echo 'again?' \u0026gt;\u0026gt;file.txt\u003cbr /\u003e$ git diff\u003cbr /\u003eindex 513feba..ba3da7b 100644\u003cbr /\u003e--- a/file.txt\u003cbr /\u003e+++ b/file.txt\u003cbr /\u003e@@ -1,2 +1,3 @@\u003cbr /\u003e hello world!\u003cbr /\u003e hello world, again\u003cbr /\u003e+again?\u003c/pre\u003e\n\n\u003cp\u003e使用正确的参数，git diff 也可以显示出上次 commit 以来的变更或是索引和最后一次 commit 之间的变更：\u003c/p\u003e\n\n\u003cpre\u003e$ git diff HEAD\u003cbr /\u003ediff --git a/file.txt b/file.txt\u003cbr /\u003eindex a042389..ba3da7b 100644\u003cbr /\u003e--- a/file.txt\u003cbr /\u003e+++ b/file.txt\u003cbr /\u003e@@ -1 +1,3 @@\u003cbr /\u003e hello world!\u003cbr /\u003e+hello world, again\u003cbr /\u003e+again?\u003cbr /\u003e$ git diff --cached\u003cbr /\u003ediff --git a/file.txt b/file.txt\u003cbr /\u003eindex a042389..513feba 100644\u003cbr /\u003e--- a/file.txt\u003cbr /\u003e+++ b/file.txt\u003cbr /\u003e@@ -1 +1,2 @@\u003cbr /\u003e hello world!\u003cbr /\u003e+hello world, again\u003c/pre\u003e\n\n\u003cp\u003e我们随时都可以使用 (没有 -a 参数的) git commit 创建一个新的 commit，只提交包含在索引文件中的变更，而不包含工作拷贝中的其他变更：\u003c/p\u003e\n\n\u003cpre\u003e$ git commit -m \u0026quot;repeat\u0026quot;\u003cbr /\u003e$ git diff HEAD\u003cbr /\u003ediff --git a/file.txt b/file.txt\u003cbr /\u003eindex 513feba..ba3da7b 100644\u003cbr /\u003e--- a/file.txt\u003cbr /\u003e+++ b/file.txt\u003cbr /\u003e@@ -1,2 +1,3 @@\u003cbr /\u003e hello world!\u003cbr /\u003e hello world, again\u003cbr /\u003e+again?\u003c/pre\u003e\n\n\u003cp\u003e缺省地，git commit 使用索引文件创建 commit，而不是工作拷贝；-a 参数的提交是首先使用工作拷贝中的全部变更更新索引，然后提交 commit。\u003c/p\u003e\n\n\u003cp\u003e最后，有必要看看 git add 对索引文件的效果：\u003c/p\u003e\n\n\u003cpre\u003e$ echo \u0026quot;goodbye, world\u0026quot; \u0026gt;closing.txt\u003cbr /\u003e$ git add closing.txt\u003c/pre\u003e\n\n\u003cp\u003eThe effect of the \u0026quot;git add\u0026quot; was to add one entry to the index file:\u003c/p\u003e\n\n\u003cpre\u003e$ git ls-files --stage\u003cbr /\u003e100644 8b9743b20d4b15be3955fc8d5cd2b09cd2336138 0       closing.txt\u003cbr /\u003e100644 513feba2e53ebbd2532419ded848ba19de88ba00 0       file.txt\u003c/pre\u003e\n\n\u003cp\u003e并且，由于能够通过 cat-file 查看，新的一项指向了当前的文件内容：\u003c/p\u003e\n\n\u003cpre\u003e$ git cat-file blob 8b9743b2\u003cbr /\u003egoodbye, world\u003c/pre\u003e\n\n\u003cp\u003estatus 命令是一个很有用的快速查看状态的方法：\u003c/p\u003e\n\n\u003cpre\u003e$ git status\u003cbr /\u003e# On branch master\u003cbr /\u003e# Changes to be committed:\u003cbr /\u003e#   (use \u0026quot;git reset HEAD \u0026lt;file\u0026gt;...\u0026quot; to unstage)\u003cbr /\u003e#\u003cbr /\u003e#       new file: closing.txt\u003cbr /\u003e#\u003cbr /\u003e# Changed but not updated:\u003cbr /\u003e#   (use \u0026quot;git add \u0026lt;file\u0026gt;...\u0026quot; to update what will be committed)\u003cbr /\u003e#\u003cbr /\u003e#       modified: file.txt\u003cbr /\u003e#\u003c/pre\u003e\n\n\u003cp\u003e由于 closing.txt 已经被缓存在索引文件中了，所以被列为将要提交的改动。而 file.txt 已经改动了但没被包含在索引中，它被标记为改动了但没有更新的。这时使用 git commit 将创建一个 commit 来添加 closing.txt (使用它的新内容)，但不会修改 file.txt 。\u003c/p\u003e\n\n\u003cp\u003e此外，请记住 git diff 可以显示 file.txt 的变化，但不会显示 closing.txt 的变更，因为当前的 closing.txt 和索引文件中的是完全一致的。\u003c/p\u003e\n\n\u003cp\u003e除了作为新 commit 的中间环节，索引文件还在 check out 一个新分支的时候从对象数据库中取出，也用于合并操作时保存相关的分支。这里请参考相关手册页和\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/core-tutorial.html\"\u003e核心教程\u003c/a\u003e\u003c/p\u003e\n\n\u003ch4\u003e下面是？\u003c/h4\u003e\n\n\u003cp\u003e现在，你已经了解了阅读 git 所有手册页所需的全部知识；一个不错的起点是学习\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/everyday.html\"\u003e每日 git\u003c/a\u003e中的命令。不知道的名词应该可以从\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/glossary.html\"\u003e词汇表\u003c/a\u003e中找到.\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/user-manual.html\"\u003eGit 手册\u003c/a\u003e包含了 git 的更全面介绍。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/cvs-migration.html\"\u003eCVS 迁移\u003c/a\u003e 文档解释了如何将一个 CVS 仓库加入到 git 中，以及如何以 CVS 的方式使用 git。\u003c/p\u003e\n\n\u003cp\u003e对于一些有趣的 git 例子，可以看看\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/howto-index.html\"\u003eHOWTO\u003c/a\u003e。\u003c/p\u003e\n\n\u003cp\u003e对于开发者，\u003ca href=\"http://www.kernel.org/pub/software/scm/git/docs/core-tutorial.html\"\u003e核心教程\u003c/a\u003e 深度介绍了 git 的底层机制，比如，创建一个新的 commit。\u003c/p\u003e\n\n\u003cp\u003e原文最后更新时间: 20-May-2007 09:08:18 UTC\u003cbr /\u003e\n  \u003cbr /\u003e王旭 (gnawux\u0026lt;at\u0026gt;gmail.com) 2008年5月1日 翻译 \u003c/p\u003e\n","cover":"","link":"translation/2008/05/01/git简要教程：第二部分/index.html","preview":"","title":"GIT简要教程：第二部分"},{"content":"\n\u003cp\u003e呵呵，还没出版先说遗憾，我也是少有的一例了吧，刚刚又完成了一次修改，算是基本的最终版了，不过，是工作总有快乐有痛苦，是项目总有成就有遗憾，Unleashed是我的骄傲，是我的快乐，但也有一些遗憾。\u003c/p\u003e\n\n\u003col\u003e\n\n\u003cli\u003eSELinux，感兴趣了很久，不过没时间琢磨，自然也没有包含进来 \u003c/li\u003e\n\n\u003cli\u003e虚拟化技术，硬件条件不是很具备，而且也有些疲劳了，否则，再有两个星期，就能写出这么一章了 \u003c/li\u003e\n\n\u003cli\u003e可以从Windows启动的安装程序，太新了，刚刚才听说，来不及测试加入了 \u003c/li\u003e\n\n\u003cli\u003eXeTeX，真的很吸引人，但我的经验不够，也没有时间做这么复杂的工具链调整了\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003cp\u003e瑕不掩瑜，终于完成了这一版，可以休息一下了。等休息一阵，可以考虑更新内容，进行下一版了。还有很多内容都可以更丰富的。下一版还会不会出版，或是在网上完全公开，都还没有确定。\u003c/p\u003e\n","cover":"","link":"misc/2008/04/30/unleashed的遗憾/index.html","preview":"","title":"Unleashed的遗憾"},{"content":"\n\u003cp\u003e\u003cb\u003e原文链接：http://www.phoronix.com/scan.php?page=article\u0026amp;item=kernel_modesetting     \u003cbr /\u003e原文发表时间：2008年4月19日      \u003cbr /\u003e原作者：\u003c/b\u003e\u003cb\u003eMichael Larabel\u003c/b\u003e    \u003cbr /\u003e\u003cb\u003e翻译时间：2008年4月22日     \u003cbr /\u003e译者：王旭 gnawux(at)gmail.com      \u003cbr /\u003e\u003c/b\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ci\u003e译者按：2008年9月19日，证实了一下，由于 TTM 到 GEM 的变化，kernel modesetting 没有进入到 2.6.27 之中，并且，刚刚尝试了一下，发现这个还很不成熟，不知道什么时候才能真的实用起来，可能需要 X driver 和 kernel, drm 等同时步进到一个稳定状态才行，这样看来，可能要到明年了。\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003eX.Org 社区之中，不少新颖的技术都在萌芽之中——其中有Gallium3D （译注：新一代Linux 3D图形驱动框架）, TTM 显存管理器（译注：用于GPU的显存管理），MPX （允许 X 拥有多个鼠标指针和键盘焦点）。不过，这些特色之中那个已经向着列表顶端进发、并给最终用户带来可以看到的好处的正是基于内核的显示模式设置（mode- setting）。正如其名字所表述的，基于内核的模式设置将显卡的模式设置代码从用户控件的X服务器驱动挪到了Linux内核。这个话题对最终用户似乎没什么意义，不过，将模式设置代码移动到内核将展现一个更简洁更漂亮的启动过程，增强挂起和恢复的支持，并提供更可靠的虚拟终端切换（等等）。内核的模式设置还没有进入主线内核，它的API也还没有冻结，不过，下个月将要发布的 Fedora 9 就将成为首个带有这一支持的主流发布版。本文中，我们将近距离观察配合 Intel X.Org 驱动的内核的模式设置及其工作时的视频（译注：译文将略过视频，请见谅）。\u003c/p\u003e\n\n\u003cp\u003e\u003ca href=\"http://www.phoronix.com/scan.php?page=news_item\u0026amp;px=NjIzNw\"\u003eRadeon 驱动的移植工作\u003c/a\u003e 仍在进行中（驱动命名为 radeon_ms），不过 Fedora 9 将只包含带有这项支持的 Intel 开源 X.Org 驱动。内核的模式支持交互不是主线内核的内容，不过 Fedora 9 Intel 启动基于 intel-kernelmode 分支。intel-kernelmode 分支目前正在转向基于 intel-batchbuffer 分支。而 Intel-batchbuffer 也正是包含初始 \u003ca href=\"http://www.phoronix.com/scan.php?page=news_item\u0026amp;px=NjQxMQ\"\u003eDRI2\u003c/a\u003e 支持，TTM 现存管理，\u003ca href=\"http://www.phoronix.com/scan.php?page=news_item\u0026amp;px=NjM4OQ\"\u003eRender\u003c/a\u003e 改进，以及其他新鲜的改进的分支。在 Mesa/DRM 这边有一个 modesetting-101 分支。\u003c/p\u003e\n\n\u003cp\u003e因为内核不再依赖于外部资源来恢复显卡了，挂起和恢复的支持将有很大提高。因为这个过程如今在内核之中了，它能自动并且更快速恢复显示模式。类似地，虚拟终端的切换也因此被提高了。内核模式设置还将提升 debug 表现，这将可以消除所谓的“硬挂（hard hang）”，并将使显示图形化的错误信息成为可能（想象一下在 Linux 中来一个蓝屏死机）。有了这项技术，启动时只需要设置一次显示模式，而无需在开始启动过程的时候（对于Fedora来说，就是RH图形化启动）启动或关闭，然后再在X Server启动、显示GDM时再次初始化设备。基于内核的模式设置是 Intel 的 Keith Packard 列出的\u003ca href=\"http://www.phoronix.com/scan.php?page=news_item\u0026amp;px=NjM1Nw\"\u003e让人满意的 Linux 桌面的应有功能\u003c/a\u003e的项目列表之一。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg title=\"A Preview Of Kernel-Based Mode-Setting\" src=\"/assets/image.php?id=kernel_modesetting\u0026amp;image=intel_km_grub\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e基于内核的模式设置组间被缺省包含在 Fedora 9 之中了，但 Intel 的内核模式设置并不会缺省启动。要打开这个设置，需要在启动时在 grub 内参数列表里添上 i915.modeset=1，或是修改 /boot/grub/grub.conf （译注：对其他发布版可能应该是 menu.lst，另外，怀疑这个参数可以通过 modprobe.d 和 initramfs 设置，未经试验，纯属译者猜测）。除非有一天内核的显示模式设置被缺省使用了，这行命令才能省掉，否则总需要这条命令来让系统使用内核态模式设置而不是用户空间的 X 驱动。\u003c/p\u003e\n\n\u003cp\u003eFedora 9 是惟一的一个今年春天发布的带有内核态模式设置功能的发布版。2.6.26 内核的 merge window 马上就要打开了，不过大家的一致看法是这一功能恐怕无法在 2.6.26 进入主线内核。这样，它进入主线内核的时间表将是这个秋天的 2.6.27，不过这恐怕对 \u003ca href=\"http://www.phoronix.com/scan.php?page=news_item\u0026amp;px=NjM0Mg\"\u003eUbuntu 8.10 \u0026quot;Intrepid Ibex\u0026quot;\u003c/a\u003e 来说太迟了。Fedora 9 里面包含的只是个功能演示版。Red Hat 和 David Airlie 计划在 Fedora 10 中用内核态的模式设置来支持快速用户切换。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg title=\"A Preview Of Kernel-Based Mode-Setting\" src=\"/assets/image.php?id=kernel_modesetting\u0026amp;image=intel_km_sys\" /\u003e\u003c/p\u003e\n\n\u003cp\u003eIntel-kernelmode 驱动支持 Intel 915 IGP 及更新的 Intel 显示芯片。为了这篇文章，我们在华擎\u003ca href=\"http://www.phoronix.com/vr.php?view=10755\"\u003eConRoe1333-DVI/H\u003c/a\u003e 主板上测试了刚刚发布的 Fedora 9 预览版，板载 Intel 945G 整合显卡，带有 VGA 和 DVI 接口。当连接到数字显示器并打开内核态模式设置时，启动过程是白了。RH图形化启动程序无法正确初始化显卡，到了启动GDM的时候，屏幕将闪动数次，但无法成功启动。而使用模拟显示器的时候，i915.modeset=1 可以顺利启动。不过，支持仍然不很完美。当使用内核态的模式设置驱动的时候，drmWaitVBlank 和 IRQ 仍有问题。\u003c/p\u003e\n\n\u003cp\u003e\u003cimg title=\"A Preview Of Kernel-Based Mode-Setting\" src=\"/assets/image.php?id=kernel_modesetting\u0026amp;image=intel_km_glxinfo\" /\u003e\u003c/p\u003e\n\n\u003cp\u003e下面几页（译注：两页，四段 youtube 视频，略了）是内核态模式设置的工作视频。\u003c/p\u003e\n\n\u003cp\u003e基于内核的模式设置是 Linux 和 X.Org 将带给最终用户的显而易见的体验的巨大进步——干净而没有屏幕闪烁的启动过程、快速而稳定的虚拟终端切换、更好的挂起与恢复支持，而且很快将让“快速用户切换”更快。而这些仅仅是冰山一尖，更多的好处，比如图形化调试功能，也将会作为基于内核的显示模式设置功能的引入而显现出来。不过，现在还不是庆祝的时间。Redhat 和所有参与到为 Fedora 9 添加这一功能的出示支持的\u003ca href=\"http://www.phoronix.com/scan.php?page=article\u0026amp;item=kernel_modesetting\u0026amp;num=4#\"\u003e\u003cu\u003e开发者\u003c/u\u003e\u003c/a\u003e都应得到赞赏，但仍然需要一段时间才能让更多图形驱动转移到内核态模式设置和并让其他发布版也支持这个功能。将模式设置代码转移到内核中并不是一个快速而直接的过程，但到今年年底，有希望达到一个比较好的状态。Intel 向 X.Org 提交的内容让他们成为了这个恐怖功能的第一个可以工作的驱动。由于内核态模式设置终将被采用并进入主线内核，我们将继续向大家展现更多亮点。\u003c/p\u003e\n\n\u003cp\u003e如果你尝试了 Intel 内核态模式设置，别忘了来 \u003ca href=\"http://www.phoronix.com/forums/\"\u003ePhoronix 论坛\u003c/a\u003e 分享你的成果。\u003c/p\u003e\n","cover":"","link":"translation/2008/04/22/[译文]-技术预览：基于内核的显示模式设定/index.html","preview":"","title":"[译文] 技术预览：基于内核的显示模式设定"},{"content":"\n\u003cp\u003e正在修改我的unleashed，发现有些想法因为书的结构或书的定位，实在不方便放进去，于是就来这里聊聊。\u003c/p\u003e\n\n\u003cp\u003e当年，AST攻击Linux的论据之一就是Linux不是微内核，架构落后，而Linus反诘的言论很简单——Linux比Minix更高效。\u003c/p\u003e\n\n\u003cp\u003e不过从最近Linux内核的发展看，在有些方面倒确实是向着微内核的方向在演进了，这种不是非革命的方式的演化似乎确实在操作系统内核演进历史中比较少见。\u003c/p\u003e\n\n\u003cp\u003e微内核或说Linux发展的思路之一是——尽量减少内核功能，尽量让一些模块改在用户空间实现——越少的功能，越少的犯错，至少错误不在内核里就好解决得多嘛。很著名的在用户空间实现的原来属于或基本属于内核的功能包括：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eudev ——用户空间的即插即用——同一功能的内核产品devfs虽然进入内核很久，却始终未能达到设计目标，最终又被清除出内核。 \u003c/li\u003e\n\n\u003cli\u003efuse——用户空间文件系统——内核中的文件系统支持已经够多了，而今，用户空间文件系统又带来了ntfs-3g, sshfs以及很多加密文件系统的支持，可以想见，将来会有大量新的文件系统支持被放到fuse框架之下。 \u003c/li\u003e\n\n\u003cli\u003euswsusp——用户空间的挂起系统——内核中的挂起到硬盘和挂起到内存已经实现很久了，而功能更丰富的swsusp2始终也没能撬开kernel的大门，最终，uswsusp倒是要把前浪推到沙滩上了，uswsusp可以更灵活地结合挂起到内存和挂起到硬盘、采取各种压缩方式……很显然，已经超过了他的内核空间的前辈们了。 \u003c/li\u003e\n\n\u003cli\u003eusplash/splashy——用户空间的bootsplash——内核空间的bootsplash从来没有成功地进入过主线内核，虽然很多用户都希望拥有这个功能，现在，这个功能已经被在用户空间实现了。\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e随着Linux需要支持的硬件、协议、文件系统、算法等越来越多，越来越多的东西可能将在用户空间被实现，单从一个业余观察者的角度看，硬件驱动和网络协议都有可能被部份地转移到用户空间去实现，如果看一下 fuse 的话我们就会发现，放在用户空间不一定意味着低效，却意味着内核的质量风险更低，照着这个趋势发展下去，很难说Linux在几年之后会不会成为一个“准微内核”。\u003c/p\u003e\n\n\u003cp\u003e呵呵，我们等着这一天的到来吧。\u003c/p\u003e\n","cover":"","link":"works/2008/04/19/linux,-用户空间,-和微内核/index.html","preview":"","title":"Linux, 用户空间, 和微内核"},{"content":"\n\u003cp\u003eBy \u003ca href=\"http://www.sobell.com/\"\u003eMark Sobell\u003c/a\u003e on February 08, 2008 (9:00:00 AM)    \u003cbr /\u003e原文链接：http://www.linux.com/feature/125977    \u003cbr /\u003e翻译时间：2008年3月7日    \u003cbr /\u003e译者：王旭（gnawux at gmail.com）\u003c/p\u003e\n\n\u003cp\u003e\u003ci\u003e译注：尽管译者是一位铁杆的Debian粉丝，但也注意 upstart 很久了，就译者本人观点，upstart 应该说是 Ubuntu 所做的众多工作中最为杰出的一个，它将可以极大地加快 Linux 系统启动的过程。尽管它不是惟一的下一代 init 程序，但它已经作为 Ubuntu 的缺省 init 进程工作了相当长的时间，这点将极大有助于程序的成熟；而且，upstart 使用了基于事件的模型，而不是简单的将各个 daemon 并行化，这个架构上的突破也是具有革命性的，下面我们来看这篇文章吧。\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003e因为传统的System V 的 init daemon (Sysvinit)无法很好地处理现代硬件，如热插拔设备、USB硬盘或山村、网络文件系统等，Ubuntu 使用了\u003ca href=\"http://upstart.ubuntu.com/\"\u003eUpstart\u003c/a\u003e init daemon。\u003c/p\u003e\n\n\u003cp\u003e\u003ci\u003e本文抽取自最近出版的 \u003c/i\u003e\u003ca href=\"http://www.amazon.com/exec/obidos/asin/013236039X/vasoft-20\"\u003eA Practical Guide to Ubuntu Linux\u003c/a\u003e\u003ci\u003e.\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003e目前已经有多种 sysvinit 的替代产品了，这其中最为著名的一个就是 \u003ca href=\"http://www.initng.org/\"\u003einitng\u003c/a\u003e，它已经可以用于 Debian 了，并且在 Ubuntu 上也能工作。在同一位置上，Solaris 使用 SMF (Service Management Facility)，而 Mac OS 则使用 launchd。而 Ubuntu 则更倾向于集这些软件的优点于一身。\u003c/p\u003e\n\n\u003cp\u003eSysvinit daemon 是一个基于运行级别的初始化程序，它使用了运行级别（如单用户、多用户等）并通过从 /etc/rc?.d 目录到 /etc/init.d 目录的初始化脚本的链接来启动与终止系统服务。自从 Feisty 开始，Ubuntu 转向了 Upstart init daemon，并开始将Sysvinit 设置转换为 Upstart 的设置。本文探讨 Upstart 和残存的部分 Sysvinit 遗迹：/etc/rc?.d 和 /etc/init.d 目录以及运行级别的概念。\u003c/p\u003e\n\n\u003cp\u003eUpstart init daemon 是基于事件的，当系统中的什么情况发生变化时，它会运行某个特定的程序。这里被运行的程序多半是用来启动或终止服务的脚本。这个配置方式和systemv 在系统进入某个运行级别的时候运行init脚本的链接的概念实际上是非常类似的，只不过 upstart 更加灵活一些。Upstart 不仅能在运行级别改变的时候启动或终止服务，也能在接收到系统发生其他改变的信息的时候启动或终止服务。这些系统的改变被称为“事件”。例如，当 upstart 从 udev 接收到运行时文件系统加载、打印机安装或其他类似的设备添加或删除的信息，并采取相应的行动。Upstart 也可以在系统启动、关闭或某个任务状态改变的时候启动或关闭服务。\u003c/p\u003e\n\n\u003cp\u003eUpstart由五个包组成，（Ubuntu 中）它们都会被缺省安装：\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003cb\u003eupstart\u003c/b\u003e 提供Upstart init daemon 和 initctl 工具。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003cb\u003eupstart-logd\u003c/b\u003e 提供 logd daemon 和 logd 服务的工作定义文件。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003cb\u003eupstart-compat-sysv\u003c/b\u003e 提供了 rc 任务的工作定义文件，并提供了 reboot, runlevel, shutdown, telinit 等工具，以便与 sysvinit 相兼容。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003cb\u003estartup-tasks\u003c/b\u003e 提供了系统启动任务的工作定义文件。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e\u003cb\u003esystem-services\u003c/b\u003e 提供了 tty 服务的工作定义文件。\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003ch6\u003e定义\u003c/h6\u003e\n\n\u003cp\u003e有几个名词帮助我们理解 init 相关的东西。事件（event）是 init 可以得到的状态变更信息。几乎系统所有的内部或外部状态变更都可以触发一个事件。比如，引导程序会触发启动（startup）事件，系统进入运行级别2会触发运行级别2（runlevel 2）事件，而文件系统加载则会触发路径加载（path-mounted）事件，拔掉或安装一个热插拔或USB设备（如打印机）也会触发一个时间。用户还可以通过 initctl emit 命令来手动触发一个事件。\u003c/p\u003e\n\n\u003cp\u003e一个工作（job）是 init 可以理解的一系列指令。典型的指令包括一个程序（二进制文件或是脚本）和事件的名称。Upstart init daemon 会在事件触发的时候运行相应的程序。用户可以分别用 initctl start 和 stop 命令手动启动或终止一项工作。工作又可以分为任务和服务。\u003c/p\u003e\n\n\u003cp\u003e任务是运行、并在执行结束后返回到等待状态的工作。\u003c/p\u003e\n\n\u003cp\u003e服务是那些通常不会自己结束的工作。比如，logd daemon 和 gettys 就被实现为服务。init daemon 会监测每个服务的状态，如果服务出现问题会重启服务，在某些事件触发时或手工停止时会杀死服务。\u003c/p\u003e\n\n\u003cp\u003e/etc/event.d 目录下包含着一系列的工作定义文件（定义了 upstart init daemon 运行的工作的文件）。最初，这个目录由 Upstart 包来生成。在 Feisty 之后的 Ubuntu 中，被安装的服务会向这个目录中添加控制服务的文件，替代哪些安装到 /etc/rc?.d 和 /etc/init.d 目录的文件。\u003c/p\u003e\n\n\u003cp\u003eUpstart init daemon 的核心是一个状态机。它持续跟踪各个工作的状态，当有事件触发的时候，跟踪工作的状态改变。当 init 跟踪到一个工作的状态从一个转变到了另一个的时候，就可能会执行工作的命令或是终止工作。\u003c/p\u003e\n\n\u003cp\u003eSystem V 的 init daemon 通过改变运行级别来启动或停止服务。而使用 Upstart init daemon 的 Ubuntu 系统没有运行级别的概念。为了将基于运行级别的系统平滑移植到基于事件的系统，并为面向其他发布版的软件提供一定的兼容性，Ubuntu 使用 Upstart 模拟了运行级别。\u003c/p\u003e\n\n\u003cp\u003e在 /etc/event.d/rc? 文件中定义的 rc? 工作会运行 /etc/init.d/rc 脚本，这个脚本会运行链接到 /etc/rc?.d 目录中的 /etc/init.d 中的启动脚本，以模拟 SysVinit 的行为。当系统进入一个运行级别的时候，rc? 工作就会运行这些脚本。同时，Upstart 提供了 runlevel 和 telinit 工具以提供与 SysVinit 的兼容性。\u003c/p\u003e\n\n\u003cp\u003e使用 initctl (init control) 工具，具有 root 权限的管理员可以和 Upstart init daemon 通信。这个工具可以用来启动、停止或报告(report)一项工作。 比如，initctl list 命令会列出所有的工作和它们的状态：\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003esudo initctl list \u003c/b\u003e\u003cbr /\u003elogd (stop) waiting\u003cbr /\u003erc-default (stop) waiting\u003cbr /\u003erc0 (stop) waiting \u003cbr /\u003e...\u003cbr /\u003etty5 (start) running, process 4720 \u003cbr /\u003etty6 (start) running, process 4727\u003c/p\u003e\u003c/pre\u003e\n\n\u003cp\u003e要获得更详细的信息，可以参考 initctl 的 man page 或本节的例子。使用 initctl help 命令 （help 前没有横杠）可以列出 initctl 的命令列表。此外，也可以用 initctl list --help 来列出 list 命令的帮助信息，当然，将 list 换乘其它的 initctl 命令会得到该命令对应的信息。start, stop 和 status 工具是 initctl 的链接，会直接运行 initctl 的对应命令。\u003c/p\u003e\n\n\u003ch6\u003e工作（Job）\u003c/h6\u003e\n\n\u003cp\u003e/etc/event.d 目录下的每个文件都定义了一个工作，其中至少应该包含一个事件和一个命令。当事件被触发的时候，init 执行对应的命令。本节将介绍管理员自定义的工作和 Upstart 包中包含的工作。\u003c/p\u003e\n\n\u003cp\u003e下面的管理员自定义的工作使用 exec 关键字执行了一条 shell 命令。实际上，也可以用这个关键字执行一个 shell 脚本或一个二进制可执行文件。\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003ecat /etc/event.d/mudat \u003c/b\u003e\u003cbr /\u003estart on runlevel 2 \u003cbr /\u003eexec echo \u0026quot;Entering multiuser mode on \u0026quot; $(date) \u0026gt; /tmp/mudat.out\u003c/p\u003e\u003c/pre\u003e\n\n\u003cp\u003e这个文件定义了一个任务：当系统进入到多用户模式（运行级2）的时候执行 echo 命令。这个命令会向 /tmp/mudat.out 文件写出一条包含日期时间消息。shell 会运行 date 命令替换其中的内容。在任务结束后， mudat 任务会停止并进入等待状态。\u003c/p\u003e\n\n\u003cp\u003e在下一个的例子中，cat 命令展示了 /tmp/mudat.out 文件的内容和 initctl list 命令关于这个任务的输出（status 工具也可以得到同样的信息）:\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003ecat /tmp/mudat.out \u003c/b\u003e\u003cbr /\u003eEntering multiuser mode on Tue Jul 10 17:34:39 PDT 2007 \u003cbr /\u003e\u003cbr /\u003e$ \u003cb\u003esudo initctl list mudat\u003c/b\u003e\u003cbr /\u003emudat (stop) waiting\u003c/p\u003e\u003c/pre\u003e\n\n\u003cp\u003e如果 exec 命令行中包含 shell 的特殊字符， init 会运行 /bin/sh（dash 的符号链接）并把命令行交给它来处理。否则，exec 会直接运行命令行。如果要执行多个 shell 命令，可以把他们放到脚本文件中并运行脚本，或是使用 script....end script （下面会介绍）。\u003c/p\u003e\n\n\u003cp\u003eUpstart initdaemon\u0026#160; 只能监测哪些使用 exec 运行的工作（服务），无法监测使用 script...end script 运行的工作。换句话说，服务应该使用 exec 运行，而任务则可以使用任意的方法。\u003c/p\u003e\n\n\u003ch6\u003emyjob 示例\u003c/h6\u003e\n\n\u003cp\u003e用户也可以自己定义一个事件，并让一个工作被这个事件触发。如下的 myjob 工作定义文件定义了一个被 hithere 事件触发的工作：\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003ecat /etc/event.d/myjob \u003c/b\u003e\u003cbr /\u003estart on hithere \u003cbr /\u003escript \u003cbr /\u003e\techo \u0026quot;Hi there, here I am!\u0026quot; \u0026gt; /tmp/myjob.out\u003cbr /\u003e \tdate \u0026gt;\u0026gt; /tmp/myjob.out \u003cbr /\u003e\tend script\u003c/p\u003e\u003c/pre\u003e\n\n\u003cp\u003emyjob 文件提供了另一种运行命令的方法：在 script 和 end script 关键字之间包含了两行命令。这两个关键字常常导致 init 去运行 /bin/sh。例中的命令将一条消息和日期输出到了 /tmp/myjob.out 文件。现在可以使用 initctl emit 命令触发这个工作。如下，init 展示了 myjobs 在我们的触发下所经历的各个状态：\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003esudo initctl emit hithere\u003c/b\u003e\u003cbr /\u003ehithere \u003cbr /\u003emyjob (start) waiting \u003cbr /\u003emyjob (start) starting \u003cbr /\u003emyjob (start) pre-start \u003cbr /\u003emyjob (start) spawned, process 6064 \u003cbr /\u003emyjob (start) post-start, (main) process 6064 \u003cbr /\u003emyjob (start) running, process 6064 \u003cbr /\u003emyjob (stop) running \u003cbr /\u003emyjob (stop) stopping \u003cbr /\u003emyjob (stop) killed \u003cbr /\u003emyjob (stop) post-stop \u003cbr /\u003emyjob (stop) waiting \u003cbr /\u003e\u003cbr /\u003e$ \u003cb\u003ecat /tmp/myjob.out \u003c/b\u003e\u003cbr /\u003eHi there, here I am! \u003cbr /\u003eSat Jul 7 20:19:13 PDT 2007 \u003cbr /\u003e\u003cbr /\u003e$ \u003cb\u003esudo initctl list myjob \u003c/b\u003e\u003cbr /\u003emyjob (stop) waiting\u003c/p\u003e\u003c/pre\u003e\n\n\u003cp\u003e在上面的例子里，cat 展示了 myjob 产生的输出，initctl 展示了工作的状态。同样也可以用 initctl start myjob（或直接用 start myjob）来运行它。initctl start 十个非常有用的命令，这样你就可以在没有事件的情况下启动一个工作。比如，你可以用 initctl start mudat 来直接运行前面例子中的 mudat 工作而不会触发 runlevel 2 事件。\u003c/p\u003e\n\n\u003ch6\u003e指定带参数的事件\u003c/h6\u003e\n\n\u003cp\u003etelinit 和 shutdown 工具发送带有参数的 runlevel 事件。比如，shutdown 发送 runlevel 0，telinit 2 会发送 runlevel 2 事件。你可以在工作定义中用如下格式匹配这些事件：\u003c/p\u003e\n\n\u003cp\u003estart | stop on \u003ci\u003eevent\u003c/i\u003e [\u003ci\u003earg\u003c/i\u003e]\u003c/p\u003e\n\n\u003cp\u003e其中 event 是一个事件，而 arg 是一个可选参数。要在系统进入 runlevel 2 的时候停止一个工作，可以指定 stop on runlevle 2，也可以指定 runlevel [235] 来匹配运行级 2, 3 和 5，或用 runlevel [!2] 来匹配 2 之外的运行级。\u003c/p\u003e\n\n\u003cp\u003e尽管 Upstart 会忽略掉多余的事件参数，但工作定义文件中的事件名称里的参数必须在事件中存在。比如，没有参数的 runlevel 可以匹配所有的 runlevel 事件，不论是否有参数，但 runlevel S arg2 将不会匹配任何事件，因为 runlevel 事件只会带有一个参数。\u003c/p\u003e\n\n\u003ch6\u003e/etc/event.d 中的工作定义文件\u003c/h6\u003e\n\n\u003cp\u003e随着 Ubuntu 从 SysVinit 向 Upstart 的迁移，更多地工作会在 /etc/event.d 文件中定义。本节介绍一些 Upstart 包放在这个目录中的工作定义文件。\u003c/p\u003e\n\n\u003cp\u003e/etc/event.d/rc2 工作定义文件定义了 rc2 任务，这和其他的 rc? 任务没什么区别。rc2 任务在系统进入到多用户模式的时候会被触发（事件名称是 runlevel 2）；当系统进入到其它任意运行级的时候（runlevel [!2]）会结束。脚本的第一个部分调用 runlevel 工具，它会让系统显示自己在运行级2 （当然，实际上已经没有运行级这个玩意儿了）并给两个变量赋值。接下来的工作由 exec 命令完成，它会使用参数 2 运行 /etc/init.d/rc 脚本。这个脚本使用相应的参数调用 /etc/rc?.d 目录中的那些链接。这里 rc2 任务会运行 /etc/rc2.d 下的符号链接对应的 init 脚本。\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003ecat /etc/event.d/rc2 \u003c/b\u003e\u003cbr /\u003e# rc2 - runlevel 2 compatibility \u003cbr /\u003e# \u003cbr /\u003e# This task runs the old sysv-rc runlevel 2 (\u0026quot;multi-user\u0026quot;) scripts. It \u003cbr /\u003e# is usually started by the telinit compatibility wrapper.\u003cbr /\u003e\u003cbr /\u003estart on runlevel 2 \u003cbr /\u003e\u003cbr /\u003estop on runlevel [!2] \u003cbr /\u003e\u003cbr /\u003econsole output \u003cbr /\u003escript \u003cbr /\u003e\tset $(runlevel --set 2 || true) \u003cbr /\u003e\tif [ \u0026quot;$1\u0026quot; != \u0026quot;unknown\u0026quot; ]; then \u003cbr /\u003e\t\tPREVLEVEL=$1\u003cbr /\u003e \t\tRUNLEVEL=$2 \u003cbr /\u003e\t\texport PREVLEVEL RUNLEVEL \u003cbr /\u003e\tfi \u003cbr /\u003e\u003cbr /\u003e\texec /etc/init.d/rc 2 \u003cbr /\u003eend script\u003c/p\u003e\u003c/pre\u003e\n\n\u003ch6\u003etty 服务\u003c/h6\u003e\n\n\u003cp\u003e如下是一个在 tty1 上启动并监视 getty 进程的服务的工作定义文件：\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003ecat /etc/event.d/tty1 \u003c/b\u003e\u003cbr /\u003e# tty1 – getty\u003cbr /\u003e# \u003cbr /\u003e# This service maintains a getty on tty1 from the point when\u003cbr /\u003e# the system is started until it is shut down again. \u003cbr /\u003e\u003cbr /\u003estart on runlevel 2 \u003cbr /\u003estart on runlevel 3 \u003cbr /\u003estart on runlevel 4 \u003cbr /\u003estart on runlevel 5 \u003cbr /\u003e\u003cbr /\u003estop on runlevel 0 \u003cbr /\u003estop on runlevel 1 \u003cbr /\u003estop on runlevel 6 \u003cbr /\u003e\u003cbr /\u003erespawn \u003cbr /\u003eexec /sbin/getty 38400 tty1\u003c/p\u003e\u003c/pre\u003e\n\n\u003cp\u003e这个服务由 runlevel 2 到 5 （多用户模式）来触发，启动 getty 进程，并在系统关闭、重启或进入单用户模式，即运行级 0，1 和 6 时触发来关闭该服务。respawn关键字告诉 init 在服务终止后重启服务，而 exec 命令是让 getty 进程以 38400 波特率运行在 tty1。如下，initctl 工具显示该服务处于启动状态，进程ID 4747，ps 命令显示该服务的进程：\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003esudo initctl list tty1 \u003c/b\u003e\u003cbr /\u003etty1 (start) running, process 4747 \u003cbr /\u003e\u003cbr /\u003e\u003cp\u003e\u003cbr /\u003e\u003cbr /\u003e\u003c/p\u003e\u003cbr /\u003e$ \u003cb\u003eps -ef | grep 4747 \u003c/b\u003e\u003cbr /\u003eroot   4747   1 0 Jul02 tty1   00:00:00 /sbin/getty 38400 tty1\u003cp\u003e\u003c/p\u003e\u003c/p\u003e\u003c/pre\u003e\n\n\u003ch6\u003erc-default 任务和 inittab\u003c/h6\u003e\n\n\u003cp\u003e在 SysVinit 中，/etc/inittab 文件通过 initdefault 项告诉 init 在系统启动的时候进入哪个运行级，而 Ubuntu 没有 inittab 文件，缺省的，Upstart init daemon （使用 rc-default 任务）引导系统进入多用户模式（缺省运行级为2）。如果希望系统启动进入其他运行级别，那么就创建一个 inittab 文件。如下会让系统缺省进入单用户模式 （runlevel S）：\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e$ \u003cb\u003ecat /etc/inittab \u003c/b\u003e\u003cbr /\u003e:id:S:initdefault:\u003c/p\u003e\u003c/pre\u003e\n\n\u003cp\u003e当系统进入到单用户（修复）模式，如果系统的root帐号没有被锁定，init 会在显示 root 提示符之前要求输入 root 密码。否则，它会不要求输入密码而直接显示 root 提示符。\u003c/p\u003e\n\n\u003cp\u003e注意：不要将系统设置启动到运行级别 0 或 6，这样系统将永远无法正常启动。要直接进入多用户模式（运行级 2），如果有 inittab 删除这个文件，或者用上述的例子，将里面的 S 替换成 2.\u003c/p\u003e\n\n\u003cpre\u003e\u003cp\u003e\u003cb\u003eUpstart的未来\u003c/b\u003e\u003c/p\u003e\u003c/pre\u003e\n\n\u003cp\u003e从 SysVinit 到 Upstart 的迁移涉及到了 Linux 系统的很多部分。要让这个转换尽量平滑并且引入尽量少的问题，Upstart 团队决定通过多个 release 来完成这个迁移。\u003c/p\u003e\n\n\u003cp\u003eUbuntu 从 Feisty 开始使用 Upstart init daemon。在 Feisty 和 Gutsy+2 之间，Ubuntu 将完成 SysVinit 到更加干净、更加灵活的 Upstart 的迁移。随着越来越多的服务被放到 Upstart 的控制之下，/etc/event.d 目录下的内容将会替代 /etc/init.d 和 /etc/rc?.d 目录下的内容。运行级将不再作为 Ubuntu 正式支持的特征，虽然它们可能为了保持与第三方软件的兼容性而继续保留。最终 Upstart 将会替换掉 crond。\u003c/p\u003e\n","cover":"","link":"translation/2008/03/08/[译文]upstart:-ubuntu-的基于事件的启动进程/index.html","preview":"","title":"[译文]Upstart: Ubuntu 的基于事件的启动进程"},{"content":"\n\u003cp\u003e原文出处：http://linuxgazette.net/148/saha.html   \u003cbr /\u003e原文作者：\u003cb\u003e\u003ca href=\"http://linuxgazette.net/authors/saha.html\"\u003eAmit Kumar Saha\u003c/a\u003e and \u003ca href=\"http://linuxgazette.net/authors/ghosh1.html\"\u003eSayantini Ghosh\u003c/a\u003e\u003c/b\u003e    \u003cbr /\u003e翻译时间：2008年3月3日    \u003cbr /\u003e译者：王旭 \u0026lt;gnawux (at) gmail.com\u0026gt;\u003c/p\u003e\n\n\u003cp\u003e\u003ci\u003e 译者按：翻译篇文章换换心情，strace 是个有用的工具，LinuxGazette 是个不错的杂志，本文也希望你喜欢。\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003e了解一切是怎么运转的是件有趣的事情。所有的C程序员们都知道，在他们的C程序的“输入-处理-输出”周期中用到了很多\u003ca href=\"http://en.wikipedia.org/wiki/System_call\"\u003e系统调用 \u003c/a\u003e。 看看程序中到底哪些系统调用被用到了无疑是件很让人兴奋的事情。本文就是关于这个话题的，让我们开始吧。\u003c/p\u003e\n\n\u003ch5\u003e何为 ’strace’?\u003c/h5\u003e\n\n\u003cp\u003e\u003cb\u003e\u003ca href=\"http://sourceforge.net/projects/strace/\"\u003e’strace’\u003c/a\u003e\u003c/b\u003e 是一个用于在运行时跟踪进程调用的系统调用的工具。它同时报告进程收到的\u003ca href=\"http://www.cs.pitt.edu/%7Ealanjawi/cs449/code/shell/UnixSignals.htm\"\u003e信号\u003c/a\u003e（或软中断） 。\u003c/p\u003e\n\n\u003cp\u003e根据手册页，在最简单的情况下，“strace 运行指定的命令直到该命令执行完成。它截获并记录进程调用的系统调用和收到的信号。”\u003c/p\u003e\n\n\u003cp\u003e直接在终端中敲入”strace”命令就可以看到它的各个开关和选项：\u003c/p\u003e\n\n\u003cpre\u003e$ strace\u003cbr /\u003eusage: strace [-dffhiqrtttTvVxx] [-a column] [-e expr] ... [-o file]\u003cbr /\u003e              [-p pid] ... [-s strsize] [-u username] [-E var=val] ...\u003cbr /\u003e              [command [arg ...]]\u003cbr /\u003e   or: strace -c [-e expr] ... [-O overhead] [-S sortby] [-E var=val] ...\u003cbr /\u003e              [command [arg ...]]\u003cbr /\u003e-c -- count time, calls, and errors for each syscall and report summary\u003cbr /\u003e\u003cbr /\u003e[[[etc.]]]\u003c/pre\u003e\n\n\u003ch5\u003e跟踪系统调用\u003c/h5\u003e\n\n\u003cp\u003e先从一个简单的例子开始。考虑如下C代码（清单1）：\u003c/p\u003e\n\n\u003cpre\u003e/* Listing 1*/\u003cbr /\u003e\u003cbr /\u003e#include \u0026lt;stdio.h\u0026gt;\u003cbr /\u003e\u003cbr /\u003eint main()\u003cbr /\u003e{\u003cbr /\u003ereturn 0;\u003cbr /\u003e}\u003c/pre\u003e\n\n\u003cp\u003e假设编译好的目标文件名为’temp.o’。如下运行：\u003c/p\u003e\n\n\u003cpre\u003e$strace ./temp.o\u003c/pre\u003e\n\n\u003cp\u003e将会得到如下跟踪结果输出：\u003c/p\u003e\n\n\u003cpre\u003eexecve(\u0026quot;./temp.o\u0026quot;, [\u0026quot;./temp.o\u0026quot;], [/* 36 vars */]) = 0\u003cbr /\u003ebrk(0)                                  = 0x804a000\u003cbr /\u003eaccess(\u0026quot;/etc/ld.so.nohwcap\u0026quot;, F_OK)      = -1 ENOENT (No such file or directory)\u003cbr /\u003emmap2(NULL, 8192, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7fba000\u003cbr /\u003eaccess(\u0026quot;/etc/ld.so.preload\u0026quot;, R_OK)      = -1 ENOENT (No such file or directory)\u003cbr /\u003eopen(\u0026quot;/etc/ld.so.cache\u0026quot;, O_RDONLY)      = 3\u003cbr /\u003efstat64(3, {st_mode=S_IFREG|0644, st_size=68539, ...}) = 0\u003cbr /\u003emmap2(NULL, 68539, PROT_READ, MAP_PRIVATE, 3, 0) = 0xb7fa9000\u003cbr /\u003eclose(3)                                = 0\u003cbr /\u003eaccess(\u0026quot;/etc/ld.so.nohwcap\u0026quot;, F_OK)      = -1 ENOENT (No such file or directory)\u003cbr /\u003eopen(\u0026quot;/lib/tls/i686/cmov/libc.so.6\u0026quot;, O_RDONLY) = 3\u003cbr /\u003eread(3, \u0026quot;177ELF111331`100\u0026quot;..., 512) = 512\u003cbr /\u003efstat64(3, {st_mode=S_IFREG|0644, st_size=1307104, ...}) = 0\u003cbr /\u003emmap2(NULL, 1312164, PROT_READ|PROT_EXEC, MAP_PRIVATE|MAP_DENYWRITE, 3, 0) = 0xb7e68000\u003cbr /\u003emmap2(0xb7fa3000, 12288, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_DENYWRITE, 3, 0x13b) = 0xb7fa3000\u003cbr /\u003emmap2(0xb7fa6000, 9636, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_FIXED|MAP_ANONYMOUS, -1, 0) = 0xb7fa6000\u003cbr /\u003eclose(3)                                = 0\u003cbr /\u003emmap2(NULL, 4096, PROT_READ|PROT_WRITE, MAP_PRIVATE|MAP_ANONYMOUS, -1, 0) = 0xb7e67000\u003cbr /\u003eset_thread_area({entry_number:-1 -\u0026gt; 6, base_addr:0xb7e676c0, limit:1048575, seg_32bit:1, contents:0, read_exec_only:0, limit_in_pages:1, seg_not_present:0, useable:1}) = 0\u003cbr /\u003emprotect(0xb7fa3000, 4096, PROT_READ)   = 0\u003cbr /\u003emunmap(0xb7fa9000, 68539)               = 0\u003cbr /\u003eexit_group(0)                           = ?\u003cbr /\u003eProcess 8909 detached\u003c/pre\u003e\n\n\u003cp\u003e现在，我们来理论联系实际一下。\u003c/p\u003e\n\n\u003cp\u003e我们知道，当用户输入命令或可执行文件来运行的时候，系统会制造一个“子”Shell，并用这个子Shell来运行程序。这是通过系统调用”execve”来实现的。因此，跟踪结果是以如下内容开始的：\u003c/p\u003e\n\n\u003cpre\u003eexecve(\u0026quot;./temp.o\u0026quot;, [\u0026quot;./temp.o\u0026quot;], [/* 36 vars */]) = 0\u003c/pre\u003e\n\n\u003cp\u003e接下来，进程调用 ‘brk()’, ‘open’,'access’, ‘open’, ‘close’ 知道最终进程从 shell 中分离并使用”exit_group(0)”推出。\u003c/p\u003e\n\n\u003cp\u003e如上，跟踪过程显示了系统调用及其返回值。\u003c/p\u003e\n\n\u003ch4\u003estrace的信号报告功能\u003c/h4\u003e\n\n\u003cp\u003e下面来看一下”strace”的信号报告功能。考虑如下C代码（列表2）：\u003c/p\u003e\n\n\u003cpre\u003e/*Listing 2*/\u003cbr /\u003e\u003cbr /\u003e#include \u0026lt;stdio.h\u0026gt;\u003cbr /\u003e\u003cbr /\u003eint main()\u003cbr /\u003e{\u003cbr /\u003eint i;\u003cbr /\u003e\u003cbr /\u003efor(i=0;i\u0026gt;=0;i++)\u003cbr /\u003e        printf(\u0026quot;infinityn\u0026quot;);\u003cbr /\u003ereturn 0;\u003cbr /\u003e}\u003c/pre\u003e\n\n\u003cp\u003e假设编译输出的可执行文件为”temp-1.o”。如下运行：\u003c/p\u003e\n\n\u003cpre\u003e$ strace -o trace.txt ./temp-1.o\u003c/pre\u003e\n\n\u003cp\u003e这里，”-o”开关将把跟踪结果保存到”trace.txt”文件。\u003c/p\u003e\n\n\u003cp\u003e这里，你将会看到”write()”系统调用将不停地被调用，现在，用”ctrl-c”来结束这个进程\u003c/p\u003e\n\n\u003cpre\u003e[[[...]]]\u003cbr /\u003e\u003cbr /\u003ewrite(1, \u0026quot;tyninfinityninfinityninfinitynin\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;nityninfinityninfinityninfinityn\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;finityninfinityninfinityninfinit\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;infinityninfinityninfinityninfin\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;yninfinityninfinityninfinityninf\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;ityninfinityninfinityninfinityni\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;inityninfinityninfinityninfinity\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;nfinityninfinityninfinityninfini\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;ninfinityninfinityninfinityninfi\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;tyninfinityninfinityninfinitynin\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;nityninfinityninfinityninfinityn\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;finityninfinityninfinityninfinit\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;infinityninfinityninfinityninfin\u0026quot;..., 1024) = 1024\u003cbr /\u003ewrite(1, \u0026quot;yninfinityninfinityninfinityninf\u0026quot;..., 1024) = 1024\u003cbr /\u003e\u003cbr /\u003e[[[etc.]]]\u003c/pre\u003e\n\n\u003cp\u003e现在，查看”trace.txt”\u003c/p\u003e\n\n\u003cpre\u003e$cat trace.txt\u003c/pre\u003e\n\n\u003cp\u003e其中的最后几行应该是：\u003c/p\u003e\n\n\u003cpre\u003e--- SIGINT (Interrupt) @ 0 (0) ---\u003cbr /\u003e+++ killed by SIGINT +++\u003c/pre\u003e\n\n\u003cp\u003e因为我们使用”ctrl-c”结束了进程，于是信号 SIGINT 被发送给进程 ，正如”strace”所输出的一样。\u003c/p\u003e\n\n\u003ch5\u003e收集系统调用相关的统计信息\u003c/h5\u003e\n\n\u003cp\u003e使用”strace”，还可以对跟踪的系统调用进行一些简单的统计。这通过”-c”开关实现。例如：\u003c/p\u003e\n\n\u003cpre\u003e$ strace -o trace-1.txt -c ./temp-1.o # 运行上述可执行程序 'temp-1.o'\u003cbr /\u003e$ cat trace-1.txt \u003cbr /\u003e\u003cbr /\u003e% time     seconds  usecs/call     calls    errors syscall\u003cbr /\u003e------ ----------- ----------- --------- --------- ----------------\u003cbr /\u003e100.00    0.007518           0     46702           write\u003cbr /\u003e  0.00    0.000000           0         1           read\u003cbr /\u003e  0.00    0.000000           0         2           open\u003cbr /\u003e  0.00    0.000000           0         2           close\u003cbr /\u003e  0.00    0.000000           0         1           execve\u003cbr /\u003e  0.00    0.000000           0         3         3 access\u003cbr /\u003e  0.00    0.000000           0         1           brk\u003cbr /\u003e  0.00    0.000000           0         1           munmap\u003cbr /\u003e  0.00    0.000000           0         1           mprotect\u003cbr /\u003e  0.00    0.000000           0         7           mmap2\u003cbr /\u003e  0.00    0.000000           0         3           fstat64\u003cbr /\u003e  0.00    0.000000           0         1           set_thread_area\u003cbr /\u003e------ ----------- ----------- --------- --------- ----------------\u003cbr /\u003e100.00    0.007518                 46725         3 total\u003c/pre\u003e\n\n\u003cp\u003e如上，在其他输出信息之外，同时还输出了系统调用的统计信息，”write()”系统调用（一共运行了46702次），花去了进程的绝大部分时间（100%）。\u003c/p\u003e\n\n\u003ch5\u003e后记\u003c/h5\u003e\n\n\u003cp\u003e本文对”strace”的一些基本功能进行了简单的介绍。这个工具在进行可执行程序的bug寻找、寻找程序崩溃点的时候非常有用。使用 “strace”，可以极大地缩小问题可能发生的范围。\u003c/p\u003e\n\n\u003cp\u003e与 \u003ca href=\"http://sourceware.org/gdb/\"\u003e‘GNU Debugger’ (gdb)\u003c/a\u003e 和 \u003ca href=\"http://freshmeat.net/projects/ltrace/\"\u003e‘ltrace’\u003c/a\u003e一起，”strace” 为 Linux 程序员提供了强大的调试能力。\u003c/p\u003e\n\n\u003ch5\u003e有用链接:\u003c/h5\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\u003ca href=\"http://www.ibm.com/developerworks/aix/library/au-unix-strace.html\"\u003eFun with strace and the GDB Debugger\u003c/a\u003e\u003c/li\u003e\n\n\u003c/ul\u003e\n","cover":"","link":"translation/2008/03/04/[译文]strace:系统调用跟踪与信号报告工具/index.html","preview":"","title":"[译文]strace:系统调用跟踪与信号报告工具"},{"content":"\n\u003cp\u003e一行命令文件改名：\u003c/p\u003e\n\n\u003cpre\u003efor f in *.jpg;\ndo\n    mv $f \\\n    $(echo ${f%.jpg}| sed -e 's/\\([0-9]\\{2\\}\\)-\\([0-9]\\{2\\}\\)-\\([0-9]\\{2\\}\\)_\\([0-9]\\{4\\}\\)/20--_/').jpg;\ndone\u003c/pre\u003e\n\n\u003cp\u003e原来的文件是 日-月-年_时间.jpg，成批改成 年-月-日_时间.jpg\u003c/p\u003e\n\n\u003cp\u003e如15-02-08_2303.jpg 就会变成 2008-02-15_2303.jpg\u003c/p\u003e\n","cover":"","link":"scripts/2008/02/16/整理手机图片用的一个批量改名命令-bash-/index.html","preview":"","title":"整理手机图片用的一个批量改名命令(bash)"},{"content":"\n\u003cp\u003e译者按：CFS 是 2.6.24 内核的一个亮点，自从 2.6.23 内核中引入 CFS 以来，又将有一次功能和性能的全面提升，这里分享一篇组调度相关的文章。\u003c/p\u003e\n\n\u003cp\u003e原文链接: \u003ca href=\"http://lwn.net/Articles/240474/\"\u003ehttp://lwn.net/Articles/240474/\u003c/a\u003e    \u003cbr /\u003e[Posted July 2, 2007 by corbet]    \u003cbr /\u003e译者：王旭    \u003cbr /\u003e翻译时间：2008 年 1 月 28 日\u003c/p\u003e\n\n\u003cp\u003eIngo Molnar 的\u003ca href=\"http://lwn.net/Articles/230574/\"\u003e完全公平调度器\u003c/a\u003e (CFS) 补丁正在持续更新当中，本文写作时的版本是\u003ca href=\"http://lwn.net/Articles/239553/\"\u003ev18\u003c/a\u003e ，翻译的时候的版本已经是\u003ca href=\"http://people.redhat.com/mingo/cfs-scheduler/\"\u003ev24\u003c/a\u003e了。不过，很多人都认为 CFS 的行为有一个极大的不足：它只在个体进程之间实现公平。如果50个进程想要同时运行，CFS 将小心行事，保障每个进程获得 2% 的 CPU。但是，这可能存在一个极端情况：这50个进程里有1个是 Alice 的 X server，而其余49个则是内核 hacker Karl 远程登陆过来，希望利用空闲空余的 CPU 时间加快内核编译过程的进程。如果 Karl 在系统中被真的公平地对待的话，应该让他的49个编译进程作为一个组来和 Alice 的 X server 来分享 CPU。换句话说，X 应该获得 50% 的 CPU（如果它需要的话），而所有的 Karl 的进程应该分享另外 50% 的 CPU。\u003c/p\u003e\n\n\u003cp\u003e上面提到的这种调度方式就称为“组调度”，Linux 中的任何一种调度器都还不能真正支持组调度。如果 CFS 在将来能被加入到内核当中，并且具备实现“组调度”的潜力，那将是一件很理想的事情。感谢 Srivatsa Vaddagiri 等人的工作，事情正在向着这个方向发展。\u003c/p\u003e\n\n\u003cp\u003eSrivatsa 的工作的第一部分已经进入了 CFS 补丁的 v17 版本了。它引入了一个称为“调度实体”的概念用以指代被调度的对象，这个对象不一定是一个进程。Srivatsa 保存了每个进程的调度信息，并将它们打包在一个 \u003ctt\u003esched_entity\u003c/tt\u003e 结构之中。这实际是一个简化，它封装了相关信息（实际要做的信息），同时也没有改变CFS 调度器的工作方式。\u003c/p\u003e\n\n\u003cp\u003e组调度实现为\u003ca href=\"http://lwn.net/Articles/239619/\"\u003e一组独立的补丁\u003c/a\u003e，目前还不是CFS代码的一部分。这些补丁将调度实体转换为一个层次结构。现在，调度实体并不和进程直接关联，相反，他们代表一组进程。每个调度实体内部有一个自己的运行队列。所有调度实体还有一个 \u003ctt\u003eparent \u003c/tt\u003e指针和一个指向调度它们的运行队列。\u003c/p\u003e\n\n\u003cp\u003e缺省地，进程都在顶级层次结构中，被单独地调度。一旦一个进程被移动到了一个调度实体下面，它就会在顶层运行队列里被删除。当进程可以运行的时候，它就被放到它的父调度实体对应的运行队列之中。\u003c/p\u003e\n\n\u003cp\u003e当调度起选择下一个要运行的任务的时候，它首先检查所有顶极调度实体，取出最应该获得CPU的任务。如果这个实体不是一个进程（而是一个高层调度实体），那么调度器就会检查调度实体中的运行队列，并重复这一过程，直到到达层次结构的最底层、找到一个进程，并运行这个进程。在进程运行时，同样会收集一些运行时统计信息，但这些信息同时会向上层调度实体传播，从而在每一级别上都正确度量其CPU占用。\u003c/p\u003e\n\n\u003cp\u003e这样，系统管理员可以为 Alice 和 Karl 各建立一个调度实体 。所有 Alice 的进程被放在她的调度实体之中，同样，Karl 的内核编译进程也放在他的调度实体里。CFS 调度器将保证 Alice 和Karl 之间的公平性；一旦调度器决定了谁应该获得 CPU，它将进入到下一级队列中，公平调度其中的用户进程。\u003c/p\u003e\n\n\u003cp\u003e队列的层次不一定按照用户来建立；进程可以被依照任何管理员觉得合适的方式来分组。分组可以更加粗略；比如，一个大学的计算机上，所有学生会被放到一个组里，教职员工放在另一个组中。层次化也可以是依照进程类型的：可以为系统守护进程、交互工具以及那些狂吃CPU的程序等各建立一个组。这个补丁中并不包括任何限制进程被如何分组的内容。\u003c/p\u003e\n\n\u003cp\u003e一个遗留问题可能是：系统管理员究竟怎么进行这个分组？答案在于组调度补丁的第二个部分，通过一个\u003ca href=\"http://lwn.net/Articles/236038/\"\u003e进程容器\u003c/a\u003e算法将调度实体组织在一起。管理员可以使用 \u003ctt\u003ecpuctl\u003c/tt\u003e 参数来加载一个容器文件系统；调度组于是就可以在那个文件系统中以创建目录的方式被创建了。进程可以用容器界面来添加到（或移出）组。这样，任意特定的分组策略都可以利用一个简单的用户态守护程序来实现了，这个守护进程只要监视进程的创建事件，并将新建进程放到其应在的组里就可以了。\u003c/p\u003e\n\n\u003cp\u003e以目前的情况，容器代码只支持一层的组层次，而两级架构（如将用户分为管理员、故园和拜访者，然后对每个组里的用户们进行公平调度）还没有实现。这似乎是一个还没有被考虑到的限制，而不是一个代码中固有的问题。\u003c/p\u003e\n\n\u003cp\u003e有了组调度功能，CFS 将对相当一部分潜在用户更具吸引力。不过这些用户可能要等比较久了。2.6.23 的 merge window 很快就要开放了，不过那时这个补丁应该还没有完全准备好被加入到内核中去（译注：2.6.23 已经部分加入CFS了，不过更多的增强还是如作者所料在 2.6.24 中加入的）。可能 2.6.24 才会拥有那个值得期待的具有组调度功能的调度器。\u003c/p\u003e\n","cover":"","link":"translation/2008/01/28/[译文]-cfs-组调度/index.html","preview":"","title":"[译文] CFS 组调度"},{"content":"\n\u003cdiv\u003e\n\n\u003cp\u003e原文链接：\u003ca href=\"http://lwn.net/Articles/229984/\"\u003ehttp://lwn.net/Articles/229984/\u003c/a\u003e\u003cbr /\u003e\n原文作者：corbet\u003cbr /\u003e\n原文发表时间：April 11, 2007\u003cbr /\u003e\n译者：王旭\u003cbr /\u003e\n翻译时间：2008年1月14日\u003c/p\u003e\n\n\u003cp\u003e\u003cstrong\u003e译者按：\u003c/strong\u003e\u003cem\u003e不知道读者朋友们有没有误入过 /sys/slab 目录，进过这个吓人的目录之后，你可能就很想知道它到底是怎么回事，这和 slab 内存分配器有关，当然，更和 SLUB 内存分配器相关了，/sys/slab 和 slub 一同在 2.6.22 内核被引入，用于提升 cache 内存分配在多处理器系统中的效率。嗯，接下来还是看看这篇不是很久远的考古译文。\u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cem\u003e***\u003cbr /\u003e\n补充一下，目前SLUB也不是一帆风顺的，和 /sys/slab 有关的东东也有很多问题，http://lwn.net/Articles/263329/ 这篇文章和之后的评论指出了这些问题，让我们拭目以待吧，好了，现在可以继续看这篇考古译文了。\u003cbr /\u003e\n*** \u003c/em\u003e\u003c/p\u003e\n\n\u003cp\u003eslab内存分配器多年以来一直位于内核的内存管理部分的核心地带，它（在底层页分配器之上）管理着特定大小的对象的缓存，允许快速而且省空间的内存分配。内核黑客们一般不愿意去动slab的带脉，因为它实在是非常复杂，而且在大多数情况下，它的工作完成的相当不错。\u003c/p\u003e\n\n\u003cp\u003eChristoph Lameter就是那些感到 slab 工作的不是那么好的少数人之一。长时间以来，他提出了一个长长的关于 slab 的问题列表。slab 分配器维护了大量的对象队列，这些队列可以让内存分配更快，却也增加了复杂度。此外，这些存储开销会随着系统规模增大而增大：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e每个节点、每个CPU都有 slab 对象队列。alien cache 队列甚至有一个为每个节点的每个cpu都保存一个队列的队列数组。对于大规模的系统，队列数量和对象数量甚至会指数增长。在我们的有一千个节点/处理器的 系统中，大约有几G字节的内存被用于存放那些队列，这还不包括哪些在这些队列上的对象。恐怕有一天所有的内存会都消耗在这些队列上头。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e而且，每个 slab (一组一个或多个连续的用于分配对象的页面) 都要在起始处包含大量的元数据 ，这使得对象的对其进一步变得困难了。而用于在内存紧张的时候情理 cache 的代码又进一步增加了复杂度……\u003c/p\u003e\n\n\u003cp\u003eChristoph 对此的处理是提出了一个\u003ca href=\"http://lwn.net/Articles/229096/\"\u003eSLUB allocator\u003c/a\u003e，用于替代 slab 代码。通过取消了大量的队列和相关开销、简化 slab 的结构，SLUB 承诺提供更好的性能和更好的系统可伸缩性，并且可以同时保持现有的 slab 分配器接口。\u003c/p\u003e\n\n\u003cp\u003e在 SLUB 分配器中，一个 slab 就是一组一个或多个页面，封装了固定大小的 对象。slab 内部没有元数据，只是空闲对象组织在简单的链表之中。当有一个分配请求的时候，第一个空闲对象就此被定位、从列表中删除并返还给调用者。\u003c/p\u003e\n\n\u003cp\u003e在缺少每个slab的元数据的情况下，你可能会非常好奇第一个空闲的对象是如何被发现的。答案就在于 SLUB  分配器将这些信息存储在了系统内存映像之中 — 与这个 slab 所在的页面相关的页结构。让\u003ctt\u003e struct page\u003c/tt\u003e 变大同样是让人不能认同的，所以SLUB 分配器通过增加了另一个 union 来让这个复杂的结构更复杂了一些，从而解决了这个问题。最终结果是 \u003ctt\u003estruct page \u003c/tt\u003e增加了三个只在作为 slab 组成部分时才有效的字段：\u003c/p\u003e\n\n\u003cpre\u003e    void *freelist;\n    short unsigned int inuse;\n    short unsigned int offset;\u003c/pre\u003e\n\n\u003cp\u003e在用于 slab 时，freelist 指向 slab 中的第一个空闲对象，\u003ctt\u003einuse \u003c/tt\u003e是 slab 已经分配出去的对象数量，而通过 \u003ctt\u003eoffset \u003c/tt\u003e，分配器可以知道那里可以找到指向链表中下一个空闲对象的指针。SLUB 分配器可以使用 RCU 来释放对象，但是，如果想这么做，它必须能够将“下一个对象”的指针放在对象之外；\u003ctt\u003eoffset\u003c/tt\u003e 指针正是 SLUB 用来跟踪指针放置位置的手段。\u003c/p\u003e\n\n\u003cp\u003e当 slab 被分配器创建的时候，没有对象从中被分配过。一旦一个对象被分配了，它也就成为了一个存储在\u003ctt\u003e kmem_cache\u003c/tt\u003e 结构中的一个链表中的“部分的” slab。作为一个以可伸缩性为目标的补丁，系统中的每个 NUMA 节点会有一个“部分的”链表。分配器尽力保证分配节点本地的内存，但是会在部分 slab 填满系统之前到达其他节点的。\u003c/p\u003e\n\n\u003cp\u003e另外，还有一个每CPU的激活 slab 的数组，用于防止包括 NUMA 节点内部的各种 cache line bouncing。 同时还有一个特别的线程（通过一个工作队列）运行，监视每 CPU  slab 的使用情况，如果一个CPU的 slab 没有被用上，它还会被放回到部分列表中，以便被其他进程使用。\u003c/p\u003e\n\n\u003cp\u003e如果一个 slab 中的所有对象都被分配出去了，分配器就可以完全不用考虑这个 slab 了。一旦一个满 slab 中的一个对象被释放了，分配器就可以可以通过系统内存映像来重定位这个 slab，并将它放回到相应的部分链表之中去。如果一个给定的 slab 中的所有对象（通过 \u003ctt\u003einuse \u003c/tt\u003e计数器标记）都被释放了，那么整个 slab 都将被放回到页分配器中，以便重用。\u003c/p\u003e\n\n\u003cp\u003eSLUB 内存分配器的一个有趣的特性是它可以合并多个有相似对象尺寸和参数的 slab。其结果是系统中可以有更少的 slab 缓存（据说可以减少 50%），更好的本地化 slab 分配和更少的 slab 内存碎片。该补丁声明：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e这个合并可以暴露出内核中迄今为止尚不为人所知的 bug，因为坏掉的对象现在可能难于放置，并会影响到临近的对象。请打开 sanity check 来发现这些问题。\u003c/p\u003e\u003c/blockquote\u003e\n\n\u003cp\u003e让 bug 暴露出来总的来说是件好事，不过，过多使用 SLUB 分配器在那些新的 bug 没有被找出来之前会引起一些奇异行为。\u003c/p\u003e\n\n\u003cp\u003e过于广泛的使用是完全可能的：SLUB 分配器现在已经在 -mm 树之中了，并且可能会被加入到 2.6.22 主线内核当中。简化的代码非常诱人，据说有 5-10% 的性能提升。如果被加入到主线内核当中，SLUB 可以和当前的 slab 分配器 （以及面向小系统的 SLOB）共存相当常一段时间。从长远来看，当前的 slab 代码可能就要到了生命的终点了。\u003c/p\u003e\u003c/div\u003e\n","cover":"","link":"translation/2008/01/14/[译文]slub-内存分配器/index.html","preview":"","title":"[译文]SLUB 内存分配器"},{"content":"\n\u003cp\u003e原文：http://lwn.net/Articles/244829/   \u003cbr /\u003e原作者：\u003cstrong\u003eJonathan Corbet\u003c/strong\u003e    \u003cbr /\u003e原作时间：August 8, 2007    \u003cbr /\u003e译者：王旭 | gnawux(at)gmail.com |    \u003cbr /\u003e翻译时间：2007年12月8日\u003c/p\u003e\n\n\u003cp\u003e译注：译者当然知道 once upon atime 和 once upon a time 是不一样的，不过，原作者这么写不就是让我们像 once upon a time 这么念 once upon atime 么，所以，题目就是这样了，本文是译者琢磨怎么节约点能源的时候考古出来的，下面是译文。\u003c/p\u003e\n\n\u003cp\u003e大多数文件系统都维护着一个元数据，用于记录文件的最新访问时间，即“atime” 。这个时间可以说是非常有用的，管理员或管理程序根据这个时间就可以判断一个文件最近一次被使用是什么时候的事情了。不过，这个功能有个很严重的问题：每次文件被访问的时候，它都需要写一次硬盘。即使是那些已经被读入缓存的，可以被方便读取的文件的只读操作也需要写一次硬盘，来维护atime值。\u003c/p\u003e\n\n\u003cp\u003e最近，一个关于磁盘写操作节流（译注：或称为占空比调制，类似于CPU在一定时间的时候关闭时钟来降低功耗的机制）的讨论在 Ingo Molnar 指出 atime 可能 是比其它人何事情都严重的一个性能障碍之后转而开始讨论 atime 了。Ingo \u003ca href=\"http://lwn.net/Articles/244830/\"\u003e提到\u003c/a\u003e:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eAtime的更新是目前影响Linux IO性能的最为严重的因素。如果能不进行 atime 更新将会显著提高 Linux 性能，这个提高会比过去10年里所有的的关于 pagecache 加速机制加起来都会多。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e他还认为 atime “可能是 Unix 的各种时间值设计中最愚蠢的一个”。\u003c/p\u003e\n\n\u003cp\u003e这个讨论很快就转换成了另一个问题：关于这种情况，我们应该怎么作呢？一个差不多所有Linux都能采用的方法就是在加载文件系统的时候使用 noatime 开关，这样就彻底地关掉了访问时间的记录。对于文件系统敏感的人物，这个改变的性能提高是立竿见影的。世事无完美，关掉 atime 在某些情况下可能会让那些依赖这个东东的程序没法正常工作。传统上说，一写邮件工具会比较访问时间和修改时间来判断邮件是否未读。tmpwatch工具和一写备份工具也使用 atime，如果这个时间不正确的话，它们可能会有异常行为。正是基于这个原因，各个发布版都不太敢于将 noatime 作为缺省开关。\u003c/p\u003e\n\n\u003cp\u003e2.6.20 内核引入了一个新的方法：relatime 开关。如果在挂载文件系统的时候使用这个开关，访问时间只有在它们比变更时间更旧的时候才会更新。这个变化允许工具们看当前文件似乎否被读过了，同时很大程度上减少了 atime 的更新次数。这个开关还很少有人使用，可能是因为很少有人听说过它或是发布版们的mount版本还没有更新，还不支持relatime。不过，如果有程序想知道某个文件是否在过去的一段特定长时间（比如一个星期）里被访问过，那它还是可能会被relatime欺骗。\u003c/p\u003e\n\n\u003cp\u003e为了解决这个问题，Linus \u003ca href=\"http://lwn.net/Articles/244831/\"\u003e建议\u003c/a\u003e调整一下 relatime的工作方式：如果在一段时间里更新过文件，比如一天，那就更新它。Ingo 很快就写了\u003ca href=\"http://lwn.net/Articles/244384/\"\u003e一个补丁\u003c/a\u003e来实现这个特性，还增加了两个新的启动参数：指定缺省更新秒数的 relatime_interval 和在所有文件系统中缺省使用 relatime 的开关 default_relatime。\u003c/p\u003e\n\n\u003cp\u003e这个补丁的类似补产品可能会进入 2.6.24。这个补丁建议当一个inode将要被写入到硬盘的时候，kernel可以同时更新 atime。不过Alan Cox反对这个改变，因为这个改动可能会让整个行为变得不可预测。这个补丁到目前位置还没有更新版本，将来如果这个补丁能进入内核当中的话，也肯定不是当前这个版本。\u003c/p\u003e\n","cover":"","link":"translation/2007/12/08/[译文]-从前……/index.html","preview":"","title":"[译文] 从前……"},{"content":"\n\u003cp\u003e原文：\u003ca href=\"http://lwn.net/Articles/243704/\"\u003ehttp://lwn.net/Articles/243704/\u003c/a\u003e    \u003cbr /\u003e原作者：\u003cstrong\u003eJonathan Corbet\u003c/strong\u003e    \u003cbr /\u003e原作时间：July 31, 2007    \u003cbr /\u003e译者：王旭 | gnawux(at)gmail.com |    \u003cbr /\u003e翻译时间：2007年12月6日\u003c/p\u003e\n\n\u003cp\u003e译者注：题目叫破镜重圆当然不好了，有点辞不达意，不过，为了吸引眼球，损点人品也就认了。\u003c/p\u003e\n\n\u003cp\u003e译者又注：这次是正经话了，这两个架构即将在2.6.24中合并，于是译者才考古出来翻译的。好了，后面是译文了，译者不注了。\u003c/p\u003e\n\n\u003cp\u003ekernel 源码目录中的 arch 目录存放着所有架构相关的代码。尽管开发社区在过去多年以来都在致力于让代码尽可能地通用化，这个目录依然十分庞大。Linux目前支持26个不同架构，其中很多又有一些子架构。这26个架构中有两个分别是 i386 (Linux 最初支持的架构) 和 x86_64 —— i386 的大哥。这两种架构之间有太多共性了，而也确实已经有一些工作正致力于在这两个架构间尽量地共享代码。尽管如此，这两种架构的源码树仍然是彼此天各一方的。\u003c/p\u003e\n\n\u003cp\u003e至少在一些开发者眼里，这两个架构的彼此孤立是个问题。对于一个架构的 bug fix 常常对另一个也是可用的，但是不是都应该施加于两个地方就不清楚了。对于新功能也需要加两次。在这些情况下，一个架构的代码更改，常常破坏另一个架构。这样，负责架构相关项目的开发者们——譬如常常提到的虚拟化团队——不得不疲于同步两个强烈相关的源码树。与之相对应，32位和64位的 PowerPC 架构已经在 2.6.15 的内核中合并为了一个架构源码树，并且大家一致认为这十个成功的合并。不过，类似的合并还没有发生在 x86 的变种们之上。\u003c/p\u003e\n\n\u003cp\u003e这种情况可能很快得到改变：Thomas Gleixner 和 Ingo Molnar 最近发起了一个关于\u003ca href=\"http://lwn.net/Articles/242439/\"\u003e合并两个架构的补丁\u003c/a\u003e的动议来征求广大开发者的意见。这个补丁将十分巨大，超过9MB 涉及 1764 个文件。它非常依赖于内核源码树的当前状态，因为它只能施加于源码 git 仓库的某一特定时刻 (commit point)。这还不是将要被采纳的补丁，它的目的在于演示打过补丁之后源码树将是什么样子。如果真的到了合并这个补丁的时候，将会是另一番情景：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我们的下一步计划是生成一个细粒度、可拆分的，完全可用的替换，以将当前代码更新到新的 x86 源码树。它将呈现为 1000-2000个 commit (译注：git的版本控制单位，大致相当于分成1000-2000个补丁，打在源码包上。)\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这也的确有一些危险。正是了解这些危险，补丁的开发者们努力地让这些补丁的过程更加可靠。这次合并将不会带来任何二进制代码变化：源码树在变更前后将可以生成完全相同的内核映像。\u003c/p\u003e\n\n\u003cp\u003e这个补丁创建了一个新的称为 x86 的架构，并将两个已有架构的所有内容移动到其中。有些地方每个架构都有相同文件的完全一样的靠北，只要在新架构源码树中保留一份即可。而更多的情况下，两个架构在同样的位置有内容不同的同名文件，在此情况下，两个文件将被移动到新的源码树中，并相应给与 _32 或 _64 的后缀。这样，比如两个架构都包含 kernel/ioport.c，那么在新的 x86 架构中就同时拥有 ioport_32.c 和 ioport_64.c 了。补丁中还用了一些简单的手法，以保证为目标架构编译代码会生使用确的文件。\u003c/p\u003e\n\n\u003cp\u003e在很多情况下（如果不是大部分情况的话），两个文件都有大量的公共代码，兵器，公共代码就留在那了。这个补丁的出发点是：目前的阶段的任务是让两个架构的源码树合并而不影响生成内核映像，这恐怕是这么一个大改动能够被进一步推进的唯一途径。一旦这些内容被合并了，在个体文件中排除重复代码的机会也就出现了——需要被处理的文件通常紧挨着。可以想象一个代码清理大军就将扑向这个工作，各自为战地解决这些问题了。当这些问题也被解决了的时候，我们就有了一个漂亮的、挤出所有重复代码的 x86 架构了，大家就都会高兴了。\u003c/p\u003e\n\n\u003cp\u003e不过也未必， Andi Kleen表达了他对于这个改动的\u003ca href=\"http://lwn.net/Articles/243714/\"\u003e反对意见\u003c/a\u003e：\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003e我觉得这不是个好主意，因为这意味着我们将永远不会丢掉那些老垃圾。IMNSHO (译注：in my not so humble opinion, 源于 IMHO——in my humble opinion，以我愚见，这里表示发文者还是很自信的)，arch/x86_64比 arch/i386 在很多方面简洁多了，我更倾向于保存 x86_64 。同样，总的说 arch/x86_64也比 arch/i386 更容易hack，因为它更容易回退测试并且在测试时需要考虑较少的无用数据。我觉得完全去掉老旧的东西之外，没有办法在i386中解决这些问题。\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003eAndi 作为 i386 和 x86_64 架构的维护者在这个讨论中非常强势。他的核心论点是——分成两个架构可以将很多老旧的问题封闭在 i386 源码树中，这是内核代码管理的一个基本思路。只支持较新硬件的代码往往比同时也处理老旧硬件的代码要干净很多，不过，去掉仍在使用中的硬件的支持是很难被接受的。所以，新的子系统被作为新的代码部分增加进来，而老的代码可以被分离出来用于支持老硬件直到它们随风而逝。这方面一个经典的例子是SATA的支持是通过一个新的子系统而不是IDE的扩展来实现的。Andi 和其他一些开发者认为 x86系列处理器也应该这样处理。\u003c/p\u003e\n\n\u003cp\u003e不过大多数 讨论的参与者都不同意Andi的意见。和老IDE设备不同，32位架构短时间内不会消失。而i386的变种数量也非常至少。Linus \u003ca href=\"http://lwn.net/Articles/243718/\"\u003e表示\u003c/a\u003e，带着老代码继续前进的时候，把它作为一个共享代码树的一部分比扔进一个角落里要好。最终，争论的结果就是依照最初的提议，基本上公认一个统一的源码树是正确的解决方案。\u003c/p\u003e\n\n\u003cp\u003e有一些建议认为这些补丁应该直接进入 2.6.23 内核，不过有可能不这么干。2.6.23 已经有很多新东西了，并且这个补丁也太新了。同时，我们还没有将这个补丁拆成上千个 commit 呢。\u003c/p\u003e\n\n\u003cp\u003e更多个关于这个问题：关于合并的讨论还没有完成。在维护者不同意的情况下将两个架构重写为一个是种非常特别的敌意的接管行为。维护者对补丁没有绝对的否决权，但是在一个这么大的补丁的问题上否决维护者的一员不是一件小事。所以，统一 x86 架构的开发者们仍然面临着一个巨大的挑战：他们必须在漂亮地解决技术问题的同时说服大部分的开发者，使他们认为这个改动是必要的。所有牵扯进来的人都非常关心是否可以找到一个方法来说服与他们相关代码的维护者。\u003c/p\u003e\n","cover":"","link":"translation/2007/12/06/[译文]-i386和x86_64:-破镜重圆？/index.html","preview":"","title":"[译文] i386和x86_64: 破镜重圆？"},{"content":"\n\u003cp\u003e作者: \u003ca href=\"http://www.dissociatedpress.net/\"\u003e\u003cb\u003eJoe 'Zonker' Brockmeier\u003c/b\u003e\u003c/a\u003e (2007年7月17日)\u003c/p\u003e\n\n\u003cp\u003e译者：王旭 (2007年7月19日)\u003c/p\u003e\n\n\u003cp\u003e过去的两个月中，我疲于奔命。就在这两个月中，我的计算机也崩溃了。要是没有 rsync 的话，我的麻烦就大了，不过，幸好我经常使用这个工具，我的数据 (实际上是大部分数据) 已经被拷贝到其他地方随时可用了。要熟悉 rsync 需要花费一段时间，不过一旦熟悉了 rsync，你就可以使用一个很短的脚本来掌控大部分地备份工作了。\u003c/p\u003e\n\n\u003cp\u003ersync 有什么突出优点呢？首先，它被设计成只传送文件的不同部分，而非传送整个文件，以加速文件传输。比如，我正在写作本文，那我就可以现在使用 rsync 复制一次，而之后再进行一次传输。第二次（第三次、第四次……）父子文件的时候，rsync 只传送文件的不同部分。这将极大地节省时间，特别是在日常备份的过程中复制整个目录的时候。第一次复制会消耗较长时间，而下一次的传输就少多了（如果你每天都不大幅修改目录的内容的话）。 \u003c/p\u003e\n\n\u003cp\u003ersync的另一个好处是它可以保留文件地所有权和访问权限信息以及复制符号链接，简而言之，它被设计成灵巧地掌控你的文件。\u003c/p\u003e\n\n\u003cp\u003e要安装 rsync，你应该不需要做什么 --- 一般的 Linux distro 都应该缺省安装它了。如果没有的话，你应该能在你的 distro 地软件包仓库里找到并安装它。如果你要把数据复制到远程系统上的话，两台机器都需要 rsync。 \u003c/p\u003e\n\n\u003cp\u003e当你使用 rsync 把文件复制到另一台主机地时候，rsync 通常使用一个远程 shell，如 ssh 或 rsh 来工作。在下面的例子中，出于安全性的考虑，我们将只使用 ssh。当然，我们也可以访问使用 rsync daemon 的远程主机，不过，既然现在 ssh 几乎是无处不在的了，我们也没有必要费力气使用一个 daemon 了。\u003c/p\u003e\n\n\u003ch6\u003e了解 rsync\u003c/h6\u003e\n\n\u003cp\u003ersync 的基本语法非常简单 --- 只要运行 rsync [options] \u003ci\u003esource\u003c/i\u003e \u003ci\u003edestination\u003c/i\u003e\u0026#160; 就可以把文件从 \u003ci\u003esource \u003c/i\u003e复制到 \u003ci\u003edestination\u003c/i\u003e。\u003c/p\u003e\n\n\u003cp\u003e所以，举个例子，如果你要把你归属目录里的文件复制到USB硬盘上去，你可以这么做：rsync -a /home/user/dir/ /media/disk/dir/ 。这里需要强调一下，对于 rsync 来说 \u0026quot;/home/user/dir/\u0026quot; 和 \u0026quot;/home/usr/dir\u0026quot; 是截然不同地。如果没有最后的斜线，rsync 会整个地复制目录；而有了最后的斜线，rsync 将只复制目录中的内容，而不创建目录本身。如果你想复制一个目录结构，那你就应该去掉结尾的斜线，比如在镜像 /var/www 到其他机器的时候或类似的情况。 \u003c/p\u003e\n\n\u003cp\u003e在这个例子中，我加入了归档开关 (-a)，这实际相当于同时使用几个 rsync 开关。它包括递归与复制符号链接开关、保留组与属主属性开关，总之就是让 rsync 适用于进行归档拷贝。注意，-a 不保留硬链接；如果你需要的话，还应该加上硬链接开关 (-H)。\u003c/p\u003e\n\n\u003cp\u003e另一个常用开关是 verbose (-v)，这将让 rsync 报告更多信息。你还可以使用两个或三个 -v 开关 --- -v 将给出一些信息，-vv 会给出更多信息，而 -vvv 会把所有信息都给出来。\u003c/p\u003e\n\n\u003cp\u003e如果没有特别的选项，rsync 会连隐藏文件 (以 . 开头的文件) 一起复制的。如果你希望不复制隐藏文件，你应该加入开关 --exclude=\u0026quot;.*/\u0026quot; 。你还可以使用\u0026#160; --exclude 来防止复制 vim 交换文件 (.swp)\u0026#160; 或其他一些程序的自动备份文件 (.bak) 。\u003c/p\u003e\n\n\u003ch6\u003e进行本地拷贝\u003c/h6\u003e\n\n\u003cp\u003e假设你有一个外接 USB 或 1394 硬盘，你希望把 home 目录复制到外接驱动器上。一个不错的方法是把重要数据保存在一个顶级目录中，之后复制到外接硬盘地备份目录之中，命令如下:\u003c/p\u003e\n\n\u003cp\u003ersync -avh /home/usr/dir/ /media/disk/backup/\u003c/p\u003e\n\n\u003cp\u003e如果你想保证本地删除的文件也在外接硬盘上被删除，你需要使用 --deleted 开关，如下:\u003c/p\u003e\n\n\u003cp\u003ersync -avh --delete \u003ci\u003e/home/user/dir/ /media/disk/backup\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003cb\u003e小心使用这个开关\u003c/b\u003e; 这个开关可能会让你在无意识的情况下删除一批无辜文件。事实上，当你要用 rsync 之前，使用 --dry-run 开关看一下要执行哪些操作而不真正同步文件可能是个好主意。如果你已经开始了一次 rsync 传输，却突然意识到这条命令可能造成数据损失的话，应该立刻用 Ctrl-C 来中止执行。一些文件可能已经损失掉了，不过你还有机会保存住剩下的。\u003c/p\u003e\n\n\u003ch6\u003e进行远程拷贝\u003c/h6\u003e\n\n\u003cp\u003e想要把文件复制到远程主机上? 没问题 --- 你需要做的就是加入主机和用户信息。举个例子，如果你想把同一个目录复制到远程主机上，你应该用:\u003c/p\u003e\n\n\u003cp\u003ersync -avhe ssh --delete \u003ci\u003e/home/user/dir/ \u003ca href=\"mailto:user@remote.host.com:dir/\"\u003euser@remote.host.com:dir/\u003c/a\u003e\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003e如果你想知道文件传输的速度，以及还有多少需要复制，可以加上 --progress 开关:\u003c/p\u003e\n\n\u003cp\u003ersync --progress -avhe ssh --delete \u003ci\u003e/home/user/dir/ \u003ca href=\"mailto:user@remote.host.com:dir/\"\u003euser@remote.host.com:dir/\u003c/a\u003e\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003e如果你不想每次使用 rsync 都被提示一次输入密码，确认一下你使用了 SSH 公钥机制而不是密码。要想这么做，你应该使用 ssh-keygen -t dsa ，并在密码提示环节直接按回车，以在本机上生成公钥。之后，使用 ssh-copy-id -i .ssh/id_dsa.pub \u003ci\u003euser@remote.host.com\u003c/i\u003e\u0026#160; 把公钥复制到远端主机上。\u003c/p\u003e\n\n\u003cp\u003e如果你想从远端主机上找回一些以前的备份文件，可以使用如下命令:\u003c/p\u003e\n\n\u003cp\u003ersync -avze ssh remote.host.com:/home/user/dir/ /local/path/\u003c/p\u003e\n\n\u003cp\u003e其中，z 开关会在传输过程中压缩数据，如果你在复制的文件在本地已经存在了，rsync 将不再传输 --- 这和把文件从本地传送到远端主机没什么区别。\u003c/p\u003e\n\n\u003ch6\u003e用一个脚本进行封装 \u003c/h6\u003e\n\n\u003cp\u003e一旦你指出了哪些目录需要进行同步，确定了同步文件的命令，就可以很容易地把这些命令封装在一个简单脚本里。这是一个简单的例子:\u003c/p\u003e\n\n\u003cpre\u003ersync --progress -avze ssh --delete /home/user/bin/ user@remote.host.com:bin/\nrsync --progress -avze ssh --delete /home/user/local/data/ user@remote.host.com:local/data/\nrsync --progress -avze ssh --delete /home/user/.tomboy/ user@remote.host.com:/.tomboy/\u003c/pre\u003e\n\n\u003cp\u003e如果你是在交互模式下运行 rsync，可以使用 --progress 开关。如果不是交互模式的话，也就不需要这个开关了。\u003c/p\u003e\n\n\u003cp\u003e如果你看 \u003ca href=\"http://www.ss64.com/bash/rsync.html\"\u003e\u003cb\u003ersync 的 man page\u003c/b\u003e\u003c/a\u003e 有可能会被它弄糊涂了。不过，当有了一些 rsync 的经验之后，你会发现设置 rsync 任务并不困难，它将为某天可能会来临的硬盘故障和数据损失做准备。\u003c/p\u003e\n\n\u003cp\u003e本文原文位于: \u003ca href=\"http://www.linux.com/feature/117236\"\u003e\u003cb\u003ehttp://www.linux.com/feature/117236\u003c/b\u003e\u003c/a\u003e\u003c/p\u003e\n","cover":"","link":"translation/2007/07/20/[译文]使用rsync进行专家级的备份/index.html","preview":"","title":"[译文]使用rsync进行专家级的备份"},{"content":"\n\u003cp\u003e原文出处: http://www.howtoforge.com/postfix_spf   \u003cbr /\u003eVersion 1.0    \u003cbr /\u003eAuthor: Falko Timme    \u003cbr /\u003eLast edited 02/09/2007    \u003cbr /\u003e\u003ci\u003e译注: 关于 SPF，可以参考译者曾经翻译的 Bruno Sousa 的《SPF 简介》 \u0026lt;http://www.linuxfocus.org/ChineseGB/December2004/article354.shtml\u0026gt;\u003c/i\u003e    \u003cbr /\u003e本教程技术了如何在 Postfix 2.x 中来实现 SPF (发送方策略框架)。SPF 是一个开放标准，用于规范防止伪造发送方地址的技术途径 (http://www.openspf.org/Introduction)。目前，有很多 Postfix 的 SPF 扩展和补丁，不过，大部分都需要你重新编译 Postfix。所以，我们将要安装的是来自 openspf.org 的 postfix-policyd-spf-perl 包，这是一个 Perl 包，它可以在已经安装好的 Postfix 上实现 SPF，而无须重新编译。    \u003cbr /\u003e开始之前，我想说的是这不是惟一的设置方法。条条大路通罗马，不过这是我选择的路。我不保证它对你也是合适的！ \u003c/p\u003e\n\n\u003ch5\u003e1 说明\u003c/h5\u003e\n\n\u003cp\u003e我架设你已经安装好了一个可以工作的 Postfix 邮件服务器。\u003c/p\u003e\n\n\u003cp\u003e下面的步骤和发布版是无关的，也就是说，它应该在任何 Linux distro 上都是工作的 (不过我只在 Debian Etch 上测试过)。\u003c/p\u003e\n\n\u003ch5\u003e2 安装需要的 Perl 模块\u003c/h5\u003e\n\n\u003cp\u003epostfix-policyd-spf-perl 包依赖于 Mail::SPF 和 NetAddr::IP Perl 模块。所以，我们准备是用 Perl shell 安装它们。现在，启动一个 Perl shell:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eperl -MCPAN -e shell\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e如果你这是第一次启动 Perl shell, 你会被问及几个问题，全都接受缺省值好了 (译注: 输出字符可以选择 no，这时输出字符集是 UTF-8, 缺省的是 Latin-1)。程序还会询问你所是用的 CPAN 仓库，选择一个最接近你的。\u003c/p\u003e\n\n\u003cp\u003e初始化 Perl shell 设置之后，现在我们可以开始安装需要的模块了，要安装 Mail::SPF，只要如下操作即可:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003einstall Mail::SPF\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e在我这里，它还会尝试安装 Module::Build (它是被依赖的)，不过随后失败了。如果在你那里也是这样的话，直接退出 Perl shell 吧\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eq\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e然后重新进入 Perl shell:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eperl -MCPAN -e shell\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e重新尝试安装 Mail::SPF :\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003einstall Mail::SPF\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这一次应该成功了，而且你应该可以看到 Net::DNS::Resolver::Programmable 和 NetAddr::IP 这两个被依赖的模块也安装上了。\u003c/p\u003e\n\n\u003cp\u003e成功的安装过程应该是这样的:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eInstalling /usr/local/bin/spfquery     \u003cbr /\u003eWriting /usr/local/lib/perl/5.8.8/auto/Mail/SPF/.packlist      \u003cbr /\u003e/usr/bin/make install -- OK\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e因为 NetAddr::IP 也已经被安装上了，现在我们退出 Perl shell:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003eq\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003ch5\u003e3 安装 postfix-policyd-spf-perl\u003c/h5\u003e\n\n\u003cp\u003e下面，我们从 _real_href=\u0026quot;http://www.openspf.org/Software\u0026quot; href=\u0026quot;http://www.openspf.org/Software\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;http://www.openspf.org/Software 下载 postfix-policyd-spf-perl ，把它放在 /usr/src，然后安装到 /usr/lib/postfix/ 。如下:\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003ecd /usr/src     \u003cbr /\u003ewget http://www.openspf.org/blobs/postfix-policyd-spf-perl-2.001.tar.gz      \u003cbr /\u003etar xvfz postfix-policyd-spf-perl-2.001.tar.gz      \u003cbr /\u003ecd postfix-policyd-spf-perl-2.001      \u003cbr /\u003ecp postfix-policyd-spf-perl /usr/lib/postfix/policyd-spf-perl\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e然后编辑 /etc/postfix/master.cf 并在最后添加如下内容\u003c/p\u003e\n\n\u003cblockquote\u003e\u003cp\u003evi /etc/postfix/master.cf\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cblockquote\u003e\u003cpre\u003e[...]\u003cbr /\u003epolicy  unix  -       n       n       -       -       spawn\u003cbr /\u003e    user=nobody argv=/usr/bin/perl /usr/lib/postfix/policyd-spf-perl\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e( user=nobody 之前的空格是必要的，这样 Postfix 才知道这一行是接着上面一行的！)\u003c/p\u003e\n\n\u003cp\u003e然后，打开 /etc/postfix/main.cf ，搜索 smtpd_recipient_restrictions 指示，这个设置之中应该包含 reject_unauth_destination ，在这之后，添加 check_policy_service unix:private/policy ，如下:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003evi /etc/postfix/main.cf\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cblockquote\u003e\n\n\u003cpre\u003e[...]\u003cbr /\u003esmtpd_recipient_restrictions = permit_sasl_authenticated,permit_mynetworks,reject_unauth_destination,check_policy_service\u003cbr /\u003e[...]\u003c/pre\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003eor like this:\u003c/p\u003e\n\n\u003cpre\u003e[...]\u003cbr /\u003e[...]\u003cbr /\u003esmtpd_recipient_restrictions =\u003cbr /\u003e        [...]\u003cbr /\u003e        reject_unauth_destination\u003cbr /\u003e        check_policy_service unix:private/policy\u003cbr /\u003e        [...]\u003cbr /\u003e[...]\u003c/pre\u003e\n\n\u003cp\u003e在 reject_unauth_destination \u003cb\u003e之后\u003c/b\u003e指定 check_policy_service 非常之重要，否则你的邮件系统就成为一个 open relay 服务器了!\u003c/p\u003e\n\n\u003cp\u003e然后重新起动 Postfix:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003e/etc/init.d/postfix restart\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e完成！你应该看看 postfix-policyd-spf-perl 包当中的 README 文件，其中包含一些关于该包如何处理邮件重要的细节，比如，postfix-policyd-spf-perl-2.0001 的 README 中写到:\u003c/p\u003e\n\n\u003cp\u003e\u003ci\u003e此版本\u003c/i\u003e\u003ci\u003e的 policy server 在 Mail From 之前检查 HELO (老版本仅在 Mail From 为空的情况下才检查 HELO)。它拒绝所有没有通过 Mail From 或 HELO SPF 检查的邮件。如果遇到一个临时性的错误并在其他检查中通过了，邮件将被延迟发送 (DEFER_IF_PERMIT)。如果 HELO 检查的结果是 \u003c/i\u003e\u003ci\u003eREJECT/DEFER，Mail From 将不被检查。\u003cbr /\u003e\n    \u003cbr /\u003e\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ci\u003e如果消息没有被拒绝，policy server 将在消息开始处添加相应的 \u003c/i\u003e\u003ci\u003eSPF Received 头部。对于有多个接收方的邮件，会添加多个头部。如果 Mail From 不是完全空白，那么，Mail From 的检查结果将被用于 SPF Received 头部 (比如 Maile From None 的情况，即使此时 HELO 已经通过了)。\u003cbr /\u003e\n    \u003cbr /\u003e\u003c/i\u003e\u003c/p\u003e\n\n\u003cp\u003e\u003ci\u003epolicy server 对于来自本机 (127.) 的连接将跳过 SPF 检查，并在邮件头部添加 \u003c/i\u003e\u003ci\u003e'SPF skipped - localhost is always allowed.'，同时记入日志。\u003c/i\u003e\u003c/p\u003e\n\n\u003ch5\u003e4 测试 policyd-spf-perl\u003c/h5\u003e\n\n\u003cp\u003e我们可以用如下方法测试 policyd-spf-perl:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003eperl /usr/lib/postfix/policyd-spf-perl\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e光标将停留在 policyd-spf-perl shell 中等待输入。现在我们模拟一封从某个域名某个服务器发送给另一个邮件地址的邮件。policyd-spf-perl 将会检查给定的服务器是否是该域名允许发送邮件的服务器并显示结果。\u003c/p\u003e\n\n\u003cp\u003e现在，咱们来看看，如果我们尝试从服务器 h****.server*********.net (IP 地址 81.169.1**.**) 发送一封来自 info@h****forge.com 的邮件，于是就会有一条 SPF 记录表明允许 81.169.1**.** 发送来自 h****forge.com 的邮件。\u003c/p\u003e\n\n\u003cp\u003e于是，咱们在 policyd-spf-perl shell 输入:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003erequest=smtpd_access_policy\u003cbr /\u003e\n    \u003cbr /\u003eprotocol_state=RCPT\u003c/p\u003e\n\n\u003cp\u003eprotocol_name=SMTP\u003c/p\u003e\n\n\u003cp\u003ehelo_name=h****forge.com\u003c/p\u003e\n\n\u003cp\u003equeue_id=8045F2AB23\u003c/p\u003e\n\n\u003cp\u003esender=info@h****forge.com\u003c/p\u003e\n\n\u003cp\u003erecipient=falko.timme@*******.de\u003c/p\u003e\n\n\u003cp\u003eclient_address=81.169.1**.**\u003c/p\u003e\n\n\u003cp\u003eclient_name=h****.server*********.net\u003c/p\u003e\n\n\u003cp\u003e[empty line]\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e输出应该是这个样子的:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003eaction=PREPEND Received-SPF: pass (h****forge.com: 81.169.1**.** is authorized to use 'info@h****forge.com' in 'mfrom' identity (mechanism 'ip4:81.169.1**.**' matched)) receiver=server1.example.com; identity=mfrom; envelope-from=\u0026quot;info@h****forge.com\u0026quot;; helo=h****forge.com; client-ip=81.169.1**.**\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这就意味着我们通过了这个测试。\u003c/p\u003e\n\n\u003cp\u003e现在来第二个测试，我们从一个不被允许发送 h****forge.com 域邮件的主机 1.2.3.4 (www.example.com) 发送邮件:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003erequest=smtpd_access_policy\u003cbr /\u003e\n    \u003cbr /\u003eprotocol_state=RCPT\u003c/p\u003e\n\n\u003cp\u003eprotocol_name=SMTP\u003c/p\u003e\n\n\u003cp\u003ehelo_name=h****forge.com\u003c/p\u003e\n\n\u003cp\u003equeue_id=8045F2AB23\u003c/p\u003e\n\n\u003cp\u003esender=info@h****forge.com\u003c/p\u003e\n\n\u003cp\u003erecipient=falko.timme@*******.de\u003c/p\u003e\n\n\u003cp\u003eclient_address=1.2.3.4\u003c/p\u003e\n\n\u003cp\u003eclient_name=www.example.com\u003c/p\u003e\n\n\u003cp\u003e[empty line]\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e下面是输出，测试输出的结果应该是失败的:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003eaction=PREPEND Received-SPF: softfail (h****forge.com: Sender is not authorized by default to use 'info@h****forge.com' in 'mfrom' identity, however domain is not currently prepared for false failures (mechanism '~all' matched)) receiver=server1.example.com; identity=mfrom; envelope-from=\u0026quot;info@h****forge.com\u0026quot;; helo=h****forge.com; client-ip=1.2.3.4\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e我们设置可以测试没有 sender 域的情况，这也正是很多垃圾邮件采用的手段。同样 policyd-spf-perl 应该可以完成这个测试:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003erequest=smtpd_access_policy\u003cbr /\u003e\n    \u003cbr /\u003eprotocol_state=RCPT\u003c/p\u003e\n\n\u003cp\u003eprotocol_name=SMTP\u003c/p\u003e\n\n\u003cp\u003ehelo_name=h****forge.com\u003c/p\u003e\n\n\u003cp\u003equeue_id=8045F2AB23\u003c/p\u003e\n\n\u003cp\u003esender=\u003c/p\u003e\n\n\u003cp\u003erecipient=falko.timme@*******.de\u003c/p\u003e\n\n\u003cp\u003eclient_address=81.169.1**.**\u003c/p\u003e\n\n\u003cp\u003eclient_name=h****.server*********.net\u003c/p\u003e\n\n\u003cp\u003e[empty line]\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e这是输出结果，我们仍然被允许发送来自 h****forge.com 的邮件:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003eaction=PREPEND Received-SPF: pass (h****forge.com: 81.169.1**.** is authorized to use 'h****forge.com' in 'helo' identity (mechanism 'ip4:81.169.1**.**' matched)) receiver=server1.example.com; identity=helo; helo=h****forge.com; client-ip=81.169.1**.**\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e现在尝试从一个非法的客户端 (译注: 注意 client 字段) 进行相同的测试:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003erequest=smtpd_access_policy\u003cbr /\u003e\n    \u003cbr /\u003eprotocol_state=RCPT\u003c/p\u003e\n\n\u003cp\u003eprotocol_name=SMTP\u003c/p\u003e\n\n\u003cp\u003ehelo_name=h****forge.com\u003c/p\u003e\n\n\u003cp\u003equeue_id=8045F2AB23\u003c/p\u003e\n\n\u003cp\u003esender=\u003c/p\u003e\n\n\u003cp\u003erecipient=falko.timme@*******.de\u003c/p\u003e\n\n\u003cp\u003eclient_address=1.2.3.4\u003c/p\u003e\n\n\u003cp\u003eclient_name=www.example.com\u003c/p\u003e\n\n\u003cp\u003e[empty line]\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e不出所料，这事输出结果:\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003eaction=PREPEND Received-SPF: softfail (h****forge.com: Sender is not authorized by default to use 'h****forge.com' in 'helo' identity, however domain is not currently prepared for false failures (mechanism '~all' matched)) receiver=server1.example.com; identity=helo; helo=h****forge.com; client-ip=1.2.3.4\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003cp\u003e要离开 the policyd-spf-perl shell, 请输入\u003c/p\u003e\n\n\u003cblockquote\u003e\n\n\u003cp\u003e[CTRL+C]\u003c/p\u003e\n\n\u003c/blockquote\u003e\n\n\u003ch5\u003e5相关链接\u003c/h5\u003e\n\n\u003cul\u003e\n\n\u003cli\u003eOpenSPF: _real_href=\u0026quot;http://www.openspf.org/\u0026quot; href=\u0026quot;http://www.openspf.org/\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;http://www.openspf.org \u003c/li\u003e\n\n\u003cli\u003epolicyd-spf-perl 下载地址: _real_href=\u0026quot;http://www.openspf.org/Software\u0026quot; href=\u0026quot;http://www.openspf.org/Software\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;http://www.openspf.org/Software \u003c/li\u003e\n\n\u003cli\u003eWikipedia 上 SPF 的定义: _real_href=\u0026quot;http://en.wikipedia.org/wiki/Sender_Policy_Framework\u0026quot; href=\u0026quot;http://en.wikipedia.org/wiki/Sender_Policy_Framework\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;http://en.wikipedia.org/wiki/Sender_Policy_Framework \u003c/li\u003e\n\n\u003cli\u003ePostfix: _real_href=\u0026quot;http://www.postfix.org/\u0026quot; href=\u0026quot;http://www.postfix.org/\u0026quot; target=\u0026quot;_blank\u0026quot;\u0026gt;http://www.postfix.org\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003eCopyright © 2007 Falko Timme\u003cbr /\u003e\n  \u003cbr /\u003eAll Rights Reserved.\u003c/p\u003e\n","cover":"","link":"translation/2007/03/27/[译文]-如何在-postfix-当中实现-spf/index.html","preview":"","title":"[译文] 如何在 Postfix 当中实现 SPF"},{"content":"\n\u003cp\u003e\u003cb\u003eTitle \u003c/b\u003eUsing Cscope and SilentBob to analyze source code    \u003cbr /\u003e\u003cb\u003eDate \u003c/b\u003e2007.03.09 4:01    \u003cbr /\u003e\u003cb\u003eAuthor \u003c/b\u003eStoneLion\u003c/p\u003e\n\n\u003cp\u003ehttp://programming.linux.com/article.pl?sid=07/03/05/1715201\u003c/p\u003e\n\n\u003cp\u003e当你开始研究一个不熟悉的项目的源代码的时候，对源代码的结构、函数和类的名称的含义等都不甚了解。这时，虽然我们可以使用 tags 来查看他们的定义，但是却很难通过一个一个看这些定义来得到全句的信息。Cscope 和 SilentBob 就是两个可以帮助我们分析不熟悉的源代码的工具。他们可以帮助你查找符号的定义，判断某个函数在哪里被调用了，发现某个给定的函数调用了哪些其他函数，以及在源代码中进行字符串模式匹配。使用这两个工具，你可以通过高速、有目的性的阅读代码来节省大量的时间，而不需要去手工 grep 所有代码文件。\u003c/p\u003e\n\n\u003ch3\u003e\u003cb\u003e使用 Cscope\u003c/b\u003e\u003c/h3\u003e\n\n\u003cp\u003eCscope 是一个非常流行的实用工具，大部分现代发行版都包含它。虽然 Cscope 最初被设计用来分析 C 代码，不过实际上，它在分析其他语言，诸如 C++ 和 Java 的时候同样好用。Cscope 拥有一个基于 ncurses 的界面，不过，它同样支持命令行模式，以便和其他前端程序一同工作，这些前端包含很多主流编辑器，如 Emacs 和 Vim。\u003c/p\u003e\n\n\u003cp\u003e当你调用 Cscope 的时候，它自动扫描当前目录之中的源文件，并把收集到的信息存储在一个内部数据库里面。如果需要递归扫描子目录，可以使用 -R 开关。如果你不需要 Cscope 的界面，只想从其它程序里查询其数据库，可以使用 -b 参数。如果你需要在一个大型或系统相关项目中使用，可以通过参考链接中的指南来查询一些优化参数，以提高速度。\u003c/p\u003e\n\n\u003cp\u003e缺省情况下，生成数据库之后，前端界面会自动启动 (可以使用 -d 参数告知 Cscope 使用已经生成的数据库，而不是重新生成一个)。这事一个两个面板的界面；在下面的面板中输入你希望查询的内容，结果会在上面的面板中显示出来。你可以使用 Tab 键在面板间切换，退出程序的快捷键是 Ctrl-D\u003c/p\u003e\n\n\u003cp\u003e在下面的面版上，可以使用方向键切换不同的查找域。使用这个面板，你可以:\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e查找某特定符号的出现位置； \u003c/li\u003e\n\n\u003cli\u003e查找全局定义 (如果找到的话，自动打开编辑器) \u003c/li\u003e\n\n\u003cli\u003e查找特定函数调用过的函数 \u003c/li\u003e\n\n\u003cli\u003e查找调用某个特定函数的函数 \u003c/li\u003e\n\n\u003cli\u003e查找文本字符串 \u003c/li\u003e\n\n\u003cli\u003e替换字符串 \u003c/li\u003e\n\n\u003cli\u003e查找一个 egrep 正则表达式 \u003c/li\u003e\n\n\u003cli\u003e在编辑器里打开一个特定文件 \u003c/li\u003e\n\n\u003cli\u003e查找 #include 了某个文件的文件\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e每当你进行一次查询，Cscope 会把查找结果进行编号，和文件名、函数名 (如果有的话)、行号以及代码行本身一起显示出来。如果使用方向键选择了一个查询结果并敲回车或是直接敲对应的数字键，Cscope 会启动系统缺省的编辑器 (由 EDITOR 环境变量确定) 打开该文件，并把光标定位到该行 (某些编辑器可能不支持定位到行，不过至少 Emacs 和 Vim 没有问题)。\u003c/p\u003e\n\n\u003ch4\u003e\u003cb\u003e使用 (X)Emacs 作为前端\u003c/b\u003e\u003c/h4\u003e\n\n\u003cp\u003e在 Emacs 中使用 Cscope 非常容易。如果你没有运行着 cscope 开头的程序，而 Emacs 中已经有 Cscope 菜单了，你可以通过安装 xcscope.el 在 Emacs 中集成 Cscope。xcscope.el 可以在 Cscope 源码包中的\u0026#160; contrib/xcscope 子目录中得到。安装的方法是把 cscope-indexer 脚本放到 $PATH 中的路径之中，并把 xcscope.el 放到 Emacs 的脚本路径 (路径相关帮助可以在 Emacs 里面运行 ``C-h v load-path`` 来查询 load-path 相关说明)。先在，把 (require 'xcscope') 这行放到 ~/.emace 或 ~/emacs.d/init.el 当中就可以了。xcscope.el 文件的开头部分的注释可以作为文档。\u003c/p\u003e\n\n\u003cp\u003e这个包把所有 Cscope 的查找命令添加导了 Emacs 菜单中的 Cscope 子菜单当中，并且可以在你编辑文件的时候使用快捷键调用。比如，如果你想查找一个符号，可以直接在菜单中选择 Cscope -\u0026gt; Symbol 或是输入 M-x cscope-find-this-symbol，或按快捷键 C-c s s，之后输入符号的名字 (如果什么都不输入，就使用光标下的名字)。搜索的结果会显示在 *cscope* buffer 之中, 按照文件名分组，并以 \u0026lt;函数名\u0026gt;[行号] \u0026lt;整行内容\u0026gt; 的形式显示。把光标移动到想查看的搜索结果上，按空格键，将会在另一个 buffer 中打开该文件，并定位光标到搜索的行。如果你按的是回车而不是空格，你将会直接从 *cscope* buffer 中跳到相应的 buffer (鼠标点击搜索结果也可以)。你可以使用 n 和 p 来选择下一个或上一个搜索结果 (当 *cscope* buffer 不是当前 buffer 的时候可以用 C-c s n 和 C-c s p)。N 或 P 可以用于选择下一个和上一个文件 (或 C-c s N 和 C-c s P)。\u003c/p\u003e\n\n\u003ch4\u003e\u003cb\u003e在 Vim 中使用 Cscope\u003c/b\u003e\u003c/h4\u003e\n\n\u003cp\u003e如果你更喜欢用 Vim，你还是可以用 Cscope。首先，你的 Vim 应该是使用 --enable-cscope 开关编译的。大部分二进制形式的 Linux 发布版都打开了这个开关。Gentoo 的用户则应该打开 cscope USE 标志。这里假设你使用的是 Vim 6.x 或 7.x。Vim 参考手册里包含了一篇使用 Cscope 接口的文章，你可以在 /usr/share/vim/vim\u0026amp;\u003ci\u003eversion\u003c/i\u003e/doc/if_cscop.txt找到它。你还可以看另一个简短的教程 (参考链接)。\u003c/p\u003e\n\n\u003cp\u003e在 Vim 中，你可以使用如下形式调用 Cscope: :cscope find \u003ci\u003esearch type\u003c/i\u003e \u003ci\u003esearch string\u003c/i\u003e (可以用 :cs f 来代替 :cscope find)，这里的 search type 包括:\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003esymbol or s -- 所有引用这个符号的地方; \u003c/li\u003e\n\n\u003cli\u003eglobal or g --查找全局符号 \u003c/li\u003e\n\n\u003cli\u003ecalls or c --查找特定函数的所有调用 \u003c/li\u003e\n\n\u003cli\u003ecalled or d --查找特定函数调用的所有函数 \u003c/li\u003e\n\n\u003cli\u003etext or t --查找文本 \u003c/li\u003e\n\n\u003cli\u003efile or f --打开文件 \u003c/li\u003e\n\n\u003cli\u003einclude or i --查找 #include 了指定文件的文件\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e 查找结果会在 Vim 窗口的底部以菜单方式显示出来。你可以键入你希望进入的查找结果的编号并按回车。如果你用 :scscope 或 :scs 代替 :cscope 的话，Vim 窗口会水平拆分成两个，你选择的查找结果将会放在新的窗口之中。\n\n\u003cp\u003e在 Vim 之中，从 Cscope 查询中跳到一个结果和跳到任意的 tag 没有什么区别; 你可以用 Ctrl-T 条回到查找之前的地方，也可以用 :tnext 和 :tprevious 在查找结果间来回跳。\u003c/p\u003e\n\n\u003cp\u003e如果你想调对光标下的词进行查找，你应该安装 cscope_maps.vim 插件 (把这个文件放在 $HOME/.vim/plugin 目录即可)。这个文件里面的注释说明了它的用法。使用这个插件，你可以用 Ctrl-\\ 代替 :cscope，用 Ctrl-space 代替 :scscope，搜索将意光标下的词作为搜索词 (比如，你把光标挪到 \u0026quot;initialize\u0026quot; 上面，输入 Ctrl-\\ s，就可以找到所有引用 initialize 符号的地方了。\u003c/p\u003e\n\n\u003ch3\u003e\u003cb\u003eSilentBob\u003c/b\u003e\u003c/h3\u003e\n\n\u003cp\u003eSilentBob 是一个用于分析源代码的新工具，目前支持 C/C++, Perl 以及 Python，不过它的插件框架 (目前尚无文档)允许用户方便地添加新语言和新功能。 \u003c/p\u003e\n\n\u003cp\u003e你可以从该软件的官方网站获取源码包或 deb 包。安装之后，在源码目录运行三次 SilentBob:\u003c/p\u003e\n\n\u003cpre\u003e  bob --make-ctags\u003cbr /\u003e  bob --cfiles\u003cbr /\u003e  bob -L cfiles --call-tags\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e这样会生成三个文件: tags, 一般标签表格; cfiles, C/C++ 文件列表; calltags, 调用标签表。 调用标签表用于函数调用，所以，如果你希望查找某个函数的所有调用，你可以让 Vim 使用 调用标签表 (:set tags=./call_tags) 并使用内建命令用于查找标签 (:tag \u003ci\u003efunction-name\u003c/i\u003e 以及用 :tnext 和 :tprevious循环查找)。这三个索引文件可以被 SilentBob 用于构建调用树和反向调用树。\u003c/p\u003e\n\n\u003cp\u003e对于 Perl 和 Python，只支持标签表和文件列表:\u003c/p\u003e\n\n\u003cpre\u003e  bob \u0026lt;--perl | --python\u0026gt; --make-ctags\u003cbr /\u003e  bob \u0026lt;--perl | --python\u0026gt; --files\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003e第二个命令会生成 generate a perl_files 或 python_files 文件。\u003c/p\u003e\n\n\u003cp\u003e一旦生成了一个标签表，SilentBob 可以显示出一个调用树:\u003c/p\u003e\n\n\u003cpre\u003e  bob [--depth \u003ci\u003eN\u003c/i\u003e] \u003ci\u003efunction\u003c/i\u003e\u003c/pre\u003e\n\n\u003cp\u003e--depth 选项允许你限制调用树的深度。如果你之希望知道哪些函数被给定函数调用了，使用 --depth 0 参数即可。否则，被调用的函数会被依次列出来。\u003c/p\u003e\n\n\u003cp\u003e注意，你可以对 SilentBob 为 Python 和 Perl 文件生成的标签表加上这个参数。不过，使用 Exuberant Ctags 生成的表是不被支持的。\u003c/p\u003e\n\n\u003cp\u003e调用标签表还可以用于生成反向调用树\u003c/p\u003e\n\n\u003cpre\u003e  bob [--depth \u003ci\u003eN\u003c/i\u003e] -u \u003ci\u003efunction\u003c/i\u003e\u003c/pre\u003e\n\n\u003cp\u003e这将依次显示调用给定函数的函数。这时，指定 --depth 1 则只显示调用此函数的函数。SilentBob 也可以使用创建的 cfiles 文件查找 C/C++代码种的文本。它检查操作符，字符串和注释会被省略掉。\u003c/p\u003e\n\n\u003cpre\u003e  bob \u003ci\u003elist of files\u003c/i\u003e --cgrep \u003ci\u003epieces of text, separated by comma\u003c/i\u003e\u003c/pre\u003e\n\n\u003cp\u003e你可以指定 -L ./cfiles 来使用生成的文件列表。几个文本应该来自于同一个操作符，所以，如果你要找检验 T 变量的地方，可以使用:\u003c/p\u003e\n\n\u003cpre\u003e  bob -L ./cfiles --cgrep if,T\u003cbr /\u003e\u003c/pre\u003e\n\n\u003cp\u003eSilentBob 还包含一个 tags 工具，让你可以在一个控制台查看标签的定义。调用 tags \u003ci\u003etag1 tag2 ... tagN\u003c/i\u003e 可以从代码中取出你感兴趣的片段 -- 函数定义、全局变量声明等等 -- 你将会看到你需要的代码片段。\u003c/p\u003e\n\n\u003ch4\u003e为什么使用 SilentBob 生成标签?\u003c/h4\u003e\n\n\u003cp\u003eSilentBob 使用语法分析器来解析源文件，这使得它比使用正则表达式定位文件中的某行的工具，如 Exuberant Ctags 要快很多。在对 Linux 内核源文件 (2.6.19) 的测试中，Exuberant Ctags 生成标签表需要 90 秒，而 SilentBob 仅需 10 秒钟 (测试机使用 2.6GHz 的赛扬处理器)。SilentBob 还支持多线程优化。\u003c/p\u003e\n\n\u003cp\u003e另一个不同来自于标签表的格式: Exuberant Ctags 生成的表中，使用正则表达式定位特定行。这就意味着，如果你编辑该文件，某些定义的位置可能会改变，但你不需要重新生成标签表。这对于 Exuberant Ctags 来说很理想，因为这样你就不需要频繁地重新生成表格了，不过，这也意味着如果你在浏览一个大型文件，在标签定义之间的跳转相对于记录行号的方式会非常慢。这就是 SilentBob 为什么在标签表中使用行号; 不过，这就意味着你必须在较大的编辑之后重新生成标签表了。\u003c/p\u003e\n\n\u003ch3\u003e参考链接\u003c/h3\u003e\n\n\u003col\u003e\n\n\u003cli\u003e\u0026quot;tags\u0026quot; - http://applications.linux.com/article.pl?sid=07/01/22/167212\u0026amp;tid=13 \u003c/li\u003e\n\n\u003cli\u003e\u0026quot;Cscope\u0026quot; - http://cscope.sourceforge.net/ \u003c/li\u003e\n\n\u003cli\u003e\u0026quot;在大型项目中使用 Cscope\u0026quot; - http://cscope.sourceforge.net/large_projects.html \u003c/li\u003e\n\n\u003cli\u003e\u0026quot;关于在 Vim 里使用 Cscope 的简短教程\u0026quot; - http://cscope.sourceforge.net/cscope_vim_tutorial.html \u003c/li\u003e\n\n\u003cli\u003e\u0026quot;cscope_maps.vim\u0026quot; - http://cscope.sourceforge.net/cscope_maps.vim \u003c/li\u003e\n\n\u003cli\u003e\u0026quot;SilentBob\u0026quot; - http://silentbob.sourceforge.net/\u003c/li\u003e\n\n\u003c/ol\u003e\n\n\u003chr /\u003e\n","cover":"","link":"translation/2007/03/17/[译文]-使用-cscope-和-silentbob-分析源代码/index.html","preview":"","title":"[译文] 使用 Cscope 和 SilentBob 分析源代码"},{"content":"\n\u003cp\u003e\u003ca href=\"http://security.linux.com/article.pl?sid=07/01/31/1539208\u0026amp;from=rss\"\u003ehttp://security.linux.com/article.pl?sid=07/01/31/1539208\u0026amp;from=rss\u003c/a\u003e    \u003cbr /\u003eThursday February 08, 2007 (03:01 PM GMT)    \u003cbr /\u003eBy: Rui Lopes\u003c/p\u003e\n\n\u003cp\u003e多 数情况下，诸如 SELinux, AppArmor, Bastille 以及 grsecurity 系统级的安全解决方案能够让你的 Linux 桌面系统相当地安全。不过，有些情况下，文件或是目录的加密还是必要的。当你需要把包含你的私人数据的文件通过可以动存储介质或是网络复制到其他什么地方 的时候，有些工具能得上忙的。    \u003cbr /\u003e这些工具大部分是命令行方式工作的，不过，它们确实很简单，大部分患有命令行恐惧正的新手在经过一定的努力之后都能使用它们。所有这些工具都很小、需要极少的依赖库 (如果确实需要的话)，可以说都是高度便携的。    \u003c/p\u003e\n\n\u003cp\u003eBcrypt   \u003c/p\u003e\n\n\u003cp\u003e我 的 U 盘里总会放着一份 Bcrypt. 这是个极为简单易用的基本工具。一旦装上了 bcrypt, 你惟一要做的就是在命令行依次输入 bcrypt 和你要加密的文件名。之后，Bcrypt 会要求你提供一个密码，仅此而已。加密之后，Bcrypt 会给文件加上 .bfe 的扩展名。同样的命令也可以用于解密，bcrypt 仅仅通过文件的扩展名来决定是要加密还是解密。   \u003c/p\u003e\n\n\u003cp\u003eBcrypt 使用 Blowfish 。算法。密码通常要有 8 到 56 个字符，并被内部哈希为一个 448 位密钥以增强安全性。缺省条件下，加密文件的时候，原始文件将被删除并在原来存储文件的位置覆写 3 次，以避免通过反删除工具发现原始文件，你可以增加或减少重写的次数。   \u003c/p\u003e\n\n\u003cp\u003eBcrypt 缺乏灵活性和各种开关，所以可能不是你加密军火库中的首选武器，不过，简单是它的强项。根据 Bcrypt 的项目网站介绍，它可以用于 Linux 和 *BSD, 没有 Windows 版本; 不过，这个网站似乎有年头没更新过了。   \u003c/p\u003e\n\n\u003cp\u003eNcrypt   \u003c/p\u003e\n\n\u003cp\u003eNcrypt 是另一个简单的文件加密/解密程序。你可以选择三个 AES 加密标准候选加密算法: Rijndael, Twofish, 和 Serpent 中的任何一个。开发者特别注意了生成密码的安全性: 当一个文本密码被用于加密文件的时候，它首先被转换为 SHA-1 哈希值，而原文被立刻清除出内存。之后，这个哈希值被用于密钥，随后，也会被清除出内存。   \u003cbr /\u003eNcrypt 同时有 Unix 和 Windows 版本。它的用法很直接: 使用 ncrypt 命令，用开关选择加密算法，是要加密、解密、还是要清除文件，以及输入输出文件名。。原始文件将被从磁盘上彻底清除；Ncrypt 也有一个非常有用的文件清除功能，你可以用它安全删除文件。    \u003c/p\u003e\n\n\u003cp\u003ePad   \u003c/p\u003e\n\n\u003cp\u003e与 Bcrypt 和 Ncrypt 不同，Pad 使用 on-time pad (OTP) 加密。一个文件会被分成两个乃至更多独立的\u0026quot;pads\u0026quot;, 没一个都类似于白噪声。两个文件看起来只是混入了无害的随机数据，可以在用户喜欢的任何时候被重新组装起来。   \u003c/p\u003e\n\n\u003cp\u003eOTP 有非常悠久的历史了。理论上讲，它是惟一真正不可破解的加密手段。不过，它有一些实际应用上的弱点: 每个 pad 尽可以被使用一次，而且必须是真正的随机数 (这实际上非常困难)，并且它很容易受到中间人工具。这样，它不被推荐用于日常加密任务。不过，有一个场合下，OTP 被认为是有价值的: 自由语音加密。比如，如果有人希望自由分发一个机密文件，它可以将文件拆成不同的 pad，并将多个部分存放在不同的一同里，并告诉别人如何获取它们并组合成原始文件。(译注: 这段翻译的不怎么好，因为译者根本不懂什么是 OTP, 查了半天还是不怎么明白，欢迎解释。)   \u003c/p\u003e\n\n\u003cp\u003eGnuPG   \u003c/p\u003e\n\n\u003cp\u003e对于多数人来说，GnuPG 是开源文件加密的不二选择。一些发布版还把它随发布版预装。引用其 FAQ 中的原文，\u0026quot;GnuPG 代表 GNU 隐私卫士，是用于安全通信与数据存储的 GNU 工具。它可以被用于数据加密和创建数字签名。它包含一个先进的密钥管理工具并与 RFC 2440 所描述的 OpenPGP Internet 标准提案相兼容。因而，它的目标是兼容 NAI 公司的 PGP。.\u0026quot;   \u003c/p\u003e\n\n\u003cp\u003eBcrypt, Ncrypt 和很多其它加密工具使用对称密钥加密文件。而 GnuPG 和 PGP 一样，使用公钥密钥加密，尽管它也支持对称加密。公钥加密使得加密和签名多个文件并和其他用户交换它们变得很容易。对于对称密钥和公钥密钥的综述以及它们 的工作机制，可以参考 GnuPG 手册的第二章和 FAQ 的 7.1 节。   \u003cbr /\u003eGnuPG 可以独自地作为命令行工具使用，它有很多功能，并可以满足各种挑剔的用户。不过，它也有各种不错的前端工具可用。其中，我所用的是 KGpg, 集成在 KDE 之中，这方便了我很多日常加密工作。比如，其它我提到的加密工具只能加密文件，而不能加密目录。你可以用 KGpg 加密目录中的所有文件，或者创建一个 .tar.gz 或是 .zip 文件，并对它进行加密 。使用 KGpg, 我只要双击一个目录并告诉程序打包加密之即可。KGpg 也允许你在桌面创建一个碎纸机，用于安全删除你放在里面的文件 (而不是目录)。这非常方便，尽管我建议你阅读作者的关于破碎文件的安全说明。KGpg 的易用性非常优秀；即使对新手来说，学习曲线也非常短。    \u003cbr /\u003eGnuPG 的开发步伐非常文鼎，而且支持多种操作系统。它在多种 Unix 系统上都可以编译，而且通过 Gpg4Win 提供了 Windows 移植版本。对于 Unix 系统的邮件加密的支持性也非常可靠: 查询 GnuPG FAQ 的 4.15 节，可以看到提供 GnuPG 集成的邮件客户端的列表 (很遗憾，支持 OpenPGP 标准的 Windows 客户端十分少见)。关于更多的邮件工具，可以看看 Aegypten 项目。    \u003c/p\u003e\n\n\u003cp\u003e关于加密的更多信息，两个不错的起点是对应的 Wikipedia 文章和 Cryptography FAQ.   \u003cbr /\u003eRui Lopes 是一个葡萄牙网页设计师和独立纸片人，在技术领域有广泛兴趣。\u003c/p\u003e\n","cover":"","link":"translation/2007/02/14/[译文]-使用加密工具提高系统安全性/index.html","preview":"","title":"[译文] 使用加密工具提高系统安全性"},{"content":"\n\u003cp\u003e过程大概是:   \u003cbr /\u003e分两组    \u003cbr /\u003e1) 组内自我介绍    \u003cbr /\u003e2) 向对方介绍自己组的同学    \u003cbr /\u003e3) 每个小组分别对一批条件进行排序    \u003cbr /\u003e4) 如果两小组排序不同的话，辩论 (都是一些没有是非的好辩论题材，基本不可能    \u003cbr /\u003e\u0026#160;\u0026#160; 排序一样)\u003c/p\u003e\n\n\u003cp\u003e偶就不说具体表现了，提一些忠告:    \u003cbr /\u003e1) 永远不要批评自己的队友，紧张的时候你可能会想埋怨，但要管住自己    \u003cbr /\u003e2) 讨论的时候要避免冲突    \u003cbr /\u003e3) 辩论的时候不要跑题，如果对手跑题了，有礼貌地请他回来    \u003cbr /\u003e4) 不要攻击对手，论事不论人    \u003cbr /\u003e5) 逻辑要清晰，你的推理似乎和论证方式重过你的论证结果    \u003cbr /\u003e6) 不要试图成为领袖，但在需要你的时候要勇敢\u003c/p\u003e\n","cover":"","link":"works/2006/11/16/群面华为归来谈谈辩论技巧/index.html","preview":"","title":"群面华为归来谈谈辩论技巧"},{"content":"\n\u003cp\u003e这个问题总被问，回答过无数次了，贴在这里，这是终极方法，适用于一切可以重新启动系统、使用 LILO/GRUB，并且引导程序没有密码的情况。   \u003cbr /\u003e如果你忘了普通用户的用户名密码，用 root 登录，然后运行 passwd username 即可修改    \u003cbr /\u003e如果忘了 root 密码，启动到单用户模式，用 passwd 命令修改密码    \u003cbr /\u003e如果单用户模式也需要密码，启动时用内核参数 init=/bin/sh 即可，出现提示符后，以 rw 方法重新 mount 根分区，编辑 /etc/passwd，去掉 root 密码即可，具体操作是    \u003cbr /\u003e1.a 如果用 grub 引导的话，在引导菜单上要启动的选项处按'e'，然后上下找到kernel那一行，再按 e，在后面加上 init=/bin/sh 这几个字，然后按回车，然后大概是按b，启动    \u003cbr /\u003e1.b 如果用lilo，在 lilo 提示界面下，输入你启动的东东的 lable，再在后面加上参数，比如label是linux，那就输入 linux init=/bin/sh，然后回车    \u003cbr /\u003e2. 看到 Shell 提示符之后，输入命令, mount -o remount,rw /，重新以可读写方式挂载根分区。    \u003cbr /\u003e3 用 passwd 命令修改密码，也可以直接修改 /etc/passwd文件    \u003cbr /\u003e4 用 mount -o ro,remount / 重新把根分区只读，这个必须做，否则就功亏一篑了    \u003cbr /\u003e5 按计算机的 reset 键，重新启动系统。因为没有 init，所以 reboot, halt, shutdown 这些命令很可能不好用。    \u003cbr /\u003e完毕。\u003c/p\u003e\n","cover":"","link":"works/2006/01/14/linux忘记密码的处理方法/index.html","preview":"","title":"Linux忘记密码的处理方法"},{"content":"\n\u003cp\u003e1. 定位 boot 分区：   \u003cbr /\u003e==================    \u003cbr /\u003e\u0026quot;grub\u0026gt;\u0026quot;提示符下运行如下命令：    \u003cbr /\u003egrub\u0026gt; find /grub/stage1    \u003cbr /\u003e(hd0,4)    \u003cbr /\u003e如果得到类似上述的结果，则表明存在单独的 /boot 分区，这是 Red hat 的典型    \u003cbr /\u003e风格，记为(*)，相应的记 /dev/hda5 为 (*')。(*)到(*')的映射遵循如下规律    \u003cbr /\u003e(hdm,n)--\u0026gt;(/dev/hdck)    \u003cbr /\u003em=0,1,2,3 ---\u0026gt; c=a,b,c,d    \u003cbr /\u003ek=n+1    \u003cbr /\u003e如果没有得到有用结果，则表明不存在 /boot 分区，那么运行如下命令    \u003cbr /\u003egrub\u0026gt; find /boot/grub/stage1    \u003cbr /\u003e(hd0,4)    \u003cbr /\u003e记此结果为 (**)，对应的 (**') 使用同样的方式转换而成    \u003cbr /\u003e(*) 或 (**) 就是对应的 grub 的分区的位置，记为 (grub)    \u003cbr /\u003e2. 定位根分区:    \u003cbr /\u003e==============    \u003cbr /\u003e如果存在(**') 则这个就是根分区，如果存在(*)，则运行如下命令    \u003cbr /\u003egrub\u0026gt; find /etc/fstab    \u003cbr /\u003e(hd0,6)    \u003cbr /\u003e记上述结果为 (***) 并用同样规则，相应得到 (***')    \u003cbr /\u003e(**') 或 (***') 就是的根分区的位置，记为 (root')    \u003cbr /\u003e3. 引导系统:    \u003cbr /\u003e一共需要三到四条命令：    \u003cbr /\u003ea) grub\u0026gt;root (grub)    \u003cbr /\u003e例如    \u003cbr /\u003egrub\u0026gt; root (hd0,4)    \u003cbr /\u003eb) kernel (vmlinuz) root=(root') ro    \u003cbr /\u003e这里(vmlinuz)以如下方式确定    \u003cbr /\u003e如果(*)    \u003cbr /\u003egrub\u0026gt; kernel /vmlinuz    \u003cbr /\u003e如果(**)    \u003cbr /\u003egrub\u0026gt; kernel /boot/vmlinuz    \u003cbr /\u003e输入上面内容后，*不要回车*，连按tab键，可以得到匹配文件名列表，选择一个    \u003cbr /\u003e合适的，输入完整，格式如下    \u003cbr /\u003egrub\u0026gt; kernel /vmlinuz-2.6.10-1 root=/dev/hda5 ro    \u003cbr /\u003e或    \u003cbr /\u003egrub\u0026gt; kernle /boot/vmlinuz-2.6.10-1 root=/dev/hda7 ro    \u003cbr /\u003ec) initrd (initrd)    \u003cbr /\u003e同样按照上面同样的命令行补全方式，输入，例如    \u003cbr /\u003egrub\u0026gt; initrd /initrd-2.6.10-i386.img    \u003cbr /\u003e或    \u003cbr /\u003egrub\u0026gt; initrd /boot/initrd-2.6.10-i386.img    \u003cbr /\u003ed) boot    \u003cbr /\u003egrub\u0026gt; boot    \u003cbr /\u003e至此，系统启动    \u003cbr /\u003e4. 修复引导程序:    \u003cbr /\u003ea)首先使用(root')和(boot')更新 /etc/fstab 里面的 / 和 /boot 的设备号，    \u003cbr /\u003e如果有其它分区，相应调整。    \u003cbr /\u003eb) 修改 /boot/grub/menu.lst 或 grub.conf    \u003cbr /\u003e按照步骤3里面的数据修改此文件    \u003cbr /\u003ec) 重新安装 grub    \u003cbr /\u003e以root用户    \u003cbr /\u003e# grub    \u003cbr /\u003egrub\u0026gt; root (boot)    \u003cbr /\u003egrub\u0026gt; setup (hd0)    \u003cbr /\u003e大概就是这样了，没有实验，直接写的，恐怕有些地方有些疏漏，请大家指正。\u003c/p\u003e\n","cover":"","link":"works/2006/01/14/硬盘分区调整导致grub无法引导的修复/index.html","preview":"","title":"硬盘分区调整导致grub无法引导的修复"},{"content":"\n\u003cp\u003e我不打算太具体地说这个启动盘的制作方法了，相反，更简洁地介绍一下更一般的方法。   \u003cbr /\u003e关键词: boot loader, initrd, syslinux, isolinux, damn small linux,    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; debian installer, bootable usb flash disk    \u003cbr /\u003e大纲:    \u003cbr /\u003e* 引导程序概述    \u003cbr /\u003e* initrd    \u003cbr /\u003e* SYSLINUX/ISOLINUX    \u003cbr /\u003e* 实战 2 in 1 双启动 U 盘    \u003cbr /\u003e说明 \u0026amp; 免责声明:    \u003cbr /\u003e* U 盘的可引导性同时依赖于 U 盘本身和计算机主板，较早主板一律不支持    \u003cbr /\u003e* 作者不对读者因为参照本文所引起的一切后果负责    \u003cbr /\u003e一、引导程序概述    \u003cbr /\u003e================    \u003cbr /\u003e任何一个操作系统在任何一个硬件平台上的运行都需要一个引导的过程，即，初始化    \u003cbr /\u003e软件环境、把内核从存储介质放到内存当中去，并开始运行。当然对于某些简单软硬    \u003cbr /\u003e件系统，这个过程可能及其简单，而对于 PC 就要略微复杂一些了。    \u003cbr /\u003ePC 的引导程序上承 BIOS，下接内核的初始化代码，虽然开一次机只运行一次后就    \u003cbr /\u003e不留痕迹了，不过还是相当重要的。所有的引导程序都在做类似的事情:    \u003cbr /\u003e* 驻留在存贮介质的特殊位置可以被 BIOS 启动，或是自己是某一系统的可执行    \u003cbr /\u003e\u0026#160; 文件，可以被用户显式或隐式在该系统（宿主系统）内启动；    \u003cbr /\u003e* 了解要被启动的必要启动文件的位置，包括系统内核、ramdisk 等，并把它们    \u003cbr /\u003e\u0026#160; 读取出来、装载到内存之中；    \u003cbr /\u003e* 构造环境、运行操作系统的内核，自己则就此退出历史舞台。    \u003cbr /\u003e历史上，用于 Linux 的最著名的引导程序莫过于 LILO 和 Grub 了，作为通用的引导    \u003cbr /\u003e程序，二者用途广泛，但对于一些特殊的场合，譬如引导程序可利用的空间比较有限    \u003cbr /\u003e的可移动存储介质 (通俗地说，包括光盘、软盘、u 盘等)，它们有些过于厚重了，这    \u003cbr /\u003e就引出了我们今天的主角 --- SYSLINUX/ISOLINUX，现在，你只要知道他们是引导程序    \u003cbr /\u003e就足够了，接下来，我们还要插入一些废话。    \u003cbr /\u003e二、initrd    \u003cbr /\u003e==========    \u003cbr /\u003einitrd = init ramdisk, 顾名思义，就是在启动时使用的一个内存虚拟磁盘，它是系统    \u003cbr /\u003e广泛的硬件支持性的必需品。    \u003cbr /\u003e我们知道，Linux 的驱动程序是内核的一部分，它们提供了硬件向上层的抽象接口，    \u003cbr /\u003eLinux 内核的核心子系统 --- 虚拟文件系统部分的工作强烈依赖于底层硬件驱动程序    \u003cbr /\u003e的支持，在启动过程当中，当某些必备的驱动程序无法使用的时候，比如 EXT2 文件    \u003cbr /\u003e系统、IDE 硬盘适配器等无法工作的时候，系统启动将就此中止，发生所谓的    \u003cbr /\u003e``Kernel Panic''，这也是初学者编译内核最常遇到的困难。    \u003cbr /\u003e然而，我们当然不能将所有的驱动都编译到内核当中去，因为    \u003cbr /\u003e* 我们不能无限制地加大内核的尺寸，这对于系统资源，尤其是引导过程中非常    \u003cbr /\u003e\u0026#160; 有限的可用存储资源是难以承受的    \u003cbr /\u003e* 我们可以把很多驱动程序编译成模块，随用随加载    \u003cbr /\u003e* 极少数情况，某些模块是相互冲突的，比如 2.4 内核的某些版本之中，reiserfs    \u003cbr /\u003e\u0026#160; 和 ext3 两种驱动不能同时被编译到内核当中。    \u003cbr /\u003e所以，我们只能在内核中放入必要的驱动程序，其余的不那么需要的部分编译成模块    \u003cbr /\u003e放到 /lib/modules/`uname -r`/ 之中，在需要的时候会被加载。    \u003cbr /\u003e但是，对于具有通用性的内核，是很难论断出哪几种驱动程序才是真正必须的，究竟    \u003cbr /\u003e是 Intel 的 IDE 磁盘控制器还是 AMD/nVidia 的，抑或是 VIA 的，乃至光纤通道    \u003cbr /\u003eSCSI 磁盘……是阿，这真是个很困扰人的问题，没有一个驱动可以在占用绝对少的空    \u003cbr /\u003e间的前提下应付所有的设备，于是，我们退而求其次，寻求一个中间介质 --- ramdisk    \u003cbr /\u003e在内核启动前，引导程序首先在内存之中构建一个 ramdisk，成为一个基本文件系统，    \u003cbr /\u003e然后 Linux 内核以此为自己的根文件系统启动，这样的好处是可以不必理会磁盘驱动    \u003cbr /\u003e的问题，只要能驱动 ramdisk 就可以了。    \u003cbr /\u003e用 ramdisk 启动之后，在 ramdisk 的启动脚本 (一般叫 /linuxrc) 之中，针对硬件    \u003cbr /\u003e尝试 ramdisk 里面的 /lib/modules/`uname -r`/，加载恰当的驱动，这时系统已经    \u003cbr /\u003e具备了切换到硬盘或其他介质上的文件系统的条件了。    \u003cbr /\u003e机不可失，这时，我们首先加载硬盘或光盘、u 盘等启动介质，然后设该介质为新的    \u003cbr /\u003e根分区，并运行其 init 进程为 1 进程，之后，在 init 脚本中，释放掉 initrd 的    \u003cbr /\u003e空间，这就是借助 initrd 的引导过程。在这个过程之中 引导程序帮我们多做了一件    \u003cbr /\u003e事 --- 构建 ramdisk, 把 initrd 放入内存。    \u003cbr /\u003e三、用 SYSLINUX/ISOLINUX 引导软盘和光盘    \u003cbr /\u003e=======================================    \u003cbr /\u003e上文已经说过了，SYSLINUX/ISOLINUX 是专门用来引导可移动介质的轻量级引导程序，    \u003cbr /\u003e因为这样的介质通常不会固定只针对一种硬件，initrd 当然是 SYSLINUX/ISOLINUX    \u003cbr /\u003e必须支持的功能了。这两种引导程序其实是一样的，没有多大区别，只是放在不同的    \u003cbr /\u003e设备的引导区罢了。    \u003cbr /\u003e3.1 配置 SYSLINUX/ISOLINUX    \u003cbr /\u003e--------------------------    \u003cbr /\u003e对于这两种引导程序，都会有一段引导代码，写入引导代码的时候，还同时需要一个    \u003cbr /\u003e配置文件: syslinux.cfg/isolinux.cfg，同样，这两个文件也是一样的，唯一的区别    \u003cbr /\u003e在于文件名，其各个字段的写法如下:    \u003cbr /\u003e\u0026#160; DISPLAY xxx.txt    \u003cbr /\u003e这指定了一个文件名，会在启动的时候显示的内容，该文件甚至可以包含一个 RLE    \u003cbr /\u003e编码的图形文件，也就是大家在安装光盘启动时看到的那个；不过这个字段不甚重要，    \u003cbr /\u003e我们就略过了。    \u003cbr /\u003e\u0026#160; DEFAULT linux    \u003cbr /\u003e指定 label 是 linux 的启动选项为缺省，当然也可以是别的。    \u003cbr /\u003e\u0026#160; LABEL linux    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; kernel vmlinuz    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; append initrd=initrd26.gz ramdisk_size=1000000 vga=791    \u003cbr /\u003e这就是一个启动描述，前面的 label 大家都认识了，之后分别是指定 kernel 和内核    \u003cbr /\u003e参数，其中重要的参数就是 initrd= 指定 initrd 的文件和 ramdisk_size= 指定    \u003cbr /\u003einitrd 的尺寸上限。其余的内核参数还可能有很多，不过这里的参数我们一般都可以    \u003cbr /\u003e抄过来。这样的启动选项描述是可以有若干个的。    \u003cbr /\u003e\u0026#160; PROMPT=1    \u003cbr /\u003e这是说，向用户提示输入选择，直接回车就是缺省选项了    \u003cbr /\u003e\u0026#160; TIMEOUT=0    \u003cbr /\u003e没有时间限制，当然也可以指定一定时间之后自动进入缺省选项。    \u003cbr /\u003e好了，就这么多，如果你会用 LILO 的话，用这个一定得心应手，说实话 grub 也    \u003cbr /\u003e差不了太多。    \u003cbr /\u003e3.2 安装 SYSLINUX/ISOLINUX    \u003cbr /\u003e--------------------------    \u003cbr /\u003e配置文件写完了，现在进入实质阶段，这里，两种引导程序还是略有差别的，首先介绍    \u003cbr /\u003eSYSLINUX:    \u003cbr /\u003e首先格式化引导介质为 FAT16 格式 (软盘似乎应该是 FAT12)，我们的例子里面是 U 盘，    \u003cbr /\u003e\u0026#160; mkdosfs -F16 -I /dev/sda    \u003cbr /\u003e我们是操作整个 U 盘，而不是里面的唯一分区，这种情况不是很多见，只是手上的 U 盘    \u003cbr /\u003e比较特殊，大部分情况下，我们也可以    \u003cbr /\u003e\u0026#160; mkdosfs -F16 /dev/sda1    \u003cbr /\u003e然后挂在该 U 盘，放入我们的 syslinux.cfg 以及 kernel 和 initrd.gz，还有其他    \u003cbr /\u003e启动所需要的东东，之后 umount 该 U 盘。    \u003cbr /\u003e\u0026#160; * 执行下面操作之前，必须 umount U 盘！*    \u003cbr /\u003e然后写引导区:    \u003cbr /\u003e\u0026#160; syslinux /dev/sda (或 syslinux /dev/sda1，如果是格式化的 /dev/sda1 的话)    \u003cbr /\u003e至此就完成了。    \u003cbr /\u003e对于光盘，同样不复杂，我们用 ISOLINUX:    \u003cbr /\u003e在准备制作 ISO 的目录里添加一个子目录，比如 boot/isolinux/ ，然后放入    \u003cbr /\u003eisolinux.cfg 和一个对所有光盘都一样的 isolinux 提供的引导介质 isolinux.bin，    \u003cbr /\u003e当然还要放入相应的 kernel, initrd 等等，然后，制作 iso 的时候要使用 -b 参数:    \u003cbr /\u003e\u0026#160; mkisofs -o output.iso \\    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; -b boot/isolinux/isolinux.bin -c boot/isolinux/boot.cat \\    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; -no-emul-boot -boot-load-size 4 -boot-info-table \\    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160; for-iso-dir/    \u003cbr /\u003e最后的参数就是指定的光盘的目录了，-c 参数的那个文件是自动生成的，不用太担心，    \u003cbr /\u003e其余参数都是固定的。事实上，也常常有人用 isolinux/ 而不是 boot/isolinux/ ，    \u003cbr /\u003e这都是约定俗成的，你完全可以用自己的。这里的路径都是相对于光盘的根的，而和    \u003cbr /\u003e制作光盘时的工作目录没有关系。    \u003cbr /\u003e至此，你也会用 SYSLINUX/ISOLINUX 了。 :)    \u003cbr /\u003e四、实战 --- damn small linux + debian installer, 2 in 1 usb disk    \u003cbr /\u003e=================================================================    \u003cbr /\u003e1 下载 di 的 hd-image 里的 kernel image 和 initrd，放入 U 盘，同时把    \u003cbr /\u003ebusinesscard iso 也放进去，从 iso 里找到 isolinux.cfg，记下里面的启动    \u003cbr /\u003e设置    \u003cbr /\u003e2 下载 dsl，把 KNOPPIX 目录搬到我们的 U 盘里，把 boot/isolinux/ 里面的    \u003cbr /\u003ekernel image 和 initrd 也放入 U 盘的根目录，这时，U 盘根目录里同时有    \u003cbr /\u003e二者的启动文件了，也记住 dsl 里面的 isolinux.cfg 的启动选项。    \u003cbr /\u003e3 以其中一个的 isolinux.cfg 为基础，加入另一个的启动参数，注意 label    \u003cbr /\u003e命名不要冲突了就可以了    \u003cbr /\u003e4 umount U盘，然后对 U 盘运行 syslinux，写引导区，大功告成。    \u003cbr /\u003e如前面帖子说过，dsl 的 initrd 之中，只搜索 /dev/sda[1-9] 而不搜索    \u003cbr /\u003e/dev/sda，所以，如果如果像我们一样被迫用 /dev/sda 的话，就不得不修改一    \u003cbr /\u003e下 dsl 的 initrd 里面的 linuxrc 了，除此之外，没有什么其它值得大书特书    \u003cbr /\u003e的了。    \u003cbr /\u003eEnjoy it!\u003c/p\u003e\n","cover":"","link":"works/2006/01/14/u盘-光盘的一般引导方法与引导介质的制作/index.html","preview":"","title":"U盘/光盘的一般引导方法与引导介质的制作"},{"content":"\n\u003cp\u003e一张小光盘可以放 200MB，一个 Damn Small Linux 只有 50MB，有点浪费，   \u003cbr /\u003eyoung 建议我把两个 iso 合并一下，做成一个。    \u003cbr /\u003e今天我把 Damn Small Linux 2.1rc2 (49MM) 和 Debian 3.1r0a (Sarge) Net    \u003cbr /\u003eInstall (109M) 合并起来做了一个 ISO，既可以运行 DSL Live CD，也可以    \u003cbr /\u003e网络安装 Debian，呵呵    \u003cbr /\u003e主要操作过程：    \u003cbr /\u003e1. 从两个 iso 中提取数据文件，放在一个目录中，注意 netinstall 中有一个    \u003cbr /\u003e\u0026#160;\u0026#160; .disk/ 隐藏目录，如果没有无法安装，我吃了这个不小的亏。    \u003cbr /\u003e2. 建立一个 isolinux 目录，参考原来两张光盘的 isolinux 目录，放入    \u003cbr /\u003e\u0026#160;\u0026#160; isolinux.bin 和 isolinux.cfg，以及一些说明性信息，boot.cat 不需要;    \u003cbr /\u003e\u0026#160;\u0026#160; isolinux.bin 对所有光盘都是一样的，不用改动; isolinux.cfg 和 lilo.conf    \u003cbr /\u003e\u0026#160;\u0026#160; 有点类似，看看就会了，其他文件照猫画虎就行了，放置好 kernel 文件和    \u003cbr /\u003e\u0026#160;\u0026#160; initrd 文件    \u003cbr /\u003e3. 重新生成 md5sum.txt，为所有东西做个 md5sum    \u003cbr /\u003e4. 生成 iso:    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; mkisofs -o twins.iso -b isolinux/isolinux.bin -c isolinux/boot.cat \\    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; -no-emul-boot -boot-load-size 4 -boot-info-table -J -r \\    \u003cbr /\u003e\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160;\u0026#160; -input-charset iso8859-1\u0026#160; twins/    \u003cbr /\u003e\u0026#160;\u0026#160; 最后的 twins/ 是我生成iso的源文件目录，开始的 twins.iso 是输出的 iso    \u003cbr /\u003e\u0026#160;\u0026#160; 文件名。    \u003cbr /\u003e其实主要就是 isolinux 这个引导程序，呵呵，不是很复杂。\u003c/p\u003e\n","cover":"","link":"works/2005/12/26/damn-small-linux-+-debian-netinstall,-2-in-1/index.html","preview":"","title":"Damn Small Linux + Debian Netinstall, 2 in 1"},{"content":"Linux 系统 Debug 小记\ndate: 2005-11-14 15:01:00 +0800\ncategories:\n- works\ntags:\n- boot\n- debug\n- init\n- works\nstatus: publish\ntype: post\npublished: true\n---\n\u003cp\u003e原创文章，转载请保留出处 (bupt.org 或 gnawux.blogchina.com) 和作者 (王旭)   \u003cbr /\u003e笔记本的 Debian Sid 系统于周末在无网络条件下出现故障，经过半天的排查、分析，    \u003cbr /\u003e调整若干处，重启十数回，终于定位错误并修正，使系统恢复如初，特此记录    \u003cbr /\u003e-------------(目录)---------------    \u003cbr /\u003e1 万恶之源---背景概述    \u003cbr /\u003e2 危机浮现---案发现场    \u003cbr /\u003e2.1 现场一: 无线网卡无法启动了    \u003cbr /\u003e2.2 现场二: CPUFreqd 启动失败    \u003cbr /\u003e2.3 现场三: 硬件监视传感器失灵、快捷键停转    \u003cbr /\u003e3 蛛丝马迹---错误排查    \u003cbr /\u003e3.1 新安装的软家包没有问题    \u003cbr /\u003e3.2 降级 udev 没有效果    \u003cbr /\u003e3.3 新内核不是罪魁祸首    \u003cbr /\u003e3.4 modconf 招来最大嫌疑    \u003cbr /\u003e3.5 单用户模式找不到问题，濒临放弃    \u003cbr /\u003e4 拨云见日---定位错误    \u003cbr /\u003e4.1 udev 仍在风口浪尖    \u003cbr /\u003e4.2 udev 拒绝认罪    \u003cbr /\u003e4.3 真相只有一个    \u003cbr /\u003e5 余音绕梁---疑虑尚存    \u003cbr /\u003e5.1 为什么会这样    \u003cbr /\u003e5.2 FHS 之疑    \u003cbr /\u003e------------------------------------    \u003cbr /\u003e万恶之源---背景概述    \u003cbr /\u003e===================    \u003cbr /\u003e这是一台华硕 M2N 笔记本，Pentium M 处理器，Intel I845GMe 的芯片组/整合显卡，    \u003cbr /\u003e以及 Intel Pro/Wireless 2100 (ipw2100) 802.11b 无线网卡，典型的迅驰配置，购    \u003cbr /\u003e买一年以来，它的 40 G 硬盘上只装过一种操作系统---Debian GNU/Linux，而且只安    \u003cbr /\u003e装过一次，稳定性、性能与功能都很不错，无可非议。    \u003cbr /\u003e硬盘的分区是很讲究的老鸟的划分方式: /, /usr/, /var/, /home/ 分享硬盘，而恰恰    \u003cbr /\u003e是这种细致的划分，让系统陷入了危机，如果上天重新给我一次机会，我一定不会分这    \u003cbr /\u003e么多分区，不过这是后话了。    \u003cbr /\u003e我的所有硬件，包括快捷按钮、无线网卡、屏幕切换、多媒体控制中心等，全部工作良    \u003cbr /\u003e好，而根据电池的情况和计算机所执行的人物，我的 Dophin Pentium M CPU 的主频也    \u003cbr /\u003e可以在 600MHz 到 1500MHz 之间浮动，一年之后的今天，电池也可以使用超过四个小    \u003cbr /\u003e时，对我来说，这台爱机真是天衣无缝阿。    \u003cbr /\u003e危机浮现---案发现场    \u003cbr /\u003e===================    \u003cbr /\u003e十一月十日，光光节前夜，在 IPW2100 进入官方内核的鼓舞下，我安装了 Debian 打    \u003cbr /\u003e包的 2.6.14 内核，并且，证实该内核工作良好，系统完全正常，无须安装其他驱动和    \u003cbr /\u003e补丁，这是我第一次在笔记本上使用这么省事的内核。    \u003cbr /\u003e第二天 (11.11) 启动，系统仍然正常，无线网卡工作很好，我还用它传送了不少数    \u003cbr /\u003e据，之后，升级了系统，安装了几个关于蓝牙软件包，准备有机会借个蓝牙适配器来调    \u003cbr /\u003e教蓝牙玩玩。    \u003cbr /\u003e晚上，回家之后，系统启动后突然发现出问题了……    \u003cbr /\u003e现场一: 无线网卡无法启动了    \u003cbr /\u003e--------------------------    \u003cbr /\u003e第一个注意到的问题就是无线网卡加载失败了……这是不小的打击，刚才不是还好好的    \u003cbr /\u003e么? 使用 modconf 加载 ipw2100 模块，仍然不起作用，究竟是怎么回事呢?    \u003cbr /\u003e系统日志里没有说明这一点，重新启动之后注意到，居然是 firmware 无法加载? 我的    \u003cbr /\u003e天阿，一年前他们就已经存在了阿? 况且刚刚换内核的时候也没有说过他们有不兼容的    \u003cbr /\u003e情况阿，重新复制一次文件也毫无反应，究竟是什么原因呢，总不会是硬盘平白无故的    \u003cbr /\u003e出问题了吧……    \u003cbr /\u003e现场二: CPUFreqd 启动失败    \u003cbr /\u003e-------------------------    \u003cbr /\u003e第二个被注意到的问题是十分容易被发现的 cpufreqd 的问题，它作为处理器频率调整    \u003cbr /\u003e工具十分重要，而且，它的启动脚本中，十分厚道的用红字显式出来---启动失败。    \u003cbr /\u003e本来一次失败不容易被注意的，因为与 ipw2100 不同，cpufreqd 在我手动加载相应模    \u003cbr /\u003e块之后便正常了，只是每次启动都需要手工加载一次，这点十分不正常！于是才引起了    \u003cbr /\u003e我的极大注意。    \u003cbr /\u003e现场三: 硬件监视传感器失灵、快捷键停转    \u003cbr /\u003e--------------------------------------    \u003cbr /\u003e同时被观察到的还有硬件传感器 lm-sensors 的硬件温度采集失灵和笔记本的快捷键也    \u003cbr /\u003e都一一停止了工作，这让我觉得十分懊恼，而他们和 cpufreqd 一样，稍后加载模块就    \u003cbr /\u003e可以工作了，只是每次加载都无法保存，似乎 /etc/modules 根本就没人理。    \u003cbr /\u003e蛛丝马迹---错误排查    \u003cbr /\u003e===================    \u003cbr /\u003e周五 (11.11) 当天晚上比较累了，于是就没有解决，问题一直拖到周日(11.13) 下午    \u003cbr /\u003e才正式开始解决，这也就是所谓的“惊魂半日”，在劫后余生的今天，我回忆着把主要    \u003cbr /\u003e的调试过程记录下来，重复一次显然不需要半天，不过当时的复杂考虑、犹豫、斗争等    \u003cbr /\u003e夹杂着的情况下，用这么长时间还是挺正常的。    \u003cbr /\u003e新安装的软家包没有问题    \u003cbr /\u003e----------------------    \u003cbr /\u003e从出问题的先后顺序看，系统在出问题前后最大的变化莫过于更新了几个软件包、安装    \u003cbr /\u003e了一些蓝牙相关的软件包，而其中恰好有一个是有关 firmware 的，它们就首当其冲的    \u003cbr /\u003e成为了我的第一批刀下之鬼。    \u003cbr /\u003e闲话少说，根据 /var/log/aptitude，直接删掉新安装软件包，使用 purge，让它随风    \u003cbr /\u003e去，不留一点痕迹 (当是显然是没有现在这么轻松的心情了)。    \u003cbr /\u003e重启系统……居然不管用! 无奈下只好考虑降级刚刚升级的软件包，可是它们看起来实    \u003cbr /\u003e在是太无辜了，根本就不关系统和硬件什么事，于是，只好转移目光。    \u003cbr /\u003e降级 udev 没有效果    \u003cbr /\u003e------------------    \u003cbr /\u003e近来硬件相关的系统级软件包当中，udev 无疑是最具偶像气质的一个，因为彻底删除    \u003cbr /\u003e了 hotplug，其出镜率一直居高不下，bug 多多也是此君最近表现枪眼的原因，自然    \u003cbr /\u003e的，我对他投上怀疑的目光也是不无道理的。    \u003cbr /\u003e迄今为止，我对系统调整仍然是软件包级别的，如果我就此深入调查一下的话，可能可    \u003cbr /\u003e以节省至少两个小时的时间，不过，处理问题总要循序渐进的，以我的水平和对问题的    \u003cbr /\u003e认识，不可能先验地直接去 Debug。    \u003cbr /\u003e于是，我抱着侥幸心理，利用 /var/cache/apt/archives 目录下的藏品，把 udev 强    \u003cbr /\u003e行降级，结果，根据上面的现象其实就已经注定这种尝试是不会有结果的，udev 包其    \u003cbr /\u003e实根本就没有变动过的。    \u003cbr /\u003e新内核不是罪魁祸首    \u003cbr /\u003e------------------    \u003cbr /\u003e那么……会不会是新内核惹的祸呢? 这是我不愿意做的假设，我对这个官方内核包还是    \u003cbr /\u003e很有信心的，可是事到如今，我也只好拿起怀疑一切的态度来了。    \u003cbr /\u003e使用旧内核启动，问题不减当年，更换内核参数，仍然是问题如故……真是有些万念俱    \u003cbr /\u003e灰的感觉阿，难道让我放弃么?!    \u003cbr /\u003emodconf 招来最大嫌疑    \u003cbr /\u003e--------------------    \u003cbr /\u003e想想这两天还动过些什么--- modconf! 用它加载的模块在后来证明根本无效，包存在    \u003cbr /\u003e/etc/modules 中的模块从来没有在启动过程中顺利启动的，这个东西已经把很多重复    \u003cbr /\u003e的内容写到 /etc/modules 里面了，难道是它干的?    \u003cbr /\u003e几乎一定是它了，去掉老的 /etc/modules，重新手动创建一个，只写我最需要的几个    \u003cbr /\u003e模块，不再用 modconf 了，而是用 modprobe 一个一个来。    \u003cbr /\u003e然后用 module-init-tools 的启动搅拌试一次，可以加载这几个模块，好了，重新启    \u003cbr /\u003e动。    \u003cbr /\u003e打击再一次降临，上面的修改，架空 modconf 根本没有取得效果，我仍然停留在原地，    \u003cbr /\u003e甚至可能让情况更糟了。    \u003cbr /\u003e单用户模式找不到问题，濒临放弃    \u003cbr /\u003e------------------------------    \u003cbr /\u003e使用单用户模式进入系统，问题丝毫没有变化，我开始把做过的大多数调整恢复，盼望    \u003cbr /\u003e着新一次的系统更新可以还给我一个干净的系统。    \u003cbr /\u003e不过，modules 刚才的问题还困扰着我，我仍然在观察着 /etc/rcS.d/ 的内容，    \u003cbr /\u003emodules-init-tools 为什么会在那个时候不工作呢? 这个问题我似乎曾经在别的什么    \u003cbr /\u003e地方遇到过啊……    \u003cbr /\u003e拨云见日---定位错误    \u003cbr /\u003e===================    \u003cbr /\u003e这种时候放弃是一个选择，但我还有方法没有尝试，更多的蛛丝马迹仍然在不断地暴    \u003cbr /\u003e露出来，我隐隐的感到---udev 还是有问题的。    \u003cbr /\u003eudev 仍在风口浪尖    \u003cbr /\u003e-----------------    \u003cbr /\u003e似乎有某个软件包宣称找不到设备，难道 udev 仍然不正常么? 来到 /dev/ 下面一    \u003cbr /\u003els，吓了我一大跳---这么多文件，难道 udev 没有工作么?    \u003cbr /\u003e大家知道，根据 hal (硬件抽象层) 提供的规则，udev 会在 /dev/ 下面创建一个    \u003cbr /\u003edisk/ 目录，可是事实是，现在这个目录并不存在，可以得到结论：udev 根本就没工    \u003cbr /\u003e作!    \u003cbr /\u003e那么，启动过程中的 udev 到底发生了什么呢? dmesg 和 syslog 都没有给我答案，    \u003cbr /\u003e我试试手动启动一下 udev，看看会怎么样。    \u003cbr /\u003e/etc/init.d/udev start 运行的结果是，该程序已经在运行中了---那它在干什么?!    \u003cbr /\u003eudev 拒绝认罪    \u003cbr /\u003e-------------    \u003cbr /\u003e忽然我在又一次启动中注意到，udev 抱怨说它无法加载 tmpfs，所以无法启动。笑    \u003cbr /\u003e话! /dev/shm 的 249MB 的 tmpfs 在那里乖乖的，你居然说挂不上! 作为愤青的我当    \u003cbr /\u003e然不能接受，可是怎么才能知道这是为什么呢?    \u003cbr /\u003e我把 /etc/udev/udev.conf 里面的日志记录级别从 ``err'' 调整到了 ``info''，    \u003cbr /\u003e冀望于它能够把更多信息写到 syslog 里面。不过，事实又一次证明了敌人的强大和    \u003cbr /\u003e我的不成熟，把希望寄托到这里是徒劳的，syslog 里面连挂不上 tmpfs 都没写，那    \u003cbr /\u003e只在系统启动时 post 出来的信息中存在……    \u003cbr /\u003e局面似乎僵持在这里了    \u003cbr /\u003e真相只有一个    \u003cbr /\u003e------------    \u003cbr /\u003e不过，我还有杀手锏没有亮出来呢!    \u003cbr /\u003e我注意到，udev 在 /etc/rcS.d/ 之中的位置是第三个，仅仅在 glibc 和    \u003cbr /\u003emountvirtualfs 之后，我们不妨手动启动一次系统，这样，谁犯的错误就是``秃子    \u003cbr /\u003e头上的虱子''---明摆着的了。    \u003cbr /\u003egrub 中设定内核参数 init=/bin/sh，这是绕过复杂登录过程的看家本领，如果密码    \u003cbr /\u003e丢失或是什么其它特殊情况，这个手段是绕过 /sbin/init 的最好手段。不要说密码    \u003cbr /\u003e了，任何守护进程都没有开过。    \u003cbr /\u003e这时，系统启动后得到了 root 权限的 shell 提示符，我已经准备好解决问题了，    \u003cbr /\u003e进入 /etc/rcS.d，一个一个的用 start 参数运行这些脚本，不多，只要三个就可以    \u003cbr /\u003e发现问题的。    \u003cbr /\u003e事实是，当运行到第二个的时候，也就是 mountvirtualfs，加载虚拟文件系统时，    \u003cbr /\u003e问题已经产生，因为缺少 libpcre3.so，无法挂载!!!    \u003cbr /\u003e这个错误其实刚才我已经注意到了，但它是 Perl 5 兼容政则表达式库，会那么关键    \u003cbr /\u003e么? 我居然忽略了它! 是事实，正是它的缺席导致了 grep -E 运行出错，既无法挂载    \u003cbr /\u003e虚拟文件系统，也会让 udev 出错，而它原本是在 /usr/lib/ 之下的，在 /usr/ 挂    \u003cbr /\u003e载之前是不可能找到的。    \u003cbr /\u003e解决问题很简单，复制一份到 / 分区里面的 /usr/lib/, 这个目录在 /usr 挂载之后    \u003cbr /\u003e会被覆盖，但在挂载之前，它独自支撑起了这个系统。    \u003cbr /\u003e重新起动……振奋人心的一刻终于来到了！问题解决，一切正常了！    \u003cbr /\u003e余音绕梁---疑虑尚存    \u003cbr /\u003e===================    \u003cbr /\u003e为什么会这样    \u003cbr /\u003e------------    \u003cbr /\u003e时至今日，我仍然不知道为什么会这样，是脚本的 grep 参数变化了，还是 grep 变    \u003cbr /\u003e化了，还是 libpcre3 变化了才引发的半日惊魂? 这个问题从何而来的让我百思不得    \u003cbr /\u003e其解，因为从软件包变化上，这个问题实在难以引人注意。    \u003cbr /\u003eFHS 之疑    \u003cbr /\u003e--------    \u003cbr /\u003e可是根据 Linux 文件系统层次标准 (debian-policy 包中)，/usr 不需要在系统启动    \u003cbr /\u003e中始终存在，甚至应该可以位于 NFS 分区上的，为什么会这样呢? 究竟是哪里的问题    \u003cbr /\u003e呢。    \u003cbr /\u003e现在，经历劫后余生，我也希望大家要主义，如果没有特殊情况，/usr 和 / 还是放到    \u003cbr /\u003e同一个分区之中吧，免生事端。    \u003cbr /\u003e补充    \u003cbr /\u003e====    \u003cbr /\u003e目前(11.14 星期一，问题发生后的第一次更新系统)，Debian 已经升级了 grep 软件包，    \u003cbr /\u003e去掉了对 libpcre 的依赖，从而解决了这一问题。\u003c/p\u003e\n","cover":"","link":"misc/2005/11/14/半日惊魂---linux-系统-debug-小记/index.html","preview":"","title":"半日惊魂"},{"content":"\n\u003cp\u003e原文出处 http://www.kernel.org/pub/linux/utils/kernel/hotplug/udev-FAQ   \u003cbr /\u003e中文翻译 王旭 \u003ca href=\"http://gnawux.blogchina.com\"\u003ehttp://gnawux.blogchina.com\u003c/a\u003e (如今是 \u003ca href=\"http://wangxu.me/blog/\"\u003ehttp://wangxu.me/blog/\u003c/a\u003e 了)\u003c/p\u003e\n\n\u003cp\u003e本文档遵循 GPL 2 及以后版本发布，修改、发布请保持许可证不变    \u003cbr /\u003e问: udev是什么? 它的目的何在?    \u003cbr /\u003e答: 看看那篇 OLS 2003 上的有关 udev 的文章吧，可以在 docs 目录里找到，也能在这    \u003cbr /\u003e里找到:    \u003cbr /\u003eOLS 2003 上还有一个关于 udev 的幻灯片，可以在这里找到:    \u003c/p\u003e\n\n\u003cp\u003e问: udev 和 devfs 是什么关系   \u003cbr /\u003e答: udev 完全在用户态 (userspace) 工作，利用设备加入或移除时内核所发送的    \u003cbr /\u003ehotplug 事件 (event) 来工作。关于设备的详细信息是由内核输出 (export) 到位    \u003cbr /\u003e于 /sys 的 sysfs 文件系统的。所有的设备命名策略、权限控制和事件处理都是在    \u003cbr /\u003e用户态下完成的。与此相反，devfs 是作为内核的一部分工作的。    \u003c/p\u003e\n\n\u003cp\u003e问: 如果 udev 不能完成所有 devfs 的工作的话，为什么把 devfs 标记为   \u003cbr /\u003eOBSOLETE/removed?    \u003cbr /\u003e答: 引用 Al Viro (Linux VFS 内核维护者):    \u003cbr /\u003e- devfs 所做的工作被确信可以在用户态来完成。    \u003cbr /\u003e- devfs 被加入内核之时，大家寄望它的质量可以迎头赶上。    \u003cbr /\u003e- devfs 被发现了一些可修复和无法修复的 bug。    \u003cbr /\u003e- 对于可修复的 bug，几个月前就已经被修复了，其维护者认为一切良好。    \u003cbr /\u003e- 对于后者，同样是相当常一段时间以来没有改观了。    \u003cbr /\u003e- devfs 的维护者和作者对它感到失望并且已经停止了对代码的维护工作。    \u003c/p\u003e\n\n\u003cp\u003e问: 但是当一个并不存在的 /dev 节点被打开的时候，udev 并不能如 devfs 一样自动加   \u003cbr /\u003e载驱动程序。    \u003cbr /\u003e答: 的确如此，但 Linux 的设计是在设备被发现的时候加载模块，而不是当它被访问的时    \u003cbr /\u003e候。    \u003c/p\u003e\n\n\u003cp\u003e问: 不过等等，我确实希望 udev 可以在不存在的节点被打开的时候自动加载驱动。这是   \u003cbr /\u003e我使用 devfs 的唯一原因了。给 udev 增加这个功能吧。    \u003cbr /\u003e答: 不，udev 是用来管理 /dev 的，不是用来加载内核驱动的。    \u003c/p\u003e\n\n\u003cp\u003e问: 嗨，求你们了。这不难做到的。   \u003cbr /\u003e答: 这么个功能对于一个配置正确的计算机是多余的。系统中所有的设备都应该产生    \u003cbr /\u003ehotplug 事件、加载恰当的驱动，而 udev 将会注意到这点并且为它创建对应的    \u003cbr /\u003e设备节点。如果你不想让所有的设备驱动停留在内存之中，应该使用其它东西来    \u003cbr /\u003e管理你的模块 (如脚本, modules.conf, 等等) 这不是 udev 的工作。    \u003c/p\u003e\n\n\u003cp\u003e问: 但是我真的喜欢那个功能，还是加上吧   \u003cbr /\u003e答: devfs 用的方法导致了大量无用的 modprobe 尝试，以此程序探测设备是否存在。    \u003cbr /\u003e每个试探性探测都新建一个运行 modprobe 的进程，而几乎所有这些都是无用的。    \u003c/p\u003e\n\n\u003cp\u003e问: 我喜欢 devfs 的设备文件命名方式，udev 可以这样命名么?   \u003cbr /\u003e答: 可以，udev 可以使用 /dev 的命名策略来创建节点。通过一个配置文件，可以把内    \u003cbr /\u003e核缺省的名字映射到 devfs 的名字。可以看看 udev 中带的 udev.rules.devfs 文    \u003cbr /\u003e件。    \u003cbr /\u003e注意: devfs 的命名方式是不被建议并且不被官方支持的，因为它所用的简单枚举设    \u003cbr /\u003e备的方式在设备可能被随时加入或删除的情况下确实是一个比较笨的方法。这些编号    \u003cbr /\u003e带给你的将只有麻烦，而并不能用来确定设备。看看那个永久性磁盘 (persistent    \u003cbr /\u003edisk) 的规则就知道如何在用户态下正确的做这件事，而不是傻傻地列出设备。    \u003c/p\u003e\n\n\u003cp\u003e问: udev 可以为哪些设备创建节点?   \u003cbr /\u003e答: 所有在 sysfs 中显示的设备都可以由 udev 来创建节点。如果内核中增加了其它设    \u003cbr /\u003e备的支持，udev 也就自动地可以为它们工作了。现在所有的块设备都在被支持之列，    \u003cbr /\u003e大部分的主字符设备也是被支持的。内核开发者们正致力于让所有的字符设备都被支    \u003cbr /\u003e持。可以到 linux-kernel 邮件列表上寻找补丁或是查看补丁的状态。    \u003c/p\u003e\n\n\u003cp\u003e问: udev 是否会去掉匿名设备数量的限制?   \u003cbr /\u003e答: udev 完全工作于用户态。如果内核支持了更多的匿名设备，udev 就会支持。    \u003c/p\u003e\n\n\u003cp\u003e问: udev 是否会支持符号链接?   \u003cbr /\u003e答: udev 现在就支持符号链接，每个设备节点拥有多个符号链接也是被支持的。    \u003c/p\u003e\n\n\u003cp\u003e问: udev 如何处理 /dev 文件系统?   \u003cbr /\u003e答: 建议使用一个每次启动系统的时候重新创建的 tmpfs 作为 /dev 的文件系统。不过    \u003cbr /\u003e实际上 udev 并不关心那种文件系统在被使用。    \u003c/p\u003e\n\n\u003cp\u003e问: 在 init 运行之前，udev 如何处理设备?   \u003cbr /\u003e答: udev 可以被放入 initramfs 之中，并在每个设备被发现的时候运行。也可以让    \u003cbr /\u003eudev 工作在一个真的根分区被加载之后根据 /sys 的内容创建的初始 /dev 目录    \u003cbr /\u003e之中。    \u003c/p\u003e\n\n\u003cp\u003e问: 我是否可以利用 udev 在一个 USB 设备被加载的时候自动加载上这个设备?   \u003cbr /\u003e答: 技术上讲是可以的，但是 udev 不是用于这个工作的。所有的主流发布版 (distro)    \u003cbr /\u003e都包含了 HAL (http://freedesktop.org/wiki/Software_2fhal) 用于这个工作，它    \u003cbr /\u003e也是专门用于监视设备变更的，并且集成进入了桌面软件。    \u003cbr /\u003e换个角度说，这可以简单的通过 fstab 来实现:    \u003cbr /\u003e/dev/disk/by-label/PENDRIVE /media/PENDRIVE vfat user,noauto 0 0    \u003cbr /\u003e这样，用户可以用如下命令来访问设备:    \u003cbr /\u003e$mount /media/PENDRIVE    \u003cbr /\u003e同样不需要管理员权限，但却拥有了设备的全部访问权限。使用永久性磁盘链接    \u003cbr /\u003e(label, uuid) 将可以指定同一设备，无论其实际上的内核名字是什么。    \u003c/p\u003e\n\n\u003cp\u003e问: 有什么我需要注意的安全问题么?   \u003cbr /\u003e答: 当使用动态设备编号的时候，一个给定的主/从设备号可能在不同时间对应不同的设    \u003cbr /\u003e备，如果一个用户拥有对这个节点的访问权限，并且可以创建一个到这个节点的硬链    \u003cbr /\u003e接，他就可以如此得到一个这个设备节点的拷贝。当设备被移除之后，udev 删除了    \u003cbr /\u003e设备节点，但硬链接依然存在。如果这个设备节点之后被重新使用不同的访问权限被    \u003cbr /\u003e创建的时候，其硬链接仍然可以使用先前的访问权限来访问。    \u003cbr /\u003e(同样的问题也存在在使用 PAM 改变访问权限的 login 上。)    \u003cbr /\u003e简单的解决方案就是通过把 /dev 放在 tmpfs 这样的单独的文件系统之上来防止建    \u003cbr /\u003e立硬链接。    \u003c/p\u003e\n\n\u003cp\u003e问: 我有其他的关于 udev 的问题，我应该问谁?   \u003cbr /\u003e答: linux-hotplug-devel 正是问这些的地方。邮件列表的地址是    \u003cbr /\u003elinux-hotplug-devel@lists.sourceforge.net    \u003cbr /\u003e加入邮件列表的相关信息可以在如下地址找到    \u003cbr /\u003e邮件列表的上的既往讨论记录可以在下面地址找到\u003c/p\u003e\n","cover":"","link":"translation/2005/10/16/udev-faq-中文翻译/index.html","preview":"","title":"udev-FAQ 中文翻译"},{"content":"\n\u003cp\u003e那天偶和偶在版面上说相声的搭挡 LeoVirgo 都提到了根据 debian 的   \u003cbr /\u003ekernel-img.conf    \u003cbr /\u003e更新完内核后会自动调用 update-grub 来更新引导程序，就觉得这个东西一定可以    \u003cbr /\u003e配置，否则每次总要改写一下 menu.lst 来修改启动内核参数毕竟不方便    \u003cbr /\u003e恰逢今天为了上一贴的那个网卡驱动，编译了一次内核，就想着看看这个东西怎么工作    \u003cbr /\u003e（阿？您问怎么看阿，当然是 man 了，男人嘛，如果是女同胞可以 alias 一下，    \u003cbr /\u003e来个 woman 什么的）    \u003cbr /\u003e发现，menu.lst 里面就有关于 update-grub 的设置，LeoVirgo 一定知道自动    \u003cbr /\u003e修改的 menu.lst 上面有一大段注释吧，以    \u003cbr /\u003e### BEGIN AUTOMAGIC KERNELS LIST    \u003cbr /\u003e开始    \u003cbr /\u003e我抄一段过来大家就知道是什么意思了    \u003cbr /\u003e## ## Start Default Options ##    \u003cbr /\u003e## default kernel options    \u003cbr /\u003e## default kernel options for automagic boot options    \u003cbr /\u003e## If you want special options for specifiv kernels use kopt_x_y_z    \u003cbr /\u003e## where x.y.z is kernel version. Minor versions can be omitted.    \u003cbr /\u003e## e.g. kopt=root=/dev/hda1 ro    \u003cbr /\u003e# kopt=root=/dev/hda1 ro acpi_sleep=s3_bios resume=/dev/hda2    \u003cbr /\u003e看到了不？这个就是设置内核参数的，我把对我有用的    \u003cbr /\u003eacpi_sleep=s3_bios resume=/dev/hda2    \u003cbr /\u003e这下，自动生成的配置文件里面就有我的自定义内核参数了，    \u003cbr /\u003e还有这个    \u003cbr /\u003e## should update-grub create alternative automagic boot options    \u003cbr /\u003e## e.g. alternative=true    \u003cbr /\u003e##\u0026#160;\u0026#160;\u0026#160;\u0026#160; alternative=false    \u003cbr /\u003e# alternative=false    \u003cbr /\u003e可以指定一个其他的启动方式，缺省文件里面是单用户模式，偶好好的用机器，    \u003cbr /\u003e要单用户模式做什么？出了问题 grub 还有命令行呢，去掉之，于是写成 false    \u003cbr /\u003e怎么样，明白了吧，还有其它设置，呵呵，自己打开 menu.lst 看看就知道了，    \u003cbr /\u003e如果用的不是 Debian，那我就不负责了;P\u003c/p\u003e\n","cover":"","link":"works/2005/10/14/debian下的grub启动选项管理/index.html","preview":"","title":"debian下的grub启动选项管理"},{"content":"\n\u003cp\u003e前两天出去讲了一回课，内容是WCDMA核心网与业务，是代表实验室去讲的。第一次做这种公司培训的讲师，心里难免有些忐忑，好在实验室的其他老师 和师兄师姐们都积极相助，出谋划策或是在知识上给予了很多帮助，一整天的课程顺利完成了，虽然不足很多，但第一次讲课，没有什么纰漏也算是个成功吧，这里 记录一下一些感想，希望下次可以做得更好。\u003c/p\u003e\n\n\u003ch3\u003e准备要充分\u003c/h3\u003e\n\n\u003cp\u003e准备工作是第一重要的，尤其是对于我们这些经验不够丰富的人来说，这里有很多常见的问题都是应该在开始之前避免的\u003cbr /\u003e\n\n\u003ch4\u003e常见问题\u003c/h4\u003e\n\n\u003cp\u003e最需要避讳的问题就是讲座的幻灯片里的内容自己不清楚，有些很生僻的缩写可能在图片的某个角落里，如果解释到这张幻灯片的时候突然发现这个东东不知道是什么，讲课的心情和讲课的效果都会大打折扣，但实际上，这确实是非常常见问题。  \u003cbr /\u003e要 了解幻灯片的内容，特别是片子不完全是自己制作的时候，常常会出现这样的问题---前面的幻灯片上解释过的东西在下一张幻灯片里出现，重复一遍显然不恰 当，但空翻过去也不应该。这次讲座因为多次研读了幻灯片的内容，基本没有出现类似的问题，对于后面没有解释的内容，可以在概述中就插入一些解释，而其它的 东西可以引导到下面的幻灯片介绍。  \u003cbr /\u003e主线必须清晰，当备课倒了一定精细的程度的时候，这时准备的粒度很细，往往是一张一张幻灯片的准备，关联也往往是前后一张幻灯片的内容，但是，线索实际上才是最重要的，围绕着线索，自然可以山南海北的闲聊，但一定会回到主线上来。\u003cbr /\u003e\n\n\u003ch4\u003e备课的要点\u003c/h4\u003e\n\n\u003cp\u003e 在我看来，备课的要点就是细致，主题思想当然要明确，不过明确的思想要落实到细致的准备中去，哪一张幻灯片说什么内容要明确，哪些内容说清，哪些内容板书都要心里有数。如果在哪里闲聊，也要准备好了，看似漫不经心的内容都必须安排好了，这才能有备无患。  \u003cbr /\u003e在 围绕幻灯片准备的同时，要准备好充足的参考材料，最好把它们整理在一起，能及时、方便地取出来，这样，一方面在讲的时候可以旁征博引，另一方面，在有人提 出细节问题的时候也可以更从容的应对，也就是说，准备的内容越深厚，心里就越有数，即使没有直接用上，也可以帮助自己提高信心和发挥。  \u003cbr /\u003e这次，我不仅前后串了所有的内容，还用wiki制作了部分幻灯片串讲的内容，并且准备了一个专门的参考幻灯片，把可能涉及到的一些流程和具体内容加入进来，防止出现意外。如果不是时间很紧张，我想我会做得更好些。\u003cbr /\u003e\n\n\u003ch3\u003e时间的使用要注意\u003c/h3\u003e\n\n\u003cp\u003e时间实际上不太可能不够用，而且我们的目的是讲明白一些知识，所以，速度的控制是非常重要的。对我来说，最大的问题是来自于语速的控制，在这个之外，我还向各位老师请教了一些其它的控制速度的方法。\u003cbr /\u003e\n\n\u003ch4\u003e板书\u003c/h4\u003e\n\n\u003cp\u003e 冯 老师的建议。我们的幻灯片有的内容比较简略，不一定能够达到内容的所有效果，而且，动画过多的幻灯片不一定效果很好。这样，结合板书是一个很好的手段，一 方面会讲解得更清楚，让下面的学生更容易理解思路，同时帮助大家改换一下跟随幻灯片的节奏，也能防止睡着；另一方面，对于讲座的人来说，加入板书可以延长 讲座的时间，调整一下自己的情绪，这个，比较阴险，不太容易看穿，呵呵。  \u003cbr /\u003e当然，板书一定要是事先有所准备的，尽量不要出现什么纰漏。\u003cbr /\u003e\n\n\u003ch4\u003e闲话\u003c/h4\u003e\n\n\u003cp\u003e 这个是王莹师姐的建议。适当的引入一些关系不是非常密切的闲话，实际上对于气氛的调整是很有好处的，一味地追求简洁往往适得其反。因此，我们加入一些人性化的内容，聊一些相关但有有些距离的，甚至是非技术性的内容还是很有效果的。  \u003cbr /\u003e当然，闲话的火候很重要，废话绝对不能太多，对于我这样的初次上阵的人来说，还是不敢加入太多的闲话，免得控制不住场面。而且，闲话看似随意，实际几乎都是设计好的，想想连上课要讲什么笑话都要预先设计，备课的难度也真是够高的了。\u003cbr /\u003e\n\n\u003ch3\u003e语言上要注意\u003c/h3\u003e\n\n\u003cp\u003e 语言上面，主要是语速和清晰度的问题，我个人的一个问题就是在讲座的时候会说很多习惯性的口头语，连自己都注意到了，这个是一个很重要的不足吧，下次一定要主义一些。\u003cbr /\u003e\n\n\u003ch3\u003e结论\u003c/h3\u003e\n\n\u003cp\u003e 讲座终于结束了，在两天的“王老师”的角色中回来，真的觉得挺累的，做老师不容易，备课很累，上课更不容易，知识掌握一定要真的达到远远超出讲课的内容，再加上精心的准备，才能做到游刃有余，我离这个的距离还很远，仍须努力阿。真的很感谢给予帮助的老师和师兄师姐们。\u003c/p\u003e\n","cover":"","link":"works/2005/08/10/讲课感言/index.html","preview":"","title":"讲课感言"},{"content":"\n\u003cp\u003e或许这是一种宿命，一种轮回，整整七年，得到你的时候，是1998年7月26日，失去你的时候，是2005年7月25日，这叫我怎么能不感伤，如何能够平复呢?   \u003cbr /\u003e七年来，我的辛酸荣辱，你全都一一见证；七年来，你的一颦一笑，我无不历历在目。\u003c/p\u003e\n\n\u003cp\u003e你是一辆深蓝色过渡到黑色的捷安特单速轻便型山地车，1998年7月26日，我为了我的清华梦把你买来，当天为你在樱桃园的宣武区交通队上了牌照``京 宣武 0591636''，从此，你就和我相依为命了。\u003c/p\u003e\n\n\u003cp\u003e我与你一起去清华送了推荐表，却和你一起取回了工大的录取通知书，从此，你我往返于工大与我家的大杂院，往返于工大4号楼和一实、信息楼还有校外的超市……   \u003cbr /\u003e2001年底，我们第一次来到了北邮，我告诉你，我要来这里上研究生。2002年，我们终于把自己的家安在了这里，这时你已经四岁了。\u003c/p\u003e\n\n\u003cp\u003e整整一年，我们来往于大运村和明光村，还记得我们为了不迟到而风驰电掣么，还记得我们晚归时为了疏解压抑唱起的《白鸽》么？非典的日子，我们也不曾休息，   \u003cbr /\u003e往返于教一楼和大运村。你有了新的名字``040 100 487''。\u003c/p\u003e\n\n\u003cp\u003e接着，我们不再光顾大运村了，我们依然在学校和明光村小区之间穿梭，直到2004年4月，你的足迹到达了交大，你的主人第一次有了女朋友，而你从此也在后座上有了一个长久的坐客。几乎每天晚上，你都会和我一起飞一样地回到北邮29号楼。\u003c/p\u003e\n\n\u003cp\u003e当我带着兴奋与迷茫踏上飞机的时候，2004年10月到2005年1月，你也度过了一段孤独的日子，等到回来后，你来到了学8楼下，你的女主人不久也搬出了交大，来到了   \u003cbr /\u003e蓟门里。学8楼，中德所，蓟门里和中间大大的蓟门桥，从此都成了你最熟悉的地方。\u003c/p\u003e\n\n\u003cp\u003e在这七年里，多少你熟知的和你一模一样的同胞兄弟接二连三的莫名失踪，而你成了一代传奇，但我，在一旁没有半点喜悦，只是为你担心，早就知道这一天迟早会   \u003cbr /\u003e来。\u003c/p\u003e\n\n\u003cp\u003e就如同人终有一死，却总是留恋人世无法释怀，我虽然早就猜到了这个结局，却还是在面对这个结局的时候有些怅然。\u003c/p\u003e\n\n\u003cp\u003e还记得么，那年冬天在一次事故中，我从你身上摔出去，腿几乎无法弯曲，却不愿意告诉任何人，因为我相信，那个在实验室度过的寒假可能改变我的一生，我不能   \u003cbr /\u003e放弃这个机会。还记得么，我们一起在的暴雨中前行，去给你的女主人送雨伞，只为让她知道，不论在什么情况下,都有个肩膀值得她依靠……所有这些只有你我分享的秘密，如今，已经不再属于你我了……\u003c/p\u003e\n\n\u003cp\u003e安息吧，陪我七年的忠实兄弟、朋友、老仆，不用指望能有重逢的一天了，对坏人期冀任何希望，或是渴求任何畸形的奇迹都是幼稚的，我们就此道别吧。   \u003cbr /\u003e安息吧，陪我七年的忠实兄弟、朋友、老仆，你可能很快就会有个新主人了，他可能和我一样呵护你，但已经无法给你往日的荣耀了，你将不再是一个传奇，而是永    \u003cbr /\u003e远地背上一个名字---``黑车''。    \u003cbr /\u003e安息吧，陪我七年的忠实兄弟、朋友、老仆，永远不会有一辆黑车来侮辱曾经属于你的位置的，我深深明白，你是因为这种肮脏的交易而被迫离我而去的，我怎么会    \u003cbr /\u003e自己来助长这种罪恶呢?!    \u003cbr /\u003e安息吧，陪我七年的忠实兄弟、朋友、老仆，希望你能飞往天堂，一个有车来车往，却不曾有肮脏的黑车交易的天堂。    \u003c/p\u003e\n\n\u003cp\u003e你七年来的兄弟、朋友、主人 王旭   \u003cbr /\u003e2005年7月25日追记\u003c/p\u003e\n","cover":"","link":"works/2005/07/25/别了，陪我七年的忠实兄弟、朋友、老仆/index.html","preview":"","title":"别了，陪我七年的忠实兄弟、朋友、老仆"},{"content":"\n\u003cp\u003e\n\n\u003cli\u003e1 讲演的时候要注意时间与速度\u003c/li\u003e\u003c/p\u003e\n\n\u003cp\u003e语速要慢，人紧张或担心时间不足的时候会自然的加快语速，所以讲演的时候一定要刻意放慢语速，如果整体需要加快，可以跳过内容或概述内容，但不要加快语速。\u003c/p\u003e\n\n\u003cp\u003e要注意控制和分配时间，我想如果你心里没数的话可以和答辩秘书说一下，在固定的时间暗示一下，如果他和我一样好的话会帮助你的，而在一般情况下，答辩秘书因为怕中断你的讲演，不愿意提示你的。\u003c/p\u003e\n\n\u003cp\u003e注意使用穿插的大纲或导航栏之类的手段来提示听众讲演的进行程度，否则给人一种遥遥无期的感觉，比较容易睡着。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e2 讲演的肢体语言\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e准备一支激光笔，这样可以方便指到你要说明的地方，用手指需要走上走下不方便，而且会挡住一部分幻灯片，而且如果你身材不好的话会让人产生反感（这个不是昨天的问题哦，昨天讲的人身材都不错）。\u003c/p\u003e\n\n\u003cp\u003e用激光笔要注意，首先不要一直指着，因为手会发抖，这会让人觉得你紧张，虽然基本上就是紧张，但其实不紧张也不能保证手不抖；另外不要在手中玩弄教鞭或激光笔。\u003c/p\u003e\n\n\u003cp\u003e不要太拘束，也不要太随便，晃来晃去的不好。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e3 有关幻灯片\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e尽量用白色或接近白色的背景，而且最好是白底黑字，加重的时候用红色字。个人推荐黑体，比较好看。这样整体亮度比较高。中德所这边的投影仪效果比较好，这个问题不突出，但WTI的投影仪亮度就不是很高，这个问题就比较显著了。\u003c/p\u003e\n\n\u003cp\u003e注意跳转，一定要插讲的话就做在中间，不用跳转到最后，那样一不小心幻灯片就退出了，效果不好。如果非要加跳转，一定要记住如何能转回来。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e4 要试讲\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e一定要有两到三次试讲，至少有一次是为了查错的，而另一次是为了计算时间的，最好再有一次，完全预演。准备充分才能游刃有余。\u003c/p\u003e\n\n\u003cp\u003e好了，就这么多吧，希望大家都能有更好的讲演技巧，这是一门不可轻视的技术，对于所有研究生都是必要的。同时，多练才是解决之道，希望大家能得到并珍惜更多的讲演机会。\u003c/p\u003e\n\n\u003cul\u003e\n\n\u003cli\u003e\n\n\u003cp\u003e总结\u003c/p\u003e\n\n\u003c/li\u003e\n\n\u003c/ul\u003e\n\n\u003cp\u003e 最后，感谢康老师给了我这个机会，听了这么多同学的答辩 ^_^ 也感谢大家看到这里，祝大家春天愉快，多出去玩，少遇到沙尘暴\u003c/p\u003e\n","cover":"","link":"works/2005/03/22/答辩观感/index.html","preview":"","title":"答辩观感"},{"content":"\n\u003cp\u003e 本文2004年12月27日发于本人在csdn的blog，之前发于北邮真情流露BBS，目前本文内容依然有效。 \u003c/p\u003e\n\n\u003cp\u003e一直用 LaTeX Suite 写文档，里面有一个折叠的功能，可以把成段的文章用一行高亮显示，节省空间，看起来条理性也更强，今天心血来潮，看了一下vi的文本 折叠功能，可能是 vim 特有的，肯定很多人还没用过吧。\u003c/p\u003e\n\n\u003cp\u003e打开一个比较长的文档，跟我做 zfG , 现在是不是全部文章都折叠成一行，高亮显示了？\u003c/p\u003e\n\n\u003cp\u003e这里 zf 是创建一个 folder，G 是移动到文件尾部，这样也就全都装进来了，也可以用其他的移动手段，呵呵\u003c/p\u003e\n\n\u003cp\u003e然后 zo 就是打开折叠文本，zc 是再把它们折叠起来。如果有很多折叠文本，用zr 就把它们全部打开了，zm 是把它们全部折叠。如果有嵌套的折叠文本，可以用zR 和 zM 一次完成打开和关闭。zn 是关闭折叠功能，zN 是重新打开折叠功能，zi是在两者间切换。\u003c/p\u003e\n\n\u003cp\u003e折叠成一行的文本可以在 visual 模式下被剪切、复制、粘贴，很方便。\u003c/p\u003e\n\n\u003cp\u003e更多的信息，可以看 vi user guide 28 或 help fold。\u003c/p\u003e\n","cover":"","link":"works/2004/12/28/vi-的一个小技巧──折叠文本/index.html","preview":"","title":"vi 的一个小技巧──折叠文本"}]