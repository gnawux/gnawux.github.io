--- 
layout: post
meta: 
  _edit_last: "1"
  posturl_add_url: "yes"
published: true
status: publish
tags: 
  - bash
  - "command sub"
  - pipe
  - "process sub"
  - script
  - scripts
  - substitute
title: "Bash 的 Process Sub"
type: post
---
Shell这东西，如果你真会用的话，你可能永远不敢说你会用。

前两天看了Process Sub，一种结合了管道和命令替换（command sub）的使用方式，非常有趣。

嗯，这得先说说命令替换，就是反引号或者 "$()"，非常好用，但是，你能把它当成文件用么，有点时候，你要把命令输出送给其他命令处理，而这个命令只是接受文件参数，无法用管道，或者，你要两个命令的输出，没法用管道，怎么办呢，process_sub 来啦，看这个：
<pre class="brush: bash; gutter: true">diff -u &lt;(grep &quot;^5076&quot; strace.log |sed -ne &#039;s/.*futex(\(0x[0-9a-f]\+\),.*/\1/p&#039; |sort|uniq) &lt;(grep &quot;^5061&quot; strace.log |sed -ne &#039;s/.*futex(\(0x[0-9a-f]\+\),.*/\1/p&#039; |sort|uniq)</pre>
嗯，不解释了，自己理解哈。

Process sub 的另一种场合，下面这两个命令几乎是等价的，试图用个循环来做 wc 的工作：
<pre class="brush: bash; gutter: true">while read x; do ((y++)); done &lt; &lt;(netstat -nr)

netstat -nr | while read x; do ((y++)); done</pre>
不留心很难看出差别，但是，如果这两条命令之前，先把 y 置空，那么，第一个命令之后，y是有值的，第二个则不会。这是因为，管道命令可以看作是
<pre class="brush: bash; gutter: true">cmd1 | (cmd2)</pre>
也就是说，后面的命令是在子 shell 里运行的，因此，无法改动父 shell 的内部状态，而 process sub 方式运行的命令则没有这个问题。

嗯，则个很好玩，前两天刚看到的，参考了 TLDP 的 Advanced Bash-Scripting Guide 。
